<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"kuring.me","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="404频道">
<meta property="og:url" content="http://kuring.me/index.html">
<meta property="og:site_name" content="404频道">
<meta property="og:locale">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://kuring.me/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-Hans","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>404频道</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">404频道</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学习笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">249</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/kuring" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kuring" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/life/tesla-drive">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/life/tesla-drive" class="post-title-link" itemprop="url">特斯拉两万公里的使用感受</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-12-18 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-18T00:00:00+00:00">2024-12-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-17 16:09:25" itemprop="dateModified" datetime="2024-12-17T16:09:25+00:00">2024-12-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 2022 年的上半年我有了属于自己的北京新能源指标，终于可以抛弃掉倍受限制的外地牌照，实现出门自由的目标了，有种翻身当家做主人般的无奈喜悦。</p>
<p>摆在我面前的第一个问题就是该换哪款新能源汽车，车对我而言仅仅是个代步工具而已，能满足出行需求即可，因此买车的原则比较简单：</p>
<ol>
<li>买最大众化的销量最高的车型。当时销量最高的品牌当属比亚迪和特斯拉，单车型销量最高的当属特斯拉 Model Y，甚至 Model Y 火热到需要等至少两个月才交付，而且还在涨价。</li>
<li>后排座椅可以放倒，可以在车里睡觉，作为一个行走的床使用，Model Y 也正好可以满足需求。</li>
</ol>
<p>我在苦苦观望了半年之久，等过了特斯拉的两拨降价后，在 2023 年元旦前夕选择了 Model Y 标准续航版。我担心过了 2023 年元旦后就没有补贴了，会额外增加一部分购车成本。事实证明我的判断是完全错误的，补贴不仅没有取消，而且一个月后居然降价两万多，肠子都要悔青了。</p>
<p>到目前为止，已经开了两年的时间，一共跑了 2 万多公里。虽然我对车并不感兴趣，但油车也开过，多少还是有些话语权的，作为一个单纯的用户，我来聊聊我的用车感受。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/IMG_0976%202.jpg" alt="IMG_0976 2.jpg"></p>
<h1 id="整体感受"><a href="#整体感受" class="headerlink" title="整体感受"></a>整体感受</h1><h2 id="驾驶"><a href="#驾驶" class="headerlink" title="驾驶"></a>驾驶</h2><p>开车后的第一感受就是悬挂还是偏硬。我虽然对五连杆之类的悬挂技术不太感冒，但不得不说 Model Y 还是非常颠的。在换车之后，家人们都觉得车变贵了，肯定会变舒服了，殊不知颠簸感要强于之前的朗逸。</p>
<p>其次是加速度。我对于加速基本追求，长期在舒适模式下驾驶，运动模式对我而言加速度过于激烈了一些。即使是在舒适模式下，也经常会让后排乘客晕车，加速度仍然是快了些。但要是自己独自开车，驾驶感受还是挺不错的。尤其是绿灯起步时，往往能一骑绝尘，超越同一起跑线的其他车辆。</p>
<p>单踏板真香。特斯拉的单踏板一直在被外界诟病，但对于我而言一直是单踏板的模式运行，日常的通行中，很少用到刹车，基本上一个踏板就不够了，大大减轻了右腿的压力。</p>
<h2 id="车身质量"><a href="#车身质量" class="headerlink" title="车身质量"></a>车身质量</h2><p>特斯拉是一家对于利润极度压榨的公司，在这种原则下造车，往往车关键部位的质量非常好，但次要的零件由于要追求性价比，不会用最好的供应商，质量就会有些堪忧，反正坏了给你换，只要不坏就是赚到了，整体而言，特斯拉还是赚的。</p>
<p>在用车的短短一年内，我遇到了两次故障：</p>
<ol>
<li>空调坏掉一次。在一次超充充电完成后，空调完全不能制冷，去售后维修是空调压缩机坏掉了。</li>
<li>离开车后不能自动锁车。经过检查是主驾驶座椅下传感器坏掉了，检测不到驾驶人已经离开车。</li>
</ol>
<h1 id="内饰"><a href="#内饰" class="headerlink" title="内饰"></a>内饰</h1><p>​相比于国内品牌的冰箱彩电大沙发的豪华配置，特斯拉无遗是毛坯房。我个人对内饰也没有过多的要求，也比较喜欢极简风，倒是可以接受。</p>
<p>座椅加热功能在冬天还是非常的必要，但夏天就比较难受了，居然没有座椅通风。开一路车后，后背非常容易湿透。不过网上倒是有可以通过点烟器供电的外置通风座椅垫，我暂时没有体验过。</p>
<p>车顶的大玻璃对我而言影响不大，第一年的时候我买了一个手动遮阳帘挂上去。但第二年我就干脆没有挂上去，也不影响用车。在夏天的太阳下，虽然大玻璃会比较热， 但如果不用手去触摸，坐在车内头部是基本感受不到上面热量的。</p>
<h1 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h1><p>作为大号鼠标，​Model Y 的空间还是非常给力的。我车上长期放着一整套的露营装备，除了露营车外，其他的装备全部可以放到前备箱和后备箱的下方储物格中这些相比油车多出的储物空间中。</p>
<p>值得一提的是，我曾经搬过一次家，全程没有找搬家公司，家里所有的物品全部是我蚂蚁搬家一点点通过 Model Y 搬完的，虽然断断续续得搬了近两个月。</p>
<p>后排放倒后，在车里​睡觉完全不是问题。​略微不爽的就是不能完全放平，稍微有个角度，但在车里睡觉倒是没啥影响。配合着露营模式，我个人也曾在车里睡过很多次的午觉，甚至还有一次在车里睡了半晚上。</p>
<p>相比之下地盘离地高度就是个大大的劣势了。我曾经拿着手机测量过，最矮处跟手机的高度差不多。原先的油车偶尔还会应急停在马路牙子上，Model Y 我是一次也没敢往马路牙子上停。走在马路上过个坑都生怕磕到电池，怕跟保险公司扯上不解的缘分。（此处求 Model 3 车主的心理阴影面积）</p>
<h1 id="续航"><a href="#续航" class="headerlink" title="续航"></a>续航</h1><p>相比油车而言，电池无遗是电车的最大短板了。</p>
<p>刚买来时，车机显示满电续航为 435km，目前仅能显示 415km，掉了 20 km，属于在可接受的范围内，如果不追求数字，实际用车也感受不明显。要是跑高速，满打满算 350km 问题不大。</p>
<p>冬天是磷酸铁锂电池的噩梦，充电速度变慢，续航衰减明显，再加上还需要方向盘加热、座椅加热、空调加热这些功能，电耗会进一步提升。电池的回收动能变差，单踏板的减速效果会大大折扣。在零下十度的天气里，刚开启动的时候，动能回收甚至是完全失效的，开一段时间热起来后动能回收才能逐渐恢复一些。</p>
<p>充电方面，虽然有购车和推荐送的充电里程，但是一直没有舍得用完，大部分的时间都在外面的充电桩充电。在北京城市里面，充电还是非常方便的，方圆两公里内就有非常多的充电桩。时间久了后，我基本上会选择在出租车师傅长出没的充电桩充电了，而且大部分会选择在晚上十一点后，充电的价格要便宜挺多，我正好睡的晚，也不影响作息。</p>
<p>最怕的就是节假日期间的高速上了，很多情况下都是要排队充电的。再就是去偏远的地方，甚至北京周边河北境内的很多地方都很难找到充电桩，在张家口市沽源县城，我居然只能找到一家充电桩，而且晚上还不营业。</p>
<p>额外吐槽一下，不得不说，特斯拉是家特别会营销的公司。前两年的时候，4680 电池都快要让媒体吹上了天，能量密度提升了多少多少，啥时候量产，最近一年，几乎已经听不到 4680 电池的新闻了。（当然也有可能是我没关注到，顺便也吐槽下比亚迪的刀片电池）</p>
<h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p>特斯拉的 OTA 升级还是比较频繁的，差不多每两个月一次升级。但两年回顾下来，真正有用的软件功能升级并不多。比如下面这次更新，看着就像是个把到架在程序员脖子上写的更新简介。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/IMG_4820.jpg" alt="IMG_4820.jpg"></p>
<p>特斯拉做产品非常的轴，跟苹果有的一拼。有的功能明明非常难用，却愣是不更新。另外就是因为国内的缘故，很多在国外可用的功能，在国内却无法使用，导致使用体验又大打折扣。</p>
<p>相比之下，国内的新能源厂商的车机体验却一路猛追，应该说早已超越了特斯拉的自研车机。当然这么比并不公平，毕竟特斯拉的主战场不是中国，而中国却是新能源厂商的主战场。中国的新能源厂商出海后，车机的体验也一定会大打折扣，有大量的本地化、安全合规等需要适配。</p>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>导航功能刚开始用的时候弱爆了，但凡走陌生的路我都要打开手机上的高德导航。上班路上有一段特别拥堵，为了躲避拥堵，我都是刻意的多走一段路，但当我已经偏离了导航很长一段距离后，导航仍然傻到不断提醒让我前方掉头。</p>
<p>经过了两年的迭代，导航已经多次改版，已经好用了很多，车道级导航、红绿灯倒计时这些最近两年才在导航软件上有的新功能都已经引入了。</p>
<p>但相比手机上的导航软件还是有一定的差距，如：在计算拥堵方面还不够精确，显示的拥堵程度总是令我半信半疑，特斯拉可获取的数据量也不足以计算出拥堵的精度。 </p>
<h2 id="语音"><a href="#语音" class="headerlink" title="语音"></a>语音</h2><p>国内的新势力厂商的语音交互早已经非常流畅，跟车机交流起来毫无障碍。而特斯拉的语音功能只能说是智障，以至于我跟车机的交互都会选择手动点击屏幕。使用语音的唯一场景就是导航时输入目的地了，剩下的下发指令类的场景完全没有使用过，完全没有通过点击屏幕来的快捷。</p>
<h2 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h2><p>特斯拉通过摄像头将物理环境通过视觉算法转换为内部的模型，并以此为基础来做更上层的数据输入来源。</p>
<p>但在目前国内的版本上，在一些极端的场景下，摄像头的识别能力还是不行的。比如在下面的场景下，明明前面有一个非常粗的杆子，在车机上却视而不见。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/IMG_4553.jpg" alt="IMG_4553.jpg"></p>
<p>车上有那么多的摄像头，却没有 360 全景功能，而是给用户展示出经过处理的模型，这明明是你内部的实现细节，暴露给用户有啥用。在摄像头的识别率还不能到百分百的情况下，其实直接将全景交给人是个更好的选择。</p>
<p>在刚交付时，车身前后的雷达还是可以使用的，在停车时可以在车机上显示出距离障碍物的距离，对停车还是非常有帮助的。但后来特斯拉一直在宣称要基于纯视觉，雷达和纯视觉变为了二选一。</p>
<h2 id="辅助驾驶"><a href="#辅助驾驶" class="headerlink" title="辅助驾驶"></a>辅助驾驶</h2><p>我没有花钱购买额外的服务，用的最多的功能就是车道居中和自适应巡航了，不过这个功能在普通的油车上都快成为标配了。另外，车道居中功能在走山路 S 弯的时候根本没法使用，弱爆了。国外的 FSD V12 和 V13 快吹上天了，而国内的辅助驾驶还处于智障水平。</p>
<p>相比于普通的油车，稍微高级点的辅助驾驶功能就只有两个：</p>
<ol>
<li>当车速太快，且没有踩刹车的情况下，车机会判断出是否会追尾，并发出滴滴的提示音。这一点还是挺有用的，可以大大降低追尾的概率。</li>
<li>车道偏离后的被车机紧急控制。我刚买车的时候，曾经有一次向右侧变道，右侧的车在后视镜的盲区内，变道过程中就被车机紧急接管方向盘，避免了一次剐蹭的事故。</li>
</ol>
<p>当然辅助驾驶还是比较弱的，在很多的极端情况下，还是无能为力的。分享我曾经遇到过两个案例。</p>
<p>案例一：<br>![[IMG_3024.mov]]<br>在右转刚开始，外卖小哥还在马路对面，在车内是很难观察的，即使看到了也预判不了外卖小哥的风骚走位。当车头调转 90 度后，正准备加速时，外卖小哥突然冲到了车身前面，没有任何一个摄像头看到了外面小哥的存在，车机也没有发出告警，位置正好卡在了摄像头的盲区。</p>
<p>好在这次事故后，外卖小哥没啥事，扶起电动车看看外卖无碍后头也不回的就走了，佩服小哥的敬业精神！而我的小 Y 就没那么幸运了，车牌凹进去了一大块，车牌上的漆被碰掉了很多。</p>
<p>这次事故后，我每次右转都要提心吊胆，尤其是在转方向时不做过快的加速，否则可能会超出对方的预判，尤其是视时间为金钱的外卖骑手们的预判。</p>
<p>案例二：<br>![[2690.mov]]<br>在等红绿灯的时候，左侧车道为摩托车。绿灯起步时，摩托车要右转到辅路。摩托车以为其他车道的车肯定没他加速快，忽略了有一种车叫 Model Y。由于带着头盔，头也没法向后扭，就直接右转到辅路。</p>
<p>摩托车右转到我车前时，还突然减了一下速，车机都完全没反应过来，没有任何告警。幸好我当时反应快，踩了一脚刹车，要不然后果不堪设想。估计事后摩托车也不知道自己离事故这么近。</p>
<p>上面两个危险的经历告诉了我们两个道理：</p>
<ol>
<li>远离电动车和摩托车，能离多远离多远。</li>
<li>特斯拉的辅助驾驶是完全靠不住的。</li>
</ol>
<h2 id="周边产品"><a href="#周边产品" class="headerlink" title="周边产品"></a>周边产品</h2><p>因为特斯拉有 OpenAPI 可以供第三方调用，因此有一些第三方的软件我也在使用。据说后续 OpenAPI 要收费了，不知道后续围绕 OpenAPI 的一些应用是否会有调整。</p>
<h3 id="TeslaMate"><a href="#TeslaMate" class="headerlink" title="TeslaMate"></a>TeslaMate</h3><p>可以在电脑上运行的软件，会持续调用 OpenAPI，并将车的运行数据都记录在本地的数据库中，并通过 grafana 来展出出来。通过该软件，可以方便的查看历史的行车轨迹。阿里云的王坚博士提在线化，这就是数据在线化的一种非常好的呈现方式。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/11415AB8-DC9C-4F62-857B-5467F499B35D-14202-0000032B37B0A7DD.PNG" alt="11415AB8-DC9C-4F62-857B-5467F499B35D-14202-0000032B37B0A7DD.PNG"><br>比如今年夏天的时候去达达线、热阿线的路线图，可以精准的绘制出来。</p>
<h3 id="小特钥匙"><a href="#小特钥匙" class="headerlink" title="小特钥匙"></a>小特钥匙</h3><p>小特钥匙是 Apple Watch 上的应用，可以实现通过 Apple Watch 来打开车门，而且走的是蓝牙协议。主要的场景就是当手机没电时，可以通过手表了开锁，多了一条开门的途径。</p>
<p>因为是收费软件，而且功能非常单一，很多人都觉得该应用很鸡肋，我也是在一次手机没电开不了车门后下定决心购买的。</p>
<p>另外，特斯拉的官方 Apple Watch 版本的应用也快要上线了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>开了两年的车，整体而言还是比较满意的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/switch-stacking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/switch-stacking/" class="post-title-link" itemprop="url">交换机堆叠</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-12-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-01T00:00:00+00:00">2024-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-17 16:09:25" itemprop="dateModified" datetime="2024-12-17T16:09:25+00:00">2024-12-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>交换机堆叠：是指将一台以上的交换机组合起来工作，从逻辑上虚拟成一台交换机，作为一个整体参与数据转发。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/20241129000351.png" alt="image.png"><br>交换机的堆叠可以通过DAC高速线缆，光模块或者专门用于堆叠的线缆来实现。</p>
<p>交换机堆叠包括堆叠主交换机和堆叠备交换机，一主多备工作模式。堆叠主交换机存储整个交换机堆栈的运行配置文件，并通过堆叠主交换机对所有的堆叠交换机进行管理。如果主交换机发生故障，堆叠系统会从备交换机中选择新的堆叠主交换机，且不会影响整个网络的性能。</p>
<p>堆叠的协议都是私有的，因此不同品牌的交换机无法实现堆叠。</p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://community.fs.com/cn/article/switch-stacking-explained-basis-configuration-and-fa-qs.html">交换机堆叠知识：概述，配置与常见问题解答</a></li>
<li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/%E5%A0%86%E5%8F%A0.html">什么是堆叠？</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/report/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/report/" class="post-title-link" itemprop="url">我理解的职场述职</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-09-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-20T00:00:00+00:00">2024-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-17 16:09:25" itemprop="dateModified" datetime="2024-12-17T16:09:25+00:00">2024-12-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>阿里巴巴的财年为每年4月1日至次年3月31日，而4月1日至9月30日为财年的上半年。大部分的团队每半个财年要完成一次述职，而眼下的 9 月 30 日前又到了述职的日子。</p>
<p>在我过往的工作经历中，并没有述职的习惯，绩效的考核也相对随意一些，绩效的好坏跟主管的主管判断关系比较大，但通常绩效的好坏跟个人的成绩也是成正比的，不会出现较大的偏差。</p>
<p>在阿里绩效的绩效考核会非常被重视，希望能够通过公平的方法来分配高低绩效，降低主管的主观判断，当然主观的判断仍然是无法避免的，而且也会仍然占较大的比重。</p>
<p>述职可以作为一种常见的职场总结方式，也是绩效考核的一个重要的参考依据。</p>
<p>记得刚来阿里的时候，团队处于业务的爆发期，述职并不是太被重视，尤其是形式方面。某一年的述职中，我仅准备了可怜的三页 PPT，仅完成了做的事情的简单罗列，缺少一些自己的思考总结，当时就被喷的比较惨。当然述职中没有体现，并不代表平常就没有思考，即使平时没有思考也不代表就会影响实际的工作。</p>
<p>一到述职，自己也曾经非常头疼，经过了这几年的洗礼，自己对职场的述职也有了一点点自己的总结，希望能帮助到大家。</p>
<h1 id="为什么要做述职？"><a href="#为什么要做述职？" class="headerlink" title="为什么要做述职？"></a>为什么要做述职？</h1><p>存在即合理，我认为的述职有这么几个好处：</p>
<ol>
<li>对自己过去做的事情的非常好的总结，帮助自己重新认识自己。这也是最关键的一点。大家肯定有这样的体会，如果让你回想过去几个月甚至一年做的事情，恐怕很难一下子想全。在现代职场中，大家都是匆匆忙忙的赶路人，任务一个接一个的完成，很难像在学校读书一样有温故而知新的机会。而述职恰恰是一个非常好的机会，回顾过去一段时间内自己做的事情，找找自己的闪光点，反思一下如果一件事情再重新做，会不会做的更好更高效。人总是在不断的总结经验中成长，述职是个很不错的职场成长机会。</li>
<li>让自己了解别人做的事情。别人做的最好的事情、吃的亏、踩过的坑都已经帮你总结好了，这是多好的一个学习机会。也许在吸取别人经验的过程中，会迸发出一些新的灵感。</li>
<li>让别人了解自己做的事情。自己做的申请同样需要传播给其他的同学，或许别人才能发现自己的闪光点，是个提升自己影响力的好时机（当然前提是自己要有货）。自己身上的不足也能够让别人发现，进而别人来帮助自己成长。</li>
<li>作为主管绩效考核的依据。这一点我倒认为并没有那么关键，自己做的事情自己的能力在日常工作中已经足够体现，不需要在述职的时候才做出判断，最多也就是作为判断的依据而已。</li>
<li>提升自己的演讲能力。演讲是一种能力，需要刻意练习。述职中要面对不同的人群，在有效的时间内将自己的事情给别人讲明白属实不是一件容易的事情。</li>
<li>通过述职这种形式化的方式来间接的促进员工在日常中工作的积极性。对于一部分员工，如果缺少了述职这种形式，在日常工作中就少了一份压力，工作中可能就会稍显懈怠。</li>
</ol>
<h1 id="述职的常见误区有哪些？"><a href="#述职的常见误区有哪些？" class="headerlink" title="述职的常见误区有哪些？"></a>述职的常见误区有哪些？</h1><p>述职也并非百害而无一利，同样是一把双刃剑，如果能利用的好，会对自己有较大的帮助。如果利用不好，就容易反噬。</p>
<ol>
<li>不要搞的花里胡哨太抽象。也是述职中最常见的问题，也是最让人诟病的。我见到过不少搞得花里胡哨的述职材料，一件很简单的事情非要说的很复杂，让人感觉很高大上，殊不知包装后，能听懂的人群更加少了。尽量少用 PPT，直接使用文档形式就非常不错，省去了大量排版的工作。图片也尽可能的简介，不要为了美观而消耗太多的时间。简简单单的真实就是最好的述职。</li>
<li>不要报喜不报忧。这也是个非常常见的问题。这种虚假的汇报，或许可以玩转一次述职，下次述职就很难遮盖过去了。或许一部分人可以糊弄过去，另外一部分人就未必。一个谎言的背后就得需要无数个谎言来弥补，实事求是在述职中非常的关键，严禁弄虚作假。</li>
<li>不要为了述职而述职。很多人都比较头疼述职，为了述职不得不做准备。其实这种心态就不太对，为了做而做，那么一定做不好。</li>
<li>不要消耗过多的时间来准备。如果一次要准备上好几天的时间就有点不值了，毕竟一年真正有效的工作时间才能有多少天呢，述职本身并不会产生业务价值，不要本末倒置。</li>
<li>不要陷在自己的主观世界中。要考虑到参加述职的人群，给别人讲明白自己做的事情。</li>
</ol>
<h1 id="述职的形式是什么样子的？"><a href="#述职的形式是什么样子的？" class="headerlink" title="述职的形式是什么样子的？"></a>述职的形式是什么样子的？</h1><p>职场中的很多事情都有固定的套路，尤其是在一家公司内部。最好的方式就是参考老员工的述职报告，找到固定的套路，或者按照主管要求的套路来。最好不要试图找到一条新的方法，前辈们总结的路基本都不会错。</p>
<p>述职的内容基本要遵循 STAR 法则（即背景 Situation、任务 Task、行为 Action、结果 Result），主要包含几部分内容：</p>
<ol>
<li>Situation：事情的背景。</li>
<li>Task：面临的挑战和遇到的困难。项目干系人，自己在其中承担的角色。</li>
<li>Action：自己的解决方案。</li>
<li>Result：获得的业务结果。能量化的一些业务结果最好要量化，这样会非常直观。</li>
</ol>
<p>其中也可以讲讲自己的总结思考和个人成长等内容。</p>
<p>另外在讲述的时候要符合金字塔原理，核心的原则：</p>
<ol>
<li>结论先行。</li>
<li>每层结论下面的论据不要超过7个。</li>
<li>每一个论点要言之有物，有明确的思想。</li>
</ol>
<h1 id="述职的材料该如何准备？"><a href="#述职的材料该如何准备？" class="headerlink" title="述职的材料该如何准备？"></a>述职的材料该如何准备？</h1><p>这里有几个建议：</p>
<ol>
<li>如果有写周报的习惯，看看周报的内容。</li>
<li>看看各种群的聊天记录的内容。</li>
<li>看看自己的代码提交记录。</li>
<li>看看自己的文档。</li>
</ol>
<p>当然，上面的一些前提都是平常要有一些积累，如果平常积累的多，那么述职的材料准备起来就比较简单快速。</p>
<p>最后，述职是一种管理员工的手段，作为员工在无法取消述职这种形式的时候，还是要尽可能将述职作为一种促进自己提升的手段，不要为了述职而述职。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/linux/lxcfs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/linux/lxcfs/" class="post-title-link" itemprop="url">lxcfs 技术</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-08-31 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-31T00:00:00+00:00">2024-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-17 16:09:25" itemprop="dateModified" datetime="2024-12-17T16:09:25+00:00">2024-12-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>容器中的执行<code>top</code>、<code>free</code>等命令展示出来的CPU，内存等信息是从<code>/proc</code>目录中的相关文件里读取出来的。而容器并没有对<code>/proc</code>，<code>/sys</code>等文件系统做隔离，因此容器中读取出来的CPU和内存的信息是宿主机的信息，与容器实际分配和限制的资源量不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/proc/cpuinfo</span><br><span class="line">/proc/diskstats</span><br><span class="line">/proc/meminfo</span><br><span class="line">/proc/stat</span><br><span class="line">/proc/swaps</span><br><span class="line">/proc/uptime</span><br></pre></td></tr></table></figure>

<p>lxcfs是一个常驻进程运行在宿主机上，从而来自动维护宿主机cgroup中容器的真实资源信息与容器内<code>/proc</code>下文件的映射关系。</p>
<p>lxcfs实现的基本原理是通过文件挂载的方式，把cgroup中容器相关的信息读取出来，存储到lxcfs相关的目录下，并将相关目录映射到容器内的&#x2F;proc目录下，从而使得容器内执行top,free等命令时拿到的&#x2F;proc下的数据是真实的cgroup分配给容器的CPU和内存数据。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/20240830114743.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th>类别</th>
<th>容器内目录</th>
<th>宿主机lxcfs目录</th>
</tr>
</thead>
<tbody><tr>
<td>cpu</td>
<td>&#x2F;proc&#x2F;cpuinfo</td>
<td>&#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;proc&#x2F;cpuinfo</td>
</tr>
<tr>
<td>内存</td>
<td>&#x2F;proc&#x2F;meminfo</td>
<td>&#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;proc&#x2F;meminfo</td>
</tr>
<tr>
<td></td>
<td>&#x2F;proc&#x2F;diskstats</td>
<td>&#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;proc&#x2F;diskstats</td>
</tr>
<tr>
<td></td>
<td>&#x2F;proc&#x2F;stat</td>
<td>&#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;proc&#x2F;stat</td>
</tr>
<tr>
<td></td>
<td>&#x2F;proc&#x2F;swaps</td>
<td>&#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;proc&#x2F;swaps</td>
</tr>
<tr>
<td></td>
<td>&#x2F;proc&#x2F;uptime</td>
<td>&#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;proc&#x2F;uptime</td>
</tr>
<tr>
<td></td>
<td>&#x2F;proc&#x2F;loadavg</td>
<td>&#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;proc&#x2F;loadavg</td>
</tr>
<tr>
<td></td>
<td>&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;online</td>
<td>&#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;online</td>
</tr>
</tbody></table>
<p>在每个容器内仅需要挂载 lxcfs 在宿主机上的目录到容器中的目录即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/daily/carnegie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/daily/carnegie/" class="post-title-link" itemprop="url">卡内基与卡耐基</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-08-21 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-21T00:00:00+00:00">2024-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-17 16:09:25" itemprop="dateModified" datetime="2024-12-17T16:09:25+00:00">2024-12-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>多年前，我曾经阅读过两本当时非常流行的书籍《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/26954744/">人性的弱点</a>》和《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/26975497/">人性的优点</a>》，作者均为卡耐基。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/20240820235758.png" alt="image.png"></p>
<p>而前段时间参加过一场[卡内基的培训](<a target="_blank" rel="noopener" href="https://www.carnegiechina.com/aboutus">卡内基训练 (carnegiechina.com)</a>)，自己就有点傻傻的分不清楚此“卡”是否为彼“卡”。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/20240821000021.png" alt="image.png"><br>于是搜索了一下资料，发现两“卡”均为 <strong>戴尔·卡耐基</strong>(Dale Carnegie，1888年11月24日—1955年11月1日)，美国的作家和演讲者。只是因为翻译的偏差，导致出现了卡内基和卡耐基两种称呼。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/20240820235142.png" alt="image.png"></p>
<p>1912 年创办了卡内基训练（Dale Carnegie Training）教导人们人际沟通及如何处理压力。<br>1936 年完成书籍《人性的弱点》又名《<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%85%A7%E5%9F%BA%E6%BA%9D%E9%80%9A%E8%88%87%E4%BA%BA%E9%9A%9B%E9%97%9C%E4%BF%82">如何赢取友谊与影响他人</a>》（_How to Win Friends and Influence People_）一书。</p>
<p>之所以会出现混淆，还有另外的名字也是跟卡耐基相关的：</p>
<ol>
<li><strong>安德鲁·卡内基</strong>（Andrew Carnegie，1835年11月25日—1919年8月11日）：美国著名的钢铁大王，其名称要远大于<strong>戴尔·卡耐基</strong>。</li>
<li><strong>卡内基·梅隆大学</strong>（Carnegie Mellon University）：由钢铁大王<strong>安德鲁·卡内基</strong>创办，全球大学排名上在前60名以内。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/ai/n-gram/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/ai/n-gram/" class="post-title-link" itemprop="url">语言模型雏形 N-Gram</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-08-19 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-19T00:00:00+00:00">2024-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-17 16:09:25" itemprop="dateModified" datetime="2024-12-17T16:09:25+00:00">2024-12-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文为对《GPT 图解 - 大模型是怎样构建的》一书的学习笔记，所有的例子和代码均来源于本书。</p>
</blockquote>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p> N-Gram 模型为语言模型的雏形。</p>
<p>基本思想为：一个词出现的概率仅依赖其前面的 N-1 个词。即通过有限的 N-1 个词来预测第 N 个词。</p>
<p>以 “我爱吃肉” 举例，分词为 [”我“, “爱”, “吃”, “肉”]。</p>
<ul>
<li>当 N&#x3D;1 时，对应的序列为[”我“, “爱”, “吃”, “肉”]，又成为 Unigram。</li>
<li>当 N&#x3D;2 时，对应的序列为[”我爱“, “爱吃”, “吃肉”]，又成为 Bigram。</li>
<li>当 N&#x3D;3 时，对应的序列为[”我爱吃“, “爱吃肉”]，又成为 Trigram。</li>
</ul>
<h2 id="2-Gram-的构建过程"><a href="#2-Gram-的构建过程" class="headerlink" title="2-Gram 的构建过程"></a>2-Gram 的构建过程</h2><h3 id="将语料拆分为分词"><a href="#将语料拆分为分词" class="headerlink" title="将语料拆分为分词"></a>将语料拆分为分词</h3><p>将给定的语料库，拆分为以一个的分词。在真实的场景中需要使用分词函数，这里简单起见，使用了一个汉字一个分词的方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">corpus = [ <span class="string">&quot;我喜欢吃苹果&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;我喜欢吃香蕉&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;她喜欢吃葡萄&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;他不喜欢吃香蕉&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;他喜欢吃苹果&quot;</span>,  </span><br><span class="line">        <span class="string">&quot;她喜欢吃草莓&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个分词函数，将文本转换为单个字符的列表  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tokenize</span>(<span class="params">text</span>):  </span><br><span class="line"> <span class="keyword">return</span> [char <span class="keyword">for</span> char <span class="keyword">in</span> text] <span class="comment"># 将文本拆分为字符列表  </span></span><br><span class="line"><span class="comment"># 对每个文本进行分词，并打印出对应的单字列表  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;单字列表:&quot;</span>)   </span><br><span class="line"><span class="keyword">for</span> text <span class="keyword">in</span> corpus:  </span><br><span class="line">    tokens = tokenize(text)  </span><br><span class="line">    <span class="built_in">print</span>(tokens)</span><br></pre></td></tr></table></figure>

<p>得到如下的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单字列表:</span><br><span class="line">[&#x27;我&#x27;, &#x27;喜&#x27;, &#x27;欢&#x27;, &#x27;吃&#x27;, &#x27;苹&#x27;, &#x27;果&#x27;]</span><br><span class="line">[&#x27;我&#x27;, &#x27;喜&#x27;, &#x27;欢&#x27;, &#x27;吃&#x27;, &#x27;香&#x27;, &#x27;蕉&#x27;]</span><br><span class="line">[&#x27;她&#x27;, &#x27;喜&#x27;, &#x27;欢&#x27;, &#x27;吃&#x27;, &#x27;葡&#x27;, &#x27;萄&#x27;]</span><br><span class="line">[&#x27;他&#x27;, &#x27;不&#x27;, &#x27;喜&#x27;, &#x27;欢&#x27;, &#x27;吃&#x27;, &#x27;香&#x27;, &#x27;蕉&#x27;]</span><br><span class="line">[&#x27;他&#x27;, &#x27;喜&#x27;, &#x27;欢&#x27;, &#x27;吃&#x27;, &#x27;苹&#x27;, &#x27;果&#x27;]</span><br><span class="line">[&#x27;她&#x27;, &#x27;喜&#x27;, &#x27;欢&#x27;, &#x27;吃&#x27;, &#x27;草&#x27;, &#x27;莓&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="计算每个-2-Gram（BiGram）-在语料库中的词频"><a href="#计算每个-2-Gram（BiGram）-在语料库中的词频" class="headerlink" title="计算每个 2-Gram（BiGram） 在语料库中的词频"></a>计算每个 2-Gram（BiGram） 在语料库中的词频</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义计算 N-Gram 词频的函数  </span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict, Counter <span class="comment"># 导入所需库  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_ngrams</span>(<span class="params">corpus, n</span>):  </span><br><span class="line">    ngrams_count = defaultdict(Counter)  <span class="comment"># 创建一个字典，存储 N-Gram 计数  </span></span><br><span class="line">    <span class="keyword">for</span> text <span class="keyword">in</span> corpus:  <span class="comment"># 遍历语料库中的每个文本  </span></span><br><span class="line">        tokens = tokenize(text)  <span class="comment"># 对文本进行分词  </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tokens) - n + <span class="number">1</span>):  <span class="comment"># 遍历分词结果，生成 N-Gram            ngram = tuple(tokens[i:i+n])  # 创建一个 N-Gram 元组  </span></span><br><span class="line">            prefix = ngram[:-<span class="number">1</span>]  <span class="comment"># 获取 N-Gram 的前缀  </span></span><br><span class="line">            token = ngram[-<span class="number">1</span>]  <span class="comment"># 获取 N-Gram 的目标单字  </span></span><br><span class="line">            ngrams_count[prefix][token] += <span class="number">1</span>  <span class="comment"># 更新 N-Gram 计数  </span></span><br><span class="line">    <span class="keyword">return</span> ngrams_count  </span><br><span class="line">bigram_counts = count_ngrams(corpus, <span class="number">2</span>) <span class="comment"># 计算 bigram 词频  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bigram 词频：&quot;</span>) <span class="comment"># 打印 bigram 词频  </span></span><br><span class="line"><span class="keyword">for</span> prefix, counts <span class="keyword">in</span> bigram_counts.items():  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;&quot;</span>.join(prefix), <span class="built_in">dict</span>(counts)))</span><br></pre></td></tr></table></figure>

<p>计算获取到如下的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bigram 词频：</span><br><span class="line">我: &#123;&#x27;喜&#x27;: 2&#125;</span><br><span class="line">喜: &#123;&#x27;欢&#x27;: 6&#125;</span><br><span class="line">欢: &#123;&#x27;吃&#x27;: 6&#125;</span><br><span class="line">吃: &#123;&#x27;苹&#x27;: 2, &#x27;香&#x27;: 2, &#x27;葡&#x27;: 1, &#x27;草&#x27;: 1&#125;</span><br><span class="line">苹: &#123;&#x27;果&#x27;: 2&#125;</span><br><span class="line">香: &#123;&#x27;蕉&#x27;: 2&#125;</span><br><span class="line">她: &#123;&#x27;喜&#x27;: 2&#125;</span><br><span class="line">葡: &#123;&#x27;萄&#x27;: 1&#125;</span><br><span class="line">他: &#123;&#x27;不&#x27;: 1, &#x27;喜&#x27;: 1&#125;</span><br><span class="line">不: &#123;&#x27;喜&#x27;: 1&#125;</span><br><span class="line">草: &#123;&#x27;莓&#x27;: 1&#125;</span><br></pre></td></tr></table></figure>
<p>即当第一个词为 ”我“，第二个词为”喜“在整个语料库中出现了 2 次。</p>
<p>如果为 3-Gram（TriGram），此时输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bigram 词频：</span><br><span class="line">我喜: &#123;&#x27;欢&#x27;: 2&#125;</span><br><span class="line">喜欢: &#123;&#x27;吃&#x27;: 6&#125;</span><br><span class="line">欢吃: &#123;&#x27;苹&#x27;: 2, &#x27;香&#x27;: 2, &#x27;葡&#x27;: 1, &#x27;草&#x27;: 1&#125;</span><br><span class="line">吃苹: &#123;&#x27;果&#x27;: 2&#125;</span><br><span class="line">吃香: &#123;&#x27;蕉&#x27;: 2&#125;</span><br><span class="line">她喜: &#123;&#x27;欢&#x27;: 2&#125;</span><br><span class="line">吃葡: &#123;&#x27;萄&#x27;: 1&#125;</span><br><span class="line">他不: &#123;&#x27;喜&#x27;: 1&#125;</span><br><span class="line">不喜: &#123;&#x27;欢&#x27;: 1&#125;</span><br><span class="line">他喜: &#123;&#x27;欢&#x27;: 1&#125;</span><br><span class="line">吃草: &#123;&#x27;莓&#x27;: 1&#125;</span><br></pre></td></tr></table></figure>

<p>如果为 1-Gram（UniGram），此时输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bigram 词频：</span><br><span class="line">: &#123;&#x27;我&#x27;: 2, &#x27;喜&#x27;: 6, &#x27;欢&#x27;: 6, &#x27;吃&#x27;: 6, &#x27;苹&#x27;: 2, &#x27;果&#x27;: 2, &#x27;香&#x27;: 2, &#x27;蕉&#x27;: 2, &#x27;她&#x27;: 2, &#x27;葡&#x27;: 1, &#x27;萄&#x27;: 1, &#x27;他&#x27;: 2, &#x27;不&#x27;: 1, &#x27;草&#x27;: 1, &#x27;莓&#x27;: 1&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看到已经退化为了每个单词在整个语料库中出现的次数。</p>
<h4 id="计算每个-2-Gram-出现的概率"><a href="#计算每个-2-Gram-出现的概率" class="headerlink" title="计算每个 2-Gram 出现的概率"></a>计算每个 2-Gram 出现的概率</h4><p>即给定前一个词，计算下一个词出现的概率。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义计算 N-Gram 出现概率的函数  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ngram_probabilities</span>(<span class="params">ngram_counts</span>):  </span><br><span class="line"> ngram_probs = defaultdict(Counter) <span class="comment"># 创建一个字典，存储 N-Gram 出现的概率  </span></span><br><span class="line"> <span class="keyword">for</span> prefix, tokens_count <span class="keyword">in</span> ngram_counts.items(): <span class="comment"># 遍历 N-Gram 前缀  </span></span><br><span class="line">     total_count = <span class="built_in">sum</span>(tokens_count.values()) <span class="comment"># 计算当前前缀的 N-Gram 计数  </span></span><br><span class="line">     <span class="keyword">for</span> token, count <span class="keyword">in</span> tokens_count.items(): <span class="comment"># 遍历每个前缀的 N-Gram         ngram_probs[prefix][token] = count / total_count # 计算每个 N-Gram 出现的概率  </span></span><br><span class="line"> <span class="keyword">return</span> ngram_probs  </span><br><span class="line">bigram_probs = ngram_probabilities(bigram_counts) <span class="comment"># 计算 bigram 出现的概率  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nbigram 出现的概率 :&quot;</span>) <span class="comment"># 打印 bigram 概率  </span></span><br><span class="line"><span class="keyword">for</span> prefix, probs <span class="keyword">in</span> bigram_probs.items():  </span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;&quot;</span>.join(prefix), <span class="built_in">dict</span>(probs)))</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bigram 出现的概率 :</span><br><span class="line">我: &#123;&#x27;喜&#x27;: 1.0&#125;</span><br><span class="line">喜: &#123;&#x27;欢&#x27;: 1.0&#125;</span><br><span class="line">欢: &#123;&#x27;吃&#x27;: 1.0&#125;</span><br><span class="line">吃: &#123;&#x27;苹&#x27;: 0.3333333333333333, &#x27;香&#x27;: 0.3333333333333333, &#x27;葡&#x27;: 0.16666666666666666, &#x27;草&#x27;: 0.16666666666666666&#125;</span><br><span class="line">苹: &#123;&#x27;果&#x27;: 1.0&#125;</span><br><span class="line">香: &#123;&#x27;蕉&#x27;: 1.0&#125;</span><br><span class="line">她: &#123;&#x27;喜&#x27;: 1.0&#125;</span><br><span class="line">葡: &#123;&#x27;萄&#x27;: 1.0&#125;</span><br><span class="line">他: &#123;&#x27;不&#x27;: 0.5, &#x27;喜&#x27;: 0.5&#125;</span><br><span class="line">不: &#123;&#x27;喜&#x27;: 1.0&#125;</span><br><span class="line">草: &#123;&#x27;莓&#x27;: 1.0&#125;</span><br></pre></td></tr></table></figure>

<h3 id="给定一个前缀，输出连续的文本"><a href="#给定一个前缀，输出连续的文本" class="headerlink" title="给定一个前缀，输出连续的文本"></a>给定一个前缀，输出连续的文本</h3><p>根据前面学习的语料信息，给定一个前缀，即可生成对应的文本内容。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义生成下一个词的函数  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_next_token</span>(<span class="params">prefix, ngram_probs</span>):  </span><br><span class="line"> <span class="keyword">if</span> <span class="keyword">not</span> prefix <span class="keyword">in</span> ngram_probs: <span class="comment"># 如果前缀不在 N-Gram 中，返回 None    return None  </span></span><br><span class="line"> next_token_probs = ngram_probs[prefix] <span class="comment"># 获取当前前缀的下一个词的概率  </span></span><br><span class="line"> next_token = <span class="built_in">max</span>(next_token_probs,   </span><br><span class="line">                    key=next_token_probs.get) <span class="comment"># 选择概率最大的词作为下一个词  </span></span><br><span class="line"> <span class="keyword">return</span> next_token</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义生成连续文本的函数  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_text</span>(<span class="params">prefix, ngram_probs, n, length=<span class="number">6</span></span>):  </span><br><span class="line"> tokens = <span class="built_in">list</span>(prefix) <span class="comment"># 将前缀转换为字符列表  </span></span><br><span class="line"> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length - <span class="built_in">len</span>(prefix)): <span class="comment"># 根据指定长度生成文本   </span></span><br><span class="line"><span class="comment"># 获取当前前缀的下一个词  </span></span><br><span class="line">     next_token = generate_next_token(<span class="built_in">tuple</span>(tokens[-(n-<span class="number">1</span>):]), ngram_probs)   </span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> next_token: <span class="comment"># 如果下一个词为 None，跳出循环  </span></span><br><span class="line">         <span class="keyword">break</span>  </span><br><span class="line">     tokens.append(next_token) <span class="comment"># 将下一个词添加到生成的文本中  </span></span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(tokens) <span class="comment"># 将字符列表连接成字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入一个前缀，生成文本  </span></span><br><span class="line">generated_text = generate_text(<span class="string">&quot;我&quot;</span>, bigram_probs, <span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n 生成的文本：&quot;</span>, generated_text) <span class="comment"># 打印生成的文本</span></span><br></pre></td></tr></table></figure>

<p>给定了文本”我“，可以生成出如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生成的文本： 我喜欢吃苹果</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>N-Gram 为非常简单的语言模型，可以根据给定的词来生成句子。</p>
<p>缺点：无法捕捉到距离较远的词之间的关系。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/gzh-coze/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/gzh-coze/" class="post-title-link" itemprop="url">微信公众号通过扣子接入大模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-06-19 00:00:00" itemprop="dateCreated datePublished" datetime="2024-06-19T00:00:00+00:00">2024-06-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-17 16:09:25" itemprop="dateModified" datetime="2024-12-17T16:09:25+00:00">2024-12-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在字节的 AI 发布平台<a target="_blank" rel="noopener" href="https://www.coze.cn/">扣子</a>中提供了创建机器人的功能，并且可以直接对接微信公众号，使用在微信公众号中回复消息，由大模型直接回复的效果。</p>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>整体操作步骤非常简单，需要申请一个 Coze 的账号和开通微信公众号的开发者功能。</p>
<p>微信公众号的开发者功能在这里配置：<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/20240619211112.png" alt="image.png"></p>
<p>点击<code>创建 Bot</code> 按钮，输入 Bot 名称后点击<code>确认</code>。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/20240619210355.png" alt="image.png|570"></p>
<p>在机器人设置页面，可以配置模型、选择自己训练的知识库等操作。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/20240619210909.png" alt="image.png"></p>
<p>设置完成后，点击<code>发布</code>，选择<code>微信公众号（订阅号）</code>配置功能，设置对应的微信公众号的 AppID。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/20240619211019.png" alt="image.png"></p>
<h1 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h1><p>访问公众号直接输入内容，可以看到自动回复内容。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/IMG_3856.PNG.JPG" alt="IMG_3856.PNG.JPG"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/mi-gpt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/mi-gpt/" class="post-title-link" itemprop="url">使用 mi-gpt 将小爱音箱接入大模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-06-13 00:00:00" itemprop="dateCreated datePublished" datetime="2024-06-13T00:00:00+00:00">2024-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-17 16:09:25" itemprop="dateModified" datetime="2024-12-17T16:09:25+00:00">2024-12-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>无意间发现了开源项目 <a target="_blank" rel="noopener" href="https://github.com/idootop/mi-gpt">mi-gpt</a>，该项目可以将家里的小爱音箱接入到 GPT 中，增强小爱音箱的功能。在跟小爱音箱对话的过程中，可以根据特定的提示词走 GPT 来回答，而不是用小爱音箱原生的回复。</p>
<p>必备条件：</p>
<ol>
<li>必须有一个小米音箱。</li>
<li>必须要有可以长期运行的服务器，可以是树莓派等设备。</li>
<li>要有一个 OpenAI 的账号，也可以用兼容 ChatGPT API 的国内大模型。</li>
</ol>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>部署比较简单，下面为我的部署过程，供大家参考。更详细的信息大家可以直接参考 github 项目中的<a target="_blank" rel="noopener" href="https://github.com/idootop/mi-gpt/tree/main/docs">相关文档</a>。</p>
<h2 id="创建配置文件-migpt-js："><a href="#创建配置文件-migpt-js：" class="headerlink" title="创建配置文件 .migpt.js："></a>创建配置文件 <code>.migpt.js</code>：</h2><p>参考项目中的文件 <a target="_blank" rel="noopener" href="https://github.com/idootop/mi-gpt/blob/main/.migpt.example.js">.migpt.example.js</a>内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// 小爱音箱扮演角色的简介</span><br><span class="line">const botProfile = `</span><br><span class="line">性别：女</span><br><span class="line">性格：乖巧可爱</span><br><span class="line">爱好：喜欢搞怪，爱吃醋。</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">// 小爱音箱主人（你）的简介</span><br><span class="line">const masterProfile = `</span><br><span class="line">性别：男</span><br><span class="line">性格：善良正直</span><br><span class="line">其他：总是舍己为人，是傻妞的主人。</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  bot: &#123;</span><br><span class="line">    name: &quot;傻妞&quot;,</span><br><span class="line">    profile: botProfile,</span><br><span class="line">  &#125;,</span><br><span class="line">  master: &#123;</span><br><span class="line">    name: &quot;陆小千&quot;,</span><br><span class="line">    profile: masterProfile,</span><br><span class="line">  &#125;,</span><br><span class="line">  speaker: &#123;</span><br><span class="line">    // 小米 ID</span><br><span class="line">    userId: &quot;12345&quot;, // 注意：不是手机号或邮箱，请在「个人信息」-「小米 ID」查看</span><br><span class="line">    // 账号密码</span><br><span class="line">    password: &quot;xxx&quot;,</span><br><span class="line">    // 小爱音箱 ID 或在米家中设置的名称</span><br><span class="line">    did: &quot;Redmi小爱触屏音箱8&quot;,</span><br><span class="line">    // 当消息以下面的关键词开头时，会调用 AI 来回复消息</span><br><span class="line">    callAIKeywords: [&quot;请&quot;, &quot;你&quot;, &quot;傻妞&quot;],</span><br><span class="line">    // 当消息以下面的关键词开头时，会进入 AI 唤醒状态</span><br><span class="line">    wakeUpKeywords: [&quot;打开&quot;, &quot;进入&quot;, &quot;召唤&quot;],</span><br><span class="line">    // 当消息以下面的关键词开头时，会退出 AI 唤醒状态</span><br><span class="line">    exitKeywords: [&quot;关闭&quot;, &quot;退出&quot;, &quot;再见&quot;],</span><br><span class="line">    </span><br><span class="line">    // 进入 AI 模式的欢迎语</span><br><span class="line">    onEnterAI: [&quot;你好，我是傻妞，很高兴认识你&quot;],</span><br><span class="line">    </span><br><span class="line">    // 退出 AI 模式的提示语</span><br><span class="line">    onExitAI: [&quot;傻妞已退出&quot;],</span><br><span class="line">    </span><br><span class="line">    // AI 开始回答时的提示语</span><br><span class="line">    onAIAsking: [&quot;让我先想想&quot;, &quot;请稍等&quot;],</span><br><span class="line">    </span><br><span class="line">    // AI 结束回答时的提示语</span><br><span class="line">    onAIReplied: [&quot;我说完了&quot;, &quot;还有其他问题吗&quot;],</span><br><span class="line">    </span><br><span class="line">    // AI 回答异常时的提示语</span><br><span class="line">    onAIError: [&quot;啊哦，出错了，请稍后再试吧！&quot;],</span><br><span class="line">    </span><br><span class="line">    // 无响应一段时间后，多久自动退出唤醒模式（默认 30 秒）</span><br><span class="line">    exitKeepAliveAfter: 30,</span><br><span class="line">    </span><br><span class="line">    // TTS 指令，请到 https://home.miot-spec.com 查询具体指令</span><br><span class="line">    ttsCommand: [3, 1],</span><br><span class="line">    </span><br><span class="line">    // 设备唤醒指令，请到 https://home.miot-spec.com 查询具体指令</span><br><span class="line">    wakeUpCommand: [3, 2],</span><br><span class="line">    </span><br><span class="line">    // 是否启用流式响应，部分小爱音箱型号不支持查询播放状态，此时需要关闭流式响应</span><br><span class="line">    streamResponse: false,</span><br><span class="line">    </span><br><span class="line">    // 查询是否在播放中指令，请到 https://home.miot-spec.com 查询具体指令</span><br><span class="line">    playingCommand: [2, 1, 1], // 默认无需配置此参数，播放出现问题时再尝试开启</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>必须要修改的内容涉及到如下字段，其他字段可以根据含义来定义：</p>
<ol>
<li>speaker.userId：小米的用户 ID。</li>
<li>speaker.password：小米的账号密码。</li>
<li>speaker.did：小爱音箱的 ID 或者小爱音箱在米家的设备名字。</li>
<li>ttsCommand：需要设置。如果设置不正常，会导致小爱音箱无法播放 GPT 回复内容的情况。</li>
<li>wakeUpCommand：需要设置。</li>
<li>streamResponse：在某些音箱设备上需要关闭。我的设备因为无法读完完整的句子，选择了关闭该功能，相关参考：<a target="_blank" rel="noopener" href="https://github.com/idootop/mi-gpt/blob/main/docs/faq.md#q%E5%B0%8F%E7%88%B1%E9%9F%B3%E7%AE%B1%E6%B2%A1%E6%9C%89%E8%AF%BB%E5%AE%8C%E6%95%B4%E4%B8%AA%E5%8F%A5%E5%AD%90%E6%80%BB%E6%98%AF%E6%88%9B%E7%84%B6%E8%80%8C%E6%AD%A2">小爱音箱没有读完整个句子，总是戛然而止</a>。</li>
</ol>
<p>ttsCommand 和 wakeUpCommand 需要在 <a target="_blank" rel="noopener" href="https://home.miot-spec.com/">https://home.miot-spec.com</a> 页面搜索对应的音箱型号<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/20240612234942.png" alt="image.png"></p>
<p>点击规格后任选一个，选择 <code>Intelligent Speaker</code>，其中的 <code>[3, 1]</code> 对应的为 ttsCommand，<code>[3, 2]</code> 对应的为 wakeUpCommand。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/20240612235825.png" alt="image.png"></p>
<h2 id="创建配置文件-env"><a href="#创建配置文件-env" class="headerlink" title="创建配置文件 .env"></a>创建配置文件 <code>.env</code></h2><p>该文件中需要配置 OPENAI 的账号信息，我这里直接采用了阿里云的通义千问大模型服务，<a target="_blank" rel="noopener" href="https://help.aliyun.com/zh/dashscope/developer-reference/compatibility-of-openai-with-dashscope/">API 是完全兼容的</a>。</p>
<p>参考文档《<a target="_blank" rel="noopener" href="https://help.aliyun.com/zh/dashscope/developer-reference/activate-dashscope-and-create-an-api-key">开通DashScope并创建API-KEY</a>》 阿里云上开通大模型服务，获取到 API-KEY<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/20240611230914.png" alt="image.png"></p>
<p>参考项目中的文件<a target="_blank" rel="noopener" href="https://github.com/idootop/mi-gpt/blob/main/.env.example">.env.example</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># OpenAI（也支持通义千问、MoonShot、DeepSeek 等模型）</span><br><span class="line">OPENAI_MODEL=qwen-turbo</span><br><span class="line">OPENAI_API_KEY=获取到的API_KEY</span><br><span class="line">OPENAI_BASE_URL=https://dashscope.aliyuncs.com/compatible-mode/v1</span><br><span class="line"></span><br><span class="line"># Azure OpenAI Service（可选）</span><br><span class="line"># OPENAI_API_VERSION=2024-04-01-preview</span><br><span class="line"># AZURE_OPENAI_API_KEY=你的密钥</span><br><span class="line"># AZURE_OPENAI_ENDPOINT=https://你的资源名.openai.azure.com</span><br><span class="line"># AZURE_OPENAI_DEPLOYMENT=你的模型部署名，比如：gpt-35-turbo-instruct</span><br><span class="line"></span><br><span class="line"># 提示音效（可选，一般不用填，你也可以换上自己的提示音链接试试看效果）</span><br><span class="line"># AUDIO_SILENT=静音音频链接，示例：https://example.com/slient.wav</span><br><span class="line"># AUDIO_BEEP=默认提示音链接，同上</span><br><span class="line"># AUDIO_ACTIVE=唤醒提示音链接，同上</span><br><span class="line"># AUDIO_ERROR=出错了提示音链接，同上</span><br><span class="line"></span><br><span class="line"># Doubao TTS（可选，用于调用第三方 TTS 服务，比如：豆包）</span><br><span class="line"># TTS_DOUBAO=豆包 TTS 接口</span><br><span class="line"># SPEAKERS_DOUBAO=豆包 TTS 音色列表接口</span><br></pre></td></tr></table></figure>
<p>主要修改如下两个值：</p>
<ol>
<li>OPENAI_API_KEY：即为上文获取到阿里云<a target="_blank" rel="noopener" href="https://help.aliyun.com/zh/dashscope/">模型服务灵积</a>的 API-KEY。</li>
<li>OPENAI_MODEL：支持的模型，可以在《<a target="_blank" rel="noopener" href="https://help.aliyun.com/zh/dashscope/developer-reference/compatibility-of-openai-with-dashscope/#7f9c78ae99pwz">支持的模型列表</a>》中查询模型列表。</li>
</ol>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>提供了两种方式：docker 和 宿主机 Node.js 方式运行，我自然会选择更加简洁的 docker 方式。</p>
<p>执行 <code>docker run -d --name mi-gpt --env-file $(pwd)/.env -v $(pwd)/.migpt.js:/app/.migpt.js idootop/mi-gpt:3.1.0</code> 即可本地运行。</p>
<h1 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h1><p>提问小爱同学：“请问一下太阳的重量是多少”，小爱同学可以顺利的回答出答案。</p>
<p>通过 <code>docker logs mi-gpt -f</code> 可以看到如下的输出日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2024/06/12 16:15:38 Speaker 🔥 请问一下太阳的重量是多少</span><br><span class="line"></span><br><span class="line">2024/06/12 16:15:38 Speaker 🔊 让我先想想</span><br><span class="line"></span><br><span class="line">2024/06/12 16:15:41 Open AI ✅ Answer: 傻妞: 哦，太阳的重量可大了，它是个恒星，比我们的地球重得多。科学家们用的是质量而不是重量来衡量，太阳的质量大约是地球的333,000倍，真是个超级大块头，想想如果它能变成棉花糖，那得多软多亮啊！不过，太阳对我们来说太遥远了，它的重量咱们还是别去抱了，哈哈。</span><br><span class="line"></span><br><span class="line">2024/06/12 16:15:41 Speaker 🔊 傻妞: 哦，太阳的重量可大了，它是个恒星，比我们的地球重得多。科学家们用的是质量而不是重量来衡量，太阳的质量大约是地球的333,000倍，真是个超级大块头，想想如果它能变成棉花糖，那得多软多亮啊！不过，太阳对我们来说太遥远了，它的重量咱们还是别去抱了，哈哈</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/k8s/k8s-authenticate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/k8s/k8s-authenticate/" class="post-title-link" itemprop="url">k8s 中的用户认证方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-04-22 00:00:00" itemprop="dateCreated datePublished" datetime="2024-04-22T00:00:00+00:00">2024-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-17 16:09:25" itemprop="dateModified" datetime="2024-12-17T16:09:25+00:00">2024-12-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 k8s 中包含两类用户：</p>
<ol>
<li>ServiceAccount。又称服务账号，在运行 pod 时必须绑定 ServiceAccount，如果没有指定，则使用当前 namespace 下的 ServiceAccount default。是针对程序而言，用于 pod 中的程序访问 kube-apiserver。</li>
<li>普通用户。在 k8s 中并没有使用单独的对象来存储，而是通过了分发证书、外部用户认证系统等方式实现，是针对用户而言。</li>
</ol>
<h1 id="1-X509-证书认证"><a href="#1-X509-证书认证" class="headerlink" title="1. X509 证书认证"></a>1. X509 证书认证</h1><p>使用场景：使用 kubectl 访问 k8s 集群即通过 X509 证书认证方式，kubeconfig 本质上是个证书文件。</p>
<p>客户端使用证书中的 Common Name 作为请求的用户名，organization 作为用户组的成员信息。</p>
<p>证书的签发可以使用 openssl、cfssl 等工具来签发，也可以使用 k8s 自带的 CertificateSigningRequest 对象来实现签发。</p>
<h2 id="1-1-CertificateSigningRequest-签发证书"><a href="#1-1-CertificateSigningRequest-签发证书" class="headerlink" title="1.1. CertificateSigningRequest 签发证书"></a>1.1. CertificateSigningRequest 签发证书</h2><p>创建私钥信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out myuser.key 2048</span><br><span class="line">openssl req -new -key myuser.key -out myuser.csr -subj &quot;/CN=myuser&quot;</span><br></pre></td></tr></table></figure>

<p>创建如下的 CertificateSigningRequest 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | kubectl apply -f -</span><br><span class="line">apiVersion: certificates.k8s.io/v1</span><br><span class="line">kind: CertificateSigningRequest</span><br><span class="line">metadata:</span><br><span class="line">  name: myuser</span><br><span class="line">spec:</span><br><span class="line">  # value 使用命令 cat myuser.csr | base64 | tr -d &quot;\n&quot; 获取</span><br><span class="line">  request: xxx</span><br><span class="line">  # 固定值</span><br><span class="line">  signerName: kubernetes.io/kube-apiserver-client</span><br><span class="line">  # 过期时间</span><br><span class="line">  expirationSeconds: 86400  # one day</span><br><span class="line">  usages:</span><br><span class="line">  - client auth</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>查看 csr 处于 Pending 状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get csr</span><br><span class="line">NAME     AGE   SIGNERNAME                            REQUESTOR          REQUESTEDDURATION   CONDITION</span><br><span class="line">myuser   12s   kubernetes.io/kube-apiserver-client   kubernetes-admin   24h                 Pending</span><br></pre></td></tr></table></figure>

<p>批准给证书签发请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl certificate approve myuser</span><br></pre></td></tr></table></figure>

<p>签发完成后的证书会存放到 status.certificate 字段中，至此证书签发完成。</p>
<h1 id="2-ServiceAccount"><a href="#2-ServiceAccount" class="headerlink" title="2. ServiceAccount"></a>2. ServiceAccount</h1><p>使用场景：该方式使用较为常见，用于 pod 中访问 k8s apiserver。</p>
<p>原理：pod 可以通过 spec.serviceAccountName 字段来指定要使用的 ServiceAccount，如果没有指定则使用 namespace 下默认的 default ServiceAccount。kube-controller-manager 中的 ServiceAccount 控制器会在拉起的 pod 中自动注入如下的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  volumeMounts: </span><br><span class="line">  - mountPath: /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">    name: kube-api-access-j6vpz</span><br><span class="line">    readOnly: true</span><br><span class="line">  volumes:</span><br><span class="line">  - name: kube-api-access-j6vpz</span><br><span class="line">    projected:</span><br><span class="line">      defaultMode: 420</span><br><span class="line">      sources:</span><br><span class="line">      - serviceAccountToken:</span><br><span class="line">          expirationSeconds: 3607</span><br><span class="line">          path: token</span><br><span class="line">      - configMap:</span><br><span class="line">          items:</span><br><span class="line">          - key: ca.crt</span><br><span class="line">            path: ca.crt</span><br><span class="line">          name: kube-root-ca.crt</span><br><span class="line">      - downwardAPI:</span><br><span class="line">          items:</span><br><span class="line">          - fieldRef:</span><br><span class="line">              apiVersion: v1</span><br><span class="line">              fieldPath: metadata.namespace</span><br><span class="line">            path: namespace</span><br></pre></td></tr></table></figure>

<p>即将信息注入到 pod 的 &#x2F;var&#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount 目录下，目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">|-- ca.crt -&gt; ..data/ca.crt</span><br><span class="line">|-- namespace -&gt; ..data/namespace</span><br><span class="line">`-- token -&gt; ..data/token</span><br></pre></td></tr></table></figure>

<p>token 为 JWT 认证，对其格式解密后如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;RS256&quot;,</span><br><span class="line">  &quot;kid&quot;: &quot;u7rF5JCtJRNiMzSUOFAYvDpCwPqUII-N-OtxR59cnQ0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;iss&quot;: &quot;kubernetes/serviceaccount&quot;,</span><br><span class="line">  &quot;kubernetes.io/serviceaccount/namespace&quot;: &quot;default&quot;,</span><br><span class="line">  &quot;kubernetes.io/serviceaccount/secret.name&quot;: &quot;ingress-token-s9gtm&quot;,</span><br><span class="line">  &quot;kubernetes.io/serviceaccount/service-account.name&quot;: &quot;ingress&quot;,</span><br><span class="line">  &quot;kubernetes.io/serviceaccount/service-account.uid&quot;: &quot;19ce4f11-7105-43ce-b189-f3d71a2ffc74&quot;,</span><br><span class="line">  &quot;sub&quot;: &quot;system:serviceaccount:default:ingress&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-Secret-存放-token"><a href="#2-1-Secret-存放-token" class="headerlink" title="2.1. Secret 存放 token"></a>2.1. Secret 存放 token</h2><p>在 1.22 版本及之前版本中，token 以 Secret 的形式存在于 pod 所在的 namespace 下，且 token 不会过期。Secret 的名字存在于 ServiceAccount 的 spec 中，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">secrets:</span><br><span class="line">- name: nginx-token-scjvn</span><br></pre></td></tr></table></figure>

<p>而 Secret 通过 Annotation <code>kubernetes.io/service-account.name</code> 指定了关联的 ServiceAccount。</p>
<p>在后续版本中，为了兼容当前方案，如果 ServiceAccount 关联了 Secret，则认为仍然使用 Secret 中存放 token 的方式。如果 Secret 已经很长时间没有使用，则自动回收 Secret。</p>
<p>如果要手工创建一个 token Secret，可以创建如下的 Secret，k8s 自动会为 Secret 产生 token：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  name: build-robot-secret</span><br><span class="line">  annotations:</span><br><span class="line">    # 带有 annotation</span><br><span class="line">    kubernetes.io/service-account.name: build-robot</span><br><span class="line">type: kubernetes.io/service-account-token</span><br></pre></td></tr></table></figure>

<h2 id="2-2-TokenRequest-API-产生-token"><a href="#2-2-TokenRequest-API-产生-token" class="headerlink" title="2.2. TokenRequest API 产生 token"></a>2.2. TokenRequest API 产生 token</h2><p>在 1.22 之后的版本中，kubelet 使用 TokenRequest API 获取有时间限制的临时 token，该 token</p>
<p>会在 pod 删除或者 token 生命周期（默认为 1h）结束后失效。</p>
<p>可以使用 <code>kubectl create token default</code> 来为 ServiceAccount default 创建 token，该命令实际上向 kube-apiserver 发送了请求 <code>/api/v1/namespaces/default/serviceaccounts/default/token</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;kind&quot;: &quot;TokenRequest&quot;,</span><br><span class="line">    &quot;apiVersion&quot;: &quot;authentication.k8s.io/v1&quot;,</span><br><span class="line">    &quot;metadata&quot;:</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;creationTimestamp&quot;: null</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;spec&quot;:</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;audiences&quot;: null,</span><br><span class="line">        &quot;expirationSeconds&quot;: null,</span><br><span class="line">        &quot;boundObjectRef&quot;: null</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;status&quot;:</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;token&quot;: &quot;&quot;,</span><br><span class="line">        &quot;expirationTimestamp&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kube-apiserver 支持如下参数：</p>
<ol>
<li>–service-account-key-file：用来验证服务账号的 token。</li>
<li>–service-account-issuer：ServiceAccount token 的签发机构。</li>
<li>–service-account-signing-key-file：ServiceAccount token 的签发私钥。</li>
</ol>
<h1 id="3-用户伪装"><a href="#3-用户伪装" class="headerlink" title="3. 用户伪装"></a>3. 用户伪装</h1><p>一个用户通过 Http Header Impersonation- 的方式来扮演另外一个用户的身份。</p>
<p>场景：跨 k8s 集群访问的网关服务</p>
<p>支持的 Http Header 如下：</p>
<ol>
<li>Impersonate-User：要伪装的用户名。</li>
<li>Impersonate-Group：要伪装的组名。该 Header 可以为多个，即支持多个组。</li>
</ol>
<h1 id="4-bootstrap-token"><a href="#4-bootstrap-token" class="headerlink" title="4. bootstrap token"></a>4. bootstrap token</h1><p>使用 kube-apiserver 参数 <code>--enable-bootstrap-token-auth=true</code> 启用功能，引导 token 以 Secret 的形式存放在 kube-system 下。</p>
<p>该功能仅用于节点初始化时加入到 k8s 集群中。</p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authentication/">用户认证</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/k8s-apiserver-request-limit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/k8s-apiserver-request-limit/" class="post-title-link" itemprop="url">k8s apiserver 的限流</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-04-07 15:34:37" itemprop="dateCreated datePublished" datetime="2024-04-07T15:34:37+00:00">2024-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-12-17 16:09:25" itemprop="dateModified" datetime="2024-12-17T16:09:25+00:00">2024-12-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="client-端限流"><a href="#client-端限流" class="headerlink" title="client 端限流"></a>client 端限流</h1><p>在 client-go 中会默认对客户端进行限流，并发度为 5。可以通过修改 rest.Conifg 来修改并发度。</p>
<h1 id="MaxInFlightLimit-限流"><a href="#MaxInFlightLimit-限流" class="headerlink" title="MaxInFlightLimit 限流"></a>MaxInFlightLimit 限流</h1><p>通过如下参数来控制：</p>
<ul>
<li>–max-requests-inflight：代表只读请求的最大并发量</li>
<li>–max-mutating-requests-inflight：代表写请求的最大并发量</li>
</ul>
<p>该实现为单个 kube-apiserver 层面的，可以针对所有的请求。</p>
<h1 id="EventRateLimit"><a href="#EventRateLimit" class="headerlink" title="EventRateLimit"></a>EventRateLimit</h1><p>用来对 Event 类型的对象进行限制，可以通过 kube-apiserver 的参数 –admission-control-config-file 来指定配置文件，文件格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiserver.config.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">AdmissionConfiguration</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">EventRateLimit</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">eventconfig.yaml</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>其中 EventRateLimit 为对 Event 的限制，eventconfig.yaml 文件为详细的对 Event 的限流策略，可以精确到 Namespace 和 User 信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">eventratelimit.admission.k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Configuration</span></span><br><span class="line"><span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Namespace</span></span><br><span class="line">    <span class="attr">qps:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">burst:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">cacheSize:</span> <span class="number">2000</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">User</span></span><br><span class="line">    <span class="attr">qps:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">burst:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
<h1 id="API-优先级和公平性"><a href="#API-优先级和公平性" class="headerlink" title="API 优先级和公平性"></a>API 优先级和公平性</h1><p>版本状态：</p>
<ol>
<li>alpha：1.18</li>
</ol>
<p>通过 kube-apiserver 的参数 <code>--enable-priority-fairness</code> 来控制是否开启 APF 特性。</p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://qingwave.github.io/k8s-rate-limit/">kubernetes apiserver限流方案</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/flow-control/">API 优先级和公平性</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"kuring/kuring.github.io","repo_id":"MDEwOlJlcG9zaXRvcnkyODM4MzQ0NTk=","category":"Announcements","category_id":"DIC_kwDOEOr4W84CdeTU","mapping":"pathname","reactions_enabled":1,"emit_metadata":1,"theme":"light","lang":"zh-CN","crossorigin":"anonymous","input_position":"bottom","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
