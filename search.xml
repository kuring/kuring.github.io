<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mmap和munmap函数的用法</title>
    <url>/post/mmap_and_munmap/</url>
    <content><![CDATA[<p>在Linux的头文件sys&#x2F;mman.h中提供了两个用来分配内存的函数：mmap和munmap，函数定义原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>
<h1 id="mmap说明"><a href="#mmap说明" class="headerlink" title="mmap说明"></a>mmap说明</h1><p>返回值：内存映射后返回虚拟内存的首地址。<br>参数：<br>    start为指定的映射的首地址，该地址应该没有映射过，如果为0则有系统指定位置。<br>    length为映射的空间大小，真正分配空间大小为(length&#x2F;pagesize+1)。<br>    prot为映射的权限，分为四种未指定（PROT_NONE）、读（PROT_READ）、写（PROT_WRITE）、执行（PROT_EXEC）。如果为PROT_WRITE，则直接可以PROT_READ。<br>    flags：映射方式，分为内存映射和文件映射。内存映射：匿名映射。当值为文件映射是后面两个参数才有效。常用的值有：MAP_ANONYMOUS、MAP_SHARED、MAP_PRIVATE。<br>    fd：映射的文件描述符。<br>    offset为从文件的偏移位置开始映射。</p>
<h1 id="munmap说明"><a href="#munmap说明" class="headerlink" title="munmap说明"></a>munmap说明</h1><p>从start位置开始释放length个字节的内存。</p>
<h1 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = mmap(<span class="literal">NULL</span>,</span><br><span class="line">                  getpagesize(),</span><br><span class="line">                  PROT_READ | PROT_WRITE,</span><br><span class="line">                  MAP_ANONYMOUS | MAP_SHARED,</span><br><span class="line">                  <span class="number">0</span>,</span><br><span class="line">                  <span class="number">0</span>);</span><br><span class="line">    munmap(p, getpagesize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中getpagesize()函数的作用为获取一个页的大小，系统默认为4K。</p>
]]></content>
  </entry>
  <entry>
    <title>blog从farbox迁移到了hexo</title>
    <url>/post/mv-farbox-to-hexo/</url>
    <content><![CDATA[<p>清明节假期突然想起了我好久不更的blog，看到Farbox官网上的<a href="https://blog.farbox.com/post/2017">《2016，终结了几个产品》</a>，说明Farbox已经停止更新了。虽然我挺喜欢Farbox这个项目，也见证了Farbox的成长及作者做产品的思考，在这里也向作者致敬。</p>
<p>我当时开始准备启用Farbox之前试用过jekyll，翻遍了整个github，也没找到个合我心意的theme。幸好是Farbox的出现，让我眼前一亮，这就是我想好的blog系统了。Farbox的停更使我不得不考虑重新换个blog，虽然2016的文章数量仅为罕见的个位数，但有可能今年有时间会多写一些。</p>
<p>近几年hexo特别的火，在试看了官方文档了解功能及考虑了blog的迁移成本后，心想，这就是我想要的blog系统了。hexo该有的功能全都有，甚至比Farbox要强大很多。Farbox的很多设计思想跟hexo相仿，但hexo显的更加自由，blog需要自己一手搭建完成。</p>
<p>当然hexo要想使用的好，做一些全面的了解及折腾是必不可少的，毕竟最终利用的Github pages是个静态的系统。早已没有了想当年翻遍整个github上jekyll theme的精力了，我这次的基调是能少折腾就少折腾，毕竟blog我也不是经常写，访问量也更是少的可怜，就当全面了解下当前最火的hexo就好了。</p>
<h1 id="theme"><a href="#theme" class="headerlink" title="theme"></a>theme</h1><p>本着不折腾原则，直接启用了很火的hexo-theme-next，文档比较全，维护比较及时。基本上按照文档走一遍，该配置的就都可以配置上了。</p>
<h1 id="代码同步"><a href="#代码同步" class="headerlink" title="代码同步"></a>代码同步</h1><p>代码通过git同步是必备技能。</p>
<h2 id="hexo项目代码同步"><a href="#hexo项目代码同步" class="headerlink" title="hexo项目代码同步"></a>hexo项目代码同步</h2><p>hexo采用的是node.js环境，而Github pages是静态的，因此Github pages上仅能存储的是hexo编译后的静态文件，这些静态文件直接通过<code>hexo d</code>部署到kuring.github.com仓库中就可以了。</p>
<p>而对于项目中的_config.yml、md文件我直接用git同步到Github上另外一个项目hexo_bak中了。网上还有思路是同步到kuring.github.com上的另外一个分支，我感觉太啰嗦，容易出错，还不如直接分开来的简便。</p>
<h2 id="theme项目的代码同步"><a href="#theme项目的代码同步" class="headerlink" title="theme项目的代码同步"></a>theme项目的代码同步</h2><p>theme项目中也包含了部分自己的配置及修改，我这里选择的同步策略为从github上fork对应的theme项目，然后clone fork下来的项目到本地，然后直接在theme的项目中通过git命令同步到github fork的项目中。</p>
<p>网上也有思路是通过git subtree的方式来解决，我仍然感觉太啰嗦，不采用。</p>
<p>但这样一个blog项目需要多个git仓库，git push起来会比较麻烦，好在theme一般不怎么修改。</p>
<h1 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h1><p>之前用多说的时候也没几个评论的，用起来还不错，至少比被墙了的disqus要好很多，可是多说这么好的项目要关闭了。我直接使用了国内的网易云跟帖来满足评论的需求。</p>
<h1 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h1><p>站内搜索是必不可少的功能，next主题提供了多种选择，我直接使用了hexo-generator-searchdb通过本地搜索来完成，生成的xml文件目前还比较小，效果还可以。</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul>
<li>启用本地server端：<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></li>
<li>部署到github：<code>hexo d</code></li>
<li>发布文章：<code>hexo new 文章url</code></li>
</ul>
<p>使用<code>hexo new draft test</code>会在source&#x2F;_drafts目录下创建对应文件，此时文件不会生成页面，用于存放未写完的文章。<code>hexo publish draft test</code>命令可将_drafts下的文章移动到_posts目录下，并添加创建时间等信息。</p>
<h1 id="收个尾"><a href="#收个尾" class="headerlink" title="收个尾"></a>收个尾</h1><p>blog总算迁移完成了，期望今年能多写上几篇。</p>
]]></content>
      <tags>
        <tag>hexo farbox</tag>
      </tags>
  </entry>
  <entry>
    <title>通过python来抓取和解析网页内容</title>
    <url>/post/python_parse_web/</url>
    <content><![CDATA[<p>最近这段时间回顾了下python，距离上次使用python已经超过两年的时间了。</p>
<p>相对于c++语言，python要灵活许多，对于工作中的一些小问题的解决可以通过python来实现比较高效和方便，比如网页的抓取和解析。甚至对于非IT的工作，也可以通过脚本的方式来解决，只要是工作中遇到反复处理的体力活劳动就可以考虑利用编程方式来解决。</p>
<p>本文以我的博客的<a href="http://kuring.me/archive">文档列表页面</a>为例，利用python对页面中的文章名进行提取。</p>
<p>文章列表页中的文章列表部分的url如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;listing&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;listing-item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;date&quot;</span>&gt;</span>2014-12-03<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/post/linux_funtion_advance_feature&quot;</span>  <span class="attr">title</span>=<span class="string">&quot;Linux函数高级特性&quot;</span> &gt;</span>Linux函数高级特性<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;listing-item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;date&quot;</span>&gt;</span>2014-12-02<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/post/cgdb&quot;</span>  <span class="attr">title</span>=<span class="string">&quot;cgdb的使用&quot;</span> &gt;</span>cgdb的使用<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="requests模块的安装"><a href="#requests模块的安装" class="headerlink" title="requests模块的安装"></a>requests模块的安装</h1><p>requests模块用于加载要请求的web页面。</p>
<p>在python的命令行中输入<code>import requests</code>，报错说明requests模块没有安装。</p>
<p>我这里打算采用easy_install的在线安装方式安装，发现系统中并不存在easy_install命令，输入<code>sudo apt-get install python-setuptools</code>来安装easy_install工具。</p>
<p>执行<code>sudo easy_install requests</code>安装requests模块。</p>
<h1 id="Beautiful-Soup安装"><a href="#Beautiful-Soup安装" class="headerlink" title="Beautiful Soup安装"></a>Beautiful Soup安装</h1><p>为了能够对页面中的内容进行解析，本文使用Beautiful Soup。当然，本文的例子需求较简单，完全可以使用分析字符串的方式。</p>
<p>执行<code>sudo easy_install beautifulsoup4</code>即可安装。</p>
<h1 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h1><p>python的编码问题确实是一个很头大的问题，尤其是对于不熟悉python的菜鸟。</p>
<p>python自身的编码问题就已经够头大的了，碰巧requests模块也有一个编码问题的bug，具体的bug见参考文章。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python                                                                                                                                                           </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; a http parse test programe &#x27;</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&#x27;kuring lv&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line">archives_url = <span class="string">&quot;http://kuring.me/archive&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_parse</span>(<span class="params">url</span>) :</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;开始获取(%s)内容&quot;</span> % url</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;获取网页内容完毕&quot;</span></span><br><span class="line">    </span><br><span class="line">    soup = bs4.BeautifulSoup(response.content.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="comment">#soup = bs4.BeautifulSoup(response.text);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 为了防止漏掉调用close方法，这里使用了with语句</span></span><br><span class="line">    <span class="comment"># 写入到文件中的编码为utf-8</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;archives.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f :</span><br><span class="line">        <span class="keyword">for</span> archive <span class="keyword">in</span> soup.select(<span class="string">&quot;li.listing-item a&quot;</span>) :</span><br><span class="line">            f.write(archive.get_text().encode(<span class="string">&#x27;utf-8&#x27;</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span> archive.get_text().encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当命令行运行该模块时，__name__等于&#x27;__main__&#x27;</span></span><br><span class="line"><span class="comment"># 其他模块导入该模块时，__name__等于&#x27;parse_html&#x27;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :</span><br><span class="line">    start_parse(archives_url)</span><br></pre></td></tr></table></figure>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><p><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000">廖雪峰的python教程</a></p>
</li>
<li><p><a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html">Beautiful Soup 4.2.0 文档</a></p>
</li>
<li><p><a href="http://wuchong.me/blog/2014/04/24/easy-web-scraping-with-python/">使用 Python 轻松抓取网页</a></p>
</li>
<li><p><a href="http://www.au92.com/archives/python-requests-chinese-improve-random-code.html">Python+Requests抓取中文乱码改进方案</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>北京自驾青海甘肃大环线系列 - 1</title>
    <url>/post/qinghai-1/</url>
    <content><![CDATA[<p>近期有一段较为充裕的假期，出去旅游对我而言是再合适不过的选择，带着对远方田野的那份向往。特别有意向的方向有两个：南下和西进。</p>
<p>南方的很多地方都未曾去过， 比如张家界、桂林等，可以从北京出发一路到海南三亚地区，而且当下正巧是烟花三月下江南的好季节。</p>
<p>对于西部地区向往已久，青海、西藏和新疆地区都未曾去过，当下四月份不是西部地区的最佳旅游季节，山基本上还都是枯黄色，草儿还在沉睡中。</p>
<p>但心想南方交通较为便利，后续会去的可能性比较大，而且景区之间跨度较大，可以分开旅游。而西部往往需要拿出一大把的时间来玩耍才能尽兴，很多地方的交通不是特别方便，往往都是需要多个景点一起才最划算。</p>
<p>因此，最终的决定是<code>北京自驾甘肃-青海大环线</code>。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/1.png"></p>
<p>此刻的我已经结束了整个行程，行程的时间段为2019.4.18 - 2019.4.30，共计13天时间。起点为北京市，终点为山东省，整个的行程达6000公里。</p>
<p>事先计划的时间为12天，留了一天的buffer，最终用时为13天，没有太大的偏差。由于一直是我一人在开车，相对而言还是比较累的，基本上一天得开500公里，尤其是前面和后面赶路的时间，基本上一天在600公里以上。大部分时间是上午在10点之后出发，下午开车的时间比较多，很多时候需要晚上开一段时间才能满足一天的行程目标。如果时间比较充裕，把整个行程放慢为20天，感觉会比较轻松，会对旅行有更深的体会，只是我时间不太允许。</p>
<p>一路上经过北京、河北、山西、陕西、宁夏、甘肃、青海、河南、山东这些省，地貌包括平原、山脉、黄土高原、戈壁、沙漠、黄河、湖泊、雪山、盆地等地貌。</p>
<p>这一路上遇到的很多地方，之前在历史和地理课本上曾经了解过，很多地方有比较深厚的历史和文化底蕴，自己的认识却是很浅薄，而旅行可以加深对一个地方的地理和历史的认识，正所谓：“纸上得来终觉浅，绝知此事要躬行”。</p>
<p>本系列文章并不打算写成单纯游记的形式，而是更多会将我个人的体会和相关的历史地理知识融合在其中，在这其中查阅相关的资料对我而言也是一种成长。由于才疏学浅，所查资料有限，很多观点不见得是正确的，欢迎指正。</p>
<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>行程：北京市 -&gt; 山西省忻州市保德县</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day1-1.png"></p>
<p>上午11点从北京出发，驱车700公里，晚上八点半到达山西省忻州市保德县城。</p>
<p>先后经过了华北平原、太行山脉、黄土高原，北京和河北境内大部分属于华北平原，河北和山西省的交界处为太行山脉，期间穿过了多个隧道，基本上是整个的行程中走过的最长的一段隧道了，后续除了祁连山脉、六盘山外隧道就比较少了。</p>
<p>到了山西，以黄土高坡地貌为主，黄土高原也是整个行程中看到最多的地貌了。黄土高原东起太行山脉，西至青海省日月山，南抵秦岭，北达长城，包括了山西、陕西、宁夏、甘肃、青海、河南、内蒙古7个省。比我印象中的要大得多，我印象中主要是在山西境内和陕西的北部地区，一下子刷新了我的认知。</p>
<p>大家都知道，黄土高原是水土流失导致现在的千沟万壑的地貌，也是因此而导致黄河水特别的黄，那么是什么时间段发生的水土流失呢？历史上的黄土高原又是什么样的呢？</p>
<p>黄土高原最初是被植被茂密的森林所覆盖，而且土壤在有充足水源的情况下还是特别肥沃的，并非大家印象中的植被少的可怜，要不然也不可能孕育出华夏文明。相反，正是由于黄土土质疏松易开垦的特点，才容易诞生人类文明，因为最早的人类文明生产工具是特别简陋的，对大自然的改造能力特别有限。黄土高原被破坏的历史时期基本上伴随着华夏文明的发展，到明清时期达到顶峰，建国之后开始逐渐恢复。</p>
<p>很难想象，偌大的黄土高原，竟然因为农耕时代的人类影响变成了如今这幅模样。假如再给现代的人类一次利用自然的机会，我想当下的人类一定会善加利用这片广袤的土地，黄河也许会改成另外一个名字。也就是说，人类不同的文明程度决定了对自然的破坏程度。</p>
<p>但今天的我们殊不知也在对自然进行着更深层次的破坏，如果放到未来来审视我们人类今天的作为，我们今天对这个星球的破坏要大大高于农耕时代对地球的破坏。比如，人类在贪婪的消耗着地球上的石油、煤炭资源，也许在不久的未来，人类会发现在这些燃料资源中还蕴藏着无穷尽的价值，但是这些资源已经被当下愚蠢的人类当做燃料给烧掉了。</p>
<p>一路上雾霾还是比较严重的，尤其是河北保定境内。保定的空气质量是早有心理预期，印象中山西的整体空气还是非常不错的。去年去过一次五台山，穿过几个长长的隧道进入山西境内后，空气会一下子好转，山西省忻州市的空气跟河北省保定的空气质量有着强烈的反差。但这次结果却比较失望，在整个山西境内并未出现晴空万里，而且看上去更像是雾霾，而不是阴天。</p>
<p>山西省境内有那么几段高速，连一辆车都看不到，让我一度怀疑已经抵达大西北的感觉。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day1-2.jpeg" alt="服务区已成为乌鸦的聚集地"></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day1-3.jpeg" alt="从服务区鸟瞰村庄"></p>
<p>晚上到达保德县，县城傍黄河而建，位于河道东侧。离黄河稍远的地方是黄土高坡，大部分楼房都离建在离黄河较劲的地势平坦处，而黄土高坡上由于地势的原因房屋逐渐变少。一进入县城，道路上到处都是开着远光灯的，仿佛对面一颗颗行进中的太阳，闪的我实在有些难受。有点匪夷所思，明明有路灯，实在想不明白远光灯的用途。真期望每个人作为社会中的一份子，在做事情的时候要多为他人考虑一分，而不是仅顾及自己的感受。</p>
<p>保德县城到处打着扫黑除恶的标语，吓得我开车都格外小心。甚至连小区门口都打着口号，让市民天天回家都可以看到。我深知越是提倡什么，说明越是缺少什么。后来走过好多地方后，发现到处都打着该口号，并不是当地特色。</p>
<p>却道是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">驱车青甘大环线</span><br><span class="line">夜晚留宿保德县</span><br><span class="line">县城建在黄河畔</span><br><span class="line">黄土高坡把城建</span><br><span class="line">黄河对岸府谷县</span><br><span class="line">一桥之隔秦晋缘</span><br></pre></td></tr></table></figure>

<p>未完待续…</p>
]]></content>
      <tags>
        <tag>青海甘肃大环线</tag>
      </tags>
  </entry>
  <entry>
    <title>北京自驾青海甘肃大环线系列 - 2</title>
    <url>/post/qinghai-2/</url>
    <content><![CDATA[<h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day2-1.png"></p>
<p>行程：山西省保德县 -&gt; 陕西省榆林市府谷县 -&gt; 宁夏回族自治区中宁县</p>
<p>路程：600公里</p>
<h3 id="第一站-府谷县"><a href="#第一站-府谷县" class="headerlink" title="第一站 - 府谷县"></a>第一站 - 府谷县</h3><p>第一天留宿的保德县临近黄河，早上醒来后本想去黄河边看下景色，其实最关心的是中段黄河的河水是什么颜色的，可惜黄河边是一条公路沿着黄河蜿蜒，而且局部在修，因为黄河的地势较低，视线受阻严重，连黄河都没看到。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day2-6.jpeg"></p>
<p>索性直接导航到了黄河对岸的府谷县，山西省保德县跟陕西省榆林市府谷县隔黄河相望，仅一河之遥，可以在跨河大桥上非常方便的在两个省之间通行。跨河大桥并不是特别宽，两车会车是没任何问题的，桥上还有一些行人在通行。上图为连接两省的大桥，在府谷县可以看到“秦晋之好“几个大字。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day2-2.png"></p>
<p>保德县虽紧挨着黄河，却没有依靠上黄河的任何优势，反而黄河成为了一大劣势。相反，府谷县却非常明智的，楼房离着黄河稍有一段距离，选择在黄河边修建了滨河公园供休闲娱乐。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day2-5.jpeg"></p>
<p>在府谷县的滨河公园可以清晰看到和对面的山西省保德县城，建筑物的朝向大多都是面向黄河，或者面向对面的府谷县城的。</p>
<p>由于现在是枯水期，人行道离河水还有一段距离，但仍可以看出黄河水还是特别清澈的，跟黄河的淤泥还是有比较鲜明的区别。跟更下游那夹杂的泥沙的黄河水一对比，让人完全联想不到是一条河。后面的行程中在更上游看到了几次黄河，但河水都要比此段的黄河水要黄，至少兰州的黄河水夹杂的泥沙量已经非常大，也就是说此段黄河水是我见到最清澈的。不知道是否我的判断有误，从理论上讲应该越下游黄河水越黄才对的。</p>
<h3 id="在路上"><a href="#在路上" class="headerlink" title="在路上"></a>在路上</h3><p>下午一点从府谷县出发，直奔西宁方向而去，最终到达了宁夏回族自治州中卫市中宁县城，最初地貌还是黄土高坡，大概从榆林市之后逐渐沙漠化，地上草还没长出来，在高速上很难判断远处是草原，还是完全的荒漠。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day2-7.jpg"></p>
<p>上图为在高速上的简陋厕所，与其说是黄土高坡地貌，我感觉更像是荒漠。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day2-3.png"></p>
<p>本以为到达宁夏后，地貌会变成接近于草原，因为提到宁夏我最先想到的是黄河冲积而成的河套平原。一路上一直在期盼，但一直也没遇到梦中的草肥水美的河套平原。事后一查资料才发现，即使河套平原最南的“西套”地区也在银川市周边，而我走的高速在银川市的南边大约100多公里的距离，可以说是跟河套平原擦肩而过。从卫星地图上可以清晰的看出河套地区的植被还是比较茂密的。上图中绿色的线为我经过的路线。</p>
<h3 id="终点站-中宁县"><a href="#终点站-中宁县" class="headerlink" title="终点站 - 中宁县"></a>终点站 - 中宁县</h3><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day2-4.png"></p>
<p>最终到达了宁夏回族自治州中卫市中宁县城，到达中宁县后，恰巧赶上了一次沙尘暴，停车吃饭的时候，车上已经积了厚厚的一层土。本以为沙尘暴在当地是家常便饭，问下了当地人，说是沙尘暴也不常有，沙尘是从北部的腾格里沙漠吹过来的。从上图中可以看出，中宁县离得腾格里沙漠还是特别近的，刮个北风，沙尘天气还是非常容易出现的。</p>
<p>比较巧合的是，中宁县也恰巧在黄河边上，一天之内，驱车600公里，从黄河“几”字形的右边到达了左边位置。</p>
<p>却道是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日行千余里</span><br><span class="line">胜似的卢骋</span><br><span class="line">朝食保德县</span><br><span class="line">夕塌宁安镇</span><br><span class="line">黄土变沙漠</span><br><span class="line">高山转草原</span><br><span class="line">早在黄河畔</span><br><span class="line">夕亦黄河边</span><br><span class="line">自东向西行</span><br><span class="line">作何现此况</span><br><span class="line">若君心有疑</span><br><span class="line">一览地图觅</span><br></pre></td></tr></table></figure>

<p>未完待续…</p>
]]></content>
      <tags>
        <tag>青海甘肃大环线</tag>
      </tags>
  </entry>
  <entry>
    <title>北京自驾青海甘肃大环线系列 - 3</title>
    <url>/post/qinghai-3/</url>
    <content><![CDATA[<h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p><img src="http://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day3-1.png"></p>
<p>行程：宁夏回族自治区中卫市中宁县 -&gt; 青海省西宁市</p>
<p>路程：500公里</p>
<p>日期：2019.4.20</p>
<p><img src="http://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day3-2.jpeg"></p>
<p>昨晚到酒店比较晚，早上拉开窗帘，一所学校的操场映入眼帘，令我眼前一亮。离开校园已经太久了，看到同学们身穿运动装在操场上洋溢着青春即亲切又陌生。</p>
<h3 id="第一站-黄河畔"><a href="#第一站-黄河畔" class="headerlink" title="第一站 黄河畔"></a>第一站 黄河畔</h3><p>从地图上看中宁县城离黄河比较近，自然要去黄河边上走一走。但与保德县和府谷县不同的是，中宁县并不傍黄河而建，主城区而是离黄河有一公里的距离。我猜测保德县和府谷县边的黄河在地势低洼处，即使河水泛滥也不会殃及县城。但中宁县地势却是非常平坦，不能依靠地势优势阻止泛滥的河水，因此县城的选址离黄河稍有距离。</p>
<p><img src="http://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day3-3.jpeg"></p>
<p><img src="http://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day3-4.jpeg"></p>
<p>远处的黄河边上有一个多层的塔，是中宁县枸杞博物馆，中宁县有“天下枸杞出宁夏,中宁枸杞甲天下”的说法，因此建个枸杞博物馆还是比较合适的。由于到枸杞博物馆的路并不好走，而且不能判断此刻博物馆是对外开放，并未前往参观。</p>
<p>黄河水比其下游的府谷县的黄河水要变黄了很多，这也是我一直比较奇怪的地方。河道非常宽，目测有至少1公里的样子，现在是枯水期，河水并不太多。河床上有各式各样的鹅卵石，不知经过了多少次的河水冲刷才形成了现在的形状，我们个体的生命相对鹅卵石的生命实在是太短，挑选了几个像模像样的留作纪念。</p>
<h3 id="在路上"><a href="#在路上" class="headerlink" title="在路上"></a>在路上</h3><p><img src="http://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day3-5.jpeg"></p>
<p>宁夏境内，一路上偶尔会看到种植了一些铺着地膜的农作物，我猜测是土豆的可能性比较大，原因是山东的种植土豆方法就是类似思路。但看下田地中的土质，大部分都是小石块，哪有多少土壤成分呀，倒是拿着石块压着地膜来防止大风非常的方便。</p>
<p>在甘肃和青海接壤地方，道路两侧多了很多树木，，山上的草有很多都绿了起来，生机勃勃的。两天之内满眼都是枯黄色的画面，突然出现鲜绿色还有点不适应。</p>
<p><img src="http://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day3-6.png"></p>
<p>查看青海省的地图会发现，有好几个地级市都是围绕着青海湖命名的，海东市、海南藏族自治州、海西蒙古族藏族自治州、海北藏族自治州。提到海南，不熟悉的人还以为是海南岛呢。</p>
<p><img src="http://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day3-7.png"></p>
<p>地图中还有一个比较有意思的地方，海西蒙古族藏族自治州居然有两块区域，中间被玉树给分割开了，完全不接壤。让我立马想到的是在中国版图中另外比较有意思的是河北省的三河市，三河市被北京市和天津市包围，像是河北省的一个孤岛。</p>
<p>青海省有藏族和回族比较容易理解，居然还有蒙古族？要不也就不会叫海西蒙古族藏族自治州了。实际上内蒙古的最西端跟青海省仅隔了甘肃省一段狭长的河西走廊，直线距离上还是特别近的。蒙古族迁徙到青海要从元朝说起，整个中国的版图都是元朝的天下，自然青海省有就了蒙古族，后续又陆陆续续的有蒙古族迁徙都青海省。但青海省的蒙古族还吸收了部分当地藏族的习俗，很难说是蒙古族入侵藏族，还是藏族同化了蒙古族。</p>
<p>青海境内的青藏高速施工，走了很长一段的非高速，跟青海的村庄和县城有了第一次近距离接触的机会。青海省的海东市相对于甘肃而言，植被还是比较茂盛的，树木挺多的，沿路很多梨树，开着洁白的梨花。经过村庄的房屋看起来也不差，很多都是二层的小楼，而且村庄还是比较密集的，大概青海人口都聚集在了东部地区。总体给我外观感受，海东地区要比甘肃东部地区富裕很多。</p>
<h3 id="第二站-西宁市"><a href="#第二站-西宁市" class="headerlink" title="第二站 西宁市"></a>第二站 西宁市</h3><p><img src="http://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day3-10.png"></p>
<p>西宁市属于中国的西部地区，如果放眼到中国的地图中，相同纬度上，西宁算是比较靠中间的城市了，如果不是西部人烟稀少，更像是个中部城市。</p>
<p><img src="http://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day3-9.jpeg"></p>
<p>晚上八点钟到达西宁市，事先知道青海省的人口只有区区600万，省会应该不咋地，结果还挺另我刮目相看的，城区面积感官上还是挺大的，颇具省会城市的规模，各种品牌应有尽有，夜景也还不错。</p>
<p><img src="http://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day3-8.jpeg"></p>
<p>晚上吃了一碗当地特色羊肠面，面相不咋地，吃起来味道还不错。</p>
<h3 id="收个尾"><a href="#收个尾" class="headerlink" title="收个尾"></a>收个尾</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">人人都说宁夏美</span><br><span class="line">砂石大漠看到尾</span><br><span class="line">甘东地区很荒凉</span><br><span class="line">似乎水源很紧张</span><br><span class="line">夏都街头走一走</span><br><span class="line">车水马龙大高楼</span><br></pre></td></tr></table></figure>

<p>未完待续…</p>
]]></content>
      <tags>
        <tag>青海甘肃大环线</tag>
      </tags>
  </entry>
  <entry>
    <title>北京自驾青海甘肃大环线系列 - 4</title>
    <url>/post/qinghai-4/</url>
    <content><![CDATA[<h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day4-1.png"></p>
<p>行程：西宁市 -&gt; 海南藏族自治州黑马河镇</p>
<p>路程：250公里</p>
<p>日期：2019.4.21</p>
<p>经过了前三天的长途跋涉，今天开始了正式的旅行。早上在西宁市的华润万家采购了一些食物，因为还不太清楚接下来的大环线旅行中沿途的住宿饮食条件是什么样子的，也不太清楚很多情况下是否有足够的时间来饱餐一顿，毕竟每天都要赶很多的路。</p>
<h3 id="第一站-塔尔寺"><a href="#第一站-塔尔寺" class="headerlink" title="第一站 塔尔寺"></a>第一站 塔尔寺</h3><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day4-2.jpg"></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day4-9.jpg"></p>
<p>塔尔寺通常都是大家青海旅游的第一站，因为距离西宁市区比较近，大概有几十公里的路程，开车一个小时即可到达。</p>
<p>塔尔寺属于典型的藏传佛教圣地，藏传佛教是受印度佛教、青藏高原本土的苯波教和汉传佛教影响的共同产物，因此有很多区别于其他佛教分支的特点。唐朝时期的文成公主是信奉佛教的，远嫁松赞干布后，为汉族的佛教向青藏地区的渗透起到了非常大的作用。</p>
<p>塔尔寺在藏传佛教中的地位应该跟五台山差不多，但同时也吸收了一些中原道教的文化，比如寺内能看到有西王母的塑像。寺内建筑宏伟，院落也较多，比起五台山而言，除了整体面积小点，其它方面并不逊色。</p>
<p>未能领悟佛教的我，草草的参观塔尔寺后，明显发现了藏传佛教的很多特色，也带给了我不少的震撼。</p>
<p>好几个大殿的院内或者周围都有虔诚的佛教徒在做周而复始的朝拜，口中还振振有词，木质结构的地板早已磨的光滑无比。那种虔诚、执着非常值得敬佩，虽然以我现在的阅历还很难理解这种宗教行为。</p>
<h3 id="第二站-日月山"><a href="#第二站-日月山" class="headerlink" title="第二站 日月山"></a>第二站 日月山</h3><p>从塔尔寺出来后，已经是下午两点了，接下来就要往青海湖进发了。日月山是此行的必经之路，属于祁连山脉的支脉，也是此行中看到的第一个雪山，沿途海拔在3000米以上。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day4-10.jpg"></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day4-11.jpg"></p>
<p>进入日月山之前，阳光普照，高原的阳光相当强烈，隔着车玻璃都能感觉到。一开进日月山，雪山清晰可见，突然下起了冰雹，紧接着又下起了雨夹雪，原本没有积雪覆盖的山上也披上了一层薄薄的银装。这一切仿佛在预示着什么，仿佛在迎接着远道而来的客人，又仿佛是在告诫我不要打扰到了雪山上的神灵。</p>
<p>因为日月山的风景太美，全然没有了赶路的想法，就想驻足体验一下日月山的神奇。主干道是京藏高速，有条公路可以通往日月山风景区，索性直接开往日月山风景区。到了景区门口，雨夹雪渐小，一下车发现空气凉了好多，原本仅穿了单件衣服，感觉立马要穿羽绒服的节奏，穿了件外套仍冻得直打哆嗦。高原的天气就是这般神奇，有阳光和没有阳光完全就是两个世界。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day4-3.jpg"></p>
<p>日月山风景区并没有必要进入参观，因为景观在景区外一览无余。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day4-4.jpg"></p>
<p>景区旁边能看到很多高原鼠兔，发出吱吱的响声，这玩意特别爱打洞，鼠兔的旁边可以看到几个洞。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day4-5.jpg"></p>
<p>之后的行程中在公路边上看到了一只死去的马匹，马的头颅已不知所踪。我想放到东部地区，这种现象是肯定不会出现的，死去的马儿肯定还有它的利用价值。</p>
<h3 id="第三站-青海湖"><a href="#第三站-青海湖" class="headerlink" title="第三站 青海湖"></a>第三站 青海湖</h3><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day4-6.jpg"></p>
<p>从日月山出来沿着G109国道继续前行，中间经过了倒淌河风景区，倒淌河水源自日月山，自东向西注入青海湖，故名倒淌河。倒淌河的水量不大，加上本来也很难分清东南西北，就很难体会到倒淌河的精妙。看评价景点比较坑，并没有进入参观。</p>
<p>过不了多久，青海湖就会出现在了眼前，而且接下来的两个多小时会一直沿着青海湖南沿的公路前进，足足有一百公里的距离，不愧为中国最大的湖泊。青海湖有个游客去的较多的二郎剑景区，并没有进入，据说性价比依旧很低，无非就是看湖，青海湖的美从哪个角度都能感受到。</p>
<p>G109国道跟青海湖稍微有一段距离，最近处差不多有一里路的样子，中间都是草原，被牧民给围成了一块一块，山羊绵羊在悠闲的吃着草。找了一处牧民的区域，开车过去，一人10元的门票，即可到青海湖边拍照。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day4-12.jpg"></p>
<p>身为游客一定觉得湖边的牧民是真正的逍遥快活，每天在自己的牧场上骑马放牧，住在青海湖畔，远处有雪山作伴，呼吸着几乎没有污染的空气。可是一旦天天都是这样的生活，又有几个游客可以放下尘世间的所有诱惑来到这近乎纯净的地方呢？牧民们也有自己的烦恼，牧民的孩子上学怎么办，牧民们生病了怎么办，各种生活的不便利。虽呼吸着最新鲜的空气，却也承受着杀伤力很强的紫外线。冬天的高原夜晚想想都会瑟瑟发抖，但牧民们也要忍受。</p>
<p>我天真的以为，青海湖最初是真正的大海，后来由于地壳运动，地壳上升，而青海湖变成了一个内陆湖。哈哈，不过这个来源忽悠人还是蛮不错的。后来经查阅资料，青海湖的最初是一个内陆淡水湖，并且注入黄河。后来由于地壳运动，青海湖流入黄河的入口被切断，从而青海湖没有了任何出水口。再加上天气较为干旱，湖水的蒸发量大于湖水的注入量，导致湖水的盐分浓度逐渐增加，从而变成了一个咸水湖。青海境内的咸水湖成因都是因为蒸发量大于注入量，包括比较出名的茶卡盐湖。青海湖的湖水浓度并没有海水的浓度高，湖水帮大家尝过了，确实挺咸的。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day4-8.jpeg"></p>
<p>青海湖的湖水非常清澈，虽湖水很宽，但空气透彻，一眼可以望到河对面远处的雪山。远处的云朵看起来非常低，跟湖水连在一起，微风吹过，湖水上一层层的波澜。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day4-7.jpeg"></p>
<p>湖边的小水坑里已经有了青蛙，晚上的青海湖畔温度还是非常低的，不知道这些青蛙夜晚是怎么度过的。当然这些小水坑的水是纯淡水，亲尝无误。</p>
<h3 id="终点站-黑马河镇"><a href="#终点站-黑马河镇" class="headerlink" title="终点站 黑马河镇"></a>终点站 黑马河镇</h3><p>黑马河位于青海湖的西端，因为是去往茶卡盐湖的必经之地，且可以看到青海湖，因此顺其自然靠着旅游而生存。早晨起来看日出的是个不错的地方，可以想象一下朝霞倒映在湖水中的场景，很多游客都会选择在黑马河观日出。</p>
<p>到达黑马河已经是晚上八点多了，温度较低，索性换上羽绒服，一点也不觉得热。住宿条件比较一般，但价格却不便宜，是整个行程住的性价比最低的宾馆了。找了一家餐馆就餐，全都是组团的游客，非常不错的食材却做的难吃的不行，上等的牦牛肉放到餐桌上后却嚼也嚼不烂，看着放弃的牦牛肉甚是可惜。这大概就是国内很多因旅游而起的餐馆的真实写照，反正能坑一个是一个，不要回头客，回回都是新客人。做的烂对自己的生意影响不大，但游客在心中对于当地的评价确实难以磨灭的。</p>
<p>未完待续…</p>
]]></content>
  </entry>
  <entry>
    <title>北京自驾青海甘肃大环线系列 - 5</title>
    <url>/post/qinghai-5/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day5-1.png"></p>
<p>行程：海南藏族自治州黑马河乡（9:30） -&gt; 茶卡盐湖（11:30 - 15:00）-&gt; 柴达木盆地 -&gt; 可鲁克湖（18:00 - 18:30） -&gt; 大柴旦镇（21:00）</p>
<p>路程：500+公里</p>
<p>日期：2019.4.22</p>
<p>今天是整个行程的第五天，第四天晚上到达了青海湖西端的黑马河乡，今天的主要行程是茶卡盐湖，以及横穿几乎整个柴达木盆地。</p>
<h2 id="黑马河日出"><a href="#黑马河日出" class="headerlink" title="黑马河日出"></a>黑马河日出</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day5-2.jpg"></p>
<p>黑马河地处青海湖最西端，往东边看去是平静的湖水，完全没有任何遮挡，加上高原的空气通透性特别好，况且地处干旱地带，以晴天为主，是个看日出的绝佳地点。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day5-3.jpg"></p>
<p>从黑马河赶往茶卡镇需要经过橡皮山，橡皮山口的海拔在3800米+，是整个行程中的海拔最高点。此时的橡皮山还完全是一座雪山，是整个行程中的第二次到达雪山。同时也是由于这些山脉的原因，才阻隔了青海湖和茶卡盐湖，使其分别成为了只进不出的咸水湖。</p>
<h2 id="茶卡盐湖"><a href="#茶卡盐湖" class="headerlink" title="茶卡盐湖"></a>茶卡盐湖</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day5-6.jpg"></p>
<p>茶卡盐湖几乎是青海旅游的毕竟之地，无论是环青海湖小环线，还是青海甘肃大环线，同时也是网红景点，网络上有太多穿着红色裙子的漂亮的小姐姐的照片和视频。</p>
<p>茶卡盐湖地处柴达木盆地，周边地势较低，在离盐湖十几公里的地方湖泊就清晰可见，天上的白云倒影在湖中，宛如一面镜子，因此素有“天空之境”之称。远处的昆仑山脉和祁连山脉的雪山清晰可见，由于天空太过透彻，使常年生活在华北地区的我很难判断出雪山的距离。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day5-4.jpg" alt="采盐船"><br>(图为采盐船)</p>
<p>茶卡盐湖的开发利用相当充分，一方面是用来开发采盐，并建有盐厂，湖面上可以看到开采盐矿的船只。另一方面，通过旅游来进一步最大化其价值，其实整个柴达木盆地有很多的盐湖，但最为大众所熟知的仅此一家。而且旅游跟采盐是完全分离的，互不相干，毕竟大部分游客都是来拍照的，旅游占用的盐湖面积比重相对较小。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day5-5.jpg"></p>
<p>茶卡盐湖的含盐量实在太高，大部分地方湖面的水都较浅，仅有薄薄的一层，下面全是沉积的盐矿，我此行并没有看到有数米深的湖水。很多地方是可以穿着靴子进入到里面的，但要小心盐坑，看似平坦的盐矿其实有很多的暗洞，很容易就陷进去，好在游客能去的地方盐洞都给堵住了，没啥安全问题。上图中黄色的网状结构为防止游客陷入的盖子。</p>
<p>死海的含盐量肯定没有盐湖的含量高的，尚且人体可以漂浮在表面，我想茶卡盐湖如果有较深的地方，人体一定是可以漂浮在表面的，可惜盐湖并未提供该项旅游体验服务，要不还真想一试。</p>
<p>茶卡盐湖的最佳拍照时机是清晨和傍晚，中午烈日当头的时候晒得人很不舒服，紫外线相当强烈，尤其是对于我这种没有墨镜装备的近视眼游客。在烈日下，去拍人像也很难拍的漂亮，眼睛是很难睁开的，手机在拍人像时，由于背景实在太亮，人像总是会偏黑一些。对于我而言，是很难做到早起的，也就赶不上清晨的茶卡盐湖，实际上到达盐湖景区的时候已经是中午了。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day5-7.jpeg"><center>(盐湖的路都是用盐结晶铺成的，好不奢侈)</center></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day5-8.jpeg"><center>(在湖中的沉淀物捞出来随手一攥都能成为一个大疙瘩)</center></p>
<h2 id="柴达木盆地"><a href="#柴达木盆地" class="headerlink" title="柴达木盆地"></a>柴达木盆地</h2><p>游览完茶卡盐湖已经是下午三点钟了，接下来还有400多公里的路程要走，好在高原的天黑时间要到晚上八点半。离开茶卡镇后，就进入了漫长的柴达木盆地。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day5-9.jpeg" alt="http://p3.pstatp.com/large/pgc-image/1528418882025edccd91e79"></p>
<hr>
<p>我原以为柴达木盆地是属于新疆地区的，后来一看地图才发现彻头彻尾的属于青海省，夹在昆仑山、祁连山和阿尔金山三大山脉之间，而今天的行程几乎就是横穿整个柴达木盆地。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day5-10.jpg"></p>
<p>刚离开茶卡镇，还能看到一些牧民养的成群的牛羊，地上也长有一些枯草，但后来地上随着枯草的减少，牛羊也就看不到了。到后面几乎就是戈壁，看不到任何的动物，完全的荒原，让我想起了《北方的空地》中描述的羌塘无人区中的画面，我感觉无人区中也不过如此罢了。地理课本上说柴达木盆地是“聚宝盆”，矿产资源异常丰富，抛开这些埋藏在地底下的矿产不说，但就感官而言，是极其的荒凉。好在一路上，总有雪山陪伴，也不至于太孤单。一路上有很多动物出没的指示牌，好想看到一个活物，但都以失望告终。</p>
<p>由于地广人稀，这段高速公路的管理也相对简陋，曾看到了一辆当地的三轮车在高速的快车道上逆行，吓得我一脸懵，估计是要按正常的路线行驶要多走出好多路。</p>
<h2 id="可鲁克湖"><a href="#可鲁克湖" class="headerlink" title="可鲁克湖"></a>可鲁克湖</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/qinghai/day5-11.jpg"></p>
<p>可鲁克湖位于高速公路旁的大约两公里处，甚至都不用下高速就可以到达，属于3A级景区。到达可鲁克湖时已经是下午6点钟，对于进入景区本不报太大的希望，经询问景区居然营业到晚上八点钟，高原地区果然天黑的晚。景区主要是一个偌大的可鲁克湖，可供游玩的地方特别少，简单拍照走人。如果在这里拍张照，拿给别人看，说是青海湖拍的，没有人能够看得出破绽。如果时间紧迫，该景区完全可以不去参观。</p>
<p>可鲁克湖景区旁边还有个比其更大的托素湖，托素湖是可鲁克湖的三倍大小，可鲁克湖的湖水最终会流入托素湖中。比较有意思的是，可鲁克湖的湖水属于淡水湖，而托素湖却属于典型的内陆咸水湖。咸水湖的形成离不开封闭的环境，托素湖由于没有排水渠道，只能靠蒸发来消耗水分，水分被蒸发后，水分中的盐分却不会被蒸发，日积月累就会形成咸水湖。而可鲁克湖由于会流向托素湖，湖水是流动的，因此没有形成咸水湖。</p>
<p>托素湖离高速较远，要开车过去需要沿着可鲁克湖的湖边，来回至少还得要一个半小时的时间，时间不太允许，且可玩性较差，就直接忽略了该景区。</p>
<p>托素湖旁边还有个外星人遗址，单看景区的名字是我特别感兴趣的类型，网上一搜，景区居然暂未开放!</p>
<h2 id="当天终点-大柴旦"><a href="#当天终点-大柴旦" class="headerlink" title="当天终点 - 大柴旦"></a>当天终点 - 大柴旦</h2><p>又是在晚上的时候到达了当天的终点站大柴旦县。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">天空之镜湖</span><br><span class="line">白雪皑皑山</span><br><span class="line">漫漫柴达木</span><br><span class="line">渺渺无人烟</span><br><span class="line">盆地全是宝</span><br><span class="line">可惜只见草</span><br><span class="line">戈壁连成片</span><br><span class="line">夜宿大柴旦</span><br></pre></td></tr></table></figure>

<p>未完待续…</p>
]]></content>
  </entry>
  <entry>
    <title>getaddrinfo函数调用问题</title>
    <url>/post/question_getaddrinfo/</url>
    <content><![CDATA[<p>最近在开发程序的过程中遇到了一个getaddrinfo函数的问题，令我感到非常奇怪。</p>
<p>程序中调用了librdkafka库，当程序选择用-static方式链接所有库时程序会在librdkafka库中某个函数core dump，但是选择动态链接系统库（包括libpthread、libdl、libz、libm、libc等）时程序却能正常运行。</p>
<p>每次程序都回core dump在getaddrinfo函数中，经过搜索发现有人跟我遇到同样的<a href="https://sourceware.org/bugzilla/show_bug.cgi?id=10652">问题</a>，但是却没有解决方案。</p>
<p>我这里实验了文中提到了例子，在静态链接的时候确实会报错，动态链接却非常正常，编译选项为<code>g++ -o test_getaddrinfo test_getaddrinfo.cpp -lpthread -Wall -static</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">test</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">addrinfo</span> *res = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;x=&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">getaddrinfo</span>(<span class="string">&quot;localhost&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;res);</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;%d &quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">pthread_t</span> thr;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;thr, <span class="literal">NULL</span>, test, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现程序在链接的时候会提示如下警告：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/tmp/cc0WILtn.o: In function `test(void*)&#x27;:</span><br><span class="line">test_getaddrinfo.cpp:(.text+0x49): warning: Using &#x27;getaddrinfo&#x27; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking</span><br><span class="line">/usr/lib/gcc/x86_64-redhat-linux/4.8.3/../../../../lib64/libpthread.a(libpthread.o): In function `sem_open&#x27;:</span><br><span class="line">(.text+0x685b): warning: the use of `mktemp&#x27; is dangerous, better use `mkstemp&#x27;</span><br></pre></td></tr></table></figure>

<p>从网上查看有该警告的人还是非常多的，都是在-static方式链接glibc库时遇到的，但是没有发现很好的解决方案。该问题的原因<br>产生估计是glibc在静态链接时调用libnss库存在问题，因此不提倡静态链接方式。</p>
<p>我看到了两种解决方案：</p>
<p>方案一：用newlib或uClibc来代替glibc来静态链接，这种方案我没有去尝试是否可行。</p>
<p>方案二：用<code>--enable-static-nss</code>重新编译glibc。我试了一下问题仍然存在。</p>
<p>我之所以采用静态链接的方式，是因为开发机器和运行机器的glibc版本不一致造成的。我尝试将libc.so相关文件复制运行机器上，并让程序链接我复制过去的文件，ldd查看可执行文件没有错误，但是当运行程序时会报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./xxx: relocation error: /home/kuring/lib/libc.so.6: symbol _dl_starting_up, version GLIBC_PRIVATE not defined in file ld-linux-x86-64.so.2 with link time reference</span><br></pre></td></tr></table></figure>

<p>最终，我放弃了静态链接的方式，采用了动态链接方式来暂时解决了问题。如果你知道解决方案，请告诉我。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><p><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=10652">getaddrinfo causes segfault if multithreaded and linked statically</a></p>
</li>
<li><p><a href="https://sourceware.org/glibc/wiki/FAQ#Even_statically_linked_programs_need_some_shared_libraries_which_is_not_acceptable_for_me.__What_can_I_do.3F">Even statically linked programs need some shared libraries which is not acceptable for me.</a></p>
</li>
<li><p><a href="http://stackoverflow.com/questions/2725255/create-statically-linked-binary-that-uses-getaddrinfo">Create statically-linked binary that uses getaddrinfo?</a></p>
</li>
<li><p><a href="http://www.akkadia.org/drepper/no_static_linking.html">Static Linking Considered Harmful</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>网件R6400V2刷梅林教程</title>
    <url>/post/r6400-merlin/</url>
    <content><![CDATA[<p>最近突发奇想，想折腾一下路由器。经过研究半天后，锁定了网件R6400这款路由器，原因是可选择的系统较多，跟华硕的路由器架构一致，且支持较为强大的梅林系统。</p>
<p>整个刷机的过程还是非常简单的，虽然花了我不少时间，本文简单记录一下。</p>
<p>拿到手后，R6400比我印象中的要大不少，可以通过下图中的苹果手机进行对比。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/r6400-11.jpeg"></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/r6400-12.jpeg"></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/r6400-13.jpeg"></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/r6400-14.jpeg"></p>
<p>R6400有v1和v2两个版本，其中v1版本的CPU频率为800MHz，v2版本的CPU频率为1GHz。v1版本的刷梅林系统和v2版本刷系统有所区别，v2版本需要先刷DD-WRT固件作为过渡固件，然后再刷梅林固件。</p>
<p>整个的过程最好用有线连接路由器操作，用无线会频繁掉线。</p>
<p><em>.chk结尾的文件为过渡固件，</em>.trx为最终固件。</p>
<p>注意：下载的固件文件最好检验一下md5，确保固件的正确性。</p>
<h2 id="刷dd-wrt固件"><a href="#刷dd-wrt固件" class="headerlink" title="刷dd-wrt固件"></a>刷dd-wrt固件</h2><p>连接上路由器后，在chrome浏览器中输入<a href="http://www.routerlogin.net可跳转到网件管理系统,通过一堆路由器设置后会重启路由器,然后重新登录./">http://www.routerlogin.net可跳转到网件管理系统，通过一堆路由器设置后会重启路由器，然后重新登录。</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/r6400-1.png"></p>
<p>选择“是”后会下载新网件固件，其实该步骤可以选择“否”即可。固件下载完成后，会升级固件，路由器会自动重启。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/r6400-2.png"></p>
<p>下载DD-WRT固件文件“DD固件.chk”，并在路由器的管理界面“高级 -&gt; 管理 -&gt; 路由器升级”中上传固件。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/r6400-3.png"></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/r6400-4.png"></p>
<p>这里选择是，然后开始升级固件，升级完成后路由器会重启。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/r6400-5.png"></p>
<p>重启完成后，Wifi信号变成dd-wrt，没有密码，可直接连接。</p>
<p>在浏览器中输入192.168.1.1，会出现dd-wrt的界面。用户名和密码可以直接输入admin，因为该系统仅为中间过度系统。在dd-wrt这个偏工程师化的系统中有非常详细的信息，包括路由器的CPU和Memory等的硬件信息，甚至还有load average，多么熟悉的指标。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/r6400-6.png"></p>
<h2 id="升级梅林固件"><a href="#升级梅林固件" class="headerlink" title="升级梅林固件"></a>升级梅林固件</h2><p>在dd-wrt的固件升级中选择“R6400_380.70_0-X7.9.1-koolshare.trx”，刷入梅林固件。待路由器重启完成后，即完成梅林固件的刷入。此时路由器的Wifi SSID变为“NETGEAR”。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/r6400-8.png"></p>
<p>访问192.168.1.1，会出现梅林系统的管理界面，依次设置即可。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/r6400-9.png"></p>
<p>题外话：无线的密码修改完后，悲剧的事情发生了，路由器重启后居然连不上wifi，提示密码错误。不得不找来一台带有网口的笔记本用有线连接。在梅林管理系统中查看，未发现密码输入错误，明明输入的密码是对的，但SSID换一个密码居然奇迹般的可以无线连接了，怀疑是一个bug。</p>
<p>设置完成后路由器会重启，此时管理系统地址变更为192.168.50.1。</p>
<p>在“高级设置 -&gt; 无线网络 -&gt; 专业设置”中，调整区域为“United States”，据说可以加快速度。</p>
<p>要想使用软件中心，需要在系统设置中开启下图选项，并重启路由器。重启后，Format JFFS partition at next boot会自动设置为false。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/r6400-10.png"></p>
<h2 id="ASUS-Router"><a href="#ASUS-Router" class="headerlink" title="ASUS Router"></a>ASUS Router</h2><p>下载app “ASUS Router”，可以直接连接到路由器，这是因为网件的路由器架构跟华硕完全一致。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://www.youtube.com/watch?v=sM3IJrXI7g0">网件Netgear R6400 v2 开箱 刷梅林固件</a></li>
<li><a href="https://asuswrt.lostrealm.ca/">梅林系统官网</a></li>
<li><a href="http://koolshare.cn/thread-139324-1-1.html">梅林固件下载地址</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>网件R6400V2重新刷回官方系统教程</title>
    <url>/post/r6400-reset/</url>
    <content><![CDATA[<p>之前购买的网件R6400V2路由器刷到了梅林系统，但一直以来信号都特别差，甚至都比不过最便宜的水星路由器，想重新刷回官方系统看下是否是梅林系统的问题。本文记录下重新刷回梅林系统的操作步骤。</p>
<h2 id="刷机之路"><a href="#刷机之路" class="headerlink" title="刷机之路"></a>刷机之路</h2><p>从如下的地址下载固件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1EBvUBlXozo_4zkXaeUMQng 密码：pqqv</span><br></pre></td></tr></table></figure>


<p>在梅林系统的界面上找到固件升级的地方，将下载的固件上传。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/reset-1.png" alt="image.png"><br>结果悲剧的事情发生了，路由器出现了不断重启的状态，并且没有无线信号。猜测可能是因为固件用的是R6400，而非R6400V2导致的。或者是因为是用无线网络升级的原因，导致升级到一半网断掉了，从而导致失败了。</p>
<h2 id="救砖之路"><a href="#救砖之路" class="headerlink" title="救砖之路"></a>救砖之路</h2><p>按照<a href="https://koolshare.cn/thread-142232-1-1.html">网件通用救砖，超详细教程</a>文档中的网件通用救砖方法，将路由器的一个LAN口跟电脑的网卡用网线直接相连，并设置网卡的ip地址为192.168.1.3，网关为255.255.255.0。</p>
<p>在路由器启动的状态下，在命令行执行ping -t 192.168.1.1来验证路由器是否可以ping通，如果不通，可能是因为路由器的LAN段不是192.168.1.0，可能是192.168.50.0的。</p>
<p>在windows电脑上下载对应的文件，并保存到本地的F盘下。</p>
<p>手工安装winpcap，主要是给nmrpflash来使用。</p>
<p>以管理员身份运行命令行工具，执行nmrpflash.exe -L后找到本机的网卡net1。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/reset-2.png" alt="image.png"><br>执行nmrpflash命令后，立即重启路由器，如果第一次提示Timeout，可以立即执行该命令，如果出现下图的提示，说明命令执行成功。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/r6400/reset-3.png" alt="image.png"></p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="http://mr.mw/share/136.html">万能网件R6400刷回最近官方固件的方法</a>（不适用于R6400V2）</li>
<li><a href="https://koolshare.cn/thread-142232-1-1.html">网件通用救砖，超详细教程</a></li>
<li><a href="https://roov.org/2019/07/netgear-unbrick-utility/#comment-37190">Netgear 网件系列路由器救砖工具</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>流量控制算法</title>
    <url>/post/rate-limit/</url>
    <content><![CDATA[<p>限流的方式有多种，每种都有其应用场景。</p>
<p>限制请求的方式包括：</p>
<ol>
<li>丢弃请求</li>
<li>放在队列中，等有令牌后再请求</li>
<li>走降级逻辑</li>
</ol>
<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>我之前设计的流控系统，以每秒为单位，如果一秒内超过固定的QPS，则将请求进行降级处理。该算法已经在生产环境中平稳运行了很久，也确实满足了业务的需求。</p>
<p>计数器流控算法简单粗暴，有一个缺点，即流控的单位为秒，但一秒的请求很可能是不均匀的，不能进行更细粒度的控制，也不允许流量存在某种程度的突发。</p>
<h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>请求先进入漏桶中，漏桶以一定的速度出水，当水流的速度过大时会直接溢出。</p>
<p>漏桶大小：起到缓冲的作用</p>
<p>漏桶的出水速度：该值固定</p>
<h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶算法相比漏桶算法而言，允许请求存在某种程度的突发，常用于网络流量整形和速率限制。</p>
<p>系统会恒定的速度往令牌桶中注入令牌，如果令牌桶中的令牌满后就不再增加。新请求来临时，会拿走一个令牌，如果没有令牌就会限制该请求。</p>
<p>这里的请求可以代表一个网络请求，或者网络的一个字节。</p>
<p>涉及到的变量：</p>
<ol>
<li>网络请求平均速率r：每隔1&#x2F;r秒向令牌桶中放入一个令牌，1秒共放入r个令牌</li>
<li>令牌桶的最大大小：令牌桶慢后，再放入的令牌会直接丢弃</li>
</ol>
<p>令牌相当于操作系统中信号量机制。</p>
<p>业界较为出名的流控工具当属Guava中的RateLimiter，基于令牌桶算法实现。</p>
<p>在实际的代码实现中，并不一定需要一个固定的线程来定期往令牌桶中放入令牌，而是在请求到来时，直接计算得出当前是否还有令牌。比如下面的python代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TokenBucket</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># rate是令牌发放速度，capacity是桶的大小</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rate, capacity</span>):</span><br><span class="line">        self._rate = rate</span><br><span class="line">        self._capacity = capacity</span><br><span class="line">        self._current_amount = <span class="number">0</span></span><br><span class="line">        self._last_consume_time = <span class="built_in">int</span>(time.time())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># token_amount是发送数据需要的令牌数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">consume</span>(<span class="params">self, token_amount</span>):</span><br><span class="line">        increment = (<span class="built_in">int</span>(time.time()) - self._last_consume_time) * self._rate  <span class="comment"># 计算从上次发送到这次发送，新发放的令牌数量</span></span><br><span class="line">        self._current_amount = <span class="built_in">min</span>(</span><br><span class="line">            increment + self._current_amount, self._capacity)  <span class="comment"># 令牌数量不能超过桶的容量</span></span><br><span class="line">        <span class="keyword">if</span> token_amount &gt; self._current_amount:  <span class="comment"># 如果没有足够的令牌，则不能发送数据</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self._last_consume_time = <span class="built_in">int</span>(time.time())</span><br><span class="line">        self._current_amount -= token_amount</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://juejin.im/post/5ab10045518825557005db65">15行Python代码，帮你理解令牌桶算法</a></p>
]]></content>
  </entry>
  <entry>
    <title>Redhat安装完成之后的设置</title>
    <url>/post/redhat_setup_base/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>＃ 安装kdevelop</p>
<p>确保可以上网，这里采用yum的安装方式进行安装。<br>首先执行命令：yum install kdevelop，会出现如下提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Loaded plugins: rhnplugin, security</span><br><span class="line">This system is not registered with RHN.</span><br><span class="line">RHN support will be disabled.</span><br><span class="line">file:///mnt/file/rh5/Cluster/repodata/repomd.xml: [Errno 5] OSError: [Errno 2] 没有那个文件或目录: &#x27;/mnt/file/rh5/Cluster/repodata/repomd.xml&#x27;</span><br><span class="line">Trying other mirror.</span><br><span class="line">Error: Cannot retrieve repository metadata (repomd.xml) for repository: Cluster. Please verify its path and try again</span><br></pre></td></tr></table></figure>

<p>出现上述错误是由于redhat没有注册，所有不能使用它自身的源进行更新，可以更换为CentOS系统的源进行更新，操作步骤为：<br>1、进入&#x2F;etc&#x2F;yum.repos.d&#x2F;目录。在命令行输入：wget <a href="http://docs.linuxtone.org/soft/lemp/CentOS-Base.repo%E3%80%82">http://docs.linuxtone.org/soft/lemp/CentOS-Base.repo。</a><br>2、ls 一下，会看到一个文件名为CentOS-Base.repo的文件。<br>3、将原来的文件rhel-debuginfo.repo改名为rhel-debuginfo.repo.bak。<br>4、将CentOS-Base.repo改名为rhel-debuginfo.repo</p>
<p>再次运行命令：yum install kdevelop，就可以安装kdevelop了。</p>
<p>安装过程中遇到了需要的pcre包无法从centos的源中下载的问题，解决方法为根据yum命令无法下载的包，在google中搜索，下载包然后再redhat上用rpm的升级命令来安装。具体下载网址为：<a href="http://mirrors.stuhome.net/centos/5.9/cr/x86_64/RPMS/">电子科技大学星辰工作室开源镜像服务</a>。</p>
<p>rpm相关命令：<br>安装一个包：rpm   -ivh<br>升级一个包：rpm   -Uvh<br>移走一个包：rpm   -e </p>
<h1 id="安装konsole"><a href="#安装konsole" class="headerlink" title="安装konsole"></a>安装konsole</h1><p>安装上kdevelop后在执行程序的时候会提示<code>/bin/sh:konsole:command not found</code>。执行<code>yum install kdebase</code>命令来安装konsole。</p>
<h1 id="配置ssh服务"><a href="#配置ssh服务" class="headerlink" title="配置ssh服务"></a>配置ssh服务</h1><p>修改ssh服务的配置文件&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，将文件中的#PasswordAuthentication yes注释打开。<br>修改ssh服务的配置文件&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，将文件中的PermitRootLogin no更改为yes。这样即可以用ssh工具连接到该机器。</p>
<h1 id="xmanager连接配置"><a href="#xmanager连接配置" class="headerlink" title="xmanager连接配置"></a>xmanager连接配置</h1><p>该部分参考文档的网址为：<a href="http://blog.csdn.net/gltyi99/article/details/6141972">http://blog.csdn.net/gltyi99/article/details/6141972</a></p>
<ol>
<li><p>修改&#x2F;usr&#x2F;share&#x2F;gdm&#x2F;defaults.conf文件的权限，默认权限为444，chmod 700 &#x2F;usr&#x2F;share&#x2F;gdm&#x2F;defaults.conf。</p>
</li>
<li><p>在&#x2F;usr&#x2F;share&#x2F;gdm&#x2F;defaults.conf文件的末尾添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enable=true</span><br><span class="line">DisplaysPerHost=10</span><br><span class="line">Port=177</span><br><span class="line">AllowRoot=true</span><br><span class="line">AllowRemoteroot=true</span><br><span class="line">AllowRemoteAutoLogin=false</span><br></pre></td></tr></table></figure></li>
<li><p>修改&#x2F;etc&#x2F;gdm&#x2F;custom.conf文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xdmcp]</span><br><span class="line">Enable=1</span><br></pre></td></tr></table></figure></li>
<li><p>修改&#x2F;etc&#x2F;inittab文件，不修改原来的设置，在文件的最后增加一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x:5:respawn:/usr/sbin/gdm</span><br></pre></td></tr></table></figure></li>
<li><p>修改&#x2F;usr&#x2F;share&#x2F;gdm&#x2F;defaults.conf文件，将其中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[security]</span><br><span class="line"># Allow root to login.  It makes sense to turn this off for kiosk use, when</span><br><span class="line"># you want to minimize the possibility of break in.</span><br><span class="line">AllowRoot=true</span><br><span class="line"># Allow login as root via XDMCP.  This value will be overridden and set to</span><br><span class="line"># false if the /etc/default/login file exists and contains</span><br><span class="line"># &quot;CONSOLE=/dev/login&quot;, and set to true if the /etc/default/login file exists</span><br><span class="line"># and contains any other value or no value for CONSOLE.</span><br><span class="line">AllowRemoteRoot=false</span><br><span class="line"># This will allow remote timed login.</span><br><span class="line">AllowRemoteAutoLogin=false</span><br><span class="line"># 0 is the most restrictive, 1 allows group write permissions, 2 allows all</span><br><span class="line"># write permissions.</span><br><span class="line">RelaxPermissions=0</span><br><span class="line"># Check if directories are owned by logon user.  Set to false, if you have, for</span><br><span class="line"># example, home directories owned by some other user.</span><br><span class="line">CheckDirOwner=true</span><br><span class="line"># Number of seconds to wait after a failed login</span><br><span class="line">#RetryDelay=1</span><br><span class="line"># Maximum size of a file we wish to read.  This makes it hard for a user to DoS</span><br><span class="line"># us by using a large file.</span><br><span class="line">#UserMaxFile=65536</span><br></pre></td></tr></table></figure>
<p>AllowRemoteRoot&#x3D;false更改为AllowRemoteRoot&#x3D;true。</p>
</li>
<li><p>修改&#x2F;etc&#x2F;securetty文件，在文件底部添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pts/0</span><br><span class="line">pts/1</span><br><span class="line">pts/2</span><br><span class="line">pts/3</span><br><span class="line">pts/4</span><br></pre></td></tr></table></figure></li>
<li><p>修改&#x2F;etc&#x2F;pam.d&#x2F;login文件，将其中的一行注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#auth [user_unknown=ignore success=ok ignore=ignore default=bad] pam_securetty.so</span><br></pre></td></tr></table></figure></li>
<li><p>修改&#x2F;etc&#x2F;pam.d&#x2F;remote，将其中的一行注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#auth       required     pam_securetty.so</span><br></pre></td></tr></table></figure></li>
<li><p>修改&#x2F;etc&#x2F;xinetd.d&#x2F;krb5-telnet文件，将文件内容由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service telnet</span><br><span class="line">&#123;</span><br><span class="line">        flags           = REUSE</span><br><span class="line">        socket_type     = stream</span><br><span class="line">        wait            = no</span><br><span class="line">        user            = root</span><br><span class="line">        server          = /usr/kerberos/sbin/telnetd</span><br><span class="line">        log_on_failure  += USERID</span><br><span class="line">        disable         = yes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service telnet</span><br><span class="line">&#123;</span><br><span class="line">        flags           = REUSE</span><br><span class="line">        socket_type     = stream</span><br><span class="line">        wait            = no</span><br><span class="line">        user            = root</span><br><span class="line">        server          = /usr/kerberos/sbin/telnetd</span><br><span class="line">        log_on_failure  += USERID</span><br><span class="line">        disable         = no</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样将&#x2F;etc&#x2F;xinetd.d&#x2F;ekrb5-telnet文件中的disable&#x3D;yes更改为disable&#x3D;no。</p>
</li>
</ol>
<h1 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h1><p>为了阅读代码方便，安装字体。</p>
<ol>
<li>将字体文件YaHei.Consolas.1.12.ttf放到Redhat的目录&#x2F;usr&#x2F;share&#x2F;fonts&#x2F;chinese&#x2F;TrueType目录下</li>
<li>执行mkfontscale命令，重新生成fonts.scale文件</li>
<li>执行mkfontdir命令，重新生成了fonts.dir文件。</li>
<li>执行chkfontpath –add &#x2F;usr&#x2F;share&#x2F;fonts&#x2F;chinese&#x2F;TrueType</li>
</ol>
<h1 id="更改操作系统编码从utf8到gb18030"><a href="#更改操作系统编码从utf8到gb18030" class="headerlink" title="更改操作系统编码从utf8到gb18030"></a>更改操作系统编码从utf8到gb18030</h1><p>可以通过locale命令来查看操作系统编码。输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LANG=zh_CN.UTF-8</span><br><span class="line">LC_CTYPE=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_NUMERIC=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_TIME=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_COLLATE=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_MONETARY=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_MESSAGES=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_PAPER=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_NAME=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_ADDRESS=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_TELEPHONE=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_MEASUREMENT=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_IDENTIFICATION=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure>

<p>打开&#x2F;etc&#x2F;sysconfig&#x2F;i18n文件，文件默认内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LANG=&quot;zh_CN.UTF-8&quot;</span><br></pre></td></tr></table></figure>
<p>将文件内容修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LANG=&quot;zh_CN.GBK&quot;</span><br></pre></td></tr></table></figure>

<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a href="http://pan.baidu.com/s/10ABX8">最适合程序员的字体：微软雅黑+Consolas</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>自动通过跳板机登录到其他服务器</title>
    <url>/post/relay-auto-login/</url>
    <content><![CDATA[<p>最近公司需要首先登录跳板机relay，然后通过跳板机才能登录服务器，操作上略显麻烦。为了节省登录服务器的时间，我编写了一个简单的脚本来简化登录操作。</p>
<p>实现效果为在本地terminal下，执行<code>wrelay $host</code>，即可自动登录到相应的主机。</p>
<h1 id="在relay服务器上增加对其他服务器的免登录命令"><a href="#在relay服务器上增加对其他服务器的免登录命令" class="headerlink" title="在relay服务器上增加对其他服务器的免登录命令"></a>在relay服务器上增加对其他服务器的免登录命令</h1><p>在relay服务器上ssh到其他主机时需要输入密码，使用expect命令来登录到其他主机时通过expect脚本来实现自动输入密码并登录的功能。</p>
<p>在&#x2F;home&#x2F;$user目录下新建mybin文件夹，并将mybin文件夹添加到$PATH环境变量中，具体修改方法不展开。</p>
<p>在mybin目录下增加gw脚本，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/expect</span><br><span class="line"></span><br><span class="line">if &#123;$argc &lt; 1&#125; &#123;</span><br><span class="line">    puts &quot;Usage:cmd &lt;host&gt;&quot;</span><br><span class="line">    exit 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set host [lindex $argv 0]</span><br><span class="line"># 在这里填写要登录的用户</span><br><span class="line">set username &quot;worker&quot;</span><br><span class="line"># 在这里填写要登录的密码</span><br><span class="line">set password &quot;worker&quot;</span><br><span class="line"></span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">set timeout 2</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;*password:&quot; &#123;</span><br><span class="line">        send &quot;$password\n&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    &quot;Are you sure you want to continue connecting (yes/no)?&quot; &#123;</span><br><span class="line">        send &quot;yes\r&quot;</span><br><span class="line">        exp_continue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect &quot;*#&quot;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>

<p>执行<code>gw 10.1.1.8</code>，即可登录到对应的主机上。</p>
<h1 id="本地主机免登录relay服务器，并自动登录到对应的服务器"><a href="#本地主机免登录relay服务器，并自动登录到对应的服务器" class="headerlink" title="本地主机免登录relay服务器，并自动登录到对应的服务器"></a>本地主机免登录relay服务器，并自动登录到对应的服务器</h1><p>在本地自动登录relay主机同样使用expect的方式，脚本名称为wrelay，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/expect</span><br><span class="line"></span><br><span class="line">if &#123;$argc &lt; 1&#125; &#123;</span><br><span class="line">    puts &quot;Usage:cmd &lt;remote_host&gt;&quot;</span><br><span class="line">    exit 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 下面指定relay主机</span><br><span class="line">set host &quot;relay.name&quot;</span><br><span class="line"># 这里输入relay的用户名</span><br><span class="line">set username &quot;&quot;</span><br><span class="line"># 这里输入relay的密码</span><br><span class="line">set password &quot;&quot;</span><br><span class="line">set remote_host [lindex $argv 0]</span><br><span class="line"></span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">set timeout 2</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;*password:&quot; &#123;</span><br><span class="line">        send &quot;$password\n&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    &quot;Are you sure you want to continue connecting (yes/no)?&quot; &#123;</span><br><span class="line">        send &quot;yes\r&quot;</span><br><span class="line">        exp_continue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect &quot;*#&quot;</span><br><span class="line"></span><br><span class="line">sleep 0.1</span><br><span class="line"># 在relay上自动登录到其他服务器主机</span><br><span class="line">send &quot;gw $remote_host\n&quot;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>药物过度依赖</title>
    <url>/post/rely_on_drug_over/</url>
    <content><![CDATA[<p><img src="/ref/life/rely_on_drug_over.jpg" alt="Image Title"></p>
<p>药是什么？药是人类文明的发展过程中不断克服自身疾病的必然产物。谁让外星人造人的时候没有把人类制造的那么完美，要是人类除了生老死之外没有病这个状态，或许药物就不会产生。</p>
<p>现实生活中，过度依赖药物的人比比皆是，尤其是在中国。在中国，药物已经用到了满天飞的程度了。得个小感冒会去药店买药，医生除了推荐你感冒药之外，肯定会推荐你消炎药。以至于大众普遍认为，有炎症必须吃消炎药。感冒烧到38度，医院医生会推荐你打针。感冒烧到38.5度，医生会推荐你挂上三天吊瓶，美其名曰挂吊瓶好的快，如果患者的心理能起到恢复快的作用的话，那么挂吊瓶应该是管用的。</p>
<p>我没去过西方国家，但我猜测在西方国家，医药分离的占多数。得病了想吃个消炎药解解馋可没那么容易，消炎药岂能是想吃就吃，没有医生的处方药店怎敢卖给患者，又不是口香糖。想打个针过过瘾更是难了，喜欢花钱让针扎着屁股玩的活中国人比较喜欢。要想挂个吊瓶数滴答玩，除非烧到了40度一星期高烧不退，否则还是自己在家挂瓶自来水数着玩吧。以上有杜撰的成分，但是话激理不歪，你懂得。</p>
<p>要知道中国较西方的文明程度还有差距。西方发明的西药在西方都谨慎使用了，反倒在中国大行其道。谁家没一抽屉瓶瓶罐罐，这可都是毒药啊。除了可以拉动GDP外，有理由怀疑中国担心未来人口老龄化加剧给经济发展造成压力而采取的措施。</p>
<p>是时候阐述本文的观点了，药物不是万能的，能少用尽量少用。</p>
<p>中药讲究是药三分毒，换成西药是药五分毒应该毫不夸张吧。当时治好了我们身体的病症，感觉一身轻松了，但是后患无穷。人类本身就具备一定的修复能力，而且修复能力很强。在人类自我修复能力许可的范围内非要硬用药物加速治疗，那造成的必然结果就是身体下次不干了，有药物可以对抗疾病，那用身体的修复能力干嘛。久而久之，身体就再也扛不住疾病了。</p>
<p>吃西药多了往往治的病好了，却带来了其他疾病。比如感冒了吃消炎药，吃着吃着把胃给吃坏了。治感冒的医生才不会管你的其他身体部位情况，反正胃吃坏了找不到他。这也是医院分那么多科室的一个弊端，只从局部看问题，不能从整体上看问题，所以看到的问题总是片面的。</p>
<p>解决药物依赖的问题从三方面着手解决。一方面要从心理上战胜自己，不要迷信药物，更不能依赖药物。另一方面，多运动，生命在于运动，真理中的真理。第三，眼光放长远，多看其他国家，多了解长寿的人是怎么生存的。</p>
<p>真心希望过度依赖药物的人可以走出这个误区。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>/etc/resolv.conf文件</title>
    <url>/post/resolv-conf/</url>
    <content><![CDATA[<p>&#x2F;etc&#x2F;resolv.conf文件为Linux主机的DNS配置文件，在 Linux 主机上可以执行 <code>man resolv.conf</code> 查看帮助信息。</p>
<h2 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h2><p>整个配置文件分为了4个部分：nameserver、search、sortlist和options</p>
<h3 id="nameserver"><a href="#nameserver" class="headerlink" title="nameserver"></a>nameserver</h3><p>用来配置DNS服务器地址。支持ipv4和ipv6地址。如果要配置多个DNS服务器，可以增加多条配置，域名按照DNS服务器配置的顺序来解析。配置多条的例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nameserver 100.100.2.136</span><br><span class="line">nameserver 100.100.2.138</span><br></pre></td></tr></table></figure>

<h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>在默认情况下，如果要查找的域名中不包含domain信息（即不包含<code>.</code>字符），此时会以当前hostname的domain信息来进行查找。可以通过search字段来修改该行为，即可以通过在域名的后面增加配置的后缀来进行查找。</p>
<p>如果存在多条search记录，则以最后一条search记录为准。</p>
<p>比如k8s的pod中的search域格式如下，如果要查找defaultnamespace下的service的svc1，此时系统会自动追加 svc1.default.svc.cluster.local来进行查找：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search default.svc.cluster.local svc.cluster.local cluster.local</span><br></pre></td></tr></table></figure>

<h3 id="sortlist"><a href="#sortlist" class="headerlink" title="sortlist"></a>sortlist</h3><p>该字段极少场景下会用到。在做域名解析时，如果返回的A记录为多条，可以对结果进行排序，排序的依据为当前的字段配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sortlist 130.155.160.0/255.255.240.0 130.155.0.0</span><br></pre></td></tr></table></figure>

<h4 id="options"><a href="#options" class="headerlink" title="options"></a>options</h4><p>该配置必须加载一行中，格式如下，其中option部分可以为多个，多个之间用空格分割：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options option ...</span><br></pre></td></tr></table></figure>

<ul>
<li>inet6: 应用程序在执行系统调用 gethostbyname 时，会优先执行 AAAA 记录的查询。如果查询不到 ipv6 地址，再去查询 ipv4 地址。</li>
</ul>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h3><p>修改&#x2F;resolv.conf配置文件的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>

<p>可以看到该nameserver是生效的，但是访问map域名是不生效的，因为没有map这个域名.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[vagrant@localhost ~]$ ping map.baidu.com</span><br><span class="line">PING map.n.shifen.com (119.75.222.71) 56(84) bytes of data.</span><br><span class="line">64 bytes from 119.75.222.71: icmp_seq=1 ttl=63 time=4.22 ms</span><br><span class="line"></span><br><span class="line">[vagrant@localhost ~]$ ping map</span><br><span class="line">ping: unknown host map</span><br></pre></td></tr></table></figure>

<h3 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h3><p>修改文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br><span class="line"></span><br><span class="line">search baidu.com google.com</span><br></pre></td></tr></table></figure>
<p>此时可以ping通map域名，解析到了跟map.baidu.com相同的域名.如果map.baidu.com的域名没有解析到，会继续解析map.google.com的域名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[vagrant@localhost ~]$ ping map</span><br><span class="line">PING map.n.shifen.com (112.80.248.48) 56(84) bytes of data.</span><br><span class="line">64 bytes from 112.80.248.48: icmp_seq=1 ttl=63 time=28.6 ms</span><br></pre></td></tr></table></figure>

<p>domain的作用跟search类似，作为search的默认值，因为search可以使用多个域。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://man7.org/linux/man-pages/man5/resolv.conf.5.html">resolv.conf(5) - Linux manual page (man7.org)</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>演讲的思考系列文章 - 张一鸣字节跳动9周年</title>
    <url>/post/review-zhangyiming/</url>
    <content><![CDATA[<p>最近因为《致阿里》的缘故，读了不少阿里内网的热帖，很多都是洋洋洒洒几千字，而且说的有理有据。如果换做是我，很多帖子哪怕我憋上一天都是写不出来的。我一直在思考，我到底比别人差在了哪里。思来想去，其中一个原因是因为平时的思考总结不够，缺少积累。</p>
<p>恰巧看了张一鸣在字节跳动9周年演讲，三观跟我特别合，想以贴为例，一来分享一下我个人的内心想法加深对演讲内容的认识，二来可以依次来锻炼自己的逻辑归纳能力。后续如有特别值得学习的演讲，也会分享一下自己的学习和思考，比如2020年张小龙的微信公开课的演讲就特别值得学习。</p>
<p>文中提到最多的词莫过于“平常心”了，“平常心”是一个佛源词，看来张一鸣没少研究佛学，整篇演讲显得也比较佛系，对于平常心的最直白的解释就是：</p>
<p>| 吃饭的时候好好吃饭，睡觉的时候好好睡觉</p>
<p>要想做到“好好吃饭，好好睡觉”对我来说是挺难的，我举一个简单的例子。平常周末来说，特别想睡一个懒觉，如果在睡觉前自己明确知道因为工作没有完成，第二天早上会有人找我，那么第二天早上一定会醒的比较早，想睡个懒觉都很难，即使第二天上午并不一定有人在我醒之前找到我。说明因为有事情的缘故，已经在无形中影响了睡眠质量。再举个例子，春节假期的睡眠质量明显会高于平常周末的睡眠质量，原因是心里总有各种工作的事情不能完全放下。如果将春节假期的心态为平常心，那么一年中的其他时间对我而言都不是平常心。</p>
<p>每家公司在年初的时候总会定义一些目标，比如全年营收目标为1个亿。一旦有了营收目标后，那么大家的工作重心一定会围绕的着目标展开。因为毕竟公司的资源是有限的，但是为了达成营收的目标，并不能保持一颗“平常心”来工作，焦虑的员工很难打磨出最好的产品，往往其他的地方就不会做的太好，比如用户体验、代码质量等等，一些本来很好的点子因为有营收目标的缘故，也很难展开实施，从而导致一些创新项目的流失。</p>
<p>接下来就是一些平常心的工作原则，总结下来有如下几点：</p>
<ul>
<li>平常心对待自己，平常人做非常事</li>
<li>平常心对待预期，没有预期和标签的束缚会发挥的更好</li>
<li>平常心对待过去和未来，关注当下</li>
<li>平常心对待竞争对手</li>
<li>平常心对待业务</li>
<li>平常心对待成功和失败</li>
</ul>
<p>文中特意提到了互联网八股文的一段话，这里就不再摘出来，我平时也没少见到类似的话术，看完后的感觉就是真牛逼，打死我都写不出来，但转头就忘记讲啥了，也许就是当时压根就看不懂，因为这些话太抽象了。互联网行业本身是一个特别务实接地气的行业，现在也渐渐在内卷严重，抽象的词汇也越来越多，期望下一个风口的到来，或许会将这股邪气吹走一些。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://mp.weixin.qq.com/s/eDn4rcdB7to-sD9N-NGySw">张一鸣演讲全文：外部波澜起伏，内心平静如常</a></p>
]]></content>
  </entry>
  <entry>
    <title>通过rsync来绕过relay同步文件</title>
    <url>/post/rsync-bypass-ralay/</url>
    <content><![CDATA[<p>由于不允许通过ssh直接连接服务器，即服务器的22端口是不开放的，但是其他端口号可以访问。这就造成了往服务器上传输文件会特别麻烦，需要通过relay中转一下。</p>
<p>rsync命令有shell模式和daemon模式，为了解决该问题，可以通过rsync的daemon模式，rysnc的daemon模式会默认使用873端口，不使用ssh协议，以此来绕过ssh的22端口限制。</p>
<p>最终可以实现在本地通过rsync一条命令直接同步文件或文件夹到服务器的指定目录下。</p>
<p>首先在服务器上搭建rsync的服务端，rsync的安装不再介绍。</p>
<p>修改服务器的rsync配置文件&#x2F;etc&#x2F;rsyncd.conf如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[worker]</span><br><span class="line">path = /home/worker</span><br><span class="line">list = true</span><br><span class="line">uid = worker</span><br><span class="line">gid = worker</span><br><span class="line">read only = false</span><br></pre></td></tr></table></figure>

<p>这里为了简便，并未设置rsync的用户名和密码。</p>
<p>客户端同步文件的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsync -avz $SRC worker@$HOST::worker --exclude=target --exclude=.git --exclude=.idea --delete</span><br></pre></td></tr></table></figure>

<p>命令中的第一个worker为HOST的登录用户名，第二个worker为rysncd配置文件中配置的组名。–exclude选项可以用来屏蔽需要同步的文件夹。–delete选项用来同步删除的文件或文件夹。</p>
<p>daemon模式跟ssh模式相比，无法指定服务器的具体某一个路径，使用不够灵活，但也基本可以满足需求。只能通过daemon配置文件中配置的组中的path参数，同步时仅能通过<code>::组名</code>的形式来指定。</p>
]]></content>
  </entry>
  <entry>
    <title>SaltStack使用</title>
    <url>/post/saltstack/</url>
    <content><![CDATA[<p>本文在学习saltstack的过程中编写，内容比较基础，方便使用时查阅命令。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>为了方便起见，直接采用yum的安装方式，centos源中并没有salt，需要手工添加一下。</p>
<h2 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h2><p>安装master</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -Uvh http://ftp.jaist.ac.jp/pub/Linux/Fedora/epel/7/x86_64/e/epel-release-7-5.noarch.rpm</span><br><span class="line">yum install salt-master</span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;salt&#x2F;master配置文件，在其中指定salt文件根目录位置，默认路径为&#x2F;srv&#x2F;salt&#x2F;。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_roots:</span><br><span class="line">  base:</span><br><span class="line">    - /svr/salt/</span><br></pre></td></tr></table></figure>

<p>salt在安装的时候已经创建了systemctl命令启动程序需要的service文件，位于&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;salt-master.service，重启<code>systemctl restart salt-master.service</code>生效。</p>
<h2 id="CentOS-6-5"><a href="#CentOS-6-5" class="headerlink" title="CentOS 6.5"></a>CentOS 6.5</h2><p>安装minion</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -Uvh http://ftp.linux.ncsu.edu/pub/epel/6/i386/epel-release-6-8.noarch.rpm</span><br><span class="line">yum install salt-minion</span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;salt&#x2F;minion配置文件，在其中指定master主机的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master: 192.168.204.128</span><br></pre></td></tr></table></figure>

<p>执行<code>service salt-minion restart</code>对服务进行重启。</p>
<h2 id="连通性测试"><a href="#连通性测试" class="headerlink" title="连通性测试"></a>连通性测试</h2><p>执行<code>salt-key -L</code>命令可以看到已认证和未认证的minion，执行<code>salt-key -a 192.168.204.149</code>可接收minion。</p>
<p>在master主机中执行<code>salt &#39;*&#39; test.ping</code>可测试连接的minion主机。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  stats  salt-key -L</span><br><span class="line">Accepted Keys:</span><br><span class="line">Denied Keys:</span><br><span class="line">Unaccepted Keys:</span><br><span class="line">192.168.204.149</span><br><span class="line">Rejected Keys:</span><br><span class="line"></span><br><span class="line">➜  stats  salt-key -a 192.168.204.149</span><br><span class="line">The following keys are going to be accepted:</span><br><span class="line">Unaccepted Keys:</span><br><span class="line">192.168.204.149</span><br><span class="line">Proceed? [n/Y] y</span><br><span class="line">Key for minion 192.168.204.149 accepted.</span><br><span class="line"></span><br><span class="line">➜  stats  salt &#x27;*&#x27; test.ping</span><br><span class="line">192.168.204.149:</span><br><span class="line">    True</span><br></pre></td></tr></table></figure>

<h1 id="state"><a href="#state" class="headerlink" title="state"></a>state</h1><p>可以通过预先定义好的sls文件对被控主机进行管理，这里演示一个简单的文件复制的例子，该例子可以将master主机上的vimrc文件复制到目标主机上。</p>
<p>在master主机的&#x2F;svr&#x2F;salt&#x2F;edit目录下新建vim.sls文件，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/vimrc:</span><br><span class="line">  file.managed:</span><br><span class="line">    - source: salt://edit/vimrc</span><br><span class="line">    - mode: 644</span><br><span class="line">    - user: root</span><br><span class="line">    - group: root</span><br></pre></td></tr></table></figure>

<p>另外在edit目录下需要存在一个空的init.sls，以确保state.sls可以找到该目录下的sls文件。同时该目录下还需要存在要复制的vimrc文件。</p>
<p>执行<code>salt &#39;*&#39; state.sls edit.vim</code>即可以执行该命令。</p>
<p>如果将vim.sls更改为init.sls文件，执行<code>salt &#39;*&#39; state.sls edit</code>命令即可。</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>salt ‘192.168.204.149’ cmd.run ‘free -m’</p>
<p>salt ‘192.168.204.149’ sys.list_modules  列出minion支持哪些模块，默认已经支持很多模块</p>
<p>salt ‘192.168.204.149’ cp.get_file salt:&#x2F;&#x2F;test_file &#x2F;root&#x2F;test_file  将master主机file_roots目录下的文件复制到minion任意目录下，该命令不可以将master主机任意目录下的文件进行复制</p>
<p>salt ‘192.168.204.149’ cp.get_dir salt:&#x2F;&#x2F;test_dir&#x2F; &#x2F;root&#x2F; 实验未成功</p>
<p>salt ‘*’ file.mkdir dir_path&#x3D;&#x2F;root&#x2F;test_dir user&#x3D;root group&#x3D;root mode&#x3D;700  在minion主机上创建目录s</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>*<a href="http://docs.saltstack.com/en/latest/topics/index.html">saltstack官方文档</a></p>
<p>*《python自动化运维技术与最佳实践》</p>
]]></content>
  </entry>
  <entry>
    <title>sbrk和brk函数</title>
    <url>/post/sbrk_and_brk/</url>
    <content><![CDATA[<p>Linux系统中提供了两个在堆中分配空间的底层函数，函数原型如下：</p>
<p>void *sbrk(intptr_t increment);<br>int brk(void *end_data_segment);</p>
<p>两个函数的作用均为从堆中分配空间，并且在内部维护一个指针，指针的值默认为NULL。如果内部指针为NULL，则得到一页的空闲地址，系统默认为4K字节。指针向后移动即为分配空间，指针向前移动为释放空间。当内部指针的位置移动到一个页的开始位置时，整个页会被操作系统回收。brk为绝对改变位置，sbrk为相对改变位置。</p>
<h1 id="sbrk函数"><a href="#sbrk函数" class="headerlink" title="sbrk函数"></a>sbrk函数</h1><p>在sbrk函数中，参数increment为要增加的字节数，increment可以为负数。当increment为负数时表示释放空间。当increment&#x3D;&#x3D;0时，内部指针位置不动。函数调用成功返回内部指针改变前的值，失败返回(void *)-1。<br>函数使用举例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p0 = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 打印堆地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this site of p0 is : %d\n&quot;</span>, p0);    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p1 = sbrk(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 这里仍然打印的是第一次的堆地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this site of p1 is : %d\n&quot;</span>, p1);    </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *p2 = sbrk(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 打印第一次堆地址+1000后的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this site of p2 is : %d\n&quot;</span>, p2);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回到初始堆地址，释放空间</span></span><br><span class="line">    sbrk(<span class="number">-1001</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *p3 = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 检查是否回到初始地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this site of p3 is : %d\n&quot;</span>, p3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下内容：<br>this site of p0 is : 264622080<br>this site of p1 is : 264622080<br>this site of p2 is : 264623080<br>this site of p3 is : 264622080</p>
<h1 id="brk函数"><a href="#brk函数" class="headerlink" title="brk函数"></a>brk函数</h1><p>在brk函数中，函数作用为将当前的内部指针移动到end_data_segment位置。成功返回0，失败返回-1。<br>函数使用举例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p0 = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this site of p0 is : %d\n&quot;</span>, p0);</span><br><span class="line">    </span><br><span class="line">    brk(p0 + <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this site is : %d\n&quot;</span>, sbrk(<span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    brk(p0 + <span class="number">1001</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this site is : %d\n&quot;</span>, sbrk(<span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    brk(p0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this site is : %d\n&quot;</span>, sbrk(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数输出如下：<br>this site of p0 is : 206979072<br>this site is : 206983072<br>this site is : 206983076<br>this site is : 206979072</p>
<h1 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h1><p>内存的管理方式比malloc和free更加灵活，适合申请不确定的内存空间的情况，特别适合同类型的大块数据。如果用malloc则可能存在申请内存空间过多浪费的情况，过少时需要重新调用realloc来重新申请内存的情况。速度比malloc快。</p>
]]></content>
  </entry>
  <entry>
    <title>在Linux上搭建HBase集群环境</title>
    <url>/post/setup_hbase/</url>
    <content><![CDATA[<p>本文是在安装完成Hadoop的基础之上进行的，Hadoop的安装戳<a href="/post/hadoop_setup">这里</a>。<br>本文采用的Hadoop版本为0.20.2，HBase版本为0.90.6，ZooKeeper的版本为3.3.2（stable版）。<br>本文仍然采用了Hadoop安装的环境，机器如下：</p>
<table>
<tr>
    <td>机器名</td>
    <td>IP地址</td>
    <td>用途</td>
    <td>Hadoop模块</td>
    <td>HBase模块</td>
    <td>ZooKeeper模块</td>
</tr>
<tr>
    <td>server206</td>
    <td>192.168.20.6</td>
    <td>Master</td>
    <td>NameNode、JobTracker、SecondaryNameNode</td>
    <td>HMaster</td>
    <td>QuorumPeerMain</td>
</tr>
<tr>
    <td>ap1</td>
    <td>192.168.20.36</td>
    <td>Slave</td>
    <td>DataNode、TaskTracker</td>
    <td>HRegionServer</td>
    <td>QuorumPeerMain</td>
</tr>
<tr>
    <td>ap2</td>
    <td>192.168.20.38</td>
    <td>Slave</td>
    <td>DataNode、TaskTracker</td>
    <td>HRegionServer</td>
    <td>QuorumPeerMain</td>
</tr>
</table>

<h1 id="安装ZooKeeper"><a href="#安装ZooKeeper" class="headerlink" title="安装ZooKeeper"></a>安装ZooKeeper</h1><p>由于HBase默认集成了ZooKeeper，可以不用单独安装ZooKeeper。本文采用独立安装ZooKeeper的方式。<br>1. 将zookeeper解压到&#x2F;home&#x2F;hadoop目录下。<br>2. 将&#x2F;home&#x2F;hadoop&#x2F;zookeeper-3.3.2&#x2F;conf目录下的zoo_sample.cfg文件拷贝一份，命名为为“zoo.cfg”。<br>3. 修改zoo.cfg文件，修改后内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line">dataDir=/home/hadoop/zookeeper-3.3.2/zookeeper_data</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181</span><br><span class="line">dataLogDir=/home/hadoop/zookeeper-3.3.2/logs</span><br><span class="line">server.1=192.168.20.6:2888:3888</span><br><span class="line">server.2=192.168.20.36:2888:3888</span><br><span class="line">server.3=192.168.20.38:2888:3888</span><br></pre></td></tr></table></figure>
<p>其中，2888端口号是zookeeper服务之间通信的端口，而3888是zookeeper与其他应用程序通信的端口。<br>这里修改了dataDir和dataLogDir的值。<br>需要特别注意的是：如果要修改dataDir的值不能将原来的行在前面加个“#”注释掉后在后面再增加一行，这样是不起作用的。可以参考bin目录下的zkServer.sh文件中的72行，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZOOPIDFILE=$(grep dataDir &quot;$ZOOCFG&quot; | sed -e &#x27;s/.*=//&#x27;)/zookeeper_server.pid</span><br></pre></td></tr></table></figure>
<p>这里通过grep和sed命令来获取dataDir的值，对于行前面添加“#”注释是不起作用的。<br>4. 创建zoo.cfg文件中的dataDir和dataLogDir所指定的目录。<br>5. 在dataDir目录下创建文件<code>myid</code>。<br>6. 通过scp命令将zookeeper-3.3.2目录拷贝到其他节点机上。<br>7. 修改<code>myid</code>文件，在对应的IP的机器上输入对应的编号，该编号要和zoo.cfg中的一致。本例中在192.168.20.6上文件内容为1；在192.168.20.36上文件内容为2；在192.168.20.38上文件内容为3。至此ＺooＫeeper的安装已经完成。</p>
<h1 id="运行ZooKeeper"><a href="#运行ZooKeeper" class="headerlink" title="运行ZooKeeper"></a>运行ZooKeeper</h1><p>1. 在节点机上依次执行<code>/home/hadoop/zookeeper-3.3.2/bin/zkServer.sh start</code>脚本。运行第一个ZooKeeper的时候会因等待其他节点而出现刷屏现象，等启动起第二个节点上的ZooKeeper后就正常了。运行完成之后该脚本会出现刷屏现象，我这里没有理会。<br>2. 通过jps命令来查看各节点机上是否含有QuorumPeerMain进程。<br>3. 通过<code>/home/hadoop/zookeeper-3.3.2/bin/zkServer.sh status</code>命令来查看状态。本例中有三个节点机，其中必有一个leader，两个follower存在。<br>4. 在各节点机上依次执行<code>/home/hadoop/zookeeper-3.3.2/bin/zkServer.sh stop</code>来停止ZooKeeper服务。</p>
<h1 id="配置时间同步ntp服务"><a href="#配置时间同步ntp服务" class="headerlink" title="配置时间同步ntp服务"></a>配置时间同步ntp服务</h1><p>HBase在运行的时候各个节点之间时间不同步会存在莫名其妙的问题，这里选择以192.168.20.36机器作为时间同步服务器，其他机器从该机器同步时间。<br>在192.168.20.36上通过service ntpd start命令来启动ntp服务。<br>在其他机器上配置crontab命令，增加下面一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 */1 * * * /usr/sbin/ntpdate 192.168.20.36 &amp;&amp; /sbin/hwclock -w</span><br></pre></td></tr></table></figure>
<p>这里采用一个小时同步一次时间的方式。</p>
<h1 id="安装HBase"><a href="#安装HBase" class="headerlink" title="安装HBase"></a>安装HBase</h1><p>1. 在HMaster机器上将HBase解压到&#x2F;home&#x2F;hadoop目录下。<br>2. 修改配置文件hbase-env.sh，使<code>export HBASE_MANAGES_ZK=false</code>。如果想要HBase使用自带的ZooKeeper则使用设置为true。使<code>export JAVA_HOME=/usr/java/jdk1.6.0_10</code>来指定java的安装路径。<br>3. 修改配置文件hbase-site.xml如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;  </span><br><span class="line">    &lt;name&gt;hbase.rootdir&lt;/name&gt;  </span><br><span class="line">    &lt;value&gt;hdfs://server206:9000/hbase&lt;/value&gt;  </span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.master.port&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;60000&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.zookeeper.property.clientPort&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;2181&lt;/value&gt;    </span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;server206,ap1,ap2&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/home/hadoop/zookeeper-3.3.2/zookeeper_data&lt;/value&gt;    </span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.support.append&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hbase.regionserver.handler.count&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;100&lt;/value&gt;</span><br><span class="line">&lt;/property&gt; </span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>4. 修改regionservers，添加HRegionServer模块所运行机器的主机名。在本例中内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ap1</span><br><span class="line">ap2</span><br></pre></td></tr></table></figure>
<p>5. 为了确保HBase和Hadoop的兼容性，这里将&#x2F;home&#x2F;hadoop&#x2F;hadoop-0.20.2&#x2F;hadoop-0.20.2-core.jar文件复制到&#x2F;home&#x2F;hadoop&#x2F;hbase-0.90.6&#x2F;lib目录下，并将原先的Hadoop的jar文件删掉或重命名为其他后缀的文件。<br>6. 将hbase-0.90.6文件夹通过scp命令复制到其他节点机上。</p>
<h1 id="HBase的启动"><a href="#HBase的启动" class="headerlink" title="HBase的启动"></a>HBase的启动</h1><ol>
<li>在Hadoop的NameNode所在的机器上使用start-all.sh脚本来启动Hadoop集群。</li>
<li>在各个节点机上调用zkServer.sh脚本来启动ZooKeeper。</li>
<li>在HMaster所在的机器上使用start-hbase.sh脚本来启动HBase集群。</li>
</ol>
<p>HBase启动后会在HDFS自动创建&#x2F;hbase的文件夹，可以通过<code>hadoop fs -ls /hbase</code>命令来查看，该目录不需要自动创建。如果在安装HBase的过程中失败需要重新启动，最好将此目录从集群中删除，通过命令<code>hadoop fs -rmr /hbase</code>来删除。</p>
<p>需要特别注意的是在hadoop集群中<code>hadoop fs -ls /hbase</code>目录和<code>hadoop fs -ls hbase</code>目录并非一个目录，通过<code>hadoop fs -ls hbase</code>查看到的目录实际上为&#x2F;user&#x2F;hadoop&#x2F;hbase目录。</p>
<h1 id="HBase管理界面"><a href="#HBase管理界面" class="headerlink" title="HBase管理界面"></a>HBase管理界面</h1><p>Master的界面：<a href="http://192.168.20.6:60010/master.jsp">http://192.168.20.6:60010/master.jsp</a><br>RegionServer的界面：<a href="http://192.168.20.36:60030/regionserver.jsp%E5%92%8Chttp://192.168.20.38:60030/regionserver.jsp">http://192.168.20.36:60030/regionserver.jsp和http://192.168.20.38:60030/regionserver.jsp</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://blog.csdn.net/gudaoqianfu/article/details/7327191">http://blog.csdn.net/gudaoqianfu/article/details/7327191</a></li>
<li><a href="http://thomas0988.iteye.com/blog/1309867">http://thomas0988.iteye.com/blog/1309867</a></li>
</ul>
<h1 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h1><p><a href="http://pan.baidu.com/share/link?shareid=1235031445&uk=3506813023">http://pan.baidu.com/share/link?shareid=1235031445&uk=3506813023</a> 提取码：v8ok</p>
]]></content>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>常用shell命令（持续更新）</title>
    <url>/post/shell-often/</url>
    <content><![CDATA[<h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><ul>
<li>–local-port：指定源端口号</li>
<li>–proxy：指定本地代理，例如：<a href="http://127.0.0.1:52114/">http://127.0.0.1:52114</a></li>
<li>-d：指定body，如果body比较小，可以直接指定<code>-d &#39;login=emma＆password=123&#39;</code>，也可以通过指定文件的方式 <code>-d &#39;@data.txt&#39;</code></li>
</ul>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>bash会将历史命令记录到文件.bash_history中，通过history命令可以查看到历史执行的命令。但history在默认情况下，仅会显示命令，不会展示出执行命令的时间。history命令可以根据环境变量HISTTIMEFORMAT来显示时间，要想显示时间可以执行如下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HISTTIMEFORMAT=&#x27;%F %T &#x27; history</span><br></pre></td></tr></table></figure>

<h2 id="lrzsz"><a href="#lrzsz" class="headerlink" title="lrzsz"></a>lrzsz</h2><p>CentOS rpm包地址：<a href="https://rpmfind.net/linux/centos/7.9.2009/os/x86_64/Packages/lrzsz-0.12.20-36.el7.x86_64.rpm">https://rpmfind.net/linux/centos/7.9.2009/os/x86_64/Packages/lrzsz-0.12.20-36.el7.x86_64.rpm</a></p>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>最常用的为<code>ps -ef</code>和<code>ps aux</code>命令，两者的输出结果差不多，其中<code>ps -ef</code>为System V Style风格，<code>ps aux</code>为BSD风格，现在ps命令两者均支持。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ps aux</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">www-data       1  0.0  0.0    212     8 ?        Ss   Apr09   0:00 /usr/bin/dumb-init -- /nginx-ingress-controller</span><br><span class="line">www-data       6  0.9  0.3 813500 100456 ?       Ssl  Apr09  67:20 /nginx-ingress-controller --publish-service</span><br><span class="line">www-data      33  0.0  0.7 458064 242252 ?       S    Apr09   0:53 nginx: master process /usr/local/nginx/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">www-data   46786  0.0  0.7 459976 239996 ?       S    17:57   0:00 rollback logs/eagleeye.log interval=60 adjust=600</span><br><span class="line">www-data   46787  1.4  0.8 559120 283328 ?       Sl   17:57   2:07 nginx: worker process</span><br><span class="line">www-data   46788  1.1  0.8 558992 284772 ?       Sl   17:57   1:38 nginx: worker process</span><br><span class="line">www-data   46789  0.0  0.7 452012 237152 ?       S    17:57   0:01 nginx: cache manager process</span><br><span class="line">www-data   46790  0.0  0.8 490832 267600 ?       S    17:57   0:00 nginx: x</span><br><span class="line">www-data   47357  0.0  0.0  60052  1832 pts/2    R+   20:21   0:00 ps aux</span><br></pre></td></tr></table></figure>

<p>每个列的值如下：</p>
<ul>
<li>%MEM：占用内存百分比</li>
<li>VSZ: 进程使用的虚拟内存量（KB）</li>
<li>RSS：进程占用的固定内存量，驻留在页中的（KB）</li>
<li>STAT：进程的状态</li>
<li>TIME：进程实际使用的cpu运行时间</li>
</ul>
<h2 id="pssh"><a href="#pssh" class="headerlink" title="pssh"></a>pssh</h2><p>该工具的定位是在多台主机上批量执行pssh命令。</p>
<ol>
<li>将文件存放到文件中 &#x2F;tmp&#x2F;hosts 中，文件格式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.1.1</span><br><span class="line">192.168.1.2</span><br></pre></td></tr></table></figure></li>
<li>批量执行shell命令：pssh -h &#x2F;tmp&#x2F;hosts -A -i ‘uptime’。</li>
</ol>
<p>具体参数说明如下：</p>
<ul>
<li>-A: 手工输入密码模式，如果未打通ssh免密，可以在执行pssh命令的时候手工输入主机密码，但要求所有主机密码必须保持一致</li>
</ul>
<h2 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h2><p>常用命令：</p>
<ol>
<li><code>rsync -avz -e &#39;ssh -p 50023&#39; ~/git/arkctl root@100.67.27.224:/tm</code></li>
</ol>
<p>常用参数：</p>
<ul>
<li><code>--delete</code>: 本地文件删除时，同步删除远程文件</li>
<li><code>-e &#39;ssh -p 50023&#39;</code>: 指定 ssh 端口号</li>
<li><code>--exclude=.git</code>: 忽略同步本地的 git 目录</li>
</ul>
<h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><ul>
<li>-P：指定端口号</li>
</ul>
<h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><p>跟踪进程的系统调用</p>
<ul>
<li>-p：指定进程</li>
<li>-s：指定输出的字符串的最大大小</li>
<li>-f：跟踪由fork调用产生的子进程</li>
</ul>
<h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><ul>
<li>-P: 当下载文件时，可以指定本地的下载的目录</li>
</ul>
<h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p>split [-bl] file [prefix]</p>
<ul>
<li><p>-b, –bytes&#x3D;SIZE：对file进行切分，每个小文件大小为SIZE。可以指定单位b,k,m。</p>
</li>
<li><p>-C,–bytes&#x3D;SIZE：与-b选项类似，但是，切割时尽量维持每行的完整性。</p>
</li>
<li><p>prefix：分割后产生的文件名前缀。</p>
</li>
</ul>
<p>拆分文件：split -b 200m ip_config.gzip ip_config.gzip</p>
<p>文件合并：cat ip_config.gzip* &gt; ip_config.gzip</p>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>快速开启一个http server <code>python -m SimpleHTTPServer 8080</code>。</p>
<p>在python3环境下该命令变更为：<code>python3 -m http.server 8080</code></p>
<p>格式化 json: <code>cat 1.json | python -m json.tool</code></p>
<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>按照,打印出一每一列 <code>awk -F, &#39;&#123;for(i=1;i&lt;=NF;i++)&#123;print $i;&#125;&#125;&#39;</code></p>
<h2 id="docker-registry"><a href="#docker-registry" class="headerlink" title="docker registry"></a>docker registry</h2><ul>
<li>列出镜像：<code>curl http://127.0.0.1:5000/v2/_catalog?n=1000</code></li>
<li>查询镜像的tag: <code>curl http://127.0.0.1:5000/v2/nginx/tags/list</code>，如果遇到镜像名类似<code>aa/bb</code>的情况，需要转移一下 <code>curl http://127.0.0.1:5000/v2/aa\/bb/tags/list</code></li>
</ul>
<h2 id="socat"><a href="#socat" class="headerlink" title="socat"></a>socat</h2><ul>
<li>向本地的 socket 文件发送数据：<code>echo &quot;test&quot; | socat - unix-connect:/tmp/unix.sock</code></li>
<li>通过交互的方式输入命令：<code>socat - UNIX-CONNECT:/var/lib/kubelet/pod-resources/kubelet.sock</code></li>
</ul>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><ul>
<li>删除远程分支 <code>git push origin --delete xxx</code></li>
<li>强制更新远程分支：<code>git push --force-with-lease origin feature/statefulset</code></li>
<li>删除本地分支：<code>git branch -D local-branch</code></li>
<li>拉取远程分支并切换分支：<code>git checkout -b develop origin/remote-branch</code> develop为本地分支，origin&#x2F;remote-branch为远程分支</li>
</ul>
<h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><ul>
<li><code>rpm -ivh xx.rpm</code>：用来安装一个 rpm 包</li>
<li><code>rpm -qa</code>：查看已经安装的包</li>
<li><code>rpm -ql</code>: 查看已经安装的 rpm 的文件内容</li>
<li><code>rpm -qpR *.rpm</code>: 查看rpm包的依赖</li>
<li><code>rpm -e *</code>：要删除的rpm包</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>leetcode题目之Single Number</title>
    <url>/post/single_number/</url>
    <content><![CDATA[<h1 id="题目一-Single-Number"><a href="#题目一-Single-Number" class="headerlink" title="题目一 Single Number"></a>题目一 Single Number</h1><blockquote>
<p>Given an array of integers, every element appears twice except for one. Find that single one.<br>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<h1 id="题目二-Single-Number-II"><a href="#题目二-Single-Number-II" class="headerlink" title="题目二 Single Number II"></a>题目二 Single Number II</h1><blockquote>
<p>Given an array of integers, every element appears three times except for one. Find that single one.<br>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<h1 id="题目一分析及解答"><a href="#题目一分析及解答" class="headerlink" title="题目一分析及解答"></a>题目一分析及解答</h1><p>针对题目一，一看就能看出是考察异或操作的特点，并迅速写出了解答方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            result ^= A[i];</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="题目二分析及解答"><a href="#题目二分析及解答" class="headerlink" title="题目二分析及解答"></a>题目二分析及解答</h1><p>要想实现时间复杂度为O(n)，空间复杂度为O(1)的算法，还是跟题目一一样需要充分利用位操作特性，但是并没有直接可用的位操作特性可以完成，于是想到肯定是各种位操作的组合操作，但是并没有继续向下想到具体的算法。本质上该题目就是模拟一个三进制的操作，当一个位的最大值为2，当为3时直接清0。</p>
<p>参照网上的算法，利用一个int类型的数组来模拟一个三进制数，每个int值的最大值为3，当然这样存在一定空间上的浪费。算法需要将A中的每个值通过移位运算获取到该位的状态，并将值添加到用来模拟三进制的int数组中相应的位置，最后将模拟三进制int数组中的值为3的更改为0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++&#123;</span><br><span class="line">                <span class="keyword">if</span> ((A[j] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    count[i]++;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">            result |= ((count[i] % <span class="number">3</span>) &lt;&lt; i); </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外，还有上述算法的改进算法，更为节省空间，效率更高，但是确实不容易理解和记忆，属于下次仍然无法记忆的算法类型。这里仅提供代码，不再给出解释，自己领悟。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>, threes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        twos |= ones &amp; A[i];</span><br><span class="line">        ones ^= A[i];<span class="comment">// 异或3次 和 异或 1次的结果是一样的</span></span><br><span class="line">       <span class="comment">//对于ones 和 twos 把出现了3次的位置设置为0 （取反之后1的位置为0）</span></span><br><span class="line">        threes = ones &amp; twos;</span><br><span class="line">        ones &amp;= ~threes;</span><br><span class="line">        twos &amp;= ~threes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>奴隶的心态</title>
    <url>/post/slave_mind/</url>
    <content><![CDATA[<p><img src="http://www.baidupcs.com/thumbnail/1d02bdb0543f902057e8d05d7aee6f69?fid=3506813023-250528-2907673101&time=1373525806&sign=FDTAR-DCb740ccc5511e5e8fedcff06b081203-EpZzqe5BS+hUIxjvOCgdmRFt+t4=&rt=sh&expires=8h&size=c850_u580&quality=100" alt="Image Title"></p>
<p>今天下午新办的工资银行卡办下来了，原先工资卡用的招商银行的金卡，现在新办了个农村信用社的普通卡，有种从城市的大马路走到了胡同里的城中村的感觉。于是大家高高兴兴的蹦蹦跳跳的屁颠屁颠的去领来的新的工资卡。为什么大家会高兴呢？这也是本文的因子，因为大家都已经有两个月没发工资了，新卡到说明工资在不久的将来也会到，大家当然高兴啦。</p>
<p>可是深入想一下，大家真的应该高兴吗？工资本来就是公司单方面拖欠大家的，给大家造成的损失员工宽宏大量没有跟公司计较也就罢了。工资关系到民生，直接影响了员工每个人的生活。要是搁到法国估计一天不发工资，员工早就集体罢工了吧。换卡势必会造成大家的麻烦，原来的银行卡可能就要销户，新的银行是否足够方便。我们却是心宽体胖，公司的错既往不咎，只要看到发工资的希望我照样努力为公司奉献。</p>
<p>这就好比是在中国假期几天高速路不收费，有车一族就喜出望外，“在中国真幸福，可以赚到国家便宜了”。殊不知，<code>世界已建成14万公里收费公路，10万公里在我国</code>。不知道了解这个之后，有车一族还笑得出来吗？我估计连哭的心态都有了。</p>
<p>那大家应该是什么心态去领工资卡呢？平常心就好。至少不至于表现出屁颠屁颠的心态吧。</p>
<p>中国两千多年的封建统治对人民的思想影响是深远的，人们心中早就建立起了人分三六九等的等级观念。而且这种等级观念影响是深远的，悄无声息的深入到我们所谓的“社会主义国家”内部的各个角落。电视里整天的宫廷剧，格格与皇阿玛齐飞，太监共丫鬟一色，这些可是典型的民权不公，民生不平。我们可是就靠这些文化垃圾养大的，心里怎么会没有了奴隶的思想呢？百姓心中的怕官、傍官的思想及考官的行为直接复制到了现在不曾改变，奴隶的心态也就不会改变。</p>
<p>好在现代文明来了，互联网时代来了。西方的文明渐渐深入，我们有的救。打倒xx，打倒xx，期待来一场轰轰烈烈的革新吧。</p>
<p>如果说奴隶的心态为“给你点阳光你就灿烂，给你点洪水你就泛滥”，期待我们的心态变成“没有阳光也要比比灿烂，没有洪水也要试图泛滥”。</p>
<p>题图：《被释放的姜戈》电影海报</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>在tomcat7.0.41上搭建solr4.3.1</title>
    <url>/post/solr4.3.1_setup/</url>
    <content><![CDATA[<p>前几天写了篇《<a href="/post/solr_setup">在Linux上搭建solr环境</a>》的博文，是基于solr3.6.2的安装。本文仅记录在tomcat7.0.41上搭建solr4.3.1搭建过程中需要注意的地方，其他地方可以参考上一篇博文。</p>
<p>配置完成之后发现<a href="http://192.168.20.38:8090/solr%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%EF%BC%8C%E4%BD%86%E6%98%AFhttp://192.168.20.38:8090/%E5%8D%B4%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%EF%BC%8C%E9%80%9A%E8%BF%87%E6%9F%A5%E7%9C%8Btomcat%E7%9A%84%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6localhost.2013-07-03.log%EF%BC%8C%E5%8F%91%E7%8E%B0%E9%87%8C%E9%9D%A2%E6%9C%89%E5%A6%82%E4%B8%8B%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%E3%80%82">http://192.168.20.38:8090/solr无法访问，但是http://192.168.20.38:8090/却可以访问，通过查看tomcat的日志文件localhost.2013-07-03.log，发现里面有如下错误提示。</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">严重: Exception starting filter SolrRequestFilter</span><br><span class="line">org.apache.solr.common.SolrException: Could not find necessary SLF4j logging jars. If using Jetty, the SLF4j logging jars need to go in the jetty lib/ext directory. For other containers, the corresponding directory should be used. For more information, see: http://wiki.apache.org/solr/SolrLogging</span><br></pre></td></tr></table></figure>
<p>解决办法：将<del>&#x2F;solr-4.3.1&#x2F;example&#x2F;lib&#x2F;ext目录下的所有jar文件复制到</del>&#x2F;apache-tomcat-7.0.41&#x2F;lib目录下，然后重启tomcat即可。</p>
<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a href="http://pan.baidu.com/share/link?shareid=1811860312&uk=3506813023">用到的文件</a></p>
]]></content>
      <tags>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title>在Linux上搭建solr环境</title>
    <url>/post/solr_setup/</url>
    <content><![CDATA[<p>本文采用Linux操作系统在hadoop用户下安装，solr采用3.x中的最新版本3.6.2，tomcat采用6.0.37版本，安装包可以从本文下方链接下载。<br>这里有两种安装方式，一种方式为利用solr自带的jetty来启动solr，默认端口为8983。另外一种方式为将solr集成到tomcat中。其中第一种方式较为简单，推荐新手采用。</p>
<h1 id="独立启动"><a href="#独立启动" class="headerlink" title="独立启动"></a>独立启动</h1><ol>
<li>将sorl的安装包解压到用户的根目录下，解压后文件夹为apache-solr-3.6.2。</li>
<li>进入到example目录下，执行<code>java -jar start.jar</code>命令，solr服务启动，端口为8983。</li>
<li>通过<code>http://IP地址:8983/solr/</code>来访问solr的web页面，进入admin页面后可以通过输入字符串来查找索引。查找索引默认显示的格式为xml格式，可以通过在url的后面加上参数<code>wt=json</code>来显示json格式的结果。</li>
</ol>
<h1 id="利用tomcat"><a href="#利用tomcat" class="headerlink" title="利用tomcat"></a>利用tomcat</h1><h2 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h2><p>1. 将apache-tomcat-6.0.37.tar.gz解压到hadoop的跟目录下。<br>2. 修改hadoop用户的环境变量，执行<code>vi ~/.bash_profile</code>命令，添加如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export CATALINA_HOME=/home/hadoop/apache-tomcat-6.0.37</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$CATALINA_HOME/lib</span><br><span class="line">export PATH=$PATH:$CATALINA_HOME/bin</span><br></pre></td></tr></table></figure>
<p>3. 执行<code>source ~/.bash_profile </code>使修改的环境变量生效。<br>4. 执行tomcat的bin目录下的startup.bat脚本来启动tomcat。<br>5. 通过<code>netstat -anp | grep 8080</code>命令查看tomcat是否启动。</p>
<h2 id="安装solr"><a href="#安装solr" class="headerlink" title="安装solr"></a>安装solr</h2><p>1. 将solr的dist&#x2F;apache-solr-3.6.2.war文件复制到tomcat的webapps目录下，并将文件命名为solr.war。执行<code>cp ~/apache-solr-3.6.2/dist/apache-solr-3.6.2.war ~/apache-tomcat-6.0.37/webapps/solr.war</code>命令。WAR是一个完整的web应用程序，包括了Solr的jar文件和所有运行Solr所依赖的Jar文件，Jsp和很多的配置文件与资源文件。</p>
<p>2. 修改<code>~/apache-tomcat-6.0.37/conf/server.xml</code>文件相应行的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; </span><br><span class="line">    connectionTimeout=&quot;20000&quot; </span><br><span class="line">    URIEncoding=&quot;UTF-8&quot;</span><br><span class="line">    redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>增加<code>URIEncoding=&quot;UTF-8&quot;</code>来支持中文。这是因为solr基于xml，json，javabin，php，python等多种格式传输请求和返回结果。</p>
<p>3.复制<code>~/apache-solr-3.6.2/example/solr</code>目录到<code>/home/hadoop/solr</code>位置。该位置为solr的应用环境目录。</p>
<p>4. 修改<code>/home/hadoop/solr/conf/solrconfig.xml</code>文件中的dataDir一行内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dataDir&gt;$&#123;solr.data.dir:/home/hadoop/solr/data&#125;&lt;/dataDir&gt;</span><br></pre></td></tr></table></figure>
<p>目的是为了指定存放索引数据的路径。</p>
<p>5. 在<code>~/apache-tomcat-6.0.37/conf/Catalina/localhost</code>目录下新建文件<code>solr.xml</code>。增加内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Context docBase=&quot;/home/hadoop/apache-tomcat-6.0.37/webapps/solr.war&quot; debug=&quot;0&quot; crossContext=&quot;true&quot; &gt;</span><br><span class="line">    &lt;Environment name=&quot;solr/home&quot; type=&quot;java.lang.String&quot; value=&quot;/home/hadoop/solr&quot; override=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure>
<p>其中docBase为tomcat的webapps下的solr.war完整路径。Environment的value属性的值为存放solr索引的文件夹，即第三步中复制的文件夹。<br>需要注意的是：Catalina目录在首次启动tomcat时创建，因此在此步骤前需要启动过tomcat。</p>
<p>6. 在tomcat的bin目录下通过<code>startup.sh</code>启动tomcat。</p>
<p>7. 通过<code>http://IP地址:8080/solr/</code>来访问solr的web页面。</p>
<h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><h2 id="放入数据到solr中"><a href="#放入数据到solr中" class="headerlink" title="放入数据到solr中"></a>放入数据到solr中</h2><p>在apache-solr-3.6.2&#x2F;example&#x2F;exampledocs目录下，执行<code>java -jar post.jar 要存放的文件名</code>。这里自己新建一个文件test.xml放入到solr中，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;add&gt;</span><br><span class="line">    &lt;doc&gt;  </span><br><span class="line">        &lt;field name=&quot;id&quot;&gt;company&lt;/field&gt;  </span><br><span class="line">        &lt;field name=&quot;text&quot;&gt;kaitone&lt;/field&gt;  </span><br><span class="line">    &lt;/doc&gt;</span><br><span class="line">&lt;/add&gt;</span><br></pre></td></tr></table></figure>
<p>执行<code>java -jar post.jar test.xml</code>将数据放入solr中。</p>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>新建文本文件test_delete.xml，内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;delete&gt;</span><br><span class="line">    &lt;id&gt;company&lt;/id&gt;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>
<p>执行<code>java -jar post.jar test_delete.xml</code>将数据从solr中删除。<br>另外还可以通过命令行的方式来删除，命令为<code>java -Ddate=args -jar post.jar &#39;&lt;delete&gt;&lt;id&gt;company&lt;/id&gt;&lt;/delete&gt;&#39;</code>。</p>
<h1 id="在Eclipse中搭建环境操作Solr-api"><a href="#在Eclipse中搭建环境操作Solr-api" class="headerlink" title="在Eclipse中搭建环境操作Solr api"></a>在Eclipse中搭建环境操作Solr api</h1><p>1. 新建一个java工程<br>2. 在工程中引入如下包：</p>
<ul>
<li>commons-httpclient-3.1.jar</li>
<li>commons-codec-1.6.jar</li>
<li>apache-solr-solrj-3.6.2.jar</li>
<li>slf4j-api-1.6.1.jar</li>
<li>slf4j-log4j12-1.6.1.jar</li>
<li>commons-logging-1.1.3.jar</li>
<li>log4j-1.2.12.jar</li>
<li>httpclient-4.2.5.jar</li>
<li>httpcore-4.2.4.jar</li>
<li>httpmime-4.2.5.jar</li>
</ul>
<p>其中<code>commons-httpclient-3.1.jar</code>、<code>commons-codec-1.6.jar</code>、<code>apache-solr-solrj-3.6.2.jar</code>、<code>slf4j-api-1.6.1.jar</code>可以从solr的目录<code>apache-solr-3.6.2</code>中的dist目录下找到。</p>
<p><code>slf4j-log4j12-1.6.1.jar</code>可以从slf4j的压缩包中<code>slf4j-1.6.1.tar.gz</code>找到。</p>
<p><code>commons-logging-1.1.3.jar</code>可以从slf4j的压缩包中<code>commons-logging-1.1.3-bin.zip</code>找到。</p>
<p><code>log4j-1.2.12.jar</code>可以从log4j的压缩包中<code>logging-log4j-1.2.12.tar.gz</code>找到。</p>
<p><code>httpclient-4.2.5.jar</code>、<code>httpcore-4.2.4.jar</code>、<code>httpmime-4.2.5.jar</code>在<code>httpcomponents-client-4.2.5-bin.tar.gz</code>文件中。</p>
<p>具体的API编程可以参考<a href="http://www.cnblogs.com/hoojo/archive/2011/10/21/2220431.html">Solr开发文档</a>。</p>
<h1 id="在linux上编译并执行程序"><a href="#在linux上编译并执行程序" class="headerlink" title="在linux上编译并执行程序"></a>在linux上编译并执行程序</h1><p>1. 将工程中用到的jar包复制到Linux机器上，这里复制到<code>/home/hadoop/test_solr/lib</code>目录下。</p>
<p>2. 将测试程序的源码放到Linux机器上，这里复制到<code>/home/hadoop/test_solr</code>目录下。其中源码包括三个文件：SolrTest.java、SolrClient.java、Index.java。该三个文件将会包含在下面相关下载中的Eclipse工程中。</p>
<p>3. 在<code>/home/hadoop/test_solr</code>目录下执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -cp lib/apache-solr-solrj-3.6.2.jar:lib/commons-httpclient-3.1.jar:lib/log4j-1.2.12.jar:lib/commons-codec-1.6.jar:lib/commons-logging-1.1.3.jar:lib/slf4j-api-1.6.1.jar:lib/httpclient-4.2.5.jar:lib/httpcore-4.2.4.jar:lib/httpmime-4.2.5.jar:. SolrTest.java</span><br></pre></td></tr></table></figure>
<p>其中-cp等同于-classpath参数，指定编译SolrTest.java文件需要的ClassPath路径，不要忘记路径后面的<code>.</code>表示当前路径，否则找不到当前目录下的其他java文件。<br>命令执行后会在<code>/home/hadoop/test_solr</code>目录下生成Index.class、SolrClient.class、SolrTest.class三个class文件。</p>
<p>4. 在<code>/home/hadoop/test_solr</code>目录下执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp lib/apache-solr-solrj-3.6.2.jar:lib/commons-httpclient-3.1.jar:lib/log4j-1.2.12.jar:lib/commons-codec-1.6.jar:lib/commons-logging-1.1.3.jar:lib/slf4j-api-1.6.1.jar:lib/httpclient-4.2.5.jar:lib/httpcore-4.2.4.jar:lib/:httpmime-4.2.5.jar:. SolrTest</span><br></pre></td></tr></table></figure>
<p>来运行程序。</p>
<h1 id="在Linux上打包并执行"><a href="#在Linux上打包并执行" class="headerlink" title="在Linux上打包并执行"></a>在Linux上打包并执行</h1><p>1. 在上面步骤基础上，为了方便执行，可以将class文件打成jar包来执行，这样在使用java命令执行的时候就不用指定classpath路径了，只需要在jar包的MANIFEST.MF文件中指定classpath。</p>
<p>2. 在<code>/home/hadoop/test_solr</code>下新建一个文件，文件名可以随便，这里取名为MANIFEST.MF，与生成的jar包中的文件名一致，文件内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Created-By: 1.6.0_10 (Sun Microsystems Inc.)</span><br><span class="line">Main-Class: SolrTest</span><br><span class="line">Class-Path: /home/hadoop/test_solr/lib/apache-solr-solrj-3.6.2.jar /home/hadoop/test_solr/lib/commons-httpclient-3.1.jar /home/hadoop/test_solr/lib/log4j-1.2.12.jar /home/hadoop/test_solr/lib/commons-codec-1.6.jar /home/hadoop/test_solr/lib/commons-logging-1.1.3.jar /home/hadoop/test_solr/lib/slf4j-api-1.6.1.jar</span><br><span class="line">/home/hadoop/test_solr/lib/httpclient-4.2.5.jar</span><br><span class="line">/home/hadoop/test_solr/lib/httpcore-4.2.4.jar</span><br><span class="line">/home/hadoop/test_solr/lib/httpmime-4.2.5.jar</span><br></pre></td></tr></table></figure>
<p>其中Main-Class指定main函数所在的类。<br>Class-Path指定用到的jar所在的路径。其中Class-Path的各个jar文件之间通过空格分隔而不是通过<code>:</code>分隔。</p>
<p>3. 将class文件打包成jar文件。执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar -cfm solrtest.jar MANIFEST.MF Index.class SolrClient.class SolrTest.class </span><br></pre></td></tr></table></figure>
<p>会在此目录下生成solrtest.jar文件。jar命令会根据指定的MANIFEST.MF文件来产生jar包中的META-INF&#x2F;MANIFEST.MF文件。两个文件内容并不完全一致，jar命令会根据格式对内容进行调整。</p>
<p>4. 运行jar文件。通过<code>java -jar solrtest.jar</code>来执行。</p>
<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a href="http://pan.baidu.com/share/link?shareid=2915568646&uk=3506813023">本文中用到的安装包</a></p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="http://demi-panda.com/2013/03/13/install-solr/">简单的Solr安装配置</a><br><a href="https://lucene.apache.org/solr/3_6_2/doc-files/tutorial.html">官方安装教程</a><br><a href="http://cxshun.iteye.com/blog/1039445">Solr初体验系列</a>讲的非常详细，适合初学者<br><a href="http://www.cnblogs.com/hoojo/archive/2011/10/21/2220431.html">Solr开发文档</a></p>
]]></content>
      <tags>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建分布式的solr环境</title>
    <url>/post/solr_setup_distribute/</url>
    <content><![CDATA[<p>本文以《<a href="/post/solr_setup">在Linux上搭建solr环境</a>》为基础，假设已经在192.168.20.6和192.168.20.38上搭建了单机版solr环境。</p>
<h1 id="主服务器配置"><a href="#主服务器配置" class="headerlink" title="主服务器配置"></a>主服务器配置</h1><p>找到solr的环境目录下的conf文件夹下的solrconfig.xml文件，我的是在<code>/hadoop/solr/conf/solrconfig.xml</code>目录下，打开后找到如下行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;requestHandler name=&quot;/replication&quot; class=&quot;solr.ReplicationHandler&quot; &gt;</span><br></pre></td></tr></table></figure>
<p>默认是被注释的，将其修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;requestHandler name=&quot;/replication&quot; class=&quot;solr.ReplicationHandler&quot; &gt;</span><br><span class="line">       &lt;lst name=&quot;master&quot;&gt;</span><br><span class="line">         &lt;str name=&quot;replicateAfter&quot;&gt;commit&lt;/str&gt;</span><br><span class="line">         &lt;str name=&quot;replicateAfter&quot;&gt;startup&lt;/str&gt;</span><br><span class="line">         &lt;str name=&quot;confFiles&quot;&gt;schema.xml,stopwords.txt&lt;/str&gt;</span><br><span class="line">       &lt;/lst&gt;</span><br><span class="line">&lt;/requestHandler&gt;</span><br></pre></td></tr></table></figure>
<p>replicateAfter表示solr会在什么情况下复制，可选项包括：commit、startup、optimize，这里保持默认。<br>confFiles表示要分发的配置文件。</p>
<h1 id="从服务器配置"><a href="#从服务器配置" class="headerlink" title="从服务器配置"></a>从服务器配置</h1><p>在从服务器上，将<code>/hadoop/solr/conf/solrconfig.xml</code>文件相应的修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;requestHandler name=&quot;/replication&quot; class=&quot;solr.ReplicationHandler&quot; &gt;</span><br><span class="line">       &lt;lst name=&quot;slave&quot;&gt;</span><br><span class="line">         &lt;str name=&quot;masterUrl&quot;&gt;http://192.168.20.6:8080/solr/replication&lt;/str&gt;</span><br><span class="line">         &lt;str name=&quot;pollInterval&quot;&gt;00:00:60&lt;/str&gt;</span><br><span class="line">       &lt;/lst&gt;</span><br><span class="line">&lt;/requestHandler&gt;</span><br></pre></td></tr></table></figure>
<p>masterUrl为服务器的url地址。<br>pollInterval为从服务器的同步时间间隔。</p>
]]></content>
      <tags>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title>SolrCloud官方文档翻译</title>
    <url>/post/solrcloud_translate/</url>
    <content><![CDATA[<p>本文是翻译的solrcloud的官方英文文档，本文仅将文中重点翻译，原文地址点<a href="http://wiki.apache.org/solr/SolrCloud">这里</a>。英文水平不咋地，翻译篇文章也算练练手。</p>
<p><img src="http://people.apache.org/~markrmiller/2shard4serverFull.jpg" alt="Image Title"></p>
<h1 id="SolrCloud"><a href="#SolrCloud" class="headerlink" title="SolrCloud"></a>SolrCloud</h1><p>SolrCloud是Solr的分布式集群。可以通过集群来搭建一个高可用性，容错性的Solr服务。当想搭建一个大规模，容错性，分布式索引，查询性能好的Solr服务时可以采用SolrCloud。</p>
<h1 id="关于SolrCores和Collections的一点小知识"><a href="#关于SolrCores和Collections的一点小知识" class="headerlink" title="关于SolrCores和Collections的一点小知识"></a>关于SolrCores和Collections的一点小知识</h1><p>在单机运行时，单独的索引叫做SolrCore。如果想要创建多个索引，可以创建多个SolrCore。利用SolrCloud，一个索引可以存放在不同的Solr服务上。意味着一个单独的索引可以由不同的机器上的SolrCore组成。不同机器上的SolrCore组成了逻辑上的索引，这些SolrCore叫做collection。组成collection的SolrCore包括了数据索引和备份。</p>
<h1 id="例子A：-简单两个shard集群"><a href="#例子A：-简单两个shard集群" class="headerlink" title="例子A： 简单两个shard集群"></a>例子A： 简单两个shard集群</h1><p><img src="http://people.apache.org/~markrmiller/2shard2server.jpg" alt="Image Title"><br>这个例子简单创建了包含两个solr服务的集群，一个collection的数据分布到两个不同的shard上。<br>因为在这个例子中我们需要两个服务器，这里仅简单的复制example的数据作为第二个服务器，复制example目录之前需要确保里面没有索引数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -r example/solr/collection1/data/*</span><br><span class="line">cp -r example example2</span><br></pre></td></tr></table></figure>
<p>下面的命令会启动一个solr服务并启动一个新的solr集群。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd example</span><br><span class="line">java -Dbootstrap_confdir=./solr/collection1/conf -Dcollection.configName=myconf -DzkRun -DnumShards=2 -jar start.jar</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-DzkRun</code> 参数会在solr服务中启动一个内置的zookeeper服务。</li>
<li><code>-Dbootstrap_confdir=./solr/collection1/conf</code> 因为在zookeeper中没有solr配置信息，这一参数会将本地的<code>./solr/conf</code>目录下的配置信息上传到zookeeper中作为<code>myconf</code>配置参数。<code>myconf</code>是在下面的<code>collection.configName</code>参数中指定的。</li>
<li><code>-Dcollection.configName=myconf</code> 为新的collection设置配置名称。如果不加这个参数配置默认名称为<code>configuration1</code>。</li>
<li><code>-DnumShards=2</code> 划分索引到逻辑分区的个数。</li>
</ul>
<p>浏览<code>http://localhost(本地主机):8983/solr/#/~cloud</code>可以看到集群的状态。</p>
<p>通过目录树可以看到配置文件已经上传到了<code>/configs/myconf/</code>目录下，一个叫collection1的collection已经创建，在collection1下是shard的列表，这些shard组成了完整的collection。</p>
<p>接下来准备启动第二个服务器，因为没有明确的设置shard的id，该服务会自动分配到shard2。</p>
<p>启动第二个服务，并将其指向集群。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd example2</span><br><span class="line">java -Djetty.port=7574 -DzkHost=localhost:9983 -jar start.jar</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-Djetty.port=7574</code>来指定Jetty的端口号。</li>
<li><code>-DzkHost=localhost:9983</code>用来指定Zookeeper集群。在本例中，在第一个Solr服务中运行了一个单独的Zookeeper服务。默认情况下，Zookeeper的端口号为Solr服务的端口号加上1000，即9983。</li>
</ul>
<p>通过访问<code>http://localhost(本地主机):8983/solr/#/~cloud</code>，在collection1中就可以看到shard1和shard2。</p>
<p><img src="/ref/solr/solrcloud_1.png" alt="Image Title"></p>
<p>下面对一些文档建立索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd exampledocs</span><br><span class="line"></span><br><span class="line">java -Durl=http://localhost:8983/solr/collection1/update -jar post.jar ipod_video.xml</span><br><span class="line"></span><br><span class="line">java -Durl=http://localhost:8983/solr/collection1/update -jar post.jar monitor.xml</span><br><span class="line"></span><br><span class="line">java -Durl=http://localhost:8983/solr/collection1/update -jar post.jar mem.xml</span><br></pre></td></tr></table></figure>
<p>无论是向集群中的任何一台服务器请求都会得到全部的collection：<code>http://localhost:8983/solr/collection1/select?q=*:*</code>。</p>
<p>假如想更改配置，可以在关闭所有服务之后删除<code>solr/zoo_data</code>目录下的所有内容。</p>
<p>实际测试插入速度要比单个服务慢。</p>
<h1 id="例子B：简单的两个shard重复的shard集群"><a href="#例子B：简单的两个shard重复的shard集群" class="headerlink" title="例子B：简单的两个shard重复的shard集群"></a>例子B：简单的两个shard重复的shard集群</h1><p><img src="http://people.apache.org/~markrmiller/2shard4server.jpg" alt="Image Title"><br>本例子会通过复制shard1和shard2来创建上一个例子。额外的shard备份可以有高可用性和容错性，简单提升索引的查询能力。</p>
<p>首先，在运行先前的例子中我们已经有了两个shard和一些索引文档。然后简单的复制这两个服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -r example exampleB</span><br><span class="line">cp -r example2 example2B</span><br></pre></td></tr></table></figure>
<p>然后，在不同的端口上启动两个新的服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd exampleB</span><br><span class="line">java -Djetty.port=8900 -DzkHost=localhost:9983 -jar start.jar</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd example2B</span><br><span class="line">java -Djetty.port=7500 -DzkHost=localhost:9983 -jar start.jar</span><br></pre></td></tr></table></figure>
<p>重新浏览网址<code>http://localhost(本地主机):8983/solr/#/~cloud</code>，检查四个solr节点是否已经都启动。<br><img src="/ref/solr/solrcloud_2.png" alt="Image Title"><br>因为我们已经告诉Solr我们需要两个逻辑上的shard，启动后的实例3和4会自动的成为原来shard的备份。</p>
<p>向集群中的任意一个服务发起查询：<code>http://localhost:7500/solr/collection1/select?q=*:*</code>。多次发起这个查询并查看solr服务的日志。可以观察到Solr通过备份对请求做了平衡，通过不同的服务来处理请求。</p>
<p>为了证明高可用性，在除了运行Zookeeper的服务上按下CTRL-C。（在例子C中将会讨论Zookeeper的冗余）当服务终止后，发送另外一个查询请求到其他服务，仍然能够看到所有的结果。</p>
<p>在没一个shard至少还有一个服务时，SolrCloud仍然可以提供服务。可以通过关闭每一个实例来查看结果。假如关闭了一个shard的所有的服务，到其他服务的请求就会收到503错误。为了能够返回其他可用的shard中的文档，可以在请求中增加参数：<code>shards.tolerant=true</code>。</p>
<p>SolrCloud用leaders和overseer来作为具体的实现。一些节点或备份将会扮演特殊的角色。不需要担心杀死了leader或overseer，假如杀死了其中的一个，集群会自动选择一个新的leader或overseer，并自动接管工作。任何的Solr实例都可以成为这种角色。</p>
<h1 id="例子C：两个shard集群，shard带备份和zookeeper集群"><a href="#例子C：两个shard集群，shard带备份和zookeeper集群" class="headerlink" title="例子C：两个shard集群，shard带备份和zookeeper集群"></a>例子C：两个shard集群，shard带备份和zookeeper集群</h1><p><img src="http://people.apache.org/~markrmiller/2shard4server2.jpg" alt="Image Title"></p>
<p>在例子B中问题是虽然有足够的Solr服务器可以避免集群挂掉，但是仅有一个zookeeper服务来维持集群的状态。假如zookeeper服务挂掉了，分布式的查询还是可以工作的，因为solr服务记录了zookeeper最后一次报告的状态。问题是没有新的服务器或客户端能发现集群的状态，集群的状态也不会改变。</p>
<p>运行多个zookeeper服务可以保证zookeeper服务具有高可用性。每一个zookeeper服务需要知道集群中的其他服务，大部分服务需要提供服务。例如，一个含有三个zookeeper服务的集群允许其中一个失败剩余的两个仍然可以提供服务。五个zookeeper服务的集群可以允许一次失败两个。</p>
<p>从产品角度考虑，推荐使用单独的zookeeper服务而不是solr服务中集成的zookeeper服务。你可以从<a href="http://zookeeper.apache.org/doc/r3.3.4/zookeeperStarted.html">这里</a>读取到更多的zookeeper集群。在这个简单的例子中，我们仅简单的使用了集成的zookeeper。</p>
<p>首先，停止四个服务，并清空zookeeper中的数据作为一个新的开始。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -r example*/solr/zoo_data</span><br></pre></td></tr></table></figure>
<p>我们仍然将服务分别运行在8983,7574,8900,7500端口。默认是在端口号+1000的端口上启动一个zookeeper服务，第一次运行的时候在另外三台服务器上zookeeper的地址分别为：localhost:9983,localhost:8574,localhost:9900。</p>
<p>为了方便通过第一个服务上传solr的配置到zookeeper集群中。在第二个zookeeper服务启动之前程序会阻塞。这是因为zookeeper在工作的时候需要其他服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd example</span><br><span class="line"></span><br><span class="line">java -Dbootstrap_confdir=./solr/collection1/conf -Dcollection.configName=myconf -DzkRun -DzkHost=localhost:9983,localhost:8574,localhost:9900 -DnumShards=2 -jar start.jar</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd example2</span><br><span class="line">java -Djetty.port=7574 -DzkRun -DzkHost=localhost:9983,localhost:8574,localhost:9900 -jar start.jar</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd exampleB</span><br><span class="line">java -Djetty.port=8900 -DzkRun -DzkHost=localhost:9983,localhost:8574,localhost:9900 -jar start.jar</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd example2B</span><br><span class="line">java -Djetty.port=7500 -DzkHost=localhost:9983,localhost:8574,localhost:9900 -jar start.jar</span><br></pre></td></tr></table></figure>
<p>现在我们运行了三个内置的zookeeper服务，如果一个服务挂掉之后其他一切正常。为了证明，在exampleB上按下<code>CTRL+C</code>杀掉服务，然后浏览<code>http://localhost:8983/solr/#/~cloud</code>来核实zookeeper服务仍然可以工作。</p>
<p>需要注意的是，当运行在多个机器上，需要在每一台机器上设置<code>-DzkRun=hostname:port</code>属性。</p>
<h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><p>多个zookeeper服务同时运行来避免错误和高可用性叫做ensemble。从产品角度，推荐运行外部的zookeeper ensemble来代替solr集成的zookeeper。浏览<a href="http://zookeeper.apache.org/">zookeeper官方网站</a>下载和运行一个zookeeper ensemble。可以参考<a href="http://zookeeper.apache.org/doc/r3.3.4/zookeeperStarted.html">Getting Started</a>和<a href="http://zookeeper.apache.org/doc/r3.3.4/zookeeperAdmin.html">ZooKeeper Admin</a>。非常简单就可以运行。可以坚持使用solr来运行zookeeper集群，但是必须知道zookeeper集群不是非常容易动态改变的。除非solr增加对zookeeper更好的支持，重新开始是最好的改变方式。zookeeper和solr是两个不同的进程是最好的方式。</p>
<p>当solr运行内置的zookeeper服务时，默认会使用solr服务的端口号加上1000作为zookeeper的客户端端口号。另外，默认会增加一个zookeeper的客户端端口号和两个zookeeper的选举端口号。所以在第一个例子中，solr运行在8983端口，内置的zookeeper服务运行在9983端口作为客户端端口，9984和9985作为服务端端口。</p>
<p>当增加了更多zookeeper节点可以提高读性能，但是会稍微降低写性能。当集群状态稳定的时候，Solr用的Zookeeper非常少。下面有一些优化zookeeper的建议：</p>
<ol>
<li>最好的情况是zookeeper有一个专用的机器。zookeeper是一个准时的服务，专用的机器可以确保及时响应。当然专用的机器不是必须的。</li>
<li>当把事务日志和snap-shots放到不同的磁盘上可以提高性能。</li>
<li>假如zookeeper和solr运行在同一台机器上，利用不同的磁盘可以提高性能。</li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://wiki.apache.org/solr/SolrCloud">https://wiki.apache.org/solr/SolrCloud</a></p>
]]></content>
      <tags>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh协议</title>
    <url>/post/ssh/</url>
    <content><![CDATA[<h2 id="ssh命令常用参数"><a href="#ssh命令常用参数" class="headerlink" title="ssh命令常用参数"></a>ssh命令常用参数</h2><p>指定私钥连接：<code>ssh -i ~/.ssh/id_rsa ido@192.168.1.111 -p 7744</code></p>
<h2 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h2><p>用来两台主机之间的ssh免密操作，步骤比较简单，主要实现如下两个操作：</p>
<ol>
<li>生成公钥和私钥</li>
<li>将公钥copy到要免密登录的服务器</li>
</ol>
<h3 id="生成公钥和私钥"><a href="#生成公钥和私钥" class="headerlink" title="生成公钥和私钥"></a>生成公钥和私钥</h3><p>执行 <code>ssh-keygen -b 4096 -t rsa</code> 即可在 ~&#x2F;.ssh&#x2F;目录下生成两个文件id_rsa和id_rsa.pub，其中id_rsa为私钥文件，id_rsa.pub为公钥文件。</p>
<h3 id="将公钥copy到要免密登录的服务器"><a href="#将公钥copy到要免密登录的服务器" class="headerlink" title="将公钥copy到要免密登录的服务器"></a>将公钥copy到要免密登录的服务器</h3><p>执行 <code>ssh-copy-id $user@$ip</code> 即可将本地的公钥文件放到放到要免密登录服务器的 $HOME&#x2F;.ssh&#x2F;authorized_keys 文件中。至此，免密登录的配置就完成了。</p>
<h2 id="ssh隧道"><a href="#ssh隧道" class="headerlink" title="ssh隧道"></a>ssh隧道</h2><p>动态端口转发：执行 <code>ssh root@xxxx -ND 127.0.0.1:1080</code> 即可在本机的1080端口开启一个ssh隧道。</p>
<h2 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h2><p>rsync的常用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rsync -avzP --delete $local_idr  $user@$remote:$remote_dir</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的tap/tun设备</title>
    <url>/post/tap-tun/</url>
    <content><![CDATA[<h1 id="Linux虚拟网络设备tap-x2F-tun"><a href="#Linux虚拟网络设备tap-x2F-tun" class="headerlink" title="Linux虚拟网络设备tap&#x2F;tun"></a>Linux虚拟网络设备tap&#x2F;tun</h1><p>tap&#x2F;tun常用于隧道通讯，通过一个字符设备来实现用户态和内核态的通讯，字符设备一端连接着用户空间，一端连接着内核空间。</p>
<p>与物理网卡的最大不同是，tap&#x2F;tun的数据源来自于用户态的程序，而物理网卡的数据源来自于物理链路。</p>
<p>对应的字符设备文件位置：</p>
<ul>
<li>tap: &#x2F;dev&#x2F;tap0</li>
<li>tun: &#x2F;dev&#x2F;net&#x2F;tun</li>
</ul>
<p>当应用程序打开字符设备文件时，驱动程序会创建并注册相应的虚拟设备接口，以tunX或tapX命名。应用程序关闭设备文件时，驱动程序会删除tunX和tapX网络虚拟设备，并删除建立起来的路由信息。</p>
<p>两个设备的不同点：</p>
<ul>
<li>tap是一个二层网络设备，只能处理二层的以太网帧，可以与物理网卡做桥接</li>
<li>tun是一个点对点的三层网络设备，只能处理处理三层的IP数据包，无法与物理网卡做桥接，可以通过三层交换方式与物理网卡连通。Linux下的隧道协议基于该tun设备实现，如ipip、gre。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                ┌──────────────┐</span><br><span class="line">                │              │</span><br><span class="line">                │     APP      │</span><br><span class="line">                │              │</span><br><span class="line">                └───────┬──────┘</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">           ┌────────────▼──────────┐</span><br><span class="line">           │                       │</span><br><span class="line">─ ─ ─ ─ ─ ─│     /dev/net/tun      ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br><span class="line">           │                       │</span><br><span class="line">           └────────────┬──────────┘</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                ┌───────▼──────┐                 ┌──────────────┐</span><br><span class="line">                │              │                 │              │</span><br><span class="line">                │     tunX     ├────────────────▶│Network Stack │</span><br><span class="line">                │              │                 │              │</span><br><span class="line">                └──────────────┘                 └──────────────┘</span><br></pre></td></tr></table></figure>



<h2 id="tun设备应用举例"><a href="#tun设备应用举例" class="headerlink" title="tun设备应用举例"></a>tun设备应用举例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          ┌──────────────┐         ┌──────────────┐</span><br><span class="line">          │              │         │              │</span><br><span class="line">          │    APP A     │         │    APP B     │◀┐</span><br><span class="line">          │              │         │              │ │</span><br><span class="line">          └───────┬──────┘         └───────┬──────┘ │</span><br><span class="line">                  │                        │        │</span><br><span class="line">                  │                        │        │</span><br><span class="line">                 1│                        │        │</span><br><span class="line">                  │                       5│        │</span><br><span class="line">                  │                        │        │</span><br><span class="line">  ─ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│─ ─ ─ ─ ┼ ─ ─ ─ ─ ─</span><br><span class="line">                  │                        │        │</span><br><span class="line">                  │                        │       4│</span><br><span class="line">                  │                        │        │</span><br><span class="line">     ┌────────────▼────────────────────────▼─────┐  │</span><br><span class="line">     │                                           │  │</span><br><span class="line">     │               Network Stack               │  │</span><br><span class="line">     │                                           │  │</span><br><span class="line">     └────────────┬───────────────────────┬──────┘  │</span><br><span class="line">                  │                       │         │</span><br><span class="line">                 6│                      3│         │</span><br><span class="line">                  │                       │         │</span><br><span class="line">          ┌───────▼──────┐              ┌─▼─────────┴──┐</span><br><span class="line">          │              │              │              │</span><br><span class="line">10.1.1.11 │     eth0     │              │     tun0     │ 192.168.1.11</span><br><span class="line">          │              │              │              │</span><br><span class="line">          └───────┬──────┘              └──────────────┘</span><br><span class="line">                  │</span><br><span class="line">                 7│</span><br><span class="line">                  │</span><br><span class="line">                  ▼</span><br><span class="line"></span><br><span class="line">             10.1.1.100 / 192.168.1.100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>应用程序A要发送数据到其他物理机192.168.1.100，由于物理网络环境下只有10.1.1.11和10.1.1.100是相互连通的，192.168.1.11和192.168.1.100是不通的，为了192.168.1.11和192.168.1.100能够进行通讯，需要将数据包进行一次封装。</p>
<p>应用程序B是通过打开字符设备文件&#x2F;dev&#x2F;net&#x2F;tun0的方式来打开网络设备</p>
<p>流程如下：</p>
<ol>
<li>A构造数据包，目的ip为192.168.1.100，并发送给协议栈</li>
<li>协议栈根据数据包中的ip地址，匹配路由规则，要从tun0出去</li>
<li>内核协议栈将数据包发送给tun0网络设备</li>
<li>tun0发送应用程序B打开，于是将数据发送给应用程序B</li>
<li>B收到数据包后，在用户态构造一个新的数据包，源IP为eth0的IP 10.1.1.11，目的IP为配置的对端10.1.1.100，并封装原来的数据包</li>
<li>协议栈根据当前数据包的IP地址选择路由，将数据包发送给eth0</li>
</ol>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://www.cnblogs.com/bakari/p/10450711.html">详解云计算网络底层技术——虚拟网络设备 tap&#x2F;tun 原理解析</a></li>
<li><a href="https://www.cnblogs.com/bakari/p/10449664.html">Linux 网络工具详解之 ip tuntap 和 tunctl 创建 tap&#x2F;tun 设备</a></li>
<li><a href="https://segmentfault.com/a/1190000009249039">Linux虚拟网络设备之tun&#x2F;tap</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>TCP Fast Open</title>
    <url>/post/tcp-fast-open/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/tcp_fast_open.webp"></p>
<p>TCP Fast Open（TFO）是一种TCP协议的扩展，旨在加快建立TCP连接的速度和降低延迟。传统的TCP连接需要进行三次握手（SYN-SYN&#x2F;ACK-ACK）才能建立连接，而TFO允许在第一个数据包中携带连接建立的请求。</p>
<p>TFO的工作原理如下：</p>
<ol>
<li>客户端在首次建立TCP连接时，在发送的SYN包中插入一个加密的Cookie。这个Cookie由服务器生成并发送给客户端。</li>
<li>当客户端发送带有TFO Cookie的SYN包到服务器时，服务器会验证Cookie的有效性。</li>
<li>如果Cookie有效，服务器会立即发送带有SYN+ACK标志的数据包，这样客户端就可以立即发送数据而无需等待ACK响应。</li>
<li>客户端收到带有SYN+ACK标志的数据包后，发送带有ACK标志的数据包，建立完整的TCP连接。</li>
</ol>
<h1 id="相关内核参数"><a href="#相关内核参数" class="headerlink" title="相关内核参数"></a>相关内核参数</h1><h2 id="net-ipv4-tcp-fastopen"><a href="#net-ipv4-tcp-fastopen" class="headerlink" title="net.ipv4.tcp_fastopen"></a><code>net.ipv4.tcp_fastopen</code></h2><p>支持如下值：</p>
<ul>
<li>0：关闭</li>
<li>1: 作为客户端可以使用 TFO 功能</li>
<li>2: 作为服务端可以使用 TFO 功能</li>
<li>3: 作为客户端和服务端均可使用 TFO</li>
</ul>
<h2 id="net-ipv4-tcp-fastopen-key"><a href="#net-ipv4-tcp-fastopen-key" class="headerlink" title="net.ipv4.tcp_fastopen_key"></a><code>net.ipv4.tcp_fastopen_key</code></h2><p>用来产生 TFO 的 Cookie。</p>
]]></content>
  </entry>
  <entry>
    <title>tekton（个人笔记）</title>
    <url>/post/tekton/</url>
    <content><![CDATA[<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>从<a href="https://github.com/tektoncd/cli/releases">https://github.com/tektoncd/cli/releases</a>下载tkn工具，该工具为tekton的命令行工具。</p>
<p>执行如下命令安装dashboard</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">apply</span> <span class="string">--filename</span> <span class="string">https://github.com/tektoncd/dashboard/releases/latest/download/tekton-dashboard-release.yaml</span></span><br></pre></td></tr></table></figure>
<p>dashboard安装完成后仅申请了ClusterIP类型的Service，可以在本地通过kubectl端口转发的方式来对外提供服务，既可以通过ip:9097的方式来对外提供服务了。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl <span class="literal">--namespace</span> tekton<span class="literal">-pipelines</span> port<span class="literal">-forward</span> svc/tekton<span class="literal">-dashboard</span> <span class="number">9097</span>:<span class="number">9097</span> <span class="literal">--address</span> <span class="number">0.0</span>.<span class="number">0.0</span> </span><br></pre></td></tr></table></figure>
<p>执行如下命令，在k8s中提交yaml</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl apply <span class="literal">--filename</span> \ https://storage.googleapis.com/tekton<span class="literal">-releases</span>/pipeline/latest/release.yaml</span><br></pre></td></tr></table></figure>
<p>会在k8s中提交如下两个deployment，此时tekton即安装完毕。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> kubectl  get deploy <span class="literal">-n</span> tekton<span class="literal">-pipelines</span> </span><br><span class="line">NAME                          READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">tekton<span class="literal">-pipelines-controller</span>   <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">4</span>m</span><br><span class="line">tekton<span class="literal">-pipelines-webhook</span>      <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">4</span>m</span><br></pre></td></tr></table></figure>
<h2 id="创建task"><a href="#创建task" class="headerlink" title="创建task"></a>创建task</h2><p>创建如下yaml，提交一个任务定义，提交完成后任务并不会被执行</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: tekton.dev/v1beta1</span><br><span class="line">kind: Task</span><br><span class="line">metadata:</span><br><span class="line">  name: hello</span><br><span class="line">spec:</span><br><span class="line">  steps:</span><br><span class="line">    - name: <span class="built_in">echo</span></span><br><span class="line">      image: alpine</span><br><span class="line">      script: |</span><br><span class="line">        <span class="comment">#!/bin/sh</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span>  </span><br></pre></td></tr></table></figure>
<p>继续提交如下的yaml，提交一次任务运行实例</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: tekton.dev/v1beta1</span><br><span class="line">kind: TaskRun</span><br><span class="line">metadata:</span><br><span class="line">  name: hello<span class="literal">-task-run</span></span><br><span class="line">spec:</span><br><span class="line">  taskRef:</span><br><span class="line">    name: hello</span><br></pre></td></tr></table></figure>
<p>查看任务执行情况</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> kubectl get taskrun hello<span class="literal">-task-run</span></span><br><span class="line">NAME             SUCCEEDED   REASON      STARTTIME   COMPLETIONTIME</span><br><span class="line">hello<span class="literal">-task-run</span>   True        Succeeded   <span class="number">45</span>s         <span class="number">22</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到创建出了任务执行的pod</span></span><br><span class="line"><span class="variable">$</span> kubectl  get pod </span><br><span class="line">NAME                 READY   STATUS      RESTARTS   AGE</span><br><span class="line">hello<span class="literal">-task-run-pod</span>   <span class="number">0</span>/<span class="number">1</span>     Completed   <span class="number">0</span>          <span class="number">2</span>m10s</span><br></pre></td></tr></table></figure>
<h2 id="创建流水线任务pipeline"><a href="#创建流水线任务pipeline" class="headerlink" title="创建流水线任务pipeline"></a>创建流水线任务pipeline</h2><p>创建新的task goodye</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">tekton.dev/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Task</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">goodbye</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">goodbye</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line">      <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        #!/bin/bash</span></span><br><span class="line"><span class="string">        echo &quot;Goodbye World!&quot;</span></span><br></pre></td></tr></table></figure>
<p>提交如下yaml，创建pipeline定义</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: tekton.dev/v1beta1</span><br><span class="line">kind: Pipeline</span><br><span class="line">metadata:</span><br><span class="line">  name: hello<span class="literal">-goodbye</span></span><br><span class="line">spec:</span><br><span class="line">  tasks:</span><br><span class="line">    - name: hello</span><br><span class="line">      taskRef:</span><br><span class="line">        name: hello</span><br><span class="line">    - name: goodbye</span><br><span class="line">      runAfter:</span><br><span class="line">        - hello</span><br><span class="line">      taskRef:</span><br><span class="line">        name: goodbye</span><br></pre></td></tr></table></figure>
<p>提交如下yaml，创建pipeline实例。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: tekton.dev/v1beta1</span><br><span class="line">kind: PipelineRun</span><br><span class="line">metadata:</span><br><span class="line">  name: hello<span class="literal">-goodbye-run</span></span><br><span class="line">spec:</span><br><span class="line">  pipelineRef:</span><br><span class="line">    name: hello<span class="literal">-goodbye</span></span><br></pre></td></tr></table></figure>
<p>可以使用tkn来查看pipeline拉起的pod日志，该工具会将pod的日志合并到一起。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">tkn</span> <span class="string">pipelinerun</span> <span class="string">logs</span> <span class="string">hello-goodbye-run</span> <span class="string">-f</span> <span class="string">-n</span> <span class="string">default</span></span><br><span class="line">[<span class="attr">hello :</span> <span class="string">echo</span>] <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"></span><br><span class="line">[<span class="attr">goodbye :</span> <span class="string">goodbye</span>] <span class="string">Goodbye</span> <span class="string">World!</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>地球家园</title>
    <url>/post/the_earth/</url>
    <content><![CDATA[<p><img src="/ref/life/the_earth.jpg" alt="Image Title"></p>
<p>这段时间，中国大部分的地区都是高温不降，有些地区甚至出现了鸡蛋自然孵化的现象。媒体报道高温热死人的现象也是时有发生，虽说媒体的话不可信，但至少从一个侧面反映了天气的确是较往年同期高出一些，开始渐渐超出人类身体可以承受的温度，开始悄悄的打破往年同期的高温纪录。</p>
<p>最近几年气候变化无常，跟人类的活动绝对脱不了干系。冬天雾霾可以持续一周不散，春天一个月干旱，夏季雨天可以持续一个月不变，秋季如蝉的生命般短暂。在北方已经生活了二十多年的我，这些现象在小时候是极少碰到的，现在却是极其频繁。记得小时候雨天过后时常会在天边挂上一道弯弯的彩虹，记得最后一次见彩虹是在小学一二年纪的时候，自此之后彩虹仅存在了我的脑海里。对于现在的大部分中国人而言，彩虹仅存在于永恒的记忆中和孩子们的画中。</p>
<p>人类近几百年来正在肆无忌惮的向地球母亲索要不该属于人类自己的东西，人类已经占有了迄今为止地球上对人类有价值的且可以占有的所有资源，人类仍然在忘形的开发并破坏着地球上生物赖以生存的家园。</p>
<p>拿中国的三峡大坝举例，从能源的角度考虑的确是有利的。但是从地球生态的角度考虑肯定是有害的。人类的存在时间相对地球是短暂的，地球每一处地形存在就有它存在的理由，已经经过了无数年的实践验证说明地形存在的正确性。可恶的中国ZF，可恨的脑残砖家居然能够利用理论来论证修建三峡的必要及正确性，TMD没学过实践是检验真理的唯一标准。在没有对地球有充足的了解之前不要利用有限的理论来推断并指导实践，因为往往实践之后就再也回不了头，就比如三峡大坝。谁敢说近几年的西南大旱、特大地震跟三峡拖得了干系，可以灾难发生了又有哪个砖家可以站出来声称我可以对这个灾难负责呢？</p>
<p>我从小就一直在担忧一个问题如果再过几十年后几百年后地球上的煤炭、石油等不可再生资源被人类用过了人类该何去何从，我时长为此而忧虑不已。也许这有点杞人忧天，肯定有人会站出来说到那时候随着人类科技的发展早就发现了新能源了，这是谁给的自信？谁这么大胆敢预言人类几十年后一定可以发现新能源？何况不可再生资源中蕴藏着的价值肯定不仅是燃烧带来的能量这点价值，假如几十年后人类已经将石油资源消耗殆尽了，却发现石油中蕴藏着巨大的能量，估计那时候我们只有哭的份了，楚人一炬，可怜焦土。</p>
<p>人类不过是地球上几百万种生物中的一种，如果硬要从广义公平的角度来考虑，人类在生物界占有的太多了，人类已经把该占有的不该占有的全部占为己有，贪婪的本性暴露无遗。很难想象几十年过后我们人类的家园已经成为了什么样子，四处可见的是拔地而起的高楼，柏油路横一条竖一条，无论在地球的哪个角落都能找到人类留下的痕迹。地球该随着人类的发展何去何从，我不敢想象，我能做到的仅仅是节约点力所能及的资源，仅此而已。</p>
]]></content>
  </entry>
  <entry>
    <title>12要素应用</title>
    <url>/post/12-factors-app/</url>
    <content><![CDATA[<p>2012 年，Heroku 创始人 Adam Wiggins 发布十二要素应用宣言，又被称为微服务十二要素。</p>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><h3 id="基准代码"><a href="#基准代码" class="headerlink" title="基准代码"></a>基准代码</h3><ol>
<li>一个应用一个代码仓库，不要出现一个代码仓库对应多个应用的情况</li>
<li>如果多个应用共享一份代码，那么需要将该代码拆分为独立的类库</li>
</ol>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>规范：</p>
<ol>
<li>应用必须通过配置显式声明出所有的依赖项，即使依赖的工具在所有的操作系统上都存在。比如 python 可以使用 pip 的 requirements.txt 文件声明出所有的依赖包及其版本信息。</li>
<li>在运行时需要通过隔离手段确保应用不会调用未显式声明的依赖项。比如 python 应用可以通过virtualenv 技术来确保隔离性。</li>
</ol>
<p>优点：</p>
<ol>
<li>简化开发者的环境配置，通过构建命令即可安装所有的依赖项。</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>规范：</p>
<ol>
<li>代码和配置单独管理，不要将配置放到代码仓库中管理。</li>
<li>配置传递给应用的方式之一为配置文件，另外一种为环境变量。</li>
</ol>
<h3 id="后端服务"><a href="#后端服务" class="headerlink" title="后端服务"></a>后端服务</h3><p>规范：</p>
<ol>
<li>后端服务分为本地服务和第三方服务，对应用而言都是后端服务，不应该区别对待。</li>
</ol>
<h3 id="构建、发布和运行"><a href="#构建、发布和运行" class="headerlink" title="构建、发布和运行"></a>构建、发布和运行</h3><p>规范：</p>
<ol>
<li>严格区分从代码到部署的三个阶段：构建编译打包代码；将构建结果和部署需要的配置放到环境中；指定发布版本，在环境中启动应用。</li>
<li>每个发布版本必须对应一个唯一的 id 标识。</li>
</ol>
<p>反模式：</p>
<ol>
<li>不可以直接修改环境中的代码，可能会导致非常难同步会构建步骤。</li>
</ol>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>规范：</p>
<ol>
<li>应用的进程需要持久化的数据一定要保存到后端服务中，保持应用进程的无状态。</li>
<li>本地的内存和磁盘可以作为应用的缓存数据。</li>
<li>反对使用基于 session 的粘滞技术（某一个用户的请求通过一致性 hash 等技术请求到同一个后端服务，而后端服务将用户数据缓存在内存中），推荐将用户数据缓存到Redis 等分布式缓存中。很多互联网公司都会采用 session 粘滞技术，都违背了这一原则。</li>
</ol>
<h3 id="端口绑定"><a href="#端口绑定" class="headerlink" title="端口绑定"></a>端口绑定</h3><p>要求应用自己通过监听端口的方式来对外提供服务。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>规范：</p>
<ol>
<li>允许通过多进程或者多线程的方式来处理高并发</li>
<li>应用不需要守护进程或者写入 PID 文件，可以借助如 systemd 等工具来实现。</li>
</ol>
<h3 id="易处理"><a href="#易处理" class="headerlink" title="易处理"></a>易处理</h3><p>规范：</p>
<ol>
<li>进程启动速度尽可能快，以便于更好的支持弹性伸缩、部署应用。</li>
<li>进程在接收到SIGTERM 信号后需要优雅停止。比如对于 nginx 而言，要等到处理完所有的连接后才可以退出。</li>
<li>进程要能够处理各种异常情况。</li>
</ol>
<h3 id="开发环境与生产环境等价"><a href="#开发环境与生产环境等价" class="headerlink" title="开发环境与生产环境等价"></a>开发环境与生产环境等价</h3><p>核心就只有一点，尽可能保证开发环境与生产环境的一致性。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>规范：</p>
<ol>
<li>应用程序将日志直接输出到标准输出，标准输出的内容由日志收集程序消费。</li>
</ol>
<p>反模式：</p>
<ol>
<li>现实中应用程序将日志直接写到了日志文件，并且自己来管理日志文件。</li>
</ol>
<h3 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h3><p>规范：</p>
<ol>
<li>仅需要执行一次的进程，跟普通的进程一样的管理思路，比如版本、执行环境等。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://12factor.net/zh_cn/">12要素应用</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>2013年总结</title>
    <url>/post/2013_summary/</url>
    <content><![CDATA[<p>2013年在不经意间过去了，总结起来收获还是不小的。我的大部分业余时间用在了学习上，看书看书再看书。每个周五或周六晚上会玩上一晚上dota以放松，周末会抽一天时间出去散散心。</p>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>学习上进步还算比较大，学习方式以看书为主，尤其是对Linux有了较深入了解。在年初的时候制定了深入学习Linux的计划，包括Linux内核，大约从五月下旬开始学习。</p>
<h2 id="信息系统项目管理师"><a href="#信息系统项目管理师" class="headerlink" title="信息系统项目管理师"></a>信息系统项目管理师</h2><p>当时抱着该考试可以挂靠的心态来学习PM，从春节后开始学习，五月末考试，大约花了三个月时间。学习思路为从淘宝上买的YY讲课的培训视频，价格还算便宜，隔一天晚上上一课，一次讲课时间在一个半小时左右。听了几次课之后就发现老师废话挺多，但是如果自己看书复习又抓不住重点，因此还是硬着头皮听老师讲课，就当作休息了。参考图书共三本，加起来足够2000页的样子，还做了历年的部分真题。由于自己手懒，写作在考试之前没有写过一篇，只是在考试之前背了两篇范文，结果考试的时候写作没有压中，离分数线差了两分。</p>
<p>下半年考试没有报名，经过了一次考试后看清了PM的真面目，纯属搞理论，距离实际太远。如果为了挂靠去花费宝贵的业余时间来学习实在有点不得不偿失。现在回想起来多少有些后悔，但是不尝试怎么能知道PM到底是个啥东西呢。</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>Linux的系统知识今年进步挺大的，无论是在编码、对系统的理解还是内核方面都有非常大的进步。</p>
<h3 id="《鸟哥的Linux私房菜–基础学习篇》"><a href="#《鸟哥的Linux私房菜–基础学习篇》" class="headerlink" title="《鸟哥的Linux私房菜–基础学习篇》"></a>《鸟哥的Linux私房菜–基础学习篇》</h3><p>两年多前看过一次，利用工作中的空闲时间重新回顾了一边，收获还是挺大的。</p>
<h3 id="《鸟哥的Linux私房菜–服务器架设篇》"><a href="#《鸟哥的Linux私房菜–服务器架设篇》" class="headerlink" title="《鸟哥的Linux私房菜–服务器架设篇》"></a>《鸟哥的Linux私房菜–服务器架设篇》</h3><p>两年前买的书，当时没有通读，感觉含金量跟基础学习篇太大。利用工作之余通读一遍，收获也还算可以。</p>
<h3 id="《Unix环境高级编程》"><a href="#《Unix环境高级编程》" class="headerlink" title="《Unix环境高级编程》"></a>《Unix环境高级编程》</h3><p>Linux编程圣经，花了接近两个月时间看完，看完后收获很大。</p>
<h3 id="《Unix网络编程》"><a href="#《Unix网络编程》" class="headerlink" title="《Unix网络编程》"></a>《Unix网络编程》</h3><p>Linux网络编程圣经，花了一个月时间看完，看完后对写TCP&#x2F;IP通信的程序很有帮助，作为《Unix环境高级编程》的很好补充。</p>
<h3 id="《Linux内核完全剖析》"><a href="#《Linux内核完全剖析》" class="headerlink" title="《Linux内核完全剖析》"></a>《Linux内核完全剖析》</h3><p>该书花了我接近半年的时间来学习，现在看完了五分之四左右，还有文件系统章节没有学习。学习下来收获很大，后续会结合《Linux内核图解》一书来补充学习和归纳。</p>
<h3 id="《程序员的自我修养》"><a href="#《程序员的自我修养》" class="headerlink" title="《程序员的自我修养》"></a>《程序员的自我修养》</h3><p>通过学习对Linux的elf和windows的pe结构都有了较深入的了解，不过事隔半年之后已经全部忘记了，需要再温习一遍。</p>
<h2 id="微信公共帐号"><a href="#微信公共帐号" class="headerlink" title="微信公共帐号"></a>微信公共帐号</h2><p>从年初开始，每天会花一定时间来阅读微信公共帐号的文章，初期订阅的文章基本都会阅读，后期订阅量大了有些就仅浏览标题了。我订阅的公共帐号里比较好的有：鬼脚七、道哥的黑板报、小道消息、Mac Talk等。鬼脚七写人生类的文章我比较喜欢看，也比较赞同作者的观点。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>###《30天自制操作系统》<br>从2012年年底开始读的图书，花了接近三个月的时间通读，读到中间部分还反过头来重读一遍。学习到三分之二的时候感觉对我用处不大，因为不会对我理解Linux或Windows操作系统有太大帮助，放弃之。</p>
<h3 id="《Hadoop权威指南》"><a href="#《Hadoop权威指南》" class="headerlink" title="《Hadoop权威指南》"></a>《Hadoop权威指南》</h3><p>项目需要，对Hadoop没有足够的兴趣，理解了是怎么回事对我就足够了。同时还研究了Solr、HBase、MonogoDB等大数据软件。</p>
<h3 id="《Git权威指南》"><a href="#《Git权威指南》" class="headerlink" title="《Git权威指南》"></a>《Git权威指南》</h3><p>向对Git有进一步的理解，目前仅看完了一半，分支管理部分还没有学习。</p>
<p>###《浪潮之巅》<br>吴军博士的经典，我主要拿来在看书看累的时候消遣用，和《黑客与画家》的效果相当，很抱歉看了大半年了到现在仍然在看。</p>
<h3 id="《深度探索C-对象模型》"><a href="#《深度探索C-对象模型》" class="headerlink" title="《深度探索C++对象模型》"></a>《深度探索C++对象模型》</h3><p>之前曾一度要学习，无奈一直没有看进去，lippman写的和侯捷翻译的实在是诡异。这次边写博客记录边看，居然效果很不错。最后时间有限，留了个小尾巴没有看完。</p>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>由于之前的公司经营不善，加上今年全国经济形式不好，公司持续几个月发不下工资来，考虑到个人经济状况换了一份工作。在济南这种小地方，找个理想的工作实在是不容易，甚至今年很多公司都不再招聘。我找工作以技术为导向，家附近一堆做电信BOSS的外包公司，一概不考虑。新工作还算可以，依旧加班较少，只是周六是间歇性上班，这个可以忍，还算有较充足的业余时间来学习。</p>
<p>工作中用到的技术以C、C++为主，兼涉及到Android、PHP等。从元旦之后上班第一天，自己单打独斗从零开始做了一个短信管家类项目，到五月份后终止，结果跟我预想的完全一致，以失败而告终。回想当初真该将我当时对项目的看法跟领导沟通一下，而不是盲目的接下公司安排的任务。当时领导对互联网、APP的理解完全是幼稚园水平，一家传统行业的软件企业想来玩转互联网行业困难可想而知，我作为唯一的项目成员在项目的开始已经看到了没有任何意外的结局。如果当初将这五个多月的时间用来做些Linux的东西，对我个人的成长将是相当巨大的。</p>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>2013经济上不是很宽裕，没有旅游，仅有的一次市外旅游是南部山区的红叶谷。在济南这种地方，工资压得低，技术牛人又少，实在悲剧。生活虽然对我少了些许精彩，但过的还算比较充实。</p>
<h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p>为了能够更好的总结学习经验，年初准备有写博客的计划。之前零零散散的也写过一些，没有坚持住，现在看来我的博客写作计划坚持的还算不错，从6月份到年底共写了40篇博客，大都是自己的学习经验总结。前期博客写了一些非技术类博文，后期觉得没有这个必要不再写非技术类博客。</p>
<p>为了搭建博客，又不想花钱买个不稳定的空间。我研究了Github上的jekyll、基于网盘（DropBox、Google Driver）的Farbox等搭建博客技术，参照了大量的jekyll主题，几乎将jekyll wiki上列出的主题都看了一个遍，也没有发现一个令我非常满意的主题，后挑选一个主题在Github上实验，不知是我markdown语法写的问题还是Github对markdown的解析问题，解析效果不够理想，但是我写的markdown在Farbox上却没有问题。最后采用了Farbox作为博客平台，并对Farbox的默认主题进行了少量修改。并从Godaddy上购买了kuring.me域名。</p>
<h1 id="2014年计划"><a href="#2014年计划" class="headerlink" title="2014年计划"></a>2014年计划</h1><p>2014，除了工作之外，我也业余时间仍然会大部分奉献给阅读书籍，以Linux内核方向为主。趁着年轻，多读些书，永远是正确的。</p>
]]></content>
  </entry>
  <entry>
    <title>2014年总结</title>
    <url>/post/2014_summary/</url>
    <content><![CDATA[<p>我的年总结是依照农历的，因为在我心中春节才算是一年的真正开始，因为只有春节的时候才能找到年的滋味，年的感觉，才能称之为年，阳历的年只能称之为year。</p>
<p>2014年又在不经意间过去了，很多地方跟2013年一样是平淡，工作和学习仍然是生活的主旋律，闲暇时间抽个时间玩玩dota放松一下，周末偶尔爬个小山锻炼下身体，对我的人生中算是比较重要的一年。</p>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>2014年经历了结婚、毕业答辩和考驾照几件占用时间的事情，留给我业余时间用来学习的就少之又少了。结婚占用两个月时间，毕业论文占用了我两个月时间，考驾照占用了多个周末，工作出差占用了我一个月时间，留给我能够独立学习的晚上也就6个月时间。</p>
<p>开始的时候小看了硕士论文，以为很简单一事情，搞过这么多软件项目还搞不了一篇硕士论文。一直以来我看不起软件工程类论文，就一项目套个模板一介绍就是一篇论文，于是我选择了写一篇理论研究类论文，没有高大上的理论，而是在公司实践中真正用到的，《将Windows平台的C&#x2F;C++程序向Linux平台移植的技术研究》，选择论文的时候我已经看到了该题目不太适合作为硕士论文，当我还是毅然作为了我的硕士论文题目，不得不说这是我今年的一大败笔。第一篇论文失败后，我重新走起了保守路线，以之前熟悉的系统为主线，辅以各种文档的拼凑，完成了一篇我曾经嗤之以项目类硕士论文，并顺利通过答辩。对于我这样的新手而言，写论文是一件漫长又痛苦的过程，占用了我大量的宝贵时间。</p>
<p>一直以来对嵌入式linux方向比较好奇，今年终于抵不住好奇，买了个2140开发板自己捣鼓了一段时间，由于时间关系虽然到现在也没有入门，多多少少对嵌入式已经有所了解。</p>
<p>感谢我的另一半，给我提供了足够的时间来干我想干的事情。</p>
<h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><p>比起2013年，今年读过的书籍少了一些。</p>
<ul>
<li>《Linux&#x2F;Unix系统编程手册》</li>
<li>《编程珠玑》</li>
<li>《LINUX设备驱动程序》（部分章节）</li>
<li>《LINUX内核设计与实现》（大部分章节）</li>
<li>《深度探索linux操作系统》</li>
<li>《剑指Office》</li>
<li>《大规模C++程序设计》</li>
<li>《程序员的自我修养》（第二遍）</li>
<li>《文明之光》</li>
<li>《程序员健康指南》</li>
<li>《黄金时代》</li>
<li>《一只特立独行的猪》</li>
<li>《算法导论》（部分章节）</li>
</ul>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>已经比较熟练掌握了公司产品的大部分技术，工作起来算是得心应手，但是却少了许多挑战，是时候该接收大挑战的了。工作的职位从后台组长到研发部副经理到研发部经理，开始了工作的转型，这是我不期望这么早来到的，我自认为技术的成长空间还很大，不想过早的接触管理岗位。</p>
<p>五月份的出差成为了我心中抹不去的痛，莫名其妙接受了任务，匆忙出差，不过坑才刚刚开始。要维护的是一个我没见过界面的产品，不过基本原理我是清楚的。产品有很多bug，这我可以理解，要不然也不会让我出差了，但要命的是我没有产品的代码，我接受的任务仅是去应付客户、发现bug后反馈、更新产品、施工，这明白着是市场+测试+维护的话，跟我半毛钱关系都没有。以上这些都无所谓，要知道我可不是一个顽固不化的程序员，但工作地点竟然是机房，而且机房是我见过最脏最乱的机房，我就站在一排机柜的后面的一堆烂纸箱子上吹着空调的冷风和机器的热风办公，时而蹲着，时而站着，时而坐着，时而将衣领撩起保暖，时而浑身打颤，以至于到现在我留下了膝盖隐隐作痛的毛病。而且系统bug不断，一连在不吃晚饭的情况下加班到大半夜好多次，而我竟然坚持下来了。原本三五天的出差计划，一待就是二十多天。这短短的二十多天成为了我今年最难忘的痛，多少次期望回到家里温暖的被窝，多少次期望在家吃着我做的炖土豆。</p>
<p>今年面试了不少人，通过面试也发现大部分技术人员的水平太差了，我甚至都搞不明白他们是怎么厚着脸皮来面试技术岗位的。济南软件行业实在是不景气，甚至找一个靠谱点的web或者php程序员都成为了公司的一大难题。</p>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>长达五年的恋情在今年终于得到了升华，当然这升华是我不愿意这么快就看到的，多么希望能迟来几年，给原本一直以为自己还是个孩子的我一个接受的缓冲区，但站在两家人面前，我的想法竟然不能主导我。我对结婚这件事情持怎么简单怎么办的态度，结婚本就一仪式，豪华也罢，没有也罢，都是过眼云烟，为一天忙碌了一阵子仅为了那一天，而之后又有谁记得。结婚之所以在中国的古代非常重视，那是因为在农业社会中人民的娱乐方式非常单一，结婚可以成为人民心中的一个盼头和没有灯光的饭后侃的资本，现在娱乐方式早已多元化，相比之下结婚的光鲜早已显得微不足道。可结婚毕竟不是我一个人的事，甚至不是两个人的事，而是两家人的事。</p>
<p>结婚定在酷夏，定下来的时间比较匆忙，从定下来要结婚到结婚仅一个月时间，对我来说是莫大的好事，因为拖得时间越长占用的准备时间就越多。半年的婚前和半年的婚后生活，其实真的没人什么两样，都是美满的二人世界，希望这种状况能持续几年。</p>
<p>我一向对车比较排斥，始终认为汽车是一个比较失败的发明，用户体验特别差。好的设计应该让用户忽略其内部实现细节，好的发明不应该让用户花费大量的时间来学习怎样使用，甚至需要多个课时的专业培训。汽车不仅是一个毫无用户体验的发明，而且危险到极致，危险到一失误就会要掉人的性命。</p>
<p>但今年我随波逐流了，毕竟驾照是早晚要考的，晚考成本只会更高。于是考驾照提上了议程，8月初已经计划报名，只可惜流程过于复杂，到现在也才到了科目二的程度。先是报名需要办暂住证，暂住证一办就是15个工作日，直接拖到了十一之后。找个离家近的驾校报个名，一等就是一个月才考科目一。科目一考完一等又是一个月才开始分车学科目二。科目二刚开始学又开始继续了，一共练了两个工作日后驾校又开始集训了，又没我啥事了。好在我找了个陪练，练了几把就顺手了。</p>
<p>虽然驾照没有考出来，仅考到了科目二，算是完成了驾照的一半，但却耗去了我的部分经历。找驾校、准备科目一、学习科目二、找陪练，这些花费的都是我的时间。要是驾校培训行业能够再成熟些，再人性化些能给多少学车的人带来方便。</p>
<p>玩游戏多少有些过了，虽然每周也就不想学习的两个晚上用来玩游戏，但我深知自己不是玩游戏的料。很多时候为了能够赢一局，会熬夜到下半夜，这是非常不理智的。另外，以后尽量用其他方式来代替游戏放松，当然我深知其中的苦难。</p>
<h1 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h1><p>去过一次云南，都在<a href="http://www.kuring.me/post/yunan_travel">这里</a>了。</p>
<p>清明节时间去过一次天津，天津比我想象的要好很多，各个地方特色比较明显，有别墅区、意大利风情区、现代的商业区等，这之间能够非常明显的区分，不像济南太混杂。不过天津的人却给我留下的印象不是很好，这也是小小的遗憾。</p>
<h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>在我心中已经为2015年制定好了一些计划，为家庭，为自己，2015年会是我人生的一个转折点，期望2015年能够顺利。我会努力的。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>记2015年十一假期的一件小事</title>
    <url>/post/2015_10_01/</url>
    <content><![CDATA[<p>十一回农村老家，有件小事有些感悟。</p>
<p>只要家里有人，家里的大门白天一直都是敞着的，外面的人都可以直接走进来，这在农村是很正常的一件事情，门敞着才说明家里是有人的，农村的人没有城里人这么多的隔阂。</p>
<p>正巧地里的活都干得差不多了，母亲在院子里晒着太阳，我在屋子里收拾东西。从门口走到院里一个人来，只见一身道姑打扮，还带一顶帽子，嘴里振振有辞，说是泰山娘娘庙里的保佑家里平安之类的。母亲见到来者第一反应就是骗子，立马上前说是地里有活要干，马上要出去了。来者压根不理会母亲的话，依旧是保佑平安之类的，像极了大街上迎上前去得乞讨者。来者说道，要捐款之类的，并有个小本子，上面写着捐款者的名字。母亲看了眼捐款者的名单，很多都是邻居家的，说明来者刚从家里过来，迟疑了一会便签上了名字，回屋里去取钱。</p>
<p>这时还在屋子里的我才看到并明白过来是这么一回事，我一看母亲名字都签上了，钱肯定是要给的了，想逃掉避免少不了一番纠结。我便回屋子去取钱，在城市待习惯了，知道乞讨者五毛一块就能打发的很高兴，我便从钱包里去了两张一块的，其中一张还是备用的，我先给一块，要是嫌少再给两块。我先于母亲出了屋子，给到了来者一块钱，岂知来者说道别人都是给三十五十的，这些太少了我不要。靠！这年头乞讨还嫌钱少啊，还是我太out了？我直接说那你走吧，我没钱，并转头回屋子，可最烦的是她也跟着往屋里走。</p>
<p>就在这时母亲从屋子里走出来并拿着10块钱，迎上前去给了她。又是嫌少之类的话，最后也不情愿的收下了，并留下了一根红丝带，说些全家平安之类的话就走了，当然了骗子的目的已经完成了，只需匆匆收场就行了。</p>
<p>此事的经过到此结束，但却有个问题挺令我深思的，这也是为什么写下本文的原因。</p>
<p>父母并不富裕，家里一直也是过得比较平淡的生活，在我看来勤奋和勤俭节约一直是我们老家那块的美德。平常家里买个菜什么的都要为了几毛钱掂量半天，但却在面对乞讨施舍这种事情上扔掉了10块钱的巨款，而且母亲对于骗钱这件事从始至终都是知情的。</p>
<p>事后，我的同样上当受骗的邻居也来到了我家，通过邻居和我母亲的谈话我大体理解了他们在经历此事时的心理活动。由于每年都会有多次来到家里进行骗钱的，骗钱的方式是多种多样的，无非是找不到孩子，回不了家之类的，母亲一开始见到骗子就知道是个骗子，这第一印象的判断是过关的。</p>
<p>母亲对骗子的第二个行为是阻拦，母亲用了要去地里干活的信息来阻拦，但是阻拦不彻底，见阻拦不成功就放弃了。这一点上就显现出了的缺点，不知道用合理的手段来保护自己，并完全从主动状态变为了被动状态。之所以意志这么不坚定，其中有一个很大的因素就是母亲知道强加阻拦的后果就是骗子可能会爆粗口，完全不想听骗子絮絮叨叨个没完没了，撵都撵不走，还不如给点钱省事。另外得罪的骗子的后果可能会更麻烦，毕竟骗子往往都是一个团伙，且知道家庭住址，怕有什么报复行为。所以之所有给钱的原因就是花钱买个安宁，免得带来一身的麻烦，当然从这个出发点上给钱是对的。骗子也正是利用了这一点才在农村屡试不爽。</p>
<p>但给钱的数目跟平时的生活水平是完全不相符的，要知道在农村买上10块钱的菜可以吃上好几顿。我觉得之所以出现这个问题，根源在于对自己的不够重视。在中国这种权力的社会中，母亲一直觉得处于权力的最底层，事实也确实如此。即使在自己的家中也很容易变主动为被动，让骗子得手。</p>
<p>可能有人会说农村的法律意识淡薄，不知道合理的维权，完全可以打110来解决。我曾经打110处理过店铺扰民这种鸡毛小事，110给的处理时间为5天，这还是在城市里。我估计换做农村的派出所，这种小事估计110是请不动的。</p>
<p>我在此次事件中并没有第一时间作出应有的反应，这点我需要反省。首先，我见到母亲签字后没有跟骗子要一下工作证明，这样子至少让骗子没这么容易得逞，给我的反驳增加大大的筹码。其次，没有阻拦母亲给骗子送钱，按照我的意思是跟骗子死缠到底的，毕竟是在我家，给不给钱也是我的自由。但我怕在家里生活时间不长，骗子的规矩我不懂，还是顺从了母亲的行为。</p>
<p>之所以写这篇文章是想梳理下农民身上的共同缺点及我身上的缺点。我不是歧视农民，我是农村出来的，我知道农村人的辛苦，忙起来的时候他们的辛苦程度是我等码农不能企及的。</p>
<p>在这里为广大奋斗在田地里的农民致敬！</p>
]]></content>
  </entry>
  <entry>
    <title>2015年找工作的一段经历</title>
    <url>/post/2015_interview/</url>
    <content><![CDATA[<p>前段时间我的工作有了一个比较大的变动，我的工作地点从济南到了北京，离开了待了9年的济南，离开了温馨的家，离开了我的亲人，独自一人开启了北漂模式。</p>
<p>本文不打算叙述面试细节问题，具体的面试细节我自己在印象笔记中整理过，但不打算放出来。本文仅选取有代表性的几家公司来叙述。</p>
<p>之所以有如此大的变动，最大的因素是我的个人技术的发展遇到了瓶颈。我近几年对个人发展的定位是在技术上能够更上一层楼，尽量不走管理路线，还是以踏踏实实学技术为主要任务。可是在济南工作已经慢慢被推上了管理的岗位，我怕会逐渐脱离技术，直到完全走上了管理的岗位，这跟我对技术非常感兴趣的初衷是有些违背的。</p>
<p>工作这几年，技术的进步主要来自于自己业余时间的学习，工作中越来越学不太着东西，不是因为工作中不需要牛逼的技术，而是没有人和精力去研究新技术，济南缺乏这个环境，而且是非常匮乏。我已经深深感觉到济南的IT行业未来会逐渐缩小，实际上目前济南的圈子就是很小的，稍微有点规模的公司也就那么几家而已。</p>
<p>我自从开始工作就以互联网公司为目标，可以济南没有一家真正意义上的互联网公司，用的技术也都不咋地，工作五年后，有了一定的技术积累，家庭也算稳定了，是时候出来闯闯了，不能在济南的安逸环境中，像水煮青蛙般等待着济南IT业的下滑。</p>
<p>这次来北京找工作的目标非常明确，互联网公司，最好是规模能够稍微大些的，BAT更好，不想加入A轮的公司，我需要的是成熟的互联网公司的环境和技术，来洗刷我已经在传统行业奋斗了多年的旧习。</p>
<p>我是裸辞的，因为毕竟面试是需要去北京的，在职请假面太麻烦，且不能够全身心的找工作。我给自己找工作的期限为一个月的时间，我最终上班的时间是在20天多点的时间。</p>
<p>在辞职后的第一周我在家里边休息边看了一遍《STL源码剖析》，之前一直觉得没必要看此书，结果看起来效果还不错，比我想象的要简单的多的多。另外，我制作了自己的简历，包括了pdf版本和markdown版本，并在拉勾网上投递了几份简历。</p>
<p>就这样第一周过去了，而我没有收到任何的面试通知，第二周我必须加紧开始找工作了。首先在100offer上申请拍卖了我的简历，之前一直关注100offer，微信公众账号和知乎上经常看到100offer的文章，感觉是个靠谱的平台，事实证明确实是一个靠谱的平台。另外，恰巧我在微信公共账号“余晟以为”的文章看到了怎样写简历的文章，就跟作者聊了一会，并且作者在twitter上推荐了我的简历，我的博客有史以来日pv达到了600多，这是我没有想到的，在这里非常感谢余晟的无私帮助。</p>
<p>100offer上拍卖后没多久就收到了二个面试通知，周三上午就赶到了北京参加面试。上午参加的一家游戏公司的面试，用C++做后台的业务逻辑处理，其实我并不喜欢游戏类工作，来面试也仅仅是为了了解北京面试的流畅增加一些资历而已。两天后收到了该公司的offer，而我理所当然是拒绝了。</p>
<p>周四上午参加了一个创业团队的面试，面试官年龄跟我差不多，问的问题非常多，非常杂，最后还有一个我最讨厌的逻辑题，一直面试到下午一点。这家公司的面试是通过twitter上看到我的简历联系我的，我来的目的其实也是出于学习和了解行业。面试完后跟团队成员一起吃了个饭，令我感动的是我面试完已经一点钟了，而大家都在等着我一起吃饭，团队的成员都是做技术的码农，还是非常好相处的。如果我已经有了几年的工作经历，或许我会选择这样一家公司。</p>
<p>下午参加了我目前所在公司一点资讯的面试，面试流程还是非常nice的，感觉跟我心目中的互联网公司基本吻合，虽然面试的时候问的问题过于简单些，令我有点怀疑公司的真实技术实力。另外还问了一堆我并不深入的web技术问题，令我非常捉急。</p>
<p>没有面试的时候，我就直接回济南了，毕竟在自己家里比北京不知舒服多少倍。</p>
<p>第三周的时候，我已经开始有些慌了。该用的能有面试机会的方式我都用了，而却收不到面试的邀请了。我用到了100offer、拉勾网、内推、jobdeer、同学内推的方式。难道是我简历写的太水了，可是我已经很难改进自己的简历了，我不想将简历写的夸张了。</p>
<p>我开始反思原因。我发现互联网用到的我擅长的C++技术的公司非常少，互联网追求的是短平快，C++并不具备开发速度快的特点，因此并不受互联网公司欢迎。像BAT类的公司用C++技术还是比较多的，因为做到一定程度会深究程序的性能，而这是C++擅长的。而BAT类的公司，我并没有任何优势，我虽有几年工作经验，但是都是在传统行业，互联网行业的经验却为0。很多大公司的hr在看到我的简历后直接就给pass掉了，压根没有面试的机会。</p>
<p>我找同学内推了百度的简历，另外在拉勾网上也投了一些百度的简历。在我入职之前的几天百度的hr妹子给我电话沟通说一周之内会给我面试通知，最终的结果是一周后百度hr妹子给我打电话让我去面试，看来大公司的流程真是复杂，连面试都得排队，而那天是我入职的第一天。没办法，只能委婉的拒绝了，hr倒是很爽快的挂掉了电话。</p>
<p>目前，我已经入职有三周的时间了，工作已经趋于稳定。我也搬到了公司附近，离公司就几分钟的路程，毕竟就自己一个人，没必要离公司太远，上下班太折腾。晚上一般会在公司待到十点以后，毕竟回去了也没太有什么事情。周末会抽时间回济南跟家人团聚，或者家人来北京，不期望因为工作的原因而对家庭有损伤。工作方面的内容还算满意，能涉及到很多新技术，对个人的成长还不错，只是组内的人员较少，沟通交流的机会不够多，通过招聘慢慢就会解决了。由于用到的很多技术都不够熟悉，自己俨然变成了一个菜鸟，有大量的技术需要学习。同事也还比较给力，大家对工作也很认真负责，团队的凝聚力也符合我的预期。</p>
<p>总结来看，这段找工作的经历虽有很多失误的地方，错误的对行业的需求进行了估计，以为C++程序员很抢手，事实并不是如此，但结果还算满意。现在自己一个人在北京奋斗，期望通过自己的努力能够有个好的收货。要想写的东西很多，很多都一笔带过了，非技术类的文章写起来还是挺费脑力的。</p>
]]></content>
  </entry>
  <entry>
    <title>2015年年终总结</title>
    <url>/post/2015_summary/</url>
    <content><![CDATA[<p>按照惯例，年终总结依旧是按照农历算，农历乙未年的年终总结。</p>
<p>2015年的夏天对我而言是个转折点，终于实现了我工作以来一直想北漂的梦想，受够了各种束缚，受够了带同事的各种无奈，受够了跟同事没有话题的工作，受够了天天雾霾比北京不知严重多少倍却没有一点声音，受够了满城市找不到一家互联网公司，受够了满城市找不到一个技术会议，受够了于为了工作而工作的同事们共事，受够了天天受到官本位思想的侵蚀。</p>
<p>上半年在济南工作生活，下半年在北京工作生活。</p>
<p>似乎一直以来我的一些人生大事都是在夏天发生的。</p>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>在济南的工作没什么好总结的，我已经在济南工作多年，似乎也没有太大的变化。</p>
<p>由于互联网公司和传统行业软件公司存在较大的差异，来到一点资讯后大约适应了两个月才完全适应。到现在，让我回想之前的工作状态，感觉好陌生，好遥远。</p>
<p>我的岗位为运维开发，叫做基础平台的研发更合适些。由于之前没有运维方面的工作经验，对运维开发这样的职位没有清晰的认识。对运维的需求也是在工作中逐步去摸索的。</p>
<p>之前在济南工作的时候，由于从事的是传统软件行业，对技术的使用比较保守，公司中很少会采用很新的技术，比如storm、kafka等。很多行业我个人利用业余时间倒是学习了很多互联网中会用到的技术，但是由于缺乏实践机会，时间一长就忘记了。</p>
<p>另外由于处理业务类型不同，使用的技术往往也不一样。比如haproxy这种反向代理软件在非互联网行业中其实用到比较少，因为非互联网行业面向的群体往往是政府和企业类的，不是使用互联网的广大用户群体，因此反向代理软件很少有永无之地。我之前待过的几家有些技术背景的非互联网公司往往会自己开发一些适合公司自己业务的类库或者技术架构，很多技术含量也是蛮高的，只是不为外界所知，组件无法公用，更没有开源的。</p>
<p>当然了，随着互联网行业的发展，传统的软件企业所使用的技术也在更新，也在采用互联网企业使用的技术。</p>
<p>因此，来到了互联网行业对我而言最重要的就是掌握互联网行业中会用到的技术，除了工作过程中会使用一些新技术之外，晚上下班之后也会将时间充分利用上，学习一些工作中会用到的技术。由于要学的技术实在太多了，至于先学什么后学什么，我采取了“用到什么就学什么，广撒网，后深入”的原则，这样既能达到不太影响工作，又可以达到一定广度，等到广度够了再深入了解各个技术。</p>
<p>由于自己的各种问题，也造成过几次系统的线上的故障，靠谱程度还有待提高。</p>
<p>在济南的环境下从来没有见过@福波和@凯荣为了工作这般拼得的同事，虽然他们这种拼得方式我学不来，但至少要从精神上拼一下。</p>
<p>工作的原因，正在使用的编程也变得更多，工作中会用到C++、Java、Python、Golang、前端技术等，不同的语言使用于不同的场景下。</p>
<p>工作上并没有太大的成就，主要是因为需要学习的东西太多，需需要了解，各种技术需要学习，一些开源的大数据处理技术和存在的坑也需要学习。相信随着学习的不断深入，2016年工作能小有成就。</p>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>由于我学习新知识很多时候还是看技术类的书籍，比较喜欢系统一点的学习，纸质书是我的最爱。今年买过不少的技术书籍，特别是下半年以来，至少有20本技术书的样子。之前都会系统的讲书籍看完，下半年买的技术书籍基本都是看上一半或找个技术重点就扔到一边去了。主要是因为没有了足够的时间来系统的学习整本书的内容，更多的时候是对症下药而已。</p>
<p>学习的方向上逐渐转为务实，为工作所用，解决工作之所需，不像之前学的很多东西都是纸上谈兵，缺少实践的机会。</p>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>上半年生活在济南，下半年生活在北京。</p>
<p>在济南的生活相对惬意，加班相对少些，虽然是单双周轮休的生活，但周末仍然是有时间出去转转的。</p>
<p>来北京后，很多时候变成了工作在北京，周末回济南的生活，有时候两周回去一次，有时候一周回去一次，一般周一早上坐最早的高铁回北京。这样的生活相对单调，也确实非常辛苦，基本被工作和学习占去了绝大多数时间，剩下的时间非常有限。可以说工作就是我的生活，我的生活就是工作。</p>
<p>由于很多时间都是远离家的，自己为家庭付出的确实非常少，这点深表遗憾。</p>
<h2 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h2><p>之前上班的时候每天可以骑一个多小时的自行车来运动，而且坡度也比较大。后来，运动对我而言就相当匮乏了，没有活动的次数都非常有限，运动这一点做的相当不好。</p>
<p>今年从夏天开始学习游泳，终于将游泳学会了，而且游泳的次数也是很多的，虽然仅仅熟练的是蛙泳。公司每周三下午有个活动时间，有一段时间每周三下午都会去游泳的，正好此时学会了游泳。</p>
<p>偶然的一次机会，同学邀请打了一次台球，竟对台球感兴趣起来。</p>
<p>北京对我而言还是个陌生的地方，偶尔周末有时间，会去一些地方转转。</p>
<h2 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h2><p>今年下半年开始，职业症状逐渐明显，每天坐得时间一长，腰疼就来了，而且有愈演愈烈之势。后来尝试了站着办公，本来以为每天只要站着办公腰疼就不要紧了，试验后才发现站久了也是会腰疼的。目前每天基本都是站着办公了，只有站累了的情况下才会坐下来办公。</p>
<p>来到北京后睡的床垫不是太舒服，后来干脆更改为了睡硬板床，早上起来后确实能明显感觉到睡硬板床轻松的多。</p>
<p>颈椎也不是太好，虽然感觉到时候没有那么多，但至少没有那么健康了。</p>
<p>做按摩的时候才发现自己的腰肌劳损挺严重了，也许是按摩师故意说的严重，至少按摩时疼的我直叫，也能感觉到按摩时腰部的肌肉硬块。听到按摩师的一句话挺伤感的，『你为了工作也是够拼的，把腰伤成这样』。</p>
<h2 id="汽车"><a href="#汽车" class="headerlink" title="汽车"></a>汽车</h2><p>一向比较排斥汽车的我也在今年的三月份拿到了驾照，并且一度产生了年底购买汽车的想法，曾经也是痴迷过一段时间的汽车节目，在做饭和骑着自行车去上班的路上听汽车广播，对常见的车型都有所了解，还去过春季车展，进过4S店，自己对车的了解也是与日俱增。曾经想过目标车型为标致2008，后来更换为马六，后来更换为昂科塞拉。曾经痴迷到在马路上见到不认识的车型就打开汽车之家的app来查看详情的地步。</p>
<p>但后来来北京工作后，之前做饭和骑自行车上班的时光都变成了在公司上班，也就没有了时间来听汽车广播，渐渐的对汽车的兴趣在逐渐下降，直到现在再也不关注任何和汽车相关的信息。</p>
<p>通过此来看，兴趣是可以培养的，但培养起来的兴趣，一旦放下了，兴趣就会逐渐淡掉，直到恢复到最初的状态。</p>
<h2 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h2><p>说来惭愧，2015年没有任何的旅行计划。我唯一的一次旅行是公司校园招聘时在哈尔滨稍微转了下。曾多少次家人建议出去旅行，都被我否决了。理由要么是不愿跟团，要么时间不够，要么自己不愿去，要么考虑钱的问题。</p>
<h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><p>最近几年每到周末是必然会晚上几盘dota的，主要是用来放松，另外也有点玩游戏的瘾。我之所以一直没有戒掉玩游戏，是因为我心里清楚到了一定的年龄段对dota自然不就感兴趣了。只是没想到来的这么快，近几个月对游戏玩的越来越少，有时候一周都不会晚上一次了，而且也没有特别想玩的冲动了。</p>
<p>也许是因为玩游戏需要久坐，而久坐容易腰痛，也许是因为我现在已经达到了特定的年龄段，总之，都在说明，我在变老，精力确实没有之前旺盛了。</p>
<h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><ul>
<li>深入学习各种技术，技术更上多层楼。</li>
<li>至少要旅行一次，期望的目的地是日本或韩国，如果实在不行就国内。</li>
<li>期望能学会自由泳，蝶泳估计没戏。</li>
<li>多加强台球的练习。</li>
<li>熟悉下北京，多转转北京，去过的地方还非常非常的少。</li>
<li>如果有时间的话，多学一些锻炼智力的游戏，比如魔方。</li>
<li>工作中提高些效率，多一些生活。</li>
<li>多读英文技术文档。</li>
<li>多参加一些技术交流活动或其他活动。</li>
<li>…</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>C/C++程序员面试宝典读书笔记</title>
    <url>/post/C_C++_review/</url>
    <content><![CDATA[<p>本文摘录《C&#x2F;C++程序员面试宝典》一书中我认为需要注意的地方。</p>
<h1 id="数组指针与指针数组的区别"><a href="#数组指针与指针数组的区别" class="headerlink" title="数组指针与指针数组的区别"></a>数组指针与指针数组的区别</h1><p>数组指针即指向数组的指针，定义数组指针的代码如<code>int (*ap)[2]</code>，定义了一个指向包含两个元素的数组的数组指针。<br>如果数组的每一个元素都是一个指针，则该数组为指针数组。实例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *chararr[] = &#123;&quot;C&quot;, &quot;C++&quot;, &quot;Java&quot;&#125;;</span><br></pre></td></tr></table></figure>
<p><code>int (*ap)[2]</code>和<code>int *ap[2]</code>的区别就是前一个是数组指针，后一个是指针数组。因为”[]”的优先级高于”*”，决定了这两个表达式的不同。</p>
<h1 id="public、protected、private"><a href="#public、protected、private" class="headerlink" title="public、protected、private"></a>public、protected、private</h1><h2 id="修饰成员变量或成员函数"><a href="#修饰成员变量或成员函数" class="headerlink" title="修饰成员变量或成员函数"></a>修饰成员变量或成员函数</h2><ul>
<li>public：可以被该类中的函数、子类的函数、友元函数和该类的对象访问。</li>
<li>protected：可以被该类中的函数、子类的函数和友元函数访问，不能被该类的对象访问。</li>
<li>private：只能由该类中的函数或友元函数访问。</li>
<li>默认为private权限。</li>
</ul>
<h2 id="用在继承中"><a href="#用在继承中" class="headerlink" title="用在继承中"></a>用在继承中</h2><ul>
<li>public：基类成员保持自己的访问级别，基类的public成员为派生类的public成员，基类的protected成员为派生类的protected成员。</li>
<li>protected：基类的public和protected成员在派生类中未protected成员。</li>
<li>private：基类的所有成员在派生类中为private成员。</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>我幻想拥有一只听话的袋鼠作为宠物</title>
    <url>/post/I_want_to_have_one_kangaroos/</url>
    <content><![CDATA[<p><img src="/ref/life/my_kangaroos.gif" alt="Image Title"></p>
<p>我想拥有一只雌性袋鼠作为宠物，我会将其取名为”点点”。之所以是雌性是看中了袋鼠的温暖舒适的育儿袋。</p>
<p>如果可以我会给育儿袋上面缝上个拉链，这样我就不会担心放在袋袋里面的东西会掉出来了。</p>
<p>我可以领着我的点点去超市购物，将购买的东西放到袋袋里面，拉链一拉，然后蹦蹦跳跳的就回家了。</p>
<p>晚上吃完饭，我可以领着点点去大街上走走，我可以将我的钱包、手机放到点点的袋袋里，拉链一拉，完全不用担心手机会摔坏。</p>
<p>如果下起了雨或遇到了寒风，我可以钻到袋袋里，露个头在外面，一跳10米远，然后蹦蹦跳跳的就回家了。</p>
<p>当然，这是不现实的，我在做梦，做一个好笑的梦。。。</p>
]]></content>
  </entry>
  <entry>
    <title>leetcode题目之Maximum Subarray</title>
    <url>/post/Maximum_Subarray/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],<br>the contiguous subarray [4,−1,2,1] has the largest sum &#x3D; 6.</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>该题目为经典题目，存在多种解题思路。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>求动态规划的关键在于找到状态方程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 问题的关键是找到状态方式，找到状态方程后问题就迎刃而解</span></span><br><span class="line"><span class="comment"> * 状态方程如下：</span></span><br><span class="line"><span class="comment"> * b[j]表示第j处，以a[j]结尾的子序列的最大和</span></span><br><span class="line"><span class="comment"> * b[j]=max(a[j] + b[j-1], a[j])</span></span><br><span class="line"><span class="comment"> * b数据的最大值即为问题的解</span></span><br><span class="line"><span class="comment"> * 问题转换为求解b数组</span></span><br><span class="line"><span class="comment"> * 时间复杂度为O(1)，空间复杂度为(n)，空间复杂度可以降为O(1)，为了使程序易读，不做调整</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> *b = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">	b[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> max_b = b[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		b[i] = std::<span class="built_in">max</span>(A[i] + b[i<span class="number">-1</span>], A[i]);</span><br><span class="line">		<span class="keyword">if</span> (max_b &lt; b[i])</span><br><span class="line">		&#123;</span><br><span class="line">			max_b = b[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] b;</span><br><span class="line">	<span class="keyword">return</span> max_b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><p>《算法导论》的分治策略一章有关于该问题的详细解释。该题利用分治法来解决要比二分查找类最简单的分治算法要复杂。将数组一分为二后，最大数组存在三种情况：在左半或右半部分、跨越中点分别占据左部分一点和右部分一点。对于跨越中点的情况，转化为求从中点开始向左的最大值和从中点开始向右的最大值之和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> compare_array[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maxSubArray</span>(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * leetcode not support stdarg.h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> count, ...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        va_list ap;</span><br><span class="line">        <span class="built_in">va_start</span>(ap, count);</span><br><span class="line">        <span class="type">int</span> max = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = <span class="built_in">va_arg</span>(ap, <span class="type">int</span>);</span><br><span class="line">            <span class="keyword">if</span> (max &lt; temp)</span><br><span class="line">            &#123;</span><br><span class="line">                max = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">va_end</span>(ap);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_compare_array</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> max_num = compare_array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (max_num &lt; compare_array[i])</span><br><span class="line">            &#123;</span><br><span class="line">                max_num = compare_array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;begin : %d, end : %d\n&quot;, begin, end);</span></span><br><span class="line">        <span class="keyword">if</span> (begin == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> A[begin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((end - begin) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//return max(3, A[begin], A[begin] + A[end], A[end]);</span></span><br><span class="line">            compare_array[<span class="number">0</span>] = A[begin];</span><br><span class="line">            compare_array[<span class="number">1</span>] = A[begin] + A[end];</span><br><span class="line">            compare_array[<span class="number">2</span>] = A[end];</span><br><span class="line">            compare_array[<span class="number">3</span>] = INT_MIN;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max_compare_array</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 处理左边子数组</span></span><br><span class="line">        <span class="type">int</span> max_left = <span class="built_in">maxSubArray</span>(A, begin, middle);</span><br><span class="line">        <span class="comment">// 处理右边子数组</span></span><br><span class="line">        <span class="type">int</span> max_right = <span class="built_in">maxSubArray</span>(A, middle + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// 处理跨越中点的情况</span></span><br><span class="line">        <span class="type">int</span> max_cross = <span class="built_in">maxCrossMiddle</span>(A, begin, end);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;begin : %d, end : %d, max_left = %d, max_right = %d, max_cross = %d\n&quot;</span>, begin, end, max_left, max_right, max_cross);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回三者中的最大值</span></span><br><span class="line">        compare_array[<span class="number">0</span>] = max_left;</span><br><span class="line">        compare_array[<span class="number">1</span>] = max_right;</span><br><span class="line">        compare_array[<span class="number">2</span>] = max_cross;</span><br><span class="line">        compare_array[<span class="number">3</span>] = INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max_compare_array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理跨越中点的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCrossMiddle</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> A[begin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 求得[begin -- middle-1]的最大值</span></span><br><span class="line">        <span class="type">int</span> max_left = A[middle - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=middle - <span class="number">1</span>; i&gt;=begin &amp;&amp; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            <span class="keyword">if</span> (max_left &lt; sum)</span><br><span class="line">            &#123;</span><br><span class="line">                max_left = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求得[middle+1 -- end]的最大值</span></span><br><span class="line">        <span class="type">int</span> max_right = A[middle + <span class="number">1</span>];</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=middle + <span class="number">1</span>; i&lt;=end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            <span class="keyword">if</span> (max_right&lt; sum)</span><br><span class="line">            &#123;</span><br><span class="line">                max_right = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        compare_array[<span class="number">0</span>] = A[middle];</span><br><span class="line">        compare_array[<span class="number">1</span>] = A[middle] + max_left;</span><br><span class="line">        compare_array[<span class="number">2</span>] = A[middle] + max_right;</span><br><span class="line">        compare_array[<span class="number">3</span>] = A[middle] + max_left + max_right;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max_compare_array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="扫描算法"><a href="#扫描算法" class="headerlink" title="扫描算法"></a>扫描算法</h1><p>《编程珠玑》一书8.4节提到该算法，时间复杂度为O(1)，是解决该问题最好的算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> current_sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> max_sum = INT_MIN;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">if</span> (current_sum &lt;= <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		current_sum = A[i];</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">		current_sum += A[i];</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (current_sum &gt; max_sum)</span><br><span class="line">	    &#123;</span><br><span class="line">		max_sum = current_sum;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>OCI</title>
    <url>/post/OCI/</url>
    <content><![CDATA[<p>OCI（Open Container Initiative）为Linux基金会下的子项目，成立于2015年，由docker、coreos等公司发起，用来制定开放的容器和容器镜像标准，同时docker将其镜像格式和容器运行时runc捐献给了OCI，因此OCI中包含了容器镜像标准和容器运行时标准两部分。</p>
<h2 id="容器镜像的发展历史"><a href="#容器镜像的发展历史" class="headerlink" title="容器镜像的发展历史"></a>容器镜像的发展历史</h2><p>2013年，docker横空出世，docker的核心能力之一为将应用封装为镜像，便于打包、发布。</p>
<p>2014年，docker将镜像格式定位为docker镜像规范v1版本。</p>
<p>2016年，docker制定了新的镜像格式规范v2，解决v1版本的部分设计缺陷。</p>
<p>2017年，OCI发布了OCI镜像规范1.0版本，整个规范以docker镜像规范v2为基础，两者的规范比较类似。</p>
<h2 id="容器镜像标准"><a href="#容器镜像标准" class="headerlink" title="容器镜像标准"></a>容器镜像标准</h2><p>官方定义：<a href="https://github.com/opencontainers/image-spec">OCI Image Format Specification</a></p>
<p>容器镜像标准包含了镜像索引（可选）、manifest、层文件和配置文件四部分内容。包含了容器的构建、分发和准备可以运行的镜像。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/oci-media-types.png" alt="https://github.com/opencontainers/image-spec/blob/main/img/media-types.png"></p>
<p>skopeo为一个容器镜像和镜像仓库的命令行操作工具，可以使用该工具来学习OCI容器镜像规范，可以直接使用 <code>yum install skopeo -y</code> 进行安装。</p>
<p>使用如下命令可以将docker的镜像转换为oci格式，并将其保存到&#x2F;tmp&#x2F;local_nginx目录下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">skopeo copy docker://nginx oci:/tmp/local_nginx</span><br></pre></td></tr></table></figure>

<p>&#x2F;tmp&#x2F;local_nginx的目录包含如下结构，参考链接：<a href="https://github.com/opencontainers/image-spec/blob/main/image-layout.md">OCI Image Layout Specification</a></p>
<ul>
<li>blobs 目录：包含了镜像Manifest、镜像层和镜像配置信息，均已sha256值命名的文件形式存储，文件可以为文本文件，也可以为gzip压缩的二进制文件。</li>
<li>oci-layout 文件：定义了当前目录结构的版本信息</li>
<li>index.json 文件：定义了镜像索引信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── blobs</span><br><span class="line">│   └── sha256</span><br><span class="line">│       ├── 4a7307612456a7f65365e1da5c3811df49cefa5a2fd68d8e04e093d26a395d60</span><br><span class="line">│       ├── 67e9751bc5aab75bba375f0a24702d70848e5b2bea70de55e50f21ed11feed14</span><br><span class="line">│       ├── 8f46223e4234ce76b244c074e79940b9ee0a01b42050012c8555ebc7ac59469e</span><br><span class="line">│       ├── 935cecace2a02d2545e0c19bd52fe9c8c728fbab2323fc274e029f5357cda689</span><br><span class="line">│       ├── b85a868b505ffd0342a37e6a3b1c49f7c71878afe569a807e6238ef08252fcb7</span><br><span class="line">│       ├── efb56228dbd26a7f02dafc74a2ca8f63d5e3bb6df9046a921f7d8174e5318387</span><br><span class="line">│       ├── f4407ba1f103abb9ae05a4b2891c7ebebaecab0c262535fc6659a628db25df44</span><br><span class="line">│       └── fe0ef4c895f5ea450aca17342e481fada37bf2a1ee85d127a4473216c3f672ea</span><br><span class="line">├── index.json</span><br><span class="line">└── oci-layout</span><br><span class="line"></span><br><span class="line">2 directories, 10 files</span><br></pre></td></tr></table></figure>

<h3 id="镜像索引"><a href="#镜像索引" class="headerlink" title="镜像索引"></a>镜像索引</h3><p>非必须部分。如果包含镜像索引，用来解决多架构问题。不同的平台上，可以使用同一个镜像tag，即可以获取到对应平台的镜像。</p>
<p>镜像索引为 json 格式的文件，查看 index.json 文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;schemaVersion&quot;: 2,</span><br><span class="line">  &quot;manifests&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;mediaType&quot;: &quot;application/vnd.oci.image.manifest.v1+json&quot;,</span><br><span class="line">      &quot;digest&quot;: &quot;sha256:15beb598b14fca498f13a46923de0614a17012abf675ba06e364904d642d8a61&quot;,</span><br><span class="line">      &quot;size&quot;: 1183</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>镜像索引文件可以包含多种架构。其中digest对应的sha256值指向 blobs&#x2F;sha256 下的文件，其文件为Manifest文件。</p>
<p>需要注意的是：docker 可以使用 <code>docker manifest</code>命令来查看镜像的manifest信息，但格式并非为OCI Manifest格式，而更类似于OCI index的信息，下面的命令中，可以看到rancher镜像为多镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker manifest inspect rancher/rancher</span><br><span class="line">&#123;</span><br><span class="line">   &quot;schemaVersion&quot;: 2,</span><br><span class="line">   &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.list.v2+json&quot;,</span><br><span class="line">   &quot;manifests&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,</span><br><span class="line">         &quot;size&quot;: 4732,</span><br><span class="line">         &quot;digest&quot;: &quot;sha256:b8f1fdb8228d32ae5fc6f240503cd8e22b214fcfd4ad2a8a0b03274f3ead4e95&quot;,</span><br><span class="line">         &quot;platform&quot;: &#123;</span><br><span class="line">            &quot;architecture&quot;: &quot;amd64&quot;,</span><br><span class="line">            &quot;os&quot;: &quot;linux&quot;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,</span><br><span class="line">         &quot;size&quot;: 4731,</span><br><span class="line">         &quot;digest&quot;: &quot;sha256:ae0fa74e8dce9b72bdc6611815deb16bbddc8fe0a555052ccc8127fdc1b76980&quot;,</span><br><span class="line">         &quot;platform&quot;: &#123;</span><br><span class="line">            &quot;architecture&quot;: &quot;arm64&quot;,</span><br><span class="line">            &quot;os&quot;: &quot;linux&quot;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,</span><br><span class="line">         &quot;size&quot;: 4519,</span><br><span class="line">         &quot;digest&quot;: &quot;sha256:94c03afba43e81885c3cd2f5065032d1b7f8f540860fcc1fce1bbd7f1068d3db&quot;,</span><br><span class="line">         &quot;platform&quot;: &#123;</span><br><span class="line">            &quot;architecture&quot;: &quot;s390x&quot;,</span><br><span class="line">            &quot;os&quot;: &quot;linux&quot;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h3><p>参考：<a href="https://github.com/opencontainers/image-spec/blob/main/manifest.md">OCI Image Manifest Specification</a></p>
<p>Manifest为json格式的描述文件，包含了如下三个用途：</p>
<ol>
<li>每一个镜像都有一个唯一的 id 标识</li>
<li>对于同一个镜像tag，可以支持多架构镜像</li>
<li>可以直接转换为OCI的运行时规范</li>
</ol>
<p>查看 blobs&#x2F;sha256&#x2F;15beb598b14fca498f13a46923de0614a17012abf675ba06e364904d642d8a61 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;schemaVersion&quot;: 2,</span><br><span class="line">  &quot;mediaType&quot;: &quot;application/vnd.oci.image.manifest.v1+json&quot;,</span><br><span class="line">  &quot;config&quot;: &#123;</span><br><span class="line">    &quot;mediaType&quot;: &quot;application/vnd.oci.image.config.v1+json&quot;,</span><br><span class="line">    &quot;digest&quot;: &quot;sha256:67e9751bc5aab75bba375f0a24702d70848e5b2bea70de55e50f21ed11feed14&quot;,</span><br><span class="line">    &quot;size&quot;: 6567</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;layers&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;mediaType&quot;: &quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;,</span><br><span class="line">      &quot;digest&quot;: &quot;sha256:b85a868b505ffd0342a37e6a3b1c49f7c71878afe569a807e6238ef08252fcb7&quot;,</span><br><span class="line">      &quot;size&quot;: 31379408</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;mediaType&quot;: &quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;,</span><br><span class="line">      &quot;digest&quot;: &quot;sha256:f4407ba1f103abb9ae05a4b2891c7ebebaecab0c262535fc6659a628db25df44&quot;,</span><br><span class="line">      &quot;size&quot;: 25354178</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;mediaType&quot;: &quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;,</span><br><span class="line">      &quot;digest&quot;: &quot;sha256:4a7307612456a7f65365e1da5c3811df49cefa5a2fd68d8e04e093d26a395d60&quot;,</span><br><span class="line">      &quot;size&quot;: 603</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;mediaType&quot;: &quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;,</span><br><span class="line">      &quot;digest&quot;: &quot;sha256:935cecace2a02d2545e0c19bd52fe9c8c728fbab2323fc274e029f5357cda689&quot;,</span><br><span class="line">      &quot;size&quot;: 893</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;mediaType&quot;: &quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;,</span><br><span class="line">      &quot;digest&quot;: &quot;sha256:8f46223e4234ce76b244c074e79940b9ee0a01b42050012c8555ebc7ac59469e&quot;,</span><br><span class="line">      &quot;size&quot;: 666</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;mediaType&quot;: &quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;,</span><br><span class="line">      &quot;digest&quot;: &quot;sha256:fe0ef4c895f5ea450aca17342e481fada37bf2a1ee85d127a4473216c3f672ea&quot;,</span><br><span class="line">      &quot;size&quot;: 1394</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包含了config 和 layers 两部分信息，其中 config 信息为运行镜像的配置，layers 为镜像中的层信息，其中gzip说明镜像的层为gzip压缩格式，每个层一个压缩文件。</p>
<h3 id="镜像配置"><a href="#镜像配置" class="headerlink" title="镜像配置"></a>镜像配置</h3><p>参考：<a href="https://github.com/opencontainers/image-spec/blob/main/config.md">OCI Image Configuration</a></p>
<p>通过 manifest 中的config信息，可以找到镜像的配置信息 blobs&#x2F;sha256&#x2F;67e9751bc5aab75bba375f0a24702d70848e5b2bea70de55e50f21ed11feed14：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;created&quot;: &quot;2022-06-23T04:13:24.820503805Z&quot;,</span><br><span class="line">  &quot;architecture&quot;: &quot;amd64&quot;,</span><br><span class="line">  &quot;os&quot;: &quot;linux&quot;,</span><br><span class="line">  &quot;config&quot;: &#123;</span><br><span class="line">    &quot;ExposedPorts&quot;: &#123;</span><br><span class="line">      &quot;80/tcp&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;Env&quot;: [</span><br><span class="line">      &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,</span><br><span class="line">      &quot;NGINX_VERSION=1.23.0&quot;,</span><br><span class="line">      &quot;NJS_VERSION=0.7.5&quot;,</span><br><span class="line">      &quot;PKG_RELEASE=1~bullseye&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;Entrypoint&quot;: [</span><br><span class="line">      &quot;/docker-entrypoint.sh&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;Cmd&quot;: [</span><br><span class="line">      &quot;nginx&quot;,</span><br><span class="line">      &quot;-g&quot;,</span><br><span class="line">      &quot;daemon off;&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;Labels&quot;: &#123;</span><br><span class="line">      &quot;maintainer&quot;: &quot;NGINX Docker Maintainers &lt;docker-maint@nginx.com&gt;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;StopSignal&quot;: &quot;SIGQUIT&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;rootfs&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;layers&quot;,</span><br><span class="line">    &quot;diff_ids&quot;: [</span><br><span class="line">      &quot;sha256:08249ce7456a1c0613eafe868aed936a284ed9f1d6144f7d2d08c514974a2af9&quot;,</span><br><span class="line">      &quot;sha256:d5b40e80384bb94d01a8d2d8fb2db1328990e7088640132c33d3f691dd8a88ee&quot;,</span><br><span class="line">      &quot;sha256:b2f82de68e0d9246de01fa8283876427af5d6f3fe21c4bb04785892d5d071aef&quot;,</span><br><span class="line">      &quot;sha256:41451f050aa883f9102df03821485fc2e27611da05689c0ba25f69dcda308988&quot;,</span><br><span class="line">      &quot;sha256:44193d3f4ea2bae7a5ae5983f2562f551618b787751a6abfb732b6d17393bb88&quot;,</span><br><span class="line">      &quot;sha256:e7344f8a29a34b4861faf6adcf072afb26fadf6096756f0e3fc4c289cdefb7c2&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;history&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T00:20:27.020952309Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop) ADD file:8adbbab04d6f84cd83b5f4205b89b0acb7ecbf27a1bb2dc181d0a629479039fe in / &quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T00:20:27.337378745Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop)  CMD [\&quot;bash\&quot;]&quot;,</span><br><span class="line">      &quot;empty_layer&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T04:13:05.737870066Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop)  LABEL maintainer=NGINX Docker Maintainers &lt;docker-maint@nginx.com&gt;&quot;,</span><br><span class="line">      &quot;empty_layer&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T04:13:05.834940798Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop)  ENV NGINX_VERSION=1.23.0&quot;,</span><br><span class="line">      &quot;empty_layer&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T04:13:05.931909571Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop)  ENV NJS_VERSION=0.7.5&quot;,</span><br><span class="line">      &quot;empty_layer&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T04:13:06.026686816Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop)  ENV PKG_RELEASE=1~bullseye&quot;,</span><br><span class="line">      &quot;empty_layer&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T04:13:23.901038357Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c set -x     &amp;&amp; addgroup --system --gid 101 nginx     &amp;&amp; adduser --system --disabled-login --ingroup nginx --no-create-home --home /nonexistent --gecos \&quot;nginx user\&quot; --shell /bin/false --uid 101 nginx     &amp;&amp; apt-get update     &amp;&amp; apt-get install --no-install-recommends --no-install-suggests -y gnupg1 ca-certificates     &amp;&amp;     NGINX_GPGKEY=573BFD6B3D8FBC641079A6ABABF5BD827BD9BF62;     found=&#x27;&#x27;;     for server in         hkp://keyserver.ubuntu.com:80         pgp.mit.edu     ; do         echo \&quot;Fetching GPG key $NGINX_GPGKEY from $server\&quot;;         apt-key adv --keyserver \&quot;$server\&quot; --keyserver-options timeout=10 --recv-keys \&quot;$NGINX_GPGKEY\&quot; &amp;&amp; found=yes &amp;&amp; break;     done;     test -z \&quot;$found\&quot; &amp;&amp; echo &gt;&amp;2 \&quot;error: failed to fetch GPG key $NGINX_GPGKEY\&quot; &amp;&amp; exit 1;     apt-get remove --purge --auto-remove -y gnupg1 &amp;&amp; rm -rf /var/lib/apt/lists/*     &amp;&amp; dpkgArch=\&quot;$(dpkg --print-architecture)\&quot;     &amp;&amp; nginxPackages=\&quot;         nginx=$&#123;NGINX_VERSION&#125;-$&#123;PKG_RELEASE&#125;         nginx-module-xslt=$&#123;NGINX_VERSION&#125;-$&#123;PKG_RELEASE&#125;         nginx-module-geoip=$&#123;NGINX_VERSION&#125;-$&#123;PKG_RELEASE&#125;         nginx-module-image-filter=$&#123;NGINX_VERSION&#125;-$&#123;PKG_RELEASE&#125;         nginx-module-njs=$&#123;NGINX_VERSION&#125;+$&#123;NJS_VERSION&#125;-$&#123;PKG_RELEASE&#125;     \&quot;     &amp;&amp; case \&quot;$dpkgArch\&quot; in         amd64|arm64)             echo \&quot;deb https://nginx.org/packages/mainline/debian/ bullseye nginx\&quot; &gt;&gt; /etc/apt/sources.list.d/nginx.list             &amp;&amp; apt-get update             ;;         *)             echo \&quot;deb-src https://nginx.org/packages/mainline/debian/ bullseye nginx\&quot; &gt;&gt; /etc/apt/sources.list.d/nginx.list                         &amp;&amp; tempDir=\&quot;$(mktemp -d)\&quot;             &amp;&amp; chmod 777 \&quot;$tempDir\&quot;                         &amp;&amp; savedAptMark=\&quot;$(apt-mark showmanual)\&quot;                         &amp;&amp; apt-get update             &amp;&amp; apt-get build-dep -y $nginxPackages             &amp;&amp; (                 cd \&quot;$tempDir\&quot;                 &amp;&amp; DEB_BUILD_OPTIONS=\&quot;nocheck parallel=$(nproc)\&quot;                     apt-get source --compile $nginxPackages             )                         &amp;&amp; apt-mark showmanual | xargs apt-mark auto &gt; /dev/null             &amp;&amp; &#123; [ -z \&quot;$savedAptMark\&quot; ] || apt-mark manual $savedAptMark; &#125;                         &amp;&amp; ls -lAFh \&quot;$tempDir\&quot;             &amp;&amp; ( cd \&quot;$tempDir\&quot; &amp;&amp; dpkg-scanpackages . &gt; Packages )             &amp;&amp; grep &#x27;^Package: &#x27; \&quot;$tempDir/Packages\&quot;             &amp;&amp; echo \&quot;deb [ trusted=yes ] file://$tempDir ./\&quot; &gt; /etc/apt/sources.list.d/temp.list             &amp;&amp; apt-get -o Acquire::GzipIndexes=false update             ;;     esac         &amp;&amp; apt-get install --no-install-recommends --no-install-suggests -y                         $nginxPackages                         gettext-base                         curl     &amp;&amp; apt-get remove --purge --auto-remove -y &amp;&amp; rm -rf /var/lib/apt/lists/* /etc/apt/sources.list.d/nginx.list         &amp;&amp; if [ -n \&quot;$tempDir\&quot; ]; then         apt-get purge -y --auto-remove         &amp;&amp; rm -rf \&quot;$tempDir\&quot; /etc/apt/sources.list.d/temp.list;     fi     &amp;&amp; ln -sf /dev/stdout /var/log/nginx/access.log     &amp;&amp; ln -sf /dev/stderr /var/log/nginx/error.log     &amp;&amp; mkdir /docker-entrypoint.d&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T04:13:24.128160562Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop) COPY file:65504f71f5855ca017fb64d502ce873a31b2e0decd75297a8fb0a287f97acf92 in / &quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T04:13:24.233980553Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop) COPY file:0b866ff3fc1ef5b03c4e6c8c513ae014f691fb05d530257dfffd07035c1b75da in /docker-entrypoint.d &quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T04:13:24.337299368Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop) COPY file:0fd5fca330dcd6a7de297435e32af634f29f7132ed0550d342cad9fd20158258 in /docker-entrypoint.d &quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T04:13:24.441125652Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop) COPY file:09a214a3e07c919af2fb2d7c749ccbc446b8c10eb217366e5a65640ee9edcc25 in /docker-entrypoint.d &quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T04:13:24.534829205Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop)  ENTRYPOINT [\&quot;/docker-entrypoint.sh\&quot;]&quot;,</span><br><span class="line">      &quot;empty_layer&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T04:13:24.627520512Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop)  EXPOSE 80&quot;,</span><br><span class="line">      &quot;empty_layer&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T04:13:24.724935944Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop)  STOPSIGNAL SIGQUIT&quot;,</span><br><span class="line">      &quot;empty_layer&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;created&quot;: &quot;2022-06-23T04:13:24.820503805Z&quot;,</span><br><span class="line">      &quot;created_by&quot;: &quot;/bin/sh -c #(nop)  CMD [\&quot;nginx\&quot; \&quot;-g\&quot; \&quot;daemon off;\&quot;]&quot;,</span><br><span class="line">      &quot;empty_layer&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中包含了如下几个关键信息：</p>
<ol>
<li>config：运行镜像的参数，比如entrypoint、labels等，跟通过 docker inspect 命令看到的信息比较类似。</li>
<li>rootfs：镜像的层信息</li>
<li>history：镜像的历史构建信息，如果empty_layer的值为true，说明未产生新的层</li>
</ol>
<h3 id="镜像层"><a href="#镜像层" class="headerlink" title="镜像层"></a>镜像层</h3><p>镜像层同样存在于 blobs&#x2F;sha256 目录下，且以压缩格式存储，一个层一个压缩文件。manifests文件中的 <code>application/vnd.oci.image.layer.v1.tar+gzip</code> 说明镜像层的压缩格式为gzip。</p>
<h2 id="容器运行时标准"><a href="#容器运行时标准" class="headerlink" title="容器运行时标准"></a>容器运行时标准</h2><p>用来定义容器的配置、运行环境和声明周期。runc为容器运行时的官方实现，其主要代码来源为docker的容器运行时，kara-containers也有对应的OCI实现。</p>
<p>参考文档：<a href="https://github.com/opencontainers/runtime-spec">opencontainers&#x2F;runtime-spec</a></p>
<h3 id="容器配置"><a href="#容器配置" class="headerlink" title="容器配置"></a>容器配置</h3><p>定义在config.json文件中，定义了创建容器的字段。由于runc更具体的操作系统环境有关，其中部分的规范是跟具体操作系统有关的。执行<code>runc spec</code>可以获取到默认的config.json文件，文件内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ociVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.2-dev&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;process&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;terminal&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;uid&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;gid&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;sh&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;TERM=xterm&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;bounding&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="string">&quot;CAP_AUDIT_WRITE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;CAP_KILL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;CAP_NET_BIND_SERVICE&quot;</span></span><br><span class="line">                        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;effective&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="string">&quot;CAP_AUDIT_WRITE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;CAP_KILL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;CAP_NET_BIND_SERVICE&quot;</span></span><br><span class="line">                        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;permitted&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="string">&quot;CAP_AUDIT_WRITE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;CAP_KILL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;CAP_NET_BIND_SERVICE&quot;</span></span><br><span class="line">                        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;ambient&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="string">&quot;CAP_AUDIT_WRITE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;CAP_KILL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;CAP_NET_BIND_SERVICE&quot;</span></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;rlimits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RLIMIT_NOFILE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="attr">&quot;hard&quot;</span><span class="punctuation">:</span> <span class="number">1024</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="attr">&quot;soft&quot;</span><span class="punctuation">:</span> <span class="number">1024</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;noNewPrivileges&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;root&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rootfs&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;readonly&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;runc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/proc&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;proc&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;proc&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tmpfs&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tmpfs&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="string">&quot;nosuid&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;strictatime&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;mode=755&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;size=65536k&quot;</span></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev/pts&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;devpts&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;devpts&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="string">&quot;nosuid&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;noexec&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;newinstance&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;ptmxmode=0666&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;mode=0620&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;gid=5&quot;</span></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev/shm&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tmpfs&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shm&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="string">&quot;nosuid&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;noexec&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;nodev&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;mode=1777&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;size=65536k&quot;</span></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/dev/mqueue&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mqueue&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mqueue&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="string">&quot;nosuid&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;noexec&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;nodev&quot;</span></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/sys&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sysfs&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sysfs&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="string">&quot;nosuid&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;noexec&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;nodev&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;ro&quot;</span></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/sys/fs/cgroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cgroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cgroup&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="string">&quot;nosuid&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;noexec&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;nodev&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;relatime&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                <span class="string">&quot;ro&quot;</span></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;linux&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;resources&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;devices&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                                <span class="punctuation">&#123;</span></span><br><span class="line">                                        <span class="attr">&quot;allow&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                                        <span class="attr">&quot;access&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rwm&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;namespaces&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pid&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;network&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ipc&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uts&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mount&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;maskedPaths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;/proc/acpi&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;/proc/asound&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;/proc/kcore&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;/proc/keys&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;/proc/latency_stats&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;/proc/timer_list&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;/proc/timer_stats&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;/proc/sched_debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;/sys/firmware&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;/proc/scsi&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;readonlyPaths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;/proc/bus&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;/proc/fs&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;/proc/irq&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;/proc/sys&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;/proc/sysrq-trigger&quot;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="运行时和生命周期"><a href="#运行时和生命周期" class="headerlink" title="运行时和生命周期"></a>运行时和生命周期</h3><p>在config.json文件中可以声明跟容器生命周期相关的部分，比如prestart、poststop等。</p>
<p>定义了很多子命令，比如状态查询的<code>state &lt;container-id&gt;</code>，删除容器的<code>delete &lt;container-id&gt;</code>等，这些子命令runc部分均有实现。通过 <code>runc state mycontainerid</code> 来查看的输出结果如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ociVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.2-dev&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mycontainerid&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;pid&quot;</span><span class="punctuation">:</span> <span class="number">40805</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;running&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bundle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/mycontainer&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;rootfs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/mycontainer/rootfs&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2022-06-29T13:51:54.795617419Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;owner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="镜像分发规范"><a href="#镜像分发规范" class="headerlink" title="镜像分发规范"></a>镜像分发规范</h2><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><h4 id="pull-manifest"><a href="#pull-manifest" class="headerlink" title="pull manifest"></a>pull manifest</h4><p>接口定义：<code>GET /v2/&lt;name&gt;/manifests/&lt;reference&gt;</code></p>
<p><code>&lt;name&gt;</code>： 镜像的 namespace。<br><code>&lt;reference&gt;</code>：镜像的 tag 或者摘要信息。</p>
<h4 id="pull-bolb"><a href="#pull-bolb" class="headerlink" title="pull bolb"></a>pull bolb</h4><p>接口定义：<code>GET /v2/&lt;name&gt;/blobs/&lt;digest&gt;</code></p>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p><code>POST /v2/&lt;name&gt;/blobs/uploads/?digest=&lt;digest&gt;</code><br><code>PUT /v2/&lt;name&gt;/manifests/&lt;reference&gt;</code></p>
<h3 id="list-tag"><a href="#list-tag" class="headerlink" title="list tag"></a>list tag</h3><p>接口定义：<code>GET /v2/&lt;name&gt;/tags/list</code></p>
<p>返回格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;&lt;name&gt;&quot;,</span><br><span class="line">  &quot;tags&quot;: [</span><br><span class="line">    &quot;&lt;tag1&gt;&quot;,</span><br><span class="line">    &quot;&lt;tag2&gt;&quot;,</span><br><span class="line">    &quot;&lt;tag3&gt;&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="list-references"><a href="#list-references" class="headerlink" title="list references"></a>list references</h3><p>接口定义： <code>GET /v2/&lt;name&gt;/referrers/&lt;digest&gt;</code></p>
<h3 id="delete-tag"><a href="#delete-tag" class="headerlink" title="delete tag"></a>delete tag</h3><p>接口定义： <code>DELETE /v2/&lt;name&gt;/manifests/&lt;tag&gt;</code></p>
<h3 id="delete-manifest"><a href="#delete-manifest" class="headerlink" title="delete manifest"></a>delete manifest</h3><p>接口定义： <code>DELETE /v2/&lt;name&gt;/manifests/&lt;digest&gt;</code></p>
<h3 id="delete-blobs"><a href="#delete-blobs" class="headerlink" title="delete blobs"></a>delete blobs</h3><p>接口定义： <code>DELETE /v2/&lt;name&gt;/blobs/&lt;digest&gt;</code></p>
<h2 id="k8s支持情况"><a href="#k8s支持情况" class="headerlink" title="k8s支持情况"></a>k8s支持情况</h2><p>K8s可以通过 pod 的 spec.runtimeClassName 来指定 oci runtime 的实现方式。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://vividcode.io/understanding-oci-image-spec/">Understanding OCI Image Spec</a> （简单明了，推荐优先阅读）</li>
<li><a href="https://opencontainers.org/">https://opencontainers.org/</a></li>
<li><a href="https://mp.weixin.qq.com/s/TVIz8p8nOj4ffYaECW7gVg">云原生制品那些事(2)：OCI 镜像规范</a></li>
<li><a href="https://github.com/containers/skopeo">skopeo</a></li>
<li><a href="https://ata.alibaba-inc.com/articles/146823?spm=ata.23639746.0.0.7a343566jpFBZQ">解读 OCI Image Spec</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>OpenKruise调研</title>
    <url>/post/OpenKruise/</url>
    <content><![CDATA[<p>OpenKruise是阿里云开源的一系列基于k8s的扩展组件的集合，其中包含了像增强版的workload、sidecar容器管理、高可用性防护等特性，包含了很多的“黑科技”。</p>
<p>如果k8s的kube-controller-manager组件可以提供非常强的扩展能力，可以实现自定义的Deployment、StatefulSet的controller，而不是使用原生的kube-controller-manager的功能，类似于实现自定义的调度器扩展功能。那么很有可能OpenKruise的实现方案就不再会采用CRD扩展的方式，而是直接在原生的Deployment、StatefulSet等对象上通过annotation的方式来实现。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以直接使用helm的方式安装</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">helm</span> <span class="string">repo</span> <span class="string">add</span> <span class="string">openkruise</span> <span class="string">https://openkruise.github.io/charts/</span></span><br><span class="line"><span class="string">helm</span> <span class="string">install</span> <span class="string">kruise</span> <span class="string">openkruise/kruise</span> <span class="string">--version</span> <span class="number">1.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<p>安装完成后，可以看到在kruise-system下创建了一个DeamonSet和一个Deployment。并且安装了很多的CRD和webhook组件。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span>  <span class="string">get</span> <span class="string">pod</span> <span class="string">-n</span> <span class="string">kruise-system</span></span><br><span class="line"><span class="string">NAME</span>                                        <span class="string">READY</span>   <span class="string">STATUS</span>    <span class="string">RESTARTS</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">kruise-controller-manager-67878b65d-cv6f4</span>   <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>          <span class="string">92s</span></span><br><span class="line"><span class="string">kruise-controller-manager-67878b65d-jrmnd</span>   <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>          <span class="string">92s</span></span><br><span class="line"><span class="string">kruise-daemon-ktwvv</span>                         <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>          <span class="string">92s</span></span><br><span class="line"><span class="string">kruise-daemon-nf84r</span>                         <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>          <span class="string">92s</span></span><br><span class="line"><span class="string">kruise-daemon-rjs26</span>                         <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>          <span class="string">92s</span></span><br><span class="line"><span class="string">kruise-daemon-vghw4</span>                         <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>          <span class="string">92s</span></span><br><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">crd</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">kruise.io</span></span><br><span class="line"><span class="string">advancedcronjobs.apps.kruise.io</span>                           <span class="number">2022-03-05T13:21:39Z</span></span><br><span class="line"><span class="string">broadcastjobs.apps.kruise.io</span>                              <span class="number">2022-03-05T13:21:39Z</span></span><br><span class="line"><span class="string">clonesets.apps.kruise.io</span>                                  <span class="number">2022-03-05T13:21:39Z</span></span><br><span class="line"><span class="string">containerrecreaterequests.apps.kruise.io</span>                  <span class="number">2022-03-05T13:21:39Z</span></span><br><span class="line"><span class="string">daemonsets.apps.kruise.io</span>                                 <span class="number">2022-03-05T13:21:39Z</span></span><br><span class="line"><span class="string">imagepulljobs.apps.kruise.io</span>                              <span class="number">2022-03-05T13:21:39Z</span></span><br><span class="line"><span class="string">nodeimages.apps.kruise.io</span>                                 <span class="number">2022-03-05T13:21:39Z</span></span><br><span class="line"><span class="string">podunavailablebudgets.policy.kruise.io</span>                    <span class="number">2022-03-05T13:21:39Z</span></span><br><span class="line"><span class="string">resourcedistributions.apps.kruise.io</span>                      <span class="number">2022-03-05T13:21:39Z</span></span><br><span class="line"><span class="string">sidecarsets.apps.kruise.io</span>                                <span class="number">2022-03-05T13:21:39Z</span></span><br><span class="line"><span class="string">statefulsets.apps.kruise.io</span>                               <span class="number">2022-03-05T13:21:39Z</span></span><br><span class="line"><span class="string">uniteddeployments.apps.kruise.io</span>                          <span class="number">2022-03-05T13:21:39Z</span></span><br><span class="line"><span class="string">workloadspreads.apps.kruise.io</span>                            <span class="number">2022-03-05T13:21:39Z</span></span><br><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span>  <span class="string">get</span> <span class="string">validatingwebhookconfigurations</span> <span class="string">kruise-validating-webhook-configuration</span> </span><br><span class="line"><span class="string">NAME</span>                                      <span class="string">WEBHOOKS</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">kruise-validating-webhook-configuration</span>   <span class="number">17</span>         <span class="string">17m</span></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span>  <span class="string">get</span> <span class="string">mutatingwebhookconfigurations</span> <span class="string">kruise-mutating-webhook-configuration</span> </span><br><span class="line"><span class="string">NAME</span>                                    <span class="string">WEBHOOKS</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">kruise-mutating-webhook-configuration</span>   <span class="number">11</span>         <span class="string">17m</span></span><br></pre></td></tr></table></figure>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><table>
<thead>
<tr>
<th>大类</th>
<th>子类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>通用工作负载</td>
<td>CloneSet</td>
<td>定位是用来代替k8s的Deployment，但做了很多能力的增强。增强的功能点：<br>1. 支持声明pvc，给pod来申请pv。当pod销毁后，pvc会同步销毁。<br>2. 指定pod来进行缩容。<br>3. 流式扩容，可以指定扩容的步长等更高级的库容特性。<br >4. 分批灰度。<br>5. 通过partition回滚。<br>6. 控制pod的升级顺序。<br>7. 发布暂停。<br>8. 原地升级自动镜像预热。<br>9. 生命周期钩子。pod的多个声明周期之间可以读取finalizer，如果finalizer中有指定的值，则controller会停止。该行为作为k8s的一种hook方式，用户可以自定义controller来控制finalizer的行为。</td>
</tr>
<tr>
<td>通用工作负载</td>
<td>Advanced StatefulSet</td>
<td>用来取代k8s原生的StatefulSet，很多增强特性跟CloneSet比较类似。<br>1. 原地升级。<br>2. 升级顺序增强。<br>3. 发布暂停。<br>4. 原地升级自动预热。<br>5. 序号跳过。StatefulSet创建的pod的后缀会从0开始依次累加，可以指定某个特定的序号跳过。<br>6. 流式扩容。</td>
</tr>
<tr>
<td>通用工作负载</td>
<td>Advanced DaemonSet</td>
<td>用来取代k8s原生的DaemonSet。1. 热升级<br>2. 暂停升级<br></td>
</tr>
<tr>
<td>任务工作负载</td>
<td>BroadcastJob</td>
<td>agent类型的job，每个节点上都会执行</td>
</tr>
<tr>
<td>任务工作负载</td>
<td>AdvancedCronJob</td>
<td>原生的CronJob的扩展版本，可以周期性创建BroadcastJob。</td>
</tr>
<tr>
<td>Sidecar容器管理</td>
<td>SidecarSet</td>
<td>用来管理Sidecar容器，其最核心的功能是支持在pod不重启的情况下Sidecar容器的热升级</td>
</tr>
<tr>
<td>多区域管理</td>
<td>WorkloadSpread</td>
<td>将workload按照不同的策略来打散，随着k8s功能不断完善，部分功能k8s已经具备。支持Deployment、ReplicaSet、CloneSet。</td>
</tr>
<tr>
<td>多区域管理</td>
<td>UnitedDeployment</td>
<td>k8s集群内可能存在不同种类型的node，该特性通过UnitedDeployment对象来管理将一个workload的不同pod分发到不同类型的节点上，并且可以指定不同类型节点的pod副本数。</td>
</tr>
<tr>
<td>增强运维</td>
<td>重启一个pod中的某个容器</td>
<td>该特性依赖于kurise-daemon组件实现，通过将容器进程停掉，kubelet检测到容器停掉后会自动将容器拉起。停掉容器的方式跟kubelet实现一致。</td>
</tr>
<tr>
<td>增强运维</td>
<td>镜像预热</td>
<td>通过ImagePullJob CR提供操作入口，底层的实现通过调用CRI的pod image接口实现</td>
</tr>
<tr>
<td>增强运维</td>
<td>控制pod中容器的启动顺序</td>
<td>kruise创建一个ConfigMap，并在pod中注入来挂载该ConfigMap，每个容器使用ConfigMap中的不同key。kruise依次往CM中增加key来实现控制容器启动顺序的目的。</td>
</tr>
<tr>
<td>增强运维</td>
<td>资源分发ResourceDestribution</td>
<td>可以跨namespace来分发CM、Secret，保证每个namespace下均有</td>
</tr>
<tr>
<td>应用安全防护</td>
<td>资源删除防护</td>
<td>通过webhook技术实现</td>
</tr>
<tr>
<td>应用安全防护</td>
<td>PodUnavailableBudget</td>
<td>通过webhook实现的k8s原生的pdb能力的增强，覆盖pdb不具备的场景</td>
</tr>
</tbody></table>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a href="https://openkruise.io/zh/docs/installation">https://openkruise.io/zh/docs/installation</a></li>
<li><a href="https://mp.weixin.qq.com/s/0YulmrteQSARXHa2NOBLeA">如何基于 OpenKruise 打破原生 Kubernetes 中的容器运行时操作局限？</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>PXE</title>
    <url>/post/PXE/</url>
    <content><![CDATA[<p>重装过电脑操作系统的同学大概知道操作系统的安装流程如下：</p>
<ol>
<li>在 BIOS 中将系统设置为光驱&#x2F;USB开机优先模式</li>
<li>以DVD或者 U 盘中的操作系统开机，进入到装机界面</li>
<li>完成一系列的装机初始化，比如磁盘分区、语言选择等</li>
<li>重启进入新安装的操作系统</li>
</ol>
<p>以上过程必须要手工才能完成，安装一台电脑还可以，但如果要大批量安装一批机器就不适用了。为此，Intel 公司研发了 PXE(Pre-boot Execution Environment) 技术，可以通过网络的方式批量安装操作系统。</p>
<p>PXE 基于 C&#x2F;S 架构，分为PXE client 和PXE server，其中 PXE client 为要安装操作系统的机器，PXE server 用来提供安装操作系统必须的镜像等信息。要想实现从网络上安装操作系统，必须要解决如下几个问题：</p>
<ol>
<li>因为还没有安装操作系统，此时并不存在 ip 地址，在装机之前必须要获取到一个 ip 地址。</li>
<li>安装操作系统需要的 boot loader 和操作系统镜像如何获取。</li>
</ol>
<p>为了解决 PXE client 的 ip 地址问题，PXE 中采用了 DHCP 协议来给 client 分配 ip 地址，这就要求 PXE server 必须要运行 dhcp server。为了解决 PXE server 可以提供 boot loader 和操作系统基线，PXE server 通过 tftp 协议的方式对 client 提供服务。</p>
<p>client 端需要 DHCP client 和 tftp client 的功能，为此 PXE 协议中将该功能以硬件的方式内置在网卡 ROM 中。当启动时，BIOS 会加载内置在网卡中的 ROM，从而该机器具备了 DHCP client 和 tftp client 的功能。</p>
<p>优点：</p>
<ol>
<li>规模化：可以批量实现多台服务器的安装</li>
<li>自动化：可以自动化安装</li>
<li>远程实现：不用本地的光盘来安装 OS</li>
</ol>
<p>客户机的前提条件：</p>
<ol>
<li>网络必须要支持 PXE 协议</li>
<li>主板支持网络引导，一般在 BIOS 中可以配置</li>
</ol>
<p>服务端：</p>
<ol>
<li>DHCP 服务，用来给客户机分配 ip 地址</li>
<li>TFTP 服务：用来提供操作系统文件的下载</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>阿里云容器服务ack技术调研（个人笔记）</title>
    <url>/post/ack/</url>
    <content><![CDATA[<p>阿里云容器服务是阿里云公有云基于Kubernetes企业级服务，在社区的Kubernetes版本基础上有能力增强， 本文用于调研社区增强功能，记录解决的问题、以及实现方法。ACK集群的增强功能有一部分是基于Kubernetes的api的prodiver实现，另外一部分是基于Kubernetes增加的额外组件，其中很多都已经开源，可以看到<a href="https://help.aliyun.com/document_detail/196039.html">开源软件</a>列表。</p>
<p>ACK的一些组件列表可以参见：<a href="https://help.aliyun.com/document_detail/277412.html">组件概述</a></p>
<h1 id="产品形态"><a href="#产品形态" class="headerlink" title="产品形态"></a>产品形态</h1><ul>
<li>专有版Kubernetes：master和worker阶段均需要创建</li>
<li>托管版Kubernetes：只需要创建worker节点，master节点通过ack托管</li>
<li>Serverless Kubernetes：master节点和worker节点均不需要自己创建</li>
</ul>
<h1 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h1><table>
<thead>
<tr>
<th>大类</th>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>节点</td>
<td>节点自动扩缩容</td>
<td>完全利用k8s的autoscaler实现，提供了白屏的配置功能。<a href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md?spm=a2c4g.11186623.0.0.5e09135f2AAa2u&file=FAQ.md">https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md?spm=a2c4g.11186623.0.0.5e09135f2AAa2u&file=FAQ.md</a></td>
</tr>
<tr>
<td></td>
<td>节点资源变配</td>
<td>master和worker节点的资源变配，通过调用ecs的变配规格接口来实现。</td>
</tr>
<tr>
<td>节点池</td>
<td></td>
<td>将节点进行了分组，同一个分组内的节点可以统一来管理。比如，可以统一设置标签污点、设置期望节点数。通过节点池实现，节点池跟弹性伸缩组为一对一关系。</td>
</tr>
</tbody></table>
<h1 id="弹性伸缩"><a href="#弹性伸缩" class="headerlink" title="弹性伸缩"></a>弹性伸缩</h1><table>
<thead>
<tr>
<th>类型</th>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>调度层</td>
<td>hpa</td>
<td>基于k8s的hpa功能实现</td>
</tr>
<tr>
<td></td>
<td>自定义指标的hpa</td>
<td>基于<a href="https://github.com/kubernetes-sigs/prometheus-adapter">prometheus-adapter</a>实现的自定义指标监控</td>
</tr>
<tr>
<td></td>
<td>vpa</td>
<td>适用于大型单体应用。k8s的vpa功能实现，基于cluster-autoscaler实现</td>
</tr>
<tr>
<td></td>
<td>CronHPA</td>
<td>定期对pod进行伸缩，组件已开源：<a href="https://github.com/AliyunContainerService/kubernetes-cronhpa-controller">kubernetes-cronhpa-controller</a></td>
</tr>
<tr>
<td></td>
<td>ElasticWorkload</td>
<td></td>
</tr>
<tr>
<td>资源层</td>
<td>节点自动伸缩</td>
<td>k8s的node自动伸缩，基于社区的cluster-autoscaler实现</td>
</tr>
<tr>
<td></td>
<td>使用ECI弹性调度</td>
<td>通过virtual-kubelet实现，将ECI抽象为k8s的node节点</td>
</tr>
</tbody></table>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><table>
<thead>
<tr>
<th>大类</th>
<th>特性</th>
<th>详细描述</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>基于Alibaba Cloud Linux 2支持等保2.0三级加固</td>
<td></td>
</tr>
<tr>
<td></td>
<td>基于Alibaba Cloud Linux 2支持CIS安全加固</td>
<td></td>
</tr>
<tr>
<td>基础设施</td>
<td>使用阿里云KMS提供Secret的落盘加密功能</td>
<td>在默认情况下，k8s的Secret是基于base64转码后明文存储的，存在一定的安全风险。<a href="https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/#ensuring-all-secrets-are-encrypted">k8s提供了使用外部的KMS provider来对Secret的数据进行加密的功能</a>，apiserver和provider之间的通讯协议采用<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/storage/value/encrypt/envelope/v1beta1/service.proto">grpc接口</a>。Secret中的数据在经过KMS provider加密后存储在etcd中。ACK借助阿里云的秘钥管理服务（KMS）提供了provider实现，该<a href="https://github.com/AliyunContainerService/ack-kms-plugin?spm=a2c4g.11186623.0.0.1cf429ecKKZx1J">provider完全开源</a>。</td>
</tr>
<tr>
<td></td>
<td>为pod动态配置阿里云产品白名单</td>
<td>ack-kubernetes-webhook-injector组件会自动将pod ip添加到阿里云产品的白名单中。</td>
</tr>
<tr>
<td></td>
<td>k8s审计日志白屏化展示</td>
<td></td>
</tr>
<tr>
<td></td>
<td>安全巡检功能</td>
<td>基于CIS Kubernetes基线的实现，用来校验k8s的安全性</td>
</tr>
<tr>
<td>容器</td>
<td>配置容器安全策略</td>
<td>基于opa实现的策略引擎，可以根据预置的规则对k8s中创建的资源进行校验，校验不通过会返回失败</td>
</tr>
<tr>
<td></td>
<td>通过巡检来检查集群中存在的安全隐患的pod</td>
<td>无</td>
</tr>
</tbody></table>
<h1 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h1><table>
<thead>
<tr>
<th>大类</th>
<th>功能项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>日志</td>
<td>日志采集功能基于logtail实现，可以采集容器日志</td>
<td>类似于开源组件log-pilot，仅需要配置环境变量，即可对日志进行收集。也可以通过AliyunLogConfig CR旁路的对日志采集进行配置。</td>
</tr>
<tr>
<td>日志</td>
<td>coredns日志</td>
<td>收集coredns日志</td>
</tr>
<tr>
<td>监控</td>
<td>基于arms产品支持应用性能监控</td>
<td></td>
</tr>
<tr>
<td>监控</td>
<td>基于ahas产品实现的架构感知监控</td>
<td></td>
</tr>
<tr>
<td>监控</td>
<td>node节点异常监控</td>
<td>npd将节点异常信息产生k8s的event</td>
</tr>
<tr>
<td>监控</td>
<td>k8s event监控</td>
<td>kube-eventer收集k8s的event</td>
</tr>
</tbody></table>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>Container OS：为容器场景而生的操作系统，操作系统镜像大大精简，提供了安全加固能力，不支持单个软件包的升级，软件包只能跟操作系统一起原子升级。<br>安全容器katacontainer</p>
<h1 id="容器-amp-镜像"><a href="#容器-amp-镜像" class="headerlink" title="容器&amp;镜像"></a>容器&amp;镜像</h1><table>
<thead>
<tr>
<th>大类</th>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>镜像</td>
<td>容器镜像服务ACR</td>
<td>使用公有云的容器镜像服务ACR</td>
</tr>
<tr>
<td></td>
<td>验证容器镜像</td>
<td>基于开源组件kritis的kritis-validation-hook组件通过webhook的方式对镜像进行验证，确保镜像安全</td>
</tr>
</tbody></table>
<h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><table>
<thead>
<tr>
<th>大类</th>
<th>特性</th>
<th>解决问题</th>
<th>适用场景</th>
<th>具体实现</th>
</tr>
</thead>
<tbody><tr>
<td>pod调度</td>
<td>使用Descheduler组件对Pod进行调度优化</td>
<td>k8s的调度为静态的，可以确保在pod调度时为最优的，但当集群运行一段时间后，集群中资源水位会发生变化，此处无法保证整个集群是最优的。</td>
<td></td>
<td>使用社区的开源组件Descheduler对pod进行重新调度</td>
</tr>
<tr>
<td>cpu调度</td>
<td>cpu拓扑感知调度</td>
<td>k8s的cpu manager特性解决的是pod调度到同一个节点上后，通过cpuset来隔离pod的cpu争抢。但却缺乏集群级别的资源视角，从而无法做到全局最优。该特性解决cpu密集型的pod调度到同一个节点上后的争抢问题，允许不是Guaranteed级别的pod实现cpuset特性。</td>
<td>cpu敏感型应用</td>
<td>通过调度器扩展来实现pod的cpu优化调度。ack-slo-manager agent负责实现每台机器上的绑核策略。</td>
</tr>
<tr>
<td></td>
<td>cpu Brust策略优化容器性能</td>
<td>k8s的cpu limit机制会在特定的时间段内将进程可以使用的时间片进行限制。但该特性不太适合一些突发类的应用，会导致这类应用在想要cpu的时间不够用，但不想用的时候却有空闲的时间片。</td>
<td>cpu突发型应用</td>
<td>ack通过slo-manager实现cpu brust的优化，该组件会监控容器的cpu throtteld状态，并且动态调整容器中的cgroup cfs quota限制。每个节点上会部署一个resource-controller的组件来动态修改pod的cgroup配置。</td>
</tr>
<tr>
<td></td>
<td>动态调整pod的资源上限</td>
<td>k8s中要想修改pod的limit配置，只能修改pod的yaml，此时一定会导致pod重建。对于想调整pod的limit限制，却又不想重启pod的场景。</td>
<td></td>
<td>通过一个Cgroups的CR来对pod使用的cpu、内存以及磁盘的上限进行动态调整，但并不会修改pod的yaml配置，因此不会导致pod的重建。每个节点上会部署一个resource-controller的组件来动态修改pod的cgroup配置。</td>
</tr>
<tr>
<td></td>
<td>通过控制L3 cache和MBA提高不同优先级任务的隔离能力</td>
<td>不同优先级的任务调度到同一台机器上存在L3 Cache和内存带宽的资源争抢的问题</td>
<td>cpu敏感型应用</td>
<td>底层利用Intel的<a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/resource-director-technology.html?spm=a2c4g.11186623.0.0.77dc7ccaJFCP94">RDT技术</a>来实现，该技术可以跟踪和控制同一台机器上同时运行的多个应用程序的共享资源情况，比如L3 Cache、内存带宽。每个节点上会部署一个resource-controller的组件来应用RDT的控制。</td>
</tr>
<tr>
<td></td>
<td>控制动态水位提高不同优先级pod的资源利用效率</td>
<td>为了充分利用机器资源，通常将不同优先级的pod部署在同一个节点上，pod的优先级往往随着时间段而有所变化。在白天的时候，在线业务pod优先级高；晚上离线任务优先级高。该特定可以调整一个节点上pod可以使用的资源上限。</td>
<td>在线业务pod和离线业务pod混部</td>
<td>通过ConfigMap来配置一台机器上的在线业务和离线业务可以使用的资源比例。通过Cronjob的方式来修改ConfigMap的配置，从而达到变配的效果。</td>
</tr>
<tr>
<td></td>
<td>动态资源超卖</td>
<td>一台机器上的pod在设计request和limit的时候总会预留一部分buffer，如果将所有pod的buffer加起来就非常多，从而导致机器的资源利用率很难上去。</td>
<td>pod预留buffer</td>
<td>引入了reclaimed资源来解决，未完全理解实现。文档：<a href="https://help.aliyun.com/document_detail/412172.html">动态资源超卖</a></td>
</tr>
<tr>
<td>gpu调度</td>
<td>GPU拓扑感知调度</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>共享GPU调度</td>
<td>GPU核共享</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FPGA调度</td>
<td>暂未深入研究</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>任务调度</td>
<td>Gang scheduling</td>
<td>Coscheduling将N个pod调度到M个节点上同时运行，需要部分pod同时启动该批处理任务即可运行。如果允许的部分pod为N时，则退化为Gang Scheduling。该场景要求pod要同时创建。</td>
<td>批处理任务</td>
<td>基于Scheduling Framework实现的自定义调度器，核心机制是借助了Permit插件的pod延迟绑定功能，等到同一个group下的pod都创建后再调度。参考文章：<a href="https://developer.aliyun.com/article/766275">支持批任务的Coscheduling&#x2F;Gang scheduling</a></td>
</tr>
<tr>
<td></td>
<td>Binpack scheduling</td>
<td>k8s默认的调度策略会将pod优先分配到空闲的节点上，但这样集群中的节点会存在资源碎片化的问题。Binpack调度策略会优先将节点的资源用完。</td>
<td>减少资源碎片化，尤其是GPU场景</td>
<td>基于Scheduling Framework实现的自定义调度器。参考文章：<a href="https://developer.aliyun.com/article/770336">支持批任务的Binpack Scheduling</a></td>
</tr>
<tr>
<td></td>
<td>Capacity Scheduling</td>
<td>k8s支持的namespace ResourceQuota特性可以设置一个namespace下的pod可以使用的资源上限，但不够灵活。比如一个namespace下资源耗尽，另外一个namespace还有额外的资源，但这部分资源却不能给资源耗尽的namespace使用。</td>
<td>namespace ResourceQuota特性增强</td>
<td>使用ElasticQuotaTree的方式来定义每个namespace下可以使用的资源最小值和资源上限，配合Scheduling Framework扩展来实现。</td>
</tr>
<tr>
<td>弹性调度</td>
<td>ECI弹性调度</td>
<td>充分利用ECI的弹性功能，解决k8s的node资源不够灵活的问题。</td>
<td>将pod调度到ECI</td>
<td>virtual kubelet技术将ECI抽象为k8s的node，并将pod指向调度到该node。调度到该node的pod最终会在ECI拉起容器。</td>
</tr>
<tr>
<td></td>
<td>自定义资源的优先级调度</td>
<td>k8s的调度器的策略采用固定的算法，会将所有node一视同仁，并不能针对某种类型的节点采用不同的策略。</td>
<td>自定义基于node调度策略</td>
<td>引入CRD ResourcePolicy用来定义节点调度的优先级。</td>
</tr>
<tr>
<td>负载感知调度</td>
<td>负载感知调度</td>
<td>在pod调度时，参考node节点历史的负载信息，优先将pod调度到负载较低的节点上，避免出现单个节点负载过高的情况。</td>
<td>避免node的资源使用率不均</td>
<td>通过调度器扩展实现，pod要开启该特性需要增加特性的annotation。</td>
</tr>
</tbody></table>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><table>
<thead>
<tr>
<th>大类</th>
<th>特性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>容器网络</td>
<td>terway网络</td>
<td>基于ENI实现，支持ipvlan模式，基于ipvlan和eBPF实现。NetworkPolicy基于eBPF实现。</td>
</tr>
<tr>
<td></td>
<td>terway网络的Hubble组件</td>
<td>基于eBPF实现的网络流量可视化</td>
</tr>
<tr>
<td></td>
<td>为pod挂载独立公网ip</td>
<td>pod声明annotation k8s.aliyun.com&#x2F;pod-with-eip:”true”</td>
</tr>
<tr>
<td>Service网络</td>
<td>ccm跨集群部署服务</td>
<td>同一个vip可以挂载到两个k8s集群内部的Service</td>
</tr>
<tr>
<td>Ingress</td>
<td>基于Nginx Ingress实现灰度发布</td>
<td>扩展Nginx Ingress实现</td>
</tr>
<tr>
<td></td>
<td>通过AHAS支持流控特性</td>
<td></td>
</tr>
<tr>
<td></td>
<td>基于Nginx Ingress实现流量复制</td>
<td></td>
</tr>
<tr>
<td></td>
<td>基于ALB实现了ALB Ingress</td>
<td>数据面直接使用ALB的七层负载均衡功能</td>
</tr>
<tr>
<td>DNS</td>
<td>引入kubernetes项目中的addon组件NodeLocal DNSCache来增加cache层</td>
<td><a href="https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/dns/nodelocaldns">NodeLocal DNS Cache</a> nodelocal dns cache位于kubernetes项目中，以DaemonSet的方式运行在k8s集群中</td>
</tr>
<tr>
<td></td>
<td>ExternalDNS服务</td>
<td>用来将DNS注册到外部的公共域名服务器</td>
</tr>
<tr>
<td></td>
<td>使用DNSTAP Analyser诊断异常</td>
<td>s使用CoreDNS DNSTAP Analyser组件来接收coredns的DNS解析报文格式dnstap协议，并最终可以输出到sls对异常的DNS解析报文进行分析。</td>
</tr>
</tbody></table>
<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>存储为ACK的一大亮点，借助云的丰富存储类型，通过k8s的CSI插件机制提供了块存储、文件存储、对象存储OSS和本地存储的支持。</p>
<p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2022/png/220839/1645347493244-2af51b21-0150-48e4-a15e-0585d5a59852.png#clientId=ub8a97252-9d7b-4&from=paste&height=916&id=ufabccb6c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=916&originWidth=2458&originalType=binary&ratio=1&size=143128&status=done&style=none&taskId=uf542f250-6209-4734-8564-306faaaaca5&width=2458" alt="image.png"></p>
<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><ol>
<li>LVM数据卷功能，基于lvm来动态创建pv</li>
<li>QuotaPath，基于ext4的quota特性实现的本地存储的quota隔离功能</li>
<li>内存数据卷</li>
<li>持久化内存技术</li>
</ol>
<h2 id="云盘存储卷"><a href="#云盘存储卷" class="headerlink" title="云盘存储卷"></a>云盘存储卷</h2><ol>
<li>支持云盘的在线扩容，k8s 1.16版本之前可以手工扩容磁盘，但是pvc保持必变。在k8s 1.16之后，在pvc修改后，可以自动完成云盘的扩容。</li>
<li>可根据磁盘的使用水位支持云盘的自动扩容，该功能通过额外的组件storage-operator来实现，策略存放到了额外的CRD StorageAutoScalerPolicy。跟k8s的hpa和vpa功能相比，该功能没有自动缩容的功能。</li>
<li>使用k8s的存储快照功能实现了存储快照。k8s定义了VolumeSnapshotContent（类似pv）、VolumeSnapshot（类似pvc）和VolumeSnapshotClass（类似StorageClass）三个类型来实现打快照功能，快照的恢复则借助pvc的spec.dataSource字段实现。</li>
<li>加密云盘功能，同样借助云上能力实现。使用时，仅需要在StorageClass的parameters参数中指定加密参数即可。</li>
</ol>
<h1 id="Serverless-Kubernetes（ASK）"><a href="#Serverless-Kubernetes（ASK）" class="headerlink" title="Serverless Kubernetes（ASK）"></a>Serverless Kubernetes（ASK）</h1><p>适用场景：</p>
<ol>
<li>业务要求高弹性，如互联网在线服务存在波峰波谷特别明显</li>
</ol>
<p>ACK提供了k8s以及k8s的管理功能，其中k8s的master节点需要单独创建和维护，每个k8s集群使用的资源是完全独立的。在ASK中，用户仅需要创建k8s集群，而不需要关心k8s集群的核心组件具体是怎么创建的。</p>
<p>在实际上，k8s的核心组件如etcd、kube-apiserver、kube-scheduler、kube-controller-manager可能是以pod的形式运行在另外的k8s集群之上，即所谓的k8s on k8s（KOK）的方案。而且这部分组件是多个k8s集群混部的，对用户完全屏蔽了实现细节，用户仅需要聚焦在如何使用k8s即可。</p>
<p>对于k8s的node节点，用户同样不需要创建，可以认为k8s的节点资源是无限多的。ask采用了virtual kubelet的技术创建了一个虚拟的k8s node节点 <code>virtual-kubelet-$&#123;region&#125;-$&#123;zone&#125;</code>，整个k8s集群仅有一个节点。因为只有一个k8s节点，实际上k8s的管控作用会大大弱化，尤其是kube-scheduler，因为只有一个k8s节点，不存在pod调度的问题。</p>
<p>用户创建的pod资源，实际上会部署在阿里云产品弹性容器实例ECI上。新创建ask集群完成后，再到ECI上即可看到有默认的容器创建出来。ECI了创建容器的功能，给用户暴露的功能是跟k8s无关的，而ask相当于是给用户提供了以k8s的方式来创建容器。</p>
<p>ask还集成了knative，用户可以使用knative的Serving和Eventing的功能来实现社区通用的serverless服务。</p>
<p>相关链接：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/3zxbdvx2LmeAjt74xqhVbw">全新的网关能力增强</a></li>
</ul>
<h1 id="分布式云容器平台ACK-One"><a href="#分布式云容器平台ACK-One" class="headerlink" title="分布式云容器平台ACK One"></a>分布式云容器平台ACK One</h1><p>ack one提供了两个相对独立的功能，一个是第三方k8s集群的注册，另外一个是k8s多集群的管理和应用发布。两个功能的入口也未统一，其中一个是在ack界面，另外一个是在分布式云容器平台ack one。</p>
<p>第三方k8s集群的注册，允许用户将自己的k8s集群注册到ack上，可以从ack上来管理用户的k8s集群，而且可以部署一些ack自己的组件到用户的k8s集群上面。需要在用户的k8s集群部署一个ack-cluster-agent的服务，在用户的k8s集群跟ack可达的情况下，即可完成用户k8s集群的托管。</p>
<p>k8s多集群的管理功能，底层直接使用了kubevela项目，实现了k8s多集群的管理、多集群的应用发布功能。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>集群成本分析</p>
]]></content>
  </entry>
  <entry>
    <title>解决airodump-ng显示ssid名称的乱码问题</title>
    <url>/post/airodump-ng_ssid_messy/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>无线wifi的essid支持英文和中文，中文的编码在802.11协议并没有规定，对于802.11协议而言仅将essid看作是二进制。而中文又存在多种编码方式，最常见的就是GB18030（我这里直接用GB18030代替了GB系列的字符集）和UTF-8了。</p>
<p>iwlist程序通过命令<code>iwlist wlan0 scanning</code>可以在终端上正常显示UTF-8编码的essid，对于其他编码的中文仍然是乱码，这也就非常容易理解了。因为具体的essid能否将中文正常显示在终端屏幕上跟essid的编码和当前终端环境的编码是否能够匹配有关，如果essid的编码和当前终端环境的编码均为UTF-8，则essid可以在屏幕上正常显示。如果当前网络中的可以搜索到的essid即包含了GB18030编码又包含了UTF-8编码，则打印在终端上的essid必然会有乱码的情况出现。</p>
<h1 id="airodump-ng程序问题"><a href="#airodump-ng程序问题" class="headerlink" title="airodump-ng程序问题"></a>airodump-ng程序问题</h1><p>对于airodump-ng程序而言，即时是essid的编码和终端编码一致也会出现某些中文字符乱码的问题，这一点比较奇怪。比如“免费”中的“免”字是乱码，“费”却能正常显示。通过这一现象有理由怀疑airodump-ng对essid做了某些处理。</p>
<p>经过查看源码发现，在airodump-ng.c文件中存在三处如下类似代码，作用为将essid中的ascii值在(126,160)之间的转换为”.”。看来airodump-ng程序并没有考虑到中文的情况，仅将ascii中无法显示的字符做了转换。将程序中的三处代码注释后就可以正常显示了。具体三处代码可以通过搜索’.’来查找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">&#123;</span><br><span class="line">	c = p[<span class="number">2</span> + i];</span><br><span class="line">	<span class="keyword">if</span>( c == <span class="number">0</span> || ( c &gt; <span class="number">126</span> &amp;&amp; c &lt; <span class="number">160</span> ) )</span><br><span class="line">	&#123;</span><br><span class="line">		c = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">//could also check ||(c&gt;0 &amp;&amp; c&lt;32)</span></span><br><span class="line">	&#125;</span><br><span class="line">	st_cur-&gt;probes[st_cur-&gt;probe_index][i] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="NetworkManager"><a href="#NetworkManager" class="headerlink" title="NetworkManager"></a>NetworkManager</h1><p>通过实践发现，GNOME和KDE桌面下的查看无线网络连接的ssid是可以正常显示的，即可以正常显示GB18030，又可以正常显示UTF-8编码的essid。则可以推测，在桌面环境下的搜索网络的程序肯定对编码做了某些处理，顺着这个思路，就可以查找GNOME或KDE的代码了。</p>
<p>在GNOME的源码中看到了network-manager-applet，该程序即为桌面上查看无线网络连接的小控件。在applet-device-wifi.c文件中看到了如下代码，其中的<code>nm_utils_ssid_to_utf8</code>函数即为将其他编码转换为UTF-8编码的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">char</span> *</span></span><br><span class="line"><span class="function"><span class="title">get_ssid_utf8</span> <span class="params">(NMAccessPoint *ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *ssid_utf8 = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">const</span> GByteArray *ssid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ap) &#123;</span><br><span class="line">		ssid = <span class="built_in">nm_access_point_get_ssid</span> (ap);</span><br><span class="line">		<span class="keyword">if</span> (ssid)</span><br><span class="line">			ssid_utf8 = <span class="built_in">nm_utils_ssid_to_utf8</span> (ssid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!ssid_utf8)</span><br><span class="line">		ssid_utf8 = <span class="built_in">g_strdup</span> (_(<span class="string">&quot;(none)&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ssid_utf8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nm_utils_ssid_to_utf8</code>函数定义在NetworkManager工程中的nm-utils.c文件中。该函数的代码如下，该函数具体功能可以查看代码中的注释，已经非常详细了。其中以<code>g_</code>开头的函数是glib库中的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *</span></span><br><span class="line"><span class="function"><span class="title">nm_utils_ssid_to_utf8</span> <span class="params">(<span class="type">const</span> GByteArray *ssid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *converted = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span> *lang, *e1 = <span class="literal">NULL</span>, *e2 = <span class="literal">NULL</span>, *e3 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">g_return_val_if_fail</span> (ssid != <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">g_utf8_validate</span> ((<span class="type">const</span> gchar *) ssid-&gt;data, ssid-&gt;len, <span class="literal">NULL</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">g_strndup</span> ((<span class="type">const</span> gchar *) ssid-&gt;data, ssid-&gt;len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* LANG may be a good encoding hint */</span></span><br><span class="line">	<span class="built_in">g_get_charset</span> ((<span class="type">const</span> <span class="type">char</span> **)(&amp;e1));</span><br><span class="line">	<span class="keyword">if</span> ((lang = <span class="built_in">getenv</span> (<span class="string">&quot;LANG&quot;</span>))) &#123;</span><br><span class="line">		<span class="type">char</span> * dot;</span><br><span class="line"></span><br><span class="line">		lang = <span class="built_in">g_ascii_strdown</span> (lang, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> ((dot = <span class="built_in">strchr</span> (lang, <span class="string">&#x27;.&#x27;</span>)))</span><br><span class="line">			*dot = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">get_encodings_for_lang</span> (lang, &amp;e1, &amp;e2, &amp;e3);</span><br><span class="line">		<span class="built_in">g_free</span> (lang);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	converted = <span class="built_in">g_convert</span> ((<span class="type">const</span> gchar *) ssid-&gt;data, ssid-&gt;len, <span class="string">&quot;UTF-8&quot;</span>, e1, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!converted &amp;&amp; e2)</span><br><span class="line">		converted = <span class="built_in">g_convert</span> ((<span class="type">const</span> gchar *) ssid-&gt;data, ssid-&gt;len, <span class="string">&quot;UTF-8&quot;</span>, e2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!converted &amp;&amp; e3)</span><br><span class="line">		converted = <span class="built_in">g_convert</span> ((<span class="type">const</span> gchar *) ssid-&gt;data, ssid-&gt;len, <span class="string">&quot;UTF-8&quot;</span>, e3, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!converted) &#123;</span><br><span class="line">		converted = <span class="built_in">g_convert_with_fallback</span> ((<span class="type">const</span> gchar *) ssid-&gt;data, ssid-&gt;len,</span><br><span class="line">		                                     <span class="string">&quot;UTF-8&quot;</span>, e1, <span class="string">&quot;?&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> converted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nm_utils_ssid_to_utf8该函数位于libnm-util.so.1动态库中，可通过<code>nm -D  /usr/lib64/libnm-util.so.1 | grep nm_utils_ssid_to_utf8</code>命令查看导出表中存在该函数。但是系统中并不存在该函数的头文件libnm-util.h，给该库的调用增加了不少难度。可以通过将相关头文件引入到该工程编译的方式来完成，但是可能会牵涉到的头文件比较多，比较繁琐。</p>
<p>我这里直接采用了将NetworkManager中相关代码抓取出来的思路，并将其封装成类的形式以方便调用。具体代码可以参照demo中的例子。</p>
<h1 id="glib"><a href="#glib" class="headerlink" title="glib"></a>glib</h1><p>glib是GTK底层调用的核心库，跟glibc是没有关系的，虽然名字中仅差一个字母。为了调用该库需要在编译的时候添加*<code>pkg-config --cflags --libs glib-2.0</code>*信息，以引入需要的头文件和要链接的库。</p>
<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a href="http://pan.baidu.com/s/1qWqjMCc">文中用到的软件源码和程序demo</a></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://git.gnome.org/browse/">GNOME源码列表</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>asleap中的简单文件索引机制</title>
    <url>/post/aleap_idx/</url>
    <content><![CDATA[<p>asleap是一个开源的vpn破解工具，最近查看了asleap的源码，该项目<a href="http://sourceforge.net/projects/asleap/">地址</a>。本文的重点是对其中的带索引的字典文件的产生过程进行介绍，产生带索引的字典文件并不复杂，但是要想用简洁易懂的语言将该问题描述明白却不容易。</p>
<p>asleap破解vpn的机制是通过字典文件暴力破解的方式，该字典文件有dat数据文件和idx索引文件两个文件组成，两个文件均为二进制格式。asleap工程中自带了genkey程序，可以将文本的字典文件转换为asleap程序需要的带索引的字典文件。</p>
<p>本文以字典文件为以下内容讲解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">turquoise</span><br><span class="line">da</span><br><span class="line">test</span><br></pre></td></tr></table></figure>

<h1 id="读取字典文件并产生md4值"><a href="#读取字典文件并产生md4值" class="headerlink" title="读取字典文件并产生md4值"></a>读取字典文件并产生md4值</h1><p>md4编码占16个字节，三个字典进行md4编码后的结果分别为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18 07 33 43 f6 30 b5 f8 2c 38 c0 34 37 f2 81 6b</span><br><span class="line">01 19 a3 80 94 40 60 3c 57 39 5e 73 f3 60 95 98</span><br><span class="line">0c b6 94 88 05 f7 97 bf 2a 82 80 79 73 b8 95 37</span><br></pre></td></tr></table></figure>

<h1 id="将字典信息写入到临时文件"><a href="#将字典信息写入到临时文件" class="headerlink" title="将字典信息写入到临时文件"></a>将字典信息写入到临时文件</h1><p>为了能够对最终生成的dat文件中的内容进行排序和便于索引，程序生成了256个临时文件，文件名格式为从genk-bucket-00.tmp到genk-bucket-ff.tmp。程序根据md4编码中的第14位将字典对应的信息分别写入到临时文件中，一个字典写入到临时文件的内容如下，如果一个临时文件中存在多个字典则依次存放：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashpass_rec</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> rec_size;		<span class="comment">// 一个字典占用文件的大小，包括该变量+字典+字典对应的md4值共占用的字节数</span></span><br><span class="line">    <span class="type">char</span>          *password;	<span class="comment">// 字典</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hash[<span class="number">16</span>];		<span class="comment">// 字典对应的md4值</span></span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure>

<p>本例子中turquoise对应结构体会写入到genk-bucket-81.tmp中，da和test对应结构体会依次写入到genk-bucket-95.tmp中。</p>
<h1 id="读取临时文件并写入到dat数据文件中"><a href="#读取临时文件并写入到dat数据文件中" class="headerlink" title="读取临时文件并写入到dat数据文件中"></a>读取临时文件并写入到dat数据文件中</h1><p>最终dat文件中的数据内容为hashpass_rec的有序集合，排序的原则是按照md4的第14和15两个字节。依次读取256个临时文件中的hashpass_rec可以保证dat文件中的数据内容是按照第14字节排序的，但是不能够保证是按照第15个字节排序的。为了保证最终dat文件中的数据内容是按照第14和15字节有序的，在将一个临时文件中的内容写入到dat文件中前需要对该临时文件中的hashpass_rec结果按照hash变量的第15字节进行排序，直接使用C语言中的qsort进行排序。</p>
<p>该例子中da和test位于同一个临时文件中，需要根据hash变量的第15字节排序的结果为test、da，最终写入到dat文件中的排序结果为turquoise、test、da。</p>
<h1 id="根据dat数据文件产生idx索引文件"><a href="#根据dat数据文件产生idx索引文件" class="headerlink" title="根据dat数据文件产生idx索引文件"></a>根据dat数据文件产生idx索引文件</h1><p>idx索引文件中存放的是多个hashpassidx_rec结果，最多有256*256项，其结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashpassidx_rec</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>	        hashkey[<span class="number">2</span>];	<span class="comment">// 对应md4编码的第14和15字节</span></span><br><span class="line">    <span class="type">off_t</span>                   offset;		<span class="comment">// 第一个匹配的hashpass_rec结构在dat文件中的偏移，占用4个字节</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> 	numrec;		<span class="comment">// dat文件中共有多少个匹配的hashpass_rec结果</span></span><br><span class="line">&#125; __attribute__ ((packed));	<span class="comment">// 字节对齐，需要填充4个字节</span></span><br></pre></td></tr></table></figure>

<p>最终完成的dat文件和idx文件的指向如下图所示：</p>
<p><img src="http://kuring.qiniudn.com/aleap_idx.png" alt="最终完成的dat文件和idx文件的指向"></p>
<h1 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h1><p>genkeys.c文件中在读取字典文件时存在bug，在文件的207行将内容更改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!feof(inputfl)) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(password, <span class="number">0</span>, MAX_NT_PASSWORD + <span class="number">1</span>);</span><br><span class="line">        fgets(password, MAX_NT_PASSWORD+<span class="number">1</span>, inputfl);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strlen</span>(password) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a href="http://pan.baidu.com/s/1jGmVF06">字典文件等相关文件下载</a></p>
]]></content>
  </entry>
  <entry>
    <title>最长公共子序列和最长公共子串问题</title>
    <url>/post/algorithm-max-subarray-or-suborder/</url>
    <content><![CDATA[<p>最长公共子串及公共子序列问题属于一类问题，都可以使用动态规划的算法来解析，且动态规划方式比较类似，比较容易混淆。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>最长公共子串：两个字符串中，相同的最长子串，字符必须是连续的</p>
<p>最长公共子序列：两个字符串中，相同的最长序列，字符不一定是连续的</p>
<p>比如：a[] &#x3D; “abcde” b[] &#x3D; “bce”</p>
<p>那么：<br>最长子串：”bc”<br>最长子序列：”bce”</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>假设A、B分别表示两个字符串</p>
<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><p>dp[i][j]表示子串A[:i]、B[:j]必须以A[i]、B[j]为结尾的两个字符串的最大子串长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if A[i] == B[j] &#123;</span><br><span class="line">    dp[i][j] = dp[i-1][j-1]</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    dp[i][j] = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终dp二维数组中的最大值即为结果</p>
<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>dp[i][j]表示子串A[:i]、B[:j]的两个字符串的最大子序列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if A[i] == B[j] &#123;</span><br><span class="line">    dp[i][j] = dp[i-1][j-1]</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    dp[i][j] = max(dp[i-1][j], dp[i][j-1])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终dp[i-1][j-1]为结果</p>
<h2 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h2><ul>
<li><a href="https://leetcode.com/problems/delete-operation-for-two-strings/">Delete Operation for Two Strings</a> （最长公共子序列）</li>
<li><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/">Maximum Length of Repeated Subarray</a> （最长公共子串）</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>大顶堆小顶堆与堆排序</title>
    <url>/post/algorithm_heap/</url>
    <content><![CDATA[<p>一直对堆排序算法用的不错，但是又是在排序中挺重要的算法，并且可以求解其他问题，比如top k问题。已经对堆排序学习过好多次了，无奈每次都记不太清楚具体的细节问题，本文对堆的问题进行整理。本文的排序例子来源于严蔚敏的《数据结构》，本文的知识点来自《算法导论》。</p>
<p>最大堆为堆中的最大元素位于根节点，顾名思义，最小堆的根节点为最小值。堆的性质决定了堆中节点一定大于等于其子节点。在堆排序算法中用到的是最大堆，最小堆用于构造优先队列，要是使用最小堆进行排序，得到的排序结果为倒序。</p>
<p>堆的结构为完全二叉树，因此可以用数组存储来代替树的链式存储结构。</p>
<h1 id="建最大堆过程"><a href="#建最大堆过程" class="headerlink" title="建最大堆过程"></a>建最大堆过程</h1><p>我这里通过图表的形式对建大顶堆的过程进行了展示，不再对文字进行叙述。在堆排序的过程中会不断进行建最大堆过程的调用。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/heap_sort_create.png" alt="堆的初始化"></p>
<h1 id="堆排序的核心步骤"><a href="#堆排序的核心步骤" class="headerlink" title="堆排序的核心步骤"></a>堆排序的核心步骤</h1><p>清楚了堆的初始化，再看一下下面的堆排序步骤就非常清楚了，不需要图片进行描述了。堆排序的步骤：</p>
<ol>
<li>将待排序的数组初始化为大顶堆，该过程即建堆。</li>
<li>将堆顶元素与最后一个元素进行交换，除去最后一个元素外可以组建为一个新的大顶堆。</li>
<li>新建立的堆不是大顶堆，需要重新建立大顶堆。重复上面的处理流程，直到堆中仅剩下一个元素。</li>
</ol>
<h1 id="top-k问题的堆解法"><a href="#top-k问题的堆解法" class="headerlink" title="top k问题的堆解法"></a>top k问题的堆解法</h1><p>该问题最常规和通用的解决思路为使用快速排序，还可以在N的范围不大的情况下采用哈希（桶）的方式。</p>
<p>另外一种解法就是堆排序的思路来解决。这里用到的为最小堆，用最小堆来存储最大的k个数，其中堆顶元素为最大k个数种最小的数。这个解法初看有些别扭，求最大的k个数，居然会用到小顶堆。</p>
<p>该算法必然是一个个遍历N个数一次就够了，这点很好理解。每读取一个新的数x，如果x比堆顶的元素y小，则抛弃；如果x比y大，则用x替换y，并重新更新堆。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常用排序算法整理及代码实现</title>
    <url>/post/algorithm_sort_code/</url>
    <content><![CDATA[<p>本文对我编写的常用的排序算法进行整理和总结，方便用时进行查阅和参考。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是实际应用中的最好选择，采用了分治法的思想。通过一趟排序将待排序记录分割成独立的两部分，其中一部分的关键字均比另外一部分的小，分别对这两部分记录进行排序，已达到整个有序。</p>
<p>是否稳定：不稳定</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(logn)，需要栈来实现递归用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivotkey = numbers[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; numbers[high] &gt;= pivotkey)</span><br><span class="line">        &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers[low] = numbers[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; numbers[low] &lt;= pivotkey)</span><br><span class="line">        &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers[high] = numbers[low];</span><br><span class="line">        numbers[low] = pivotkey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pivotloc = <span class="built_in">partition</span>(numbers, low, high);</span><br><span class="line">        <span class="built_in">quick_sort</span>(numbers, low, pivotloc - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quick_sort</span>(numbers, pivotloc + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">quick_sort</span>(numbers, <span class="number">0</span>, numbers.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">49</span>&#125;;</span><br><span class="line">    <span class="built_in">quick_sort</span>(numbers);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numbers.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>将两个或两个以上的有序表组合成一个新的有序表。合并两个有序表的方法为：比较两个有序表中第一个数，谁小先取谁。继续进行比较，只要有一个有序表为空，直接将另一个有序表取出即可。</p>
<p>是否稳定：稳定</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(n) （当使用顺序存储时，为了能够实现两个有序表之间的合并），或O(1)（当使用链式存储的时候，不再需要临时的空间来存储排序的结果）</p>
<h2 id="顺序存储代码"><a href="#顺序存储代码" class="headerlink" title="顺序存储代码"></a>顺序存储代码</h2><p>以下为采用顺序存储结构的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序使用递归算法的效率比较低，具体应用中会采用非递归算法代替</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers, std::vector&lt;<span class="type">int</span>&gt; &amp;extra, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> middle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = low, j = middle+<span class="number">1</span>, k = low;</span><br><span class="line">    <span class="keyword">for</span> (; i&lt;=middle &amp;&amp; j&lt;=high; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &lt;= numbers[j])</span><br><span class="line">        &#123;</span><br><span class="line">            extra[k] = numbers[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            extra[k] = numbers[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle)</span><br><span class="line">    &#123;</span><br><span class="line">        extra[k++] = numbers[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= middle)</span><br><span class="line">    &#123;</span><br><span class="line">        extra[k++] = numbers[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = low; m &lt;= high; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        numbers[m] = extra[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers, std::vector&lt;<span class="type">int</span>&gt; &amp;extra, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low == high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(numbers, extra, low, middle);</span><br><span class="line">    <span class="built_in">merge_sort</span>(numbers, extra, middle + <span class="number">1</span>, high);</span><br><span class="line">    <span class="built_in">merge</span>(numbers, extra, low, high, middle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请额外的存储空间来用于排序处理</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; extra = numbers;</span><br><span class="line">    <span class="built_in">merge_sort</span>(numbers, extra, <span class="number">0</span>, numbers.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">49</span>&#125;;</span><br><span class="line">    <span class="built_in">merge_sort</span>(numbers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numbers.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式存储代码"><a href="#链式存储代码" class="headerlink" title="链式存储代码"></a>链式存储代码</h2><p>以下为采用链式存储结构的代码，本答案为我在LeetCode上的<a href="https://leetcode.com/problems/sort-list/">Sort List </a>题目的答案，源码放在<a href="https://github.com/kuring/leetcode/blob/master/src/sortList/sort_list.cpp">我的Github上</a>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用归并排序方法，核心思想为将数组拆分为两半，分别对两半进行排序，排序完成后再进行一次排序，排序算法就可以采用插入排序的方式。</span></span><br><span class="line"><span class="comment"> * 对两半排序的算法仍然采用归并排序算法，即问题为递归问题</span></span><br><span class="line"><span class="comment"> * 在使用线性存储结果的归并排序算法中，会使用额外的空间来存储临时结果，空间复杂度为O(n)，而在链式存储中，空间复杂度为O(1)</span></span><br><span class="line"><span class="comment"> * 归并排序的时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="comment"> * 如果存储结构为双向链表，可以使用快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 仅有两个元素，对两个元素进行排序后直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val &lt; head-&gt;next-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = head-&gt;next;</span><br><span class="line">            tmp-&gt;next = head;</span><br><span class="line">            tmp-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了找到中间节点，这里采用快慢指针的方式，否则需要使用先遍历一次取长度，然后找到中间位置的两次遍历方式</span></span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    ListNode *slow_prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow_prev = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = slow_prev-&gt;next;</span><br><span class="line">    slow_prev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别对两段链表进行排序</span></span><br><span class="line">    slow = <span class="built_in">sortList</span>(head);</span><br><span class="line">    fast = <span class="built_in">sortList</span>(fast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对两段链表进行合并</span></span><br><span class="line">    ListNode *node = <span class="literal">nullptr</span>, *result = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="literal">nullptr</span> &amp;&amp; fast != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow-&gt;val &lt; fast-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;next = slow;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node = slow;</span><br><span class="line">                result = slow;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;next = fast;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node = fast;</span><br><span class="line">                result = fast;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slow != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;next = slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;next = fast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p>该排序算法的时间复杂度为O(n^2)，算法复杂度过高。分为顺序存储和链式存储两种算法，其中顺序存储每比较一个元素是从该元素往前比较的，而链式存储是从链头开始比较的，这点有所不同，造成不同的是由存储结构决定的。</p>
<h2 id="顺序存储代码-1"><a href="#顺序存储代码-1" class="headerlink" title="顺序存储代码"></a>顺序存储代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void insertion_sort(std::vector&lt;int&gt; &amp;numbers)</span><br><span class="line">&#123;</span><br><span class="line">	if (numbers.size() &lt;= 1)</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 1; i &lt; numbers.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int j = i; j &gt; 0; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			if (numbers[j] &lt; numbers[j - 1])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(numbers[j], numbers[j - 1]);</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[] = &#123; 49, 38, 65, 97, 76, 13, 27, 49 &#125;;</span><br><span class="line">	vector&lt;int&gt; numbers(a, a + sizeof(a) / sizeof(int));</span><br><span class="line">	insertion_sort(numbers);</span><br><span class="line">	for (int i = 0; i&lt;numbers.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d\t&quot;, numbers[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式存储代码-1"><a href="#链式存储代码-1" class="headerlink" title="链式存储代码"></a>链式存储代码</h2><p>以下代码为LeetCode上的链式存储的情况时的直接插入排序算法的代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    ListNode *node = head-&gt;next;</span><br><span class="line">    ListNode *new_head = head;</span><br><span class="line">    new_head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *node_next = node-&gt;next;   <span class="comment">// 先将当前遍历的下一个节点保存</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前节点插入到新链表中</span></span><br><span class="line">        ListNode *new_node_tmp = new_head;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val &lt; new_node_tmp-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前节点插入新链表的第一个位置</span></span><br><span class="line">            node-&gt;next = new_head;</span><br><span class="line">            new_head = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将当前节点插入到中间</span></span><br><span class="line">            <span class="keyword">while</span> (new_node_tmp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;val &lt; new_node_tmp-&gt;next-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    node-&gt;next = new_node_tmp-&gt;next;</span><br><span class="line">                    new_node_tmp-&gt;next = node;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                new_node_tmp = new_node_tmp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将该节点插入到最后位置</span></span><br><span class="line">            <span class="keyword">if</span> (new_node_tmp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                new_node_tmp-&gt;next = node;</span><br><span class="line">                node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 开始遍历当前节点的下一个节点</span></span><br><span class="line">        node = node_next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里巴巴开源云原生项目分析（持续更新）</title>
    <url>/post/alibaba_opensource_cloudnative/</url>
    <content><![CDATA[<h1 id="ackdistro"><a href="#ackdistro" class="headerlink" title="ackdistro"></a><a href="https://github.com/AliyunContainerService/ackdistro">ackdistro</a></h1><p>阿里云的k8s发行版，跟阿里云的ack采用了相同的源码。该项目采用<a href="#sealer">sealer</a>来部署k8s集群，并通过sealer支持k8s集群的扩容、缩容节点等运维操作。该项目并没有将k8s相关的源码开源，而主要维护了安装k8s集群需要的yaml文件、helm chart。</p>
<p>ack的k8s发行版比较简洁，并没有公有云ack的丰富的组件。除了k8s原生的几个组件外，网络插件集成了<a href="#hybridnet">hybridnet</a>，存储插件集成了<a href="#open-local">open-local</a>。</p>
<h1 id="hybridnet"><a href="#hybridnet" class="headerlink" title="hybridnet"></a><a href="https://github.com/alibaba/hybridnet">hybridnet</a></h1><p>容器网络插件，支持underlay网络和overlay网络，且可以支持一个k8s集群内的网络同时支持overlay网络和underlay网络。underlay网络模式下，可以支持vlan网络，也可以支持bgp网络。</p>
<h1 id="image-syncer"><a href="#image-syncer" class="headerlink" title="image-syncer"></a><a href="https://github.com/AliyunContainerService/image-syncer">image-syncer</a></h1><p>镜像仓库同步工具，用于两个镜像仓库之间的数据同步。在公有云的产品ack one中有所应用。</p>
<h1 id="kube-eventer"><a href="#kube-eventer" class="headerlink" title="kube-eventer"></a><a href="https://github.com/AliyunContainerService/kube-eventer">kube-eventer</a></h1><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/kube-eventer.png" alt="![https://user-images.githubusercontent.com/8912557/117400612-97cf3a00-af35-11eb-90b9-f5dc8e8117b5.png](https://kuring.oss-cn-beijing.aliyuncs.com/common/sealer.png)"></p>
<p>k8s的Event会存放在etcd中，并跟对象关联。Event有一定的有效时常，默认为1小时。业界通常做法是将event存放在单独的etcd集群中，并将event的生命周期设长。对于异常类型的Event，是一种非常理想的告警机制。</p>
<p>kube-eventer组件可以将k8s的event对象收集起来，可以发送到钉钉、kafka等数据sink端。</p>
<h1 id="kubernetes-cronhpa-controller"><a href="#kubernetes-cronhpa-controller" class="headerlink" title="kubernetes-cronhpa-controller"></a><a href="https://github.com/AliyunContainerService/kubernetes-cronhpa-controller">kubernetes-cronhpa-controller</a></h1><p>k8s提供了hpa机制，可以针对pod的监控信息对pod进行扩缩容。该组件提供了定期扩缩容的机制，可以定期对pod的数量进行设置。</p>
<p>相关资料：<a href="https://help.aliyun.com/document_detail/151557.htm?spm=a2c4g.11186623.0.0.48b151bb3ZWte9#task-2391975">容器定时伸缩（CronHPA）</a></p>
<h1 id="log-pilot"><a href="#log-pilot" class="headerlink" title="log-pilot"></a><a href="https://github.com/AliyunContainerService/log-pilot">log-pilot</a></h1><p>针对容器类型的服务研发的日志收集agent，可以在k8s pod上通过简单配置环境变量的方式即可采集日志，使用起来非常简洁。</p>
<h1 id="open-local"><a href="#open-local" class="headerlink" title="open-local"></a><a href="https://github.com/alibaba/open-local">open-local</a></h1><p>k8s对于本地磁盘设备的使用相对较弱，提供了emptyDir、hostPath和local pv的能力来使用本地磁盘设备，但这些功能并没有使用到k8s的动态创建pv的功能，即在pod在使用pvc之前，pv必须实现要创建出来。</p>
<p>该项目提供了本地存储设备的动态供给能力，可以将本地的一块完整磁盘作为一个pv来动态创建。也可以将本地的磁盘切分成多块，通过lvm的方式来分配本地的不同pod来使用，以满足磁盘的共享，同时又有完整的磁盘quota能力。</p>
<p>相关资料：<a href="https://help.aliyun.com/document_detail/178476.html">LVM数据卷</a></p>
<h1 id="sealer"><a href="#sealer" class="headerlink" title="sealer"></a><a href="https://github.com/alibaba/sealer">sealer</a></h1><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/sealer.png" alt="https://user-images.githubusercontent.com/8912557/117400612-97cf3a00-af35-11eb-90b9-f5dc8e8117b5.png"></p>
<p>当前的应用发布经历了三个阶段：</p>
<ul>
<li>阶段一 裸部署在物理机或者vm上。直接裸部署在机器上的进程，存在操作系统、软件包的依赖问题，比如要部署一个python应用，那么需要机器上必须要包含对应版本的python运行环境以及应用依赖的所有包。</li>
<li>阶段二 通过镜像的方式部署在宿主机上。docker通过镜像的方式将应用以及依赖打包到一起，解决了单个应用的依赖问题。</li>
<li>阶段三 通过k8s的方式来标准化部署。在k8s时代，可以将应用直接部署到k8s集群上，将应用的发布标准化，实现应用的跨机器部署。</li>
</ul>
<p>在阶段三中，应用发布到k8s集群后，应用会对k8s集群有依赖，比如k8s管控组件的配置、使用的网络插件、应用的部署yaml文件，对镜像仓库和dockerd的配置也有所依赖。当前绝大多数应用发布是跟k8s集群部署完全独立的，即先部署k8s集群，然后再部署应用，跟阶段一的发布单机应用模式比较类似，先安装python运行环境，然后再启动应用。</p>
<p>sealer项目是个非常有意思的开源项目，旨在解决k8s集群连同应用发布的自动化问题，可以实现类似docker镜像的方式将整个k8s集群连同应用一起打包成集群镜像，有了集群镜像后既可以标准化的发布到应用到各个地方。sealer深受docker的启发，提出的很多概念跟docker非常类似，支持docker常见的子命令run、inspect、save、load、build、login、push、pull等。</p>
<ul>
<li>Kubefile概念跟Dockerfile非常类似，且可以执行sealer build命令打包成集群镜像，语法也类似于Dockerfile。</li>
<li>CloudImage：集群镜像，将Kubefile打包后的产物，类比与dockerimage。基础集群镜像通常为裸k8s集群，跟docker基础镜像为裸操作系统一致。</li>
<li>Clusterfile：要想运行CloudImage，需要配合Clusterfile文件来启动，类似于Docker Compose。Clusterfile跟Docker Compose一致，并不是必须的，也可以通过sealer run的方式来启动集群镜像。</li>
</ul>
<p>sealer要实现上述功能需要实现将k8s集群中的所有用到镜像全部打包到一个集群镜像中。</p>
<p>相关资料：<a href="https://mp.weixin.qq.com/s/0SBslzaMWtqn9H8Q57urNA">集群镜像：实现高效的分布式应用交付</a></p>
]]></content>
  </entry>
  <entry>
    <title>阿里巴巴入职三周年感悟</title>
    <url>/post/aliyun-3years/</url>
    <content><![CDATA[<p>今年六月份入职阿里正好三周年，在阿里入职三年被称为”三年醇”，三年才称之为真正的阿里人。我个人在这三年的时间里也变化了许多，值得反思总结一下。</p>
<h2 id="阿里缘起"><a href="#阿里缘起" class="headerlink" title="阿里缘起"></a>阿里缘起</h2><p>三年前，从上家公司离开。当时可选择的机会还是比较多的，基本上职位比较match的面试都通过了，甚至有公司经过了七面。之所以最终选择了阿里，主要如下两个原因：</p>
<ol>
<li>阿里的技术在国内的知名度是响当当的。从技术深度和广度而言，阿里的技术都可圈可点，进入阿里我想多接触一下牛人，技术更进一层。</li>
<li>过往工作经历没有一线大厂，需要丰富下阅历。大厂的经历还是比较关键，不光是为了给自己的职业生涯中增加一份光鲜的经历，更多的是想看大厂是如何运作的，同样一件事情，在不同规模的公司有着不同的处理思路。</li>
</ol>
<p>主要是基于上述原因，即使不是最好选择，即使做出了部分牺牲，毅然决定加入阿里云，加入了国内最领先的云计算厂商之一。</p>
<h2 id="工作内容及感受"><a href="#工作内容及感受" class="headerlink" title="工作内容及感受"></a>工作内容及感受</h2><p>上家公司为互联网公司，处理的业务为高并发的在线业务，在互联网公司摸爬滚打积累了大量经验。来到阿里云后，加入了混合云，场景变为了专有云，虽然工作内容同样为云原生领域，但本质上为离线业务，跟互联网的在线业务在工作内容上有了较大的区别。互联网业务在线化，仅需要几套在线环境即可满足需求，专有云场景却需要维护大量的测试环境和客户的离线环境，从而导致业务复杂度急剧上升。主要体现在如下方面：</p>
<ol>
<li>专有云场景强化对版本的概念。由于大量环境的存在，要想做到统一的管理和运维，必须用版本来强管理，否则维护大量环境将成为灾难。</li>
<li>专有云对自动化部署的要求变高。几套环境的情况下，考虑到ROI，并不需要很高的自动化程度，相反引入自动化会给变更引入额外的复杂性。但如果成百上千套环境，自动化部署成为了强需求，混合云的很多能力都是围绕着自动化部署展开的。</li>
<li>专有云场景对自动化运维的要求变高。运维场景包括了升级、扩缩容、故障处理等，由于是离线的场景，运维的流程变成了：客户 -&gt; 驻场运维 -&gt; 远程运维支持 -&gt; 研发，相比在线业务的支持流程会更长，更难找到bug的真正owner。一方面需要对支持链路上的人员进行相关的培训，更为重要的是需要通过增强平台的自动化运维能力来降低运维成本。</li>
<li>bug在客户环境的问题收敛非常慢。由于有大量的客户环境存在，一旦发现bug，需要在客户现场打hotfix，由于绝大多数环境无法远程，需要人工在客户现场操作，受限于人力、客户变更窗口等限制，hotfix patch的速度很难快起来。从而导致一个bug，会在多个客户现场环境爆发。</li>
<li>墨菲定律凸显，只要是 bug 暴露出来的概率明显增加。由于大量环境的存在，且客户现场运行着多个历史版本，非常难以拉齐版本，哪怕是多年前的旧 bug，在客户现场也极有可能会被发现。</li>
<li>专有云场景下忌架构变更大，架构复杂。专有云场景下经常出现的问题是，一个组件在版本一的架构，还没等一线的运维熟悉架构，在版本二下更换为了另外一套方案，导致运维性特别差。在引入“高大上”的高级特性时也一定要慎重，避免将架构搞复杂，将学习成本变高，专有云的试错成本太高。专有云场景下做好的架构解决方案是，使用尽可能通用简洁的方案来解决复杂的业务问题。</li>
</ol>
<p>虽然两份工作内容都是云原生领域，但因为业务场景的不同，却对工作的重心产生了质的差异，量变产生了质变。正是因为质变，导致用互联网的“快糙猛”、“短平快”的思路来做需要精心打磨的专有云业务，路子非常容易走偏。</p>
<p>从工作量上来看，虽然上一份工作也不怎么轻松，但跟当前工作相比，却是小巫见大巫。尤其是前两年的时间，正处在业务从0到1的阶段，基本上一直处于高度运转的状态，每天都会有大量的钉钉消息和大量的会议，不是在救火就是在救火的路上，钉钉消息泛滥到惨不忍睹。能休息的周末也非常少，基本上周末都用来加班干一周攒下来的工作了。下面为相对卷的轻一些的2021年度的钉钉报告，一年光钉钉的会议就有三万多分钟，平均一天有两个小时，还不包含阿里内部的阿里郎会议和会议室中参加的线下会议。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/3ago-1.jpg"></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/3ago-2.jpg"></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/3ago-3.jpg"></p>
<h2 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h2><p>最大的成长是在工作方法上有了比较大的进步。阿里有一套工作处事的方法论，“搞不定就上升问题”，“责任边界”，“总结思考”等基本上是行走江湖必备技能，在网络上大家也可以看到大量的带有“阿里味”的文章，虽然处理起工作我还是比较喜欢按照自己的方式，但实在搞不定的时候可作为兜底处理思路的，在阿里的江湖里要想风生水起除了靠技术实力，做事方法也极为关键。</p>
<p>文档能力有了很大提升。在过往的工作经历中，很多事情想好了直接就开干了，反正使用方也不会很多，导致写的文档比较少，毕竟写一篇文档有可能花费时间比写代码的时间还要长。但目前我基本上已经养成了写文档的好习惯，写文档是一个整理思路的好方法，同时也可以将方案分享出去。在阿里的这几年深切体会到文档的重要性，因为业务方特别多，哪怕是一个技术点也会被多个人频繁提问，这时候扔一篇文档是比较好的减负方法。</p>
<p>另一个比较大的转变是很少失眠了。上一份工作经历大概是处理在线业务的原因，或者是工作不够饱和，经常出现失眠的情况。来阿里之前还比较担心失眠的问题发生，顶不住阿里高强度的工作压力。结果后来发现失眠根本就不存在，当每天都处理N件事情后，超卖非常严重，已经从原来的脑力劳动变成了体力加脑力劳动，根本不存在失眠的情况。到现在为止，即使工作没有刚加入阿里时那么饱和，失眠的情况也比较少了。</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>面向钉钉的工作方式没有改掉。刚加入阿里的时候，看到同事的钉钉怎么那么多群，而且都把消息清一色设置为了屏蔽状态，我还特别的不理解。入职没多长时间就渐渐习惯了，每天总会加入几个群，刚开始的时候还会关注群消息，后来发现大部分群都是跟自己无关的。由于会随时被@，所以就把消息提醒给关掉了，否则会特别影响注意力。关掉消息提醒后，消息的查看方式就从push模式变了定期pull模式，基本上每隔几分钟就会打开一次钉钉。虽然大部分情况下都能看到新的消息要处理，但也养成了一个坏习惯，一旦不打开钉钉，总感觉心里不舒服。我不知道这个坏习惯算不算一种医学上的疾病，至少我扣手指的坏习惯在医学上找到了对应的名称“强迫性皮肤剥离症”。这个坏习惯一度尝试修正，比如采用“番茄工作法”的方式，每隔十五分钟再打开一次钉钉，但一直没有强有力的推动下去，总是忍不住打开钉钉看一眼消息。钉钉俨然成为了我工作效率的最大杀手，这句话也不完全对，因为钉钉本来就是我工作的一部分。如果这个问题可以解掉，我的工作效率会上一个大大的台阶。</p>
<p>能力陷阱问题突出。工作中有大量时间是作为客服来答疑解惑各类问题，前期阶段不管我是不是owner，只要是我力所能及的都尽可能提供帮助，直到我实在扛不住。虽然一方面服务了大量的客户，但另一方面我自己可支配的时间变的非常少。后面渐渐将不是我的问题路由到其他同学，自己才释放出一些时间。但路由器其实不是那么好当的，平台有大量组件，而且不同的组件往往归属不同的owner，有很多问题其实并不能直观看出具体是哪个组件，很多情况下都是多个组件配合的问题，因此还需要充当问题初步定位的工作以及没有owner问题的默认路由。</p>
<p>自身的学习投入比重偏少。工作时间多的最突出问题就是没有太多的精力来投入到新技术新知识的学习，虽然最近一年有很大的改善，但相比上家公司学习的技术的投入是完全不能比的。更别提，刚工作那几年曾经看过满满一书架的技术书籍了，现在想来真是一种奢侈。</p>
<p>前瞻性不够。每天都有很多问题在排队的后果就是规划能力不够。阿里还是特别强调抬头看路，但现实中，我却大部分的时间消耗在了低头解问题，思考的时间偏少。长此以往，渐渐发现自己的创造性是不够的。多花时间独立思考，这条路永远是正确的。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>自己对未来有很多的期待，这里最想提升的点为：打造个人品牌影响力。个人影响力方面过去不够重视，期望将来能够行动起来。要想做到这一点并非易事，需要很多基础能力，比如需要大量的知识积累，需要大量的工作实践等。期望借着阿里的平台，能够最大化个人影响力，未来可期！</p>
]]></content>
  </entry>
  <entry>
    <title>阿里云产品分析（持续更新）</title>
    <url>/post/aliyun-product/</url>
    <content><![CDATA[<p>阿里云上有众多的云产品，本文主要分析云产品的功能以及应用场景。</p>
<h1 id="容器与中间件"><a href="#容器与中间件" class="headerlink" title="容器与中间件"></a>容器与中间件</h1><p>该部分领域与我的工作重合度较高，为重点研究领域。</p>
<h2 id="事件总线EventBridge"><a href="#事件总线EventBridge" class="headerlink" title="事件总线EventBridge"></a>事件总线EventBridge</h2><p>很多服务会产生输出供下游的服务来消费，最常见的解决办法是数据生产者通过rpc调用的方式将消息发送给数据消费者。但假如消费者的数量不止一处，该模式下就需要数据生产者将数据重复发送给多个消费者，该方式对于生产者可配置的灵活性要求非常高。</p>
<p>为了解决上述问题，将生产者和消费者解耦，解决办法就是引入一个中间层，这也是软件架构中最常见的解决复杂问题的方法。引入的中间层即为消息队列类的服务，比如Kafka。生成者仅负责生产数据到消息队列，消费者负责从消息队列消费数据，且可以存在多个消费者。生成者和消费者根本不用关心彼此，仅需要跟消息队列进行交互就可以了。</p>
<p>阿里云上的某个产品新增加了一个新的操作，比如ECS主机完成了一次快照操作，都会产生事件。如果有服务要消费事件，可以使用该产品。</p>
<p>阿里云上的很多产品会将新产生的事件发送到事件总线，另外也支持自定义事件源，通过编程的方式将事件推送到事件源上。</p>
<p>数据的消费模块跟通常的消息队列有所不同，这里的数据消费需要由事件总线产品主动推送消息到对应的服务，具体要推送到哪些服务，则需要在创建总线的时候配置，该功能即消息路由。支持的消费端包括钉钉、消息队列、Serverless服务、HTTP Server等。可以看到数据的消费端除了HTTP Server外，基本不需要额外开发一个服务，也是阿里云的一些其他云产品。</p>
<p>消息的规范完成遵循云原生社区CNCF的CloudEvent规则。</p>
<p>相关链接：</p>
<ul>
<li><a href="https://cloudevents.io/">CloudEvents规范</a></li>
</ul>
<h2 id="弹性容器实例ECI"><a href="#弹性容器实例ECI" class="headerlink" title="弹性容器实例ECI"></a>弹性容器实例ECI</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/aliyun/eci.jpg"></p>
<p>该产品的功能比较简单，相当于提供了管控页面来创建k8s的pod，具体pod部署在哪里用户不需要关心，提供了非常好的弹性能力，充分发挥了云的优势。</p>
<p>具体在实现层面，实际上会以pod的形式部署在阿里云维护的公共k8s集群中，且容器的网络在用户指定的vpc中。</p>
<p>除了给用户提供直接创建容器实例外，还有很大一部分功能是给Serverless Kubernetes（ASK）和容器服务（ACK）来提供弹性扩缩容的功能。</p>
<h2 id="企业级分布式应用服务EDAS"><a href="#企业级分布式应用服务EDAS" class="headerlink" title="企业级分布式应用服务EDAS"></a>企业级分布式应用服务EDAS</h2><p>提供了应用托管和微服务的治理能力。</p>
<p>在应用托管方面支持应用发布到虚拟机和k8s两种方式。</p>
<p>微服务治理方面支持了Spring Cloud、Dubbo、HSF三种微服务框架。</p>
<h2 id="Serverless应用引擎SAE"><a href="#Serverless应用引擎SAE" class="headerlink" title="Serverless应用引擎SAE"></a>Serverless应用引擎SAE</h2><p>提供了类似于knative的serving功能，可以支持应用的托管，用户不需要关心底层的服务器资源，可以自动将用户的应用部署在托管的k8s集群中，且具备秒级的弹性扩缩容的功能。</p>
<h2 id="Serverless工作流SWF"><a href="#Serverless工作流SWF" class="headerlink" title="Serverless工作流SWF"></a>Serverless工作流SWF</h2>]]></content>
  </entry>
  <entry>
    <title>利用aws科学上网</title>
    <url>/post/aws_net/</url>
    <content><![CDATA[<p>曾经使用过多种科学上网方式，​最近尝试了使用aws的免费试用一年的功能搭建shadowsocks，访问google的速度非常不错，比很多收费的服务要好用，amazon真是良心企业！</p>
<p>本文用于记录在aws上搭建服务的步骤及其中的一些注意事项，步骤不会太详细，aws上关于主机的功能需要读者自己在试验的过程中去自己探索。</p>
<h1 id="注册aws账号"><a href="#注册aws账号" class="headerlink" title="注册aws账号"></a>注册aws账号</h1><p>为了能够搭建搭建aws服务，拥有一个amazon账号是必须的，在<a href="https://aws.amazon.com/cn/free/">aws免费套餐</a>的页面点击『创建免费账号』按钮即可按照步骤创建aws账号。</p>
<p>值得一提的是，注册aws的账号需要一张信用卡。</p>
<h1 id="开启EC2主机实例"><a href="#开启EC2主机实例" class="headerlink" title="开启EC2主机实例"></a>开启EC2主机实例</h1><p>该步骤的目的是开启aws上的主机实例。​</p>
<p>进入aws的控制面板，在左上角的服务中选择EC2，aws提供了多种类型的主机，这里选择EC2即可。</p>
<p>在EC2控制面板界面中需要选择右上角的区域，这个用于选择EC2主机所在的机房，不同机房之间主机是不可以共享的。我这里选择了『美国西部（俄勒冈）』，感觉速度还不错，没有试验过亚洲地区的，新加坡的速度是不是会更好些。后续经过验证，首尔的服务器确实速度更快一些。<br>​<br>下面即可创建EC2的实例了，点击界面上的『启动实例』按钮即可按照步骤创建EC2实例了，创建实例的时候一定要选择免费的EC2主机，否则就会悲剧了。我选择了ubuntu14.04的主机，redhat7.2的主机yum源不太全，没有选择使用。</p>
<p>最终会得到ssh登录用的pem文件，用于ssh远程登录主机。并在界面上启动刚刚创建的实例。</p>
<h1 id="按照shadowsocks"><a href="#按照shadowsocks" class="headerlink" title="按照shadowsocks"></a>按照shadowsocks</h1><p>接下来就是在EC2实例上安装sock5代理工具了。</p>
<p>登录刚刚启动的EC2，需要pem文件。可以通过<code>ssh -i &quot;key.pem&quot; ubuntu@ec2-52-26-2-14.us-west-2.compute.amazonaws.com</code>命令来登录到远程主机，其他工具请自行google。</p>
<p>使用命令<code>pip install shadowsocks</code>来安装shadowssocks，pip命令的安装自行解决。</p>
<p>在ubuntu的home目录下执行<code>mkdir shadowsocks</code>创建保存配置文件的文件夹，并创建配置文件config.json，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;server_port&quot;:10001,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;xxx&quot;,</span><br><span class="line">    &quot;timeout&quot;:600,</span><br><span class="line">    &quot;method&quot;:&quot;bf-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要说明的是最好配置一下server_port选项，更改shadowsocks的默认端口号。method选项用于控制加密方式，我这里更改为了bf-cfb。</p>
<p>执行<code>nohup ssserver -c config.json &amp;</code>命令即可启动shadowsocks服务。</p>
<p>由于对外增加了10001端口号，aws的默认安全策略为仅对外提供22端口，需要在EC2主机的安全策略中增加外放访问tcp端口10001的权限。</p>
<h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><p>为了安装方便，我简单写了个脚本如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">#yum update -y</span><br><span class="line">yum install python2-pip -y</span><br><span class="line">pip install shadowsocks</span><br><span class="line">mkdir ~/shadowsocks</span><br><span class="line">echo &#x27;&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;server_port&quot;:10001,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;xxx&quot;,</span><br><span class="line">    &quot;timeout&quot;:600,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;&#x27; &gt; ~/shadowsocks/config.json</span><br><span class="line">systemctl disable firewalld.service</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">nohup ssserver -c ~/shadowsocks/config.json &amp;</span><br></pre></td></tr></table></figure>

<p>在某些云主机的CentOS7系统发现无法使用<code>yum install python2-pip</code>进行安装，原因是有些源被禁用了，可以使用<code>yum repolist disabled</code>来查看被禁用的源，其中会包含epel源。可以使用<code>yum install python2-pip -y --enablerepo=epel</code>的方式来安装。</p>
<h1 id="安装shadowsocks客户端"><a href="#安装shadowsocks客户端" class="headerlink" title="安装shadowsocks客户端"></a>安装shadowsocks客户端</h1><p>这里是支持的<a href="https://shadowsocks.com/client.html">客户端列表</a>，​我这里仅使用的mac客户端ShadowsocksX，支持Auto Proxy Mode和Global Mode两种方式，其中Auto方式会自动下载使用sock5代理的列表，非常方便。</p>
<h1 id="kcptun"><a href="#kcptun" class="headerlink" title="kcptun"></a>kcptun</h1><p>为了加快访问速度，推荐使用kcp + shadowsocks</p>
<p>kcp的服务端配置如下，即启用20001端口，该端口会将流量导入到127.0.0.1:10001端口，即本机的shadowsocks端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~ &amp;&amp; mkdir kcptun &amp;&amp; cd kcptun</span><br><span class="line">wget https://github.com/xtaci/kcptun/releases/download/v20190109/kcptun-linux-amd64-20190109.tar.gz</span><br><span class="line">tar zvxf kcptun-linux-amd64-20190109.tar.gz</span><br><span class="line">nohup ./server_linux_amd64 -l :20001 -t 127.0.0.1:10001 -key xxx -mode fast2 --log ~/kcptun/20001.log &amp;</span><br></pre></td></tr></table></figure>

<p>配置了kcptun的shadowsocks客户端仅需要配置代理为远程的kcpdun端口即可，不再需要指定shadowsocks的端口，相当于shadowsocks是透明的。</p>
<h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><p>为了避免aws产生额外的费用，一定要设置一下费用报警，否则被扣费了就麻烦了。</p>
<p>另外，可定期查看下aws的费用。试用期为一年，一年后一定要记得停掉aws服务。</p>
<p>最后，祝你玩的愉快！</p>
]]></content>
      <tags>
        <tag>aws</tag>
      </tags>
  </entry>
  <entry>
    <title>红米路由器 AX6000 科学上网</title>
    <url>/post/ax6000-clash/</url>
    <content><![CDATA[<p>在上篇文章《红米路由器 AX6000 解锁 SSH》中，解锁了红米路由器 AX6000 的 SSH 功能，本文在此基础上安装 clash，用来科学上网。</p>
<h1 id="安装-clash"><a href="#安装-clash" class="headerlink" title="安装 clash"></a>安装 clash</h1><p>通过 ssh 命令连接到红米路由器，执行如下 shell 命令，即可下载并安装 clash 软件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/openclash &amp;&amp; cd /data/openclash</span><br><span class="line">export url=&#x27;https://raw.fastgit.org/juewuy/ShellClash/master&#x27;</span><br><span class="line">curl -kfsSl $url/install.sh &gt; install.sh</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure>

<p>会出现如下的提示：<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/ax6000/clash-1.png" alt="image.png"><br>install.sh 会将 ShellCrash 安装到 &#x2F;data&#x2F;ShellCrash 目录下。</p>
<h1 id="clash-配置"><a href="#clash-配置" class="headerlink" title="clash 配置"></a>clash 配置</h1><p>在安装完 clash 后，输入 clash 命令即可对 clash 进行管理，该操作有点类似于打客户电话的操作。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/ax6000/clash-2.png" alt="image.png"></p>
<h1 id="clash-UI"><a href="#clash-UI" class="headerlink" title="clash UI"></a>clash UI</h1><p>通过上述 clash 命令可以安装 clash UI，可以通过网址 <a href="http://192.168.31.1:9999/ui">http://192.168.31.1:9999/ui</a> 访问。UI 的功能较 clash 的客户端更为简单，但也可以弥补上述 clash 命令的很多不足之处。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/ax6000/clash-ui.png" alt="image.png"></p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://www.youtube.com/watch?v=e90UWDpAlxA">https://www.youtube.com/watch?v=e90UWDpAlxA</a></p>
]]></content>
  </entry>
  <entry>
    <title>红米路由器 AX6000 解锁 SSH</title>
    <url>/post/ax6000-ssh/</url>
    <content><![CDATA[<p>半年前购买了红米路由器 AX6000，用起来一直非常稳定。因为最近在折腾树莓派，准备将红米路由器上开启 SSH 的功能。最早是准备将路由器刷成 <a href="https://openwrt.org/toh/xiaomi/redmi_ax6000">OpenWRT 系统</a>，当一旦路由器能够开启 SSH 功能后，刷 OpenWRT 系统的必要性就不是太大了。</p>
<blockquote>
<p>声明：本文下面操作步骤均为从网络上获取的现有操作步骤。</p>
</blockquote>
<p>在电脑的浏览器上登录红米路由器的管理页面，红米路由器管理页面为：<a href="https://miwifi.com/">https://miwifi.com/</a>，或者 <a href="http://192.168.31.1/">http://192.168.31.1/</a>。如果本地设置过其他的 DNS 服务器，需要使用 ip 地址的形式访问。<br>登录后可以获取到当前红米路由器的版本，我的已经是最新的 1.0.67，该版本的固件可以支持开启 SSH 协议。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/ax6000/ax6000-version.png" alt="image.png"><br>在登录红米路由器管理页面后，查看浏览器的地址栏，<code>https://miwifi.com/cgi-bin/luci/;stok=5e55c58e949d5419c001bce8288e5a27/web/home#router</code>，可以看到参数 stok <code>5e55c58e949d5419c001bce8288e5a27</code> 即我们需要用到该值。需要注意的是参数 stok 在每次登录时均会发生改变。</p>
<p>用浏览器打开下面的网址，其中 stok 为上面步骤获取到的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.31.1/cgi-bin/luci/;stok=5e55c58e949d5419c001bce8288e5a27/api/misystem/set_sys_time?timezone=%20%27%20%3B%20zz%3D%24%28dd%20if%3D%2Fdev%2Fzero%20bs%3D1%20count%3D2%202%3E%2Fdev%2Fnull%29%20%3B%20printf%20%27%A5%5A%25c%25c%27%20%24zz%20%24zz%20%7C%20mtd%20write%20-%20crash%20%3B%20</span><br></pre></td></tr></table></figure>
<p>浏览器如果返回<code>&#123;&quot;code&quot;:0&#125;</code>，说明该步骤执行成功。</p>
<p>在浏览器执行路由器重启操作，返回 <code>&#123;&quot;code&quot;:0&#125;</code>，说明该步骤执行成功，此时路由器会发生重启。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.31.1/cgi-bin/luci/;stok=5e55c58e949d5419c001bce8288e5a27/api/misystem/set_sys_time?timezone=%20%27%20%3b%20reboot%20%3b%20</span><br></pre></td></tr></table></figure>

<p>重新登录红米路由器，获取到新的 stok 值 221bcd3ba09b3e4597b0308cc1df18a2。<br>在浏览器继续访问如下的地址，用来开启 telnet，成功后仍然返回 <code>&#123;&quot;code&quot;:0&#125;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.31.1/cgi-bin/luci/;stok=221bcd3ba09b3e4597b0308cc1df18a2/api/misystem/set_sys_time?timezone=%20%27%20%3B%20bdata%20set%20telnet_en%3D1%20%3B%20bdata%20set%20ssh_en%3D1%20%3B%20bdata%20set%20uart_en%3D1%20%3B%20bdata%20commit%20%3B%20</span><br></pre></td></tr></table></figure>

<p>再继续执行重启命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.31.1/cgi-bin/luci/;stok=221bcd3ba09b3e4597b0308cc1df18a2/api/misystem/set_sys_time?timezone=%20%27%20%3b%20reboot%20%3b%20</span><br></pre></td></tr></table></figure>

<p>在重启完成后，路由器的 telnet 服务已经开启。在终端中执行 <code>telnet 192.168.31.1</code> 即可远程连接到小米路由器，而且不需要密码。</p>
<p>在终端中执行如下的命令，用来设置 root 密码，开启并固化 ssh 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改 root 密码</span><br><span class="line">echo -e &#x27;wangss19881.\nwangss19881.&#x27; | passwd root</span><br><span class="line"></span><br><span class="line"># 开启 ssh 服务</span><br><span class="line">nvram set ssh_en=1</span><br><span class="line">nvram set telnet_en=1</span><br><span class="line">nvram set uart_en=1</span><br><span class="line">nvram set boot_wait=on</span><br><span class="line">nvram commit</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s/channel=.*/channel=&quot;debug&quot;/g&#x27; /etc/init.d/dropbear</span><br><span class="line">/etc/init.d/dropbear restart</span><br><span class="line"></span><br><span class="line"># 设置 ssh 服务开机自启动</span><br><span class="line">mkdir /data/auto_ssh</span><br><span class="line">cd /data/auto_ssh</span><br><span class="line">curl -O https://fastly.jsdelivr.net/gh/lemoeo/AX6S@main/auto_ssh.sh</span><br><span class="line">chmod +x auto_ssh.sh</span><br><span class="line">uci set firewall.auto_ssh=include</span><br><span class="line">uci set firewall.auto_ssh.type=&#x27;script&#x27;</span><br><span class="line">uci set firewall.auto_ssh.path=&#x27;/data/auto_ssh/auto_ssh.sh&#x27;</span><br><span class="line">uci set firewall.auto_ssh.enabled=&#x27;1&#x27;</span><br><span class="line">uci commit firewall</span><br><span class="line"></span><br><span class="line"># 设置时区</span><br><span class="line">uci set system.@system[0].timezone=&#x27;CST-8&#x27;</span><br><span class="line">uci set system.@system[0].webtimezone=&#x27;CST-8&#x27;</span><br><span class="line">uci set system.@system[0].timezoneindex=&#x27;2.84&#x27;</span><br><span class="line">uci commit</span><br><span class="line"></span><br><span class="line"># 关闭开发模式</span><br><span class="line">mtd erase crash</span><br><span class="line"></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>
<p>在终端中执行 <code>ssh -o HostkeyAlgorithms=+ssh-rsa -o PubkeyAcceptedKeyTypes=+ssh-rsa  root@192.168.31.1</code>即可 ssh 连接到路由器。</p>
<p>进入到系统后我们可以看到系统为基于 Linux 5.4 内核版本的 XiaoQiang 系统，至于名字为什么叫 XiaoQiang 我还不得而知。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@XiaoQiang:~# uname -a</span><br><span class="line">Linux XiaoQiang 5.4.150 #0 SMP Mon Jan 30 09:23:25 2023 aarch64 GNU/Linux</span><br></pre></td></tr></table></figure>

<p>整个磁盘分区的使用情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@XiaoQiang:~# df -h</span><br><span class="line">Filesystem                Size      Used Available Use% Mounted on</span><br><span class="line">/dev/root                15.5M     15.5M         0 100% /</span><br><span class="line">tmpfs                   240.0M      9.9M    230.1M   4% /tmp</span><br><span class="line">ubi1_0                   40.4M      7.6M     30.7M  20% /data</span><br><span class="line">ubi1_0                   40.4M      7.6M     30.7M  20% /userdisk</span><br><span class="line">/dev/root                15.5M     15.5M         0 100% /userdisk/data</span><br><span class="line">ubi1_0                   40.4M      7.6M     30.7M  20% /etc/config</span><br><span class="line">ubi1_0                   40.4M      7.6M     30.7M  20% /etc/datacenterconfig</span><br><span class="line">ubi1_0                   40.4M      7.6M     30.7M  20% /etc/smartcontroller</span><br><span class="line">ubi1_0                   40.4M      7.6M     30.7M  20% /etc/parentalctl</span><br><span class="line">ubi1_0                   40.4M      7.6M     30.7M  20% /etc/smartvpn</span><br><span class="line">ubi1_0                   40.4M      7.6M     30.7M  20% /etc/ppp</span><br><span class="line">ubi1_0                   40.4M      7.6M     30.7M  20% /etc/crontabs</span><br><span class="line">tmpfs                   512.0K     12.0K    500.0K   2% /dev</span><br></pre></td></tr></table></figure>

<p>使用 top 命令查看整体的系统负载情况，cpu 利用率还是非常低。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mem: 325692K used, 165808K free, 11208K shrd, 12652K buff, 76388K cached</span><br><span class="line">CPU:  0.3% usr  1.3% sys  0.0% nic 97.8% idle  0.0% io  0.0% irq  0.4% sirq</span><br><span class="line">Load average: 1.05 1.06 1.12 2/147 28107</span><br></pre></td></tr></table></figure>

<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://www.youtube.com/watch?v=u5Qg4zqj_V0">https://www.youtube.com/watch?v=u5Qg4zqj_V0</a><br><a href="https://uzbox.com/tech/openwrt/ax6000.html">https://uzbox.com/tech/openwrt/ax6000.html</a><br><a href="https://github.com/kjfx/AX6000/releases/tag/RedmiAX6000">https://github.com/kjfx/AX6000/releases/tag/RedmiAX6000</a></p>
]]></content>
  </entry>
  <entry>
    <title>Linux Bridge brctl命令</title>
    <url>/post/brctl/</url>
    <content><![CDATA[<h2 id="查看网桥设备以及端口"><a href="#查看网桥设备以及端口" class="headerlink" title="查看网桥设备以及端口"></a>查看网桥设备以及端口</h2><p>使用brctl show可以查看本地上的所有的网桥设备以及接到网桥设备上的所有网络设备。</p>
<h2 id="查看网桥设备的mac地址表"><a href="#查看网桥设备的mac地址表" class="headerlink" title="查看网桥设备的mac地址表"></a>查看网桥设备的mac地址表</h2><p>执行brctl showmacs ${dev}，常用来排查一些包丢在网桥上的场景。<br>其中port no为网桥通过mac地址学习到的某个mac地址所在的网桥端口号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brctl showmacs br0</span><br><span class="line">port no mac addr                is local?       ageing timer</span><br><span class="line"> 1     02:50:89:59:ac:4b       no                 3.96</span><br><span class="line">69     02:e2:14:78:d7:92       no                 0.57</span><br><span class="line"> 1     0a:1e:01:dc:67:87       no                10.23</span><br><span class="line"> 1     0a:60:3c:ca:a8:85       no                 6.04</span><br><span class="line"> 1     0e:01:ce:d6:fc:66       no                 8.36</span><br><span class="line"> 1     0e:0c:f8:6c:08:75       no                56.73</span><br><span class="line">58     0e:49:85:f6:a1:40       no                 1.30</span><br><span class="line">22     0e:c0:99:b0:d9:f9       no                 0.85</span><br></pre></td></tr></table></figure>

<h2 id="查看网桥设备的某个端口的挂载设备"><a href="#查看网桥设备的某个端口的挂载设备" class="headerlink" title="查看网桥设备的某个端口的挂载设备"></a>查看网桥设备的某个端口的挂载设备</h2><p>在上文中中可以获取到某个mac地址对应的网桥设备的端口号，要想知道某个网桥设备的端口号对应的设备可以使用brctl showstp ${dev}命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brctl showstp br0</span><br><span class="line">br0</span><br><span class="line"> bridge id              8000.ae90501b5b47</span><br><span class="line"> designated root        8000.ae90501b5b47</span><br><span class="line"> root port                 0                    path cost                  0</span><br><span class="line"> max age                  20.00                 bridge max age            20.00</span><br><span class="line"> hello time                2.00                 bridge hello time          2.00</span><br><span class="line"> forward delay            15.00                 bridge forward delay      15.00</span><br><span class="line"> ageing time             300.00</span><br><span class="line"> hello timer               0.03                 tcn timer                  0.00</span><br><span class="line"> topology change timer     0.00                 gc timer                  62.37</span><br><span class="line"> flags</span><br><span class="line">bond0.11 (1)</span><br><span class="line"> port id                8001                    state                forwarding</span><br><span class="line"> designated root        8000.ae90501b5b47       path cost                100</span><br><span class="line"> designated bridge      8000.ae90501b5b47       message age timer          0.00</span><br><span class="line"> designated port        8001                    forward delay timer        0.00</span><br><span class="line"> designated cost           0                    hold timer                 0.00</span><br><span class="line"> flags</span><br><span class="line">veth02b41ce8 (20)</span><br><span class="line"> port id                8014                    state                forwarding</span><br><span class="line"> designated root        8000.ae90501b5b47       path cost                  2</span><br><span class="line"> designated bridge      8000.ae90501b5b47       message age timer          0.00</span><br><span class="line"> designated port        8014                    forward delay timer        0.00</span><br><span class="line"> designated cost           0                    hold timer                 0.00</span><br><span class="line"> flags</span><br><span class="line"> hairpin mode              1</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>LNMP开发环境搭建</title>
    <url>/post/build_lnmp/</url>
    <content><![CDATA[<p>这是一篇拿来主义的文章，所有的安装步骤仅为互联网上查找，网络上的教程各种凌乱，这里根据我的实践情况进行了更改，本文仅记录了我的安装过程，由于不同环境可能导致安装步骤不甚相同。</p>
<h1 id="MAC-OS-X-10-10"><a href="#MAC-OS-X-10-10" class="headerlink" title="MAC OS X 10.10"></a>MAC OS X 10.10</h1><h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2><p>Mac OSX 10.10的系统自带了php、php-fpm，省去了安装的麻烦，可以执行<code>php -v</code>查看php的版本。这里需要简单地修改下php-fpm的配置，否则运行php-fpm会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp /private/etc/php-fpm.conf.default /private/etc/php-fpm.conf</span><br><span class="line">vim /private/etc/php-fpm.conf</span><br></pre></td></tr></table></figure>

<p>修改php-fpm.conf文件中的error_log项，默认该项被注释掉，这里需要去注释并且修改为error_log &#x3D; &#x2F;usr&#x2F;local&#x2F;var&#x2F;log&#x2F;php-fpm.log。如果不修改该值，运行php-fpm的时候会提示log文件输出路径不存在的错误。</p>
<p>如果系统中存在多个php-fpm.conf，不知道需要编辑哪一个，可以执行<code>php-fpm -t</code>命令查看php-fpm要读取的配置文件。</p>
<p>通过<code>php-fpm -D</code>来启动php-fpm，可以通过<code>lsof -Pni4 | grep LISTEN | grep php</code>命令来查看php-fpm是否监听在9000端口。</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>这里为了简单，直接采用了brew的方式安装。执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure>

<p>nginx的配置文件位于&#x2F;usr&#x2F;local&#x2F;etc&#x2F;nginx&#x2F;nginx.conf，默认只能解析html文件，需要配置后才能调用php-fpm解析php文件。下面内容为该修改后的文件全部有效内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8080;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        root           /Users/kuring/www;	// 页面存放路径</span><br><span class="line">        location / &#123;</span><br><span class="line">            index  index.html index.htm index.php;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">            fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">            fastcgi_index  index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">            include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">include servers/*;</span><br></pre></td></tr></table></figure>

<p>然后执行<code>nginx</code>命令即可启动，默认监听的端口为8080，在浏览器中输入<code>http://127.0.0.1:8080</code>即可看到nginx的初始界面。nginx要想监听1024以下端口还需要进一步的配置，8080端口既能满足我需求，不再更改。</p>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install mysql</span><br></pre></td></tr></table></figure>

<p>在启动mysql之前可对mysql的配置文件进行更改，我这里需要更改mysql的编码方式，将所有的编码方式都更改为utf8，防止乱码问题的发生。mysql的配置文件为my.cnf，我的位于&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;mysql&#x2F;5.6.25&#x2F;my.cnf，对文件添加如下内容，有些选项不存在，可手动添加。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>

<p>输入<code>mysqld</code>命令即可启动mysql，启动mysql后输入<code>mysql_secure_installation</code>命令对mysql进行配置，可以设置root用户的密码。</p>
<p>通过<code>mysql -uroot -p</code>命令连接到mysql后，输入<code>status</code>命令可查看刚才更改的编码是否生效。</p>
<p>由于不需要长期使用mysql，这里不设置mysql自启动命令。</p>
<h1 id="CentOS6"><a href="#CentOS6" class="headerlink" title="CentOS6"></a>CentOS6</h1><p>我首先采用的方案为完全用普通用户安装，尝试失败后采用root安装依赖库普通用户编译程序的方案。</p>
<h2 id="普通用户安装依赖库"><a href="#普通用户安装依赖库" class="headerlink" title="普通用户安装依赖库"></a>普通用户安装依赖库</h2><p>我首选选择在普通用户kuring下进行安装和运行整个web环境。因此不能使用yum安装方式，必须采用源码安装的方式。通过普通用户安装，最麻烦的地方就在于需要安装很多的依赖库，而依赖的库的安装可能又有需要的库，且库之间存在版本问题。</p>
<p>首先普及几个小知识：</p>
<p>bash查找命令的先后顺序为：</p>
<ol>
<li>alias别名</li>
<li>shell中的关键字，如if等</li>
<li>shell中的函数</li>
<li>shell内置命令，如echo等</li>
<li>$PATH环境变量，PATH中的匹配顺序为从前向后的。</li>
</ol>
<p>程序查找lib库的先后顺序为：</p>
<ol>
<li>编译程序时指定的链接库路径，g++编译器可以通过<code>-Wl,-rpath,路径</code>来指定链接库的路径。</li>
<li>环境变量LD_LIBRARY_PATH指定的搜索路径。</li>
<li>&#x2F;etc&#x2F;ld.so.conf指定的路径。</li>
<li>默认的系统动态库搜索路径，如&#x2F;usr&#x2F;lib64、&#x2F;usr&#x2F;local&#x2F;lib64等。</li>
</ol>
<p>很多程序采用pkg-config程序来检查库的版本号，pkg-config命令依赖于动态链接库对应的.pc文件，这些.pc文件一般位于系统的&#x2F;usr&#x2F;local&#x2F;lib&#x2F;pkgconfig目录下。为了能够将安装完成的库通过pkg-config找到对应的.pc文件，需要将.pc文件所在的路径&#x2F;home&#x2F;kuring&#x2F;local&#x2F;lib&#x2F;pkg-config设置到环境变量PKG_CONFIG_PATH中。</p>
<p>安装php依赖的libxml2库时提示找不到libtool、autoconf和automake，首先安装libtool。执行<code>./configure --prefix=/home/kuring/local;make; make install</code>将其安装到当前用户的local目录下。</p>
<p>用同样的步骤安装autoconf，执行<code>./configure --prefix=/home/kuring/local;make; make install</code>。</p>
<p>为了能够将安装的程序起作用，需要将&#x2F;home&#x2F;kuring&#x2F;local目录添加到PATH环境变量中，在.bash_profile文件中添加PATH&#x3D;$PATH:$HOME&#x2F;local&#x2F;bin语句，并执行<code>source ~/.bash_profile</code>。</p>
<p>安装之前需要先安装libxml2库，下载地址采用<code>git clone git://git.gnome.org/libxml2</code>的方式下载。在执行<code>sh autogen</code>产生configure配置文件的过程中，发现提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure: line 13094: syntax error near unexpected token `LZMA,liblzma,&#x27;</span><br><span class="line">./configure: line 13094: `    PKG_CHECK_MODULES(LZMA,liblzma,&#x27;</span><br></pre></td></tr></table></figure>

<p>经过发现是由于找不到PKG_CHECK_MODULES造成的，正常情况下该函数定义在aclocal.m4文件，而该情况下aclocal.m4文件中并不存在该函数。之所以不存在是由于aclocal命令找不到pkg.m4文件造成的，可以通过<code>aclocal --print</code>命令查看查找的pkg.m4文件的路径。我这里的解决思路为直接从其他机器上复制一个pkg.m4文件过来。</p>
<p>在产生了configure命令后，执行<code>./configure --prefix=/home/kuring/local</code>命令后发现提示找不到Python.h命令的错误。</p>
<p>鉴于遇到了如此之多的错误，本着不浪费生命的原则还是采用yum来安装依赖库吧。</p>
<h2 id="php-1"><a href="#php-1" class="headerlink" title="php"></a>php</h2><p>这里的mysql直接采用了yum命令安装的。</p>
<p>在执行php的<code>./configure</code>命令后提示libxml2找不到错误，直接<code>yum install libxml-devel</code>命令安装libxml-devel即可。然后执行<code>./configure --enable-fpm --prefix=/home/kuring/php5.5 --with-mysqli=/usr/bin/mysql_config;make; make install;</code>。在编译php的时候要加上php-fpm选项来安装php-fpm命令。</p>
<p>安装后配置~&#x2F;.bash_profile文件的$PATH环境变量的值为：PATH&#x3D;$HOME&#x2F;bin:$HOME&#x2F;php5.5&#x2F;bin:$HOME&#x2F;php5.5&#x2F;sbin:$PATH。</p>
<p>此时即可通过<code>php-fpm -D</code>命令来启动php-fpm命令了。</p>
<p>安装完成后通过phpinfo()函数查看里面有MySQLi的选项，但是实际程序运行的时候居然不支持mysqli的一些力函数，说明mysqli的扩展安装不成功。在&#x2F;home&#x2F;kuring&#x2F;php5.5&#x2F;include&#x2F;php&#x2F;ext&#x2F;mysqli目录中找到了对应的.h文件，却没有找到mysqli.so的动态链接库文件。大概是由于在编译php时mysql的路径配置有些问题造成的，因为mysql是通过yum安装的，路径比较乱一些。</p>
<p>为了能够产生mysqli.so文件，采用单独编译的方式，在php的源码目录中已经包含了mysqli的源码，进入mysqli源码目录下执行<code>phpize;./configure --prefix=/home/kuring/php5.5/mysqli --with-php-config=/home/kuring/php5.5/bin/php-config --with-mysqli=/usr/bin/mysql_config;make;make install；</code>。将mysqli.so文件安装到了&#x2F;home&#x2F;kuring&#x2F;php5.5&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20121212目录下，不知道为什么目录末尾还要加个这么长的文件夹名，直接将文件复制到上一级目录下。</p>
<p>在&#x2F;home&#x2F;kuring&#x2F;php5.5目录下没有找到php.ini文件，通过<code>php --ini</code>命令查看php的配置文件路径为&#x2F;home&#x2F;kuring&#x2F;php5.5&#x2F;lib，直接从php的源码文件中复制一个php.ini文件到该目录下。并将php.ini中的增加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extension_dir = &quot;/home/kuring/php5.5/lib/php/extensions&quot;</span><br><span class="line">extension=mysqli.so</span><br></pre></td></tr></table></figure>

<p>再运行程序，发现mysqli的系列函数已经支持了，好一段折腾。</p>
<h2 id="php-fpm"><a href="#php-fpm" class="headerlink" title="php-fpm"></a>php-fpm</h2><p>执行<code>cp $HOME/php5.5/etc/php-fpm.conf.default $HOME/php5.5/etc/php-fpm.conf</code>来增加配置文件。</p>
<h2 id="nginx-1"><a href="#nginx-1" class="headerlink" title="nginx"></a>nginx</h2><p>首先安装pcre库，该库为正则表达式库。下载后通过</p>
<p>下载源码后执行<code>./configure --prefix /home/kuring/nginx;make;make install;</code>即可安装完成。</p>
<p>修改nginx的配置文件为如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8080;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        root           /home/kuring/www;   </span><br><span class="line">        location / &#123;</span><br><span class="line">            index  index.html index.htm index.php;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">            fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">            fastcgi_index  index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">            include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">include servers/*;</span><br></pre></td></tr></table></figure>


<h1 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h1><h2 id="nginx-2"><a href="#nginx-2" class="headerlink" title="nginx"></a>nginx</h2><ul>
<li>nginx -s stop：关闭</li>
<li>nginx -t：检测nginx的配置是否正确</li>
</ul>
<h2 id="mysql-1"><a href="#mysql-1" class="headerlink" title="mysql"></a>mysql</h2><ul>
<li>mysqld_safe：启动mysql</li>
<li>mysqladmin shutdown -u root -p：关闭mysql</li>
<li>create user kuring identified by ‘kuring_pass’：mysql创建用户（我尝试过几次，每次创建的用户密码都为空）</li>
<li>drop user kuring：删除一个用户</li>
<li>grant all privileges on <em>.</em> to ‘root‘@’%’ identified by ‘root’ with grant option ：允许mysql的root用户通过远程登录</li>
</ul>
<h3 id="创建用户的操作"><a href="#创建用户的操作" class="headerlink" title="创建用户的操作"></a>创建用户的操作</h3><p>使用<code>create user kuring identified by &#39;kuring_pass&#39;</code>命令创建用户kuring。默认创建完成的用户在本机无法登陆，但是远程却可以登陆。 这是因为mysql数据库中的user表中存在一条记录造成的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">select user,host,password from user;</span><br><span class="line"></span><br><span class="line">// 在表中存在一条用户名为空的记录</span><br><span class="line">+---------+-----------+-------------------------------------------+</span><br><span class="line">| User    | host      | password                                  |</span><br><span class="line">+---------+-----------+-------------------------------------------+</span><br><span class="line">| root    | localhost | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |</span><br><span class="line">| root    | 127.0.0.1 | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |</span><br><span class="line">| root    | ::1       | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |</span><br><span class="line">|         | localhost |                                           |</span><br><span class="line">| root    | %         | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B |</span><br><span class="line">| report1 | %         | *884CAA4D6FA1C3F7E4849C8DAF1B5B37FCB3EC0B |</span><br><span class="line">+---------+-----------+-------------------------------------------+</span><br><span class="line"></span><br><span class="line">// 将mysql中的为空的记录删除掉，这样就可以通过创建的用户连接了</span><br></pre></td></tr></table></figure>

<p>在mysql命令行中执行<code>grant all privileges on kuring_db.* to kuring identified by &#39;kuring_pass&#39;</code>命令可以给刚创建的用户对数据库的权限。</p>
<h3 id="修改mysql用户密码"><a href="#修改mysql用户密码" class="headerlink" title="修改mysql用户密码"></a>修改mysql用户密码</h3><p>mysql将用户名和密码存放到了mysql数据库的user表中，在mysql命令行中执行<code>use mysql;update user set password=password(&quot;new password&quot;) where user=&quot;username&quot;;flush privileges;</code>即可更新相应用户的密码。</p>
<h2 id="php-fpm-1"><a href="#php-fpm-1" class="headerlink" title="php-fpm"></a>php-fpm</h2><ul>
<li>php-fpm -D：启动php-fpm，如果需要指定php.ini文件，可以使用-c参数</li>
<li>php-fpm -t：检查php-fpm的配置文件</li>
<li>kill -USR2: 重启php-fpm</li>
<li>kill -INT: 停止php-fpm</li>
</ul>
<h2 id="php-2"><a href="#php-2" class="headerlink" title="php"></a>php</h2><ul>
<li>php –ini：显示php.ini文件路径</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="http://www.cnblogs.com/hnrainll/archive/2013/01/06/2847069.html">运用Autoconf和Automake生成Makefile的学习之路</a></li>
</ol>
]]></content>
      <tags>
        <tag>LNMP</tag>
      </tags>
  </entry>
  <entry>
    <title>用C语言实现的trim函数</title>
    <url>/post/c_trim/</url>
    <content><![CDATA[<p>trim函数在其他语言中比较常见，这里用C语言实现一个，不使用C语言的库函数。该例子中不需要额外的申请空间，算法的时间复杂度为O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">char *trim(char * str)</span><br><span class="line">&#123;</span><br><span class="line">	char *buf1, *buf2;</span><br><span class="line">	int i;</span><br><span class="line">	if (str == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 处理字符串前面的空格	</span><br><span class="line">	for (buf1=str; *buf1 &amp;&amp; *buf1==&#x27; &#x27;; buf1++);</span><br><span class="line"></span><br><span class="line">	// 将去掉前面空格的字符串向前复制</span><br><span class="line">	for (buf2=str, i=0; *buf1;)</span><br><span class="line">	&#123;</span><br><span class="line">		*buf2++ = *buf1++;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	*buf2 = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line">	// 处理字符串后面的空格</span><br><span class="line">	while (*--buf2 == &#x27; &#x27;)</span><br><span class="line">	&#123;</span><br><span class="line">		*buf2 = &#x27;\0&#x27;;</span><br><span class="line">	&#125;</span><br><span class="line">	return str;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">      printf(&quot;trim(\&quot;%s\&quot;) &quot;, argv[1]);</span><br><span class="line">      printf(&quot;returned \&quot;%s\&quot;\n&quot;, trim(argv[1]));</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>linux capability</title>
    <url>/post/capability/</url>
    <content><![CDATA[<p>传统的unix权限模型将进程分为root用户进程（有效用户id为0）和普通用户进程。普通用户需要root权限的某些功能，通常通过setuid系统调用实现。但普通用户并不需要root的所有权限，可能仅仅需要修改系统时间的权限而已。这种粗放的权限管理方式势必会带来一定的安全隐患。</p>
<p>linux内核中引入了capability，用于消除需要执行某些操作的程序对root权限的依赖。</p>
<p>capability用于分割root用户的权限，将root的权限分割为不同的能力，每一种能力代表一定的特权操作。例如，CAP_SYS_MODULE用于表示用户加载内核模块的特权操作。根据进程具有的能力来进行特权操作的访问控制。</p>
<p>只有进程和可执行文件才有能力，每个进程拥有以下几组能力集(set)。</p>
<ul>
<li>cap_effective: 进程当前可用的能力集</li>
<li>cap_inheritable: 进程可以传递给子进程的能力集</li>
<li>cap_permitted: 进程可拥有的最大能力集</li>
<li>cap_ambient: Linux 4.3后引入的能力集，</li>
<li>cap_bounding: 用于进一步限制能力的获取</li>
</ul>
<p>可以通过&#x2F;proc&#x2F;${pid}&#x2F;status文件中的CapInh CapPrm CapEff CapBnd CapAmb来表示，每个字段为8个字节即64bit，每个比特表示一种能力，这几个字段存放在进程的内核数据结构task_struct中，由此可见capability的最小单位为线程，而不是进程。</p>
<h2 id="example-1-设置进程能力"><a href="#example-1-设置进程能力" class="headerlink" title="example 1 设置进程能力"></a>example 1 设置进程能力</h2><p>在执行下面程序之前需要安装<code>yum install libcap-devel</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _POSIX_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/capability.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> errno;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">whoami</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;uid=%i  euid=%i  gid=%i\n&quot;</span>, getuid(), geteuid(), getgid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listCaps</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cap_t</span> caps = cap_get_proc();</span><br><span class="line">    <span class="type">ssize_t</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The process %d was give capabilities %s\n&quot;</span>,(<span class="type">int</span>) getpid(), cap_to_text(caps, &amp;y));</span><br><span class="line">    fflush(<span class="number">0</span>);</span><br><span class="line">    cap_free(caps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> stat;</span><br><span class="line">    whoami();</span><br><span class="line">    stat = setuid(geteuid());</span><br><span class="line">    <span class="type">pid_t</span> parentPid = getpid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!parentPid)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">cap_t</span> caps = cap_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给进程增加5中能力</span></span><br><span class="line">    <span class="type">cap_value_t</span> capList[<span class="number">5</span>] =&#123; CAP_NET_RAW, CAP_NET_BIND_SERVICE , CAP_SETUID, CAP_SETGID,CAP_SETPCAP &#125; ;</span><br><span class="line">    <span class="type">unsigned</span> num_caps = <span class="number">5</span>;</span><br><span class="line">    cap_set_flag(caps, CAP_EFFECTIVE, num_caps, capList, CAP_SET);</span><br><span class="line">    cap_set_flag(caps, CAP_INHERITABLE, num_caps, capList, CAP_SET);</span><br><span class="line">    cap_set_flag(caps, CAP_PERMITTED, num_caps, capList, CAP_SET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cap_set_proc(caps)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;capset()&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    listCaps();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将进程的能力清除</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dropping caps\n&quot;</span>);</span><br><span class="line">    cap_clear(caps);  <span class="comment">// resetting caps storage</span></span><br><span class="line">    <span class="keyword">if</span> (cap_set_proc(caps)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;capset()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    listCaps();</span><br><span class="line"></span><br><span class="line">    cap_free(caps);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并执行如下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc capability.c -lcap -o capability</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要使用root执行，因为普通用户不能给进程设置能力</span></span><br><span class="line">sudo ./capability</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出如下内容</span></span><br><span class="line">uid=0  euid=0  gid=0</span><br><span class="line">The process 5044 was give capabilities = cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw+eip</span><br><span class="line">dropping caps</span><br><span class="line">The process 5044 was give capabilities =</span><br></pre></td></tr></table></figure>

<h2 id="example-2-获取进程能力"><a href="#example-2-获取进程能力" class="headerlink" title="example 2 获取进程能力"></a>example 2 获取进程能力</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> _POSIX_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/capability.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">user_cap_header_struct</span> <span class="title">cap_header_data</span>;</span></span><br><span class="line">    <span class="type">cap_user_header_t</span> cap_header = &amp;cap_header_data;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">user_cap_data_struct</span> <span class="title">cap_data_data</span>;</span></span><br><span class="line">    <span class="type">cap_user_data_t</span> cap_data = &amp;cap_data_data;</span><br><span class="line"></span><br><span class="line">    cap_header-&gt;pid = getpid();</span><br><span class="line">    cap_header-&gt;version = _LINUX_CAPABILITY_VERSION_1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (capget(cap_header, cap_data) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed capget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cap data 0x%x, 0x%x, 0x%x\n&quot;</span>, cap_data-&gt;effective,cap_data-&gt;permitted, cap_data-&gt;inheritable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过capget命令获取进程的能力</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[vagrant@localhost tmp]$ gcc get_capability.c -lcap -o get_capability</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">普通用户默认情况下没有任何能力</span></span><br><span class="line">[vagrant@localhost tmp]$ ./get_capability</span><br><span class="line">Cap data 0x0, 0x0, 0x0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">root用户默认拥有所有的能力</span></span><br><span class="line">[vagrant@localhost tmp]$ sudo ./get_capability</span><br><span class="line">Cap data 0xffffffff, 0xffffffff, 0x0</span><br></pre></td></tr></table></figure>

<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol>
<li>getcap用于获取程序文件所具有的能力。</li>
<li>getpcaps用于获取进程所具有的能力。</li>
<li>setcap用于设置程序文件所具有的能力。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将<span class="built_in">chown</span>命令授权给普通用户也具备更改文件owner的能力</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中eip分别代表cap_effective(e) cap_inheritable(i) cap_permitted(p)</span></span><br><span class="line">[vagrant@localhost tmp]$ sudo setcap cap_chown=eip /usr/bin/chown</span><br><span class="line">[vagrant@localhost tmp]$ getcap /usr/bin/chown</span><br><span class="line">/usr/bin/chown = cap_chown+eip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用root创建测试文件</span></span><br><span class="line">[vagrant@localhost tmp]$ sudo touch /tmp/aa</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">普通用户也可以修改root用户创建文件的owner了</span></span><br><span class="line">[vagrant@localhost tmp]$ chown vagrant:vagrant /tmp/aa</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除<span class="built_in">chown</span>的能力</span></span><br><span class="line">[vagrant@localhost tmp]$ sudo setcap -r /usr/bin/chown</span><br><span class="line">[vagrant@localhost tmp]$ getcap /usr/bin/chown</span><br></pre></td></tr></table></figure>

<h2 id="runc项目中的应用"><a href="#runc项目中的应用" class="headerlink" title="runc项目中的应用"></a>runc项目中的应用</h2><p>runc的容器配置文件<code>spec.Process.Capabilities</code>可以定义各个能力集的能力，用来限制容器的能力。</p>
<h2 id="docker中的应用"><a href="#docker中的应用" class="headerlink" title="docker中的应用"></a>docker中的应用</h2><p>docker默认情况下给容器去掉了一些比较危险的capabilities，比如<code>cap_sys_admin</code>。</p>
<p>例如在docker中使用gdb命令默认是不允许的，这是因为docker已经将SYS_PTRACE相关的能力给去掉了。</p>
<p>在docker中使用<code>--cap-add</code>和<code>--cap-drop</code>命令来增加和删除capabilities，</p>
<p>可以使用<code>--privileged</code>赋予容器所有的capabilities，该操作谨慎使用。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://blog.csdn.net/wangpengqi/article/details/9821227">Linux的capability深入分析(1)</a></li>
<li><a href="https://blog.csdn.net/wangpengqi/article/details/9821231">Linux的capability深入分析(2)</a></li>
<li><a href="http://man7.org/linux/man-pages/man7/capabilities.7.html">Linux Programmer’s Manual CAPABILITIES</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI0NjI4MDg5MQ==&mid=2715292188&idx=1&sn=2b7f26203aa594027550e324460bc901&chksm=cd6d15c8fa1a9cde757868fd34c8336433c4877d3e7689ed0a2bd90eb1ef6271bda97aa3bb03&mpshare=1&scene=1&srcid=12045vIwpmKLu97HvFOssitt%23rd">如何在Docker内部使用gdb调试器</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>CentOS6.5下安装svn客户端软件</title>
    <url>/post/centos6.5_svn/</url>
    <content><![CDATA[<p>在用CentOS默认的svn客户端工具访问Windows下搭建的subversion时会提示如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kuring@localhost 桌面]$ svn checkout https://192.168.100.100/svn/test</span><br><span class="line">svn: 方法 OPTIONS 失败于 “https://192.168.100.100/svn/test: SSL handshake failed: SSL 错误：Key usage violation in certificate has been detected. (https://192.168.100.100)</span><br></pre></td></tr></table></figure>

<p>通过执行如下命令可以看到svn是支持https协议的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kuring@localhost ~]$ svn --version</span><br><span class="line">svn，版本 1.6.11 (r934486)</span><br><span class="line">   编译于 Apr 11 2013，16:13:51</span><br><span class="line"></span><br><span class="line">版权所有 (C) 2000-2009 CollabNet。</span><br><span class="line">Subversion 是开放源代码软件，请参阅 http://subversion.tigris.org/ 站点。</span><br><span class="line">此产品包含由 CollabNet(http://www.Collab.Net/) 开发的软件。</span><br><span class="line"></span><br><span class="line">可使用以下的版本库访问模块:</span><br><span class="line"></span><br><span class="line">* ra_neon : 通过 WebDAV 协议使用 neon 访问版本库的模块。</span><br><span class="line">  - 处理“http”方案</span><br><span class="line">  - 处理“https”方案</span><br><span class="line">* ra_svn : 使用 svn 网络协议访问版本库的模块。  - 使用 Cyrus SASL 认证</span><br><span class="line">  - 处理“svn”方案</span><br><span class="line">* ra_local : 访问本地磁盘的版本库模块。</span><br><span class="line">  - 处理“file”方案</span><br></pre></td></tr></table></figure>

<p>这是由于svn客户端在https协议中使用了GnuTLS库造成的，将其更改为使用openssl库即可。通过执行如下命令可以查看svn使用的库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kuring@localhost bin]$ ldd svn | grep ssl</span><br><span class="line">[kuring@localhost bin]$ ldd svn | grep tls</span><br><span class="line">        libgnutls.so.26 =&gt; /usr/lib64/libgnutls.so.26 (0x00007f33004ad000)</span><br></pre></td></tr></table></figure>

<hr>
<p>下面选择重新编译的方式来安装svn。</p>
<h1 id="删除subversion"><a href="#删除subversion" class="headerlink" title="删除subversion"></a>删除subversion</h1><p>执行：<code>yum remove subversion</code></p>
<h1 id="检查openssl安装情况"><a href="#检查openssl安装情况" class="headerlink" title="检查openssl安装情况"></a>检查openssl安装情况</h1><p>这里已经安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kuring@localhost tmp]$ rpm -qa | grep openssl</span><br><span class="line">openssl-1.0.1e-15.el6.x86_64</span><br><span class="line">openssl-devel-1.0.1e-15.el6.x86_64</span><br></pre></td></tr></table></figure>

<h1 id="安装neon"><a href="#安装neon" class="headerlink" title="安装neon"></a>安装neon</h1><p>这里选择的安装版本为0.29.6，subversion对neon的版本有要求。如果不是subversion的版本，在执行subversion下的configure文件时并不会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kuring@localhost software]$ tar zvxf neon-0.29.6.tar.gz</span><br><span class="line">[kuring@localhost software]$ cd neon-0.29.6</span><br><span class="line">./configure --with-ssl=openssl</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h1 id="安装apr"><a href="#安装apr" class="headerlink" title="安装apr"></a>安装apr</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar zvxf apr-1.5.0.tar.gz</span><br><span class="line">cd apr-1.5.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h1 id="安装apr-util"><a href="#安装apr-util" class="headerlink" title="安装apr-util"></a>安装apr-util</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar zvxf apr-util-1.5.3.tar.gz </span><br><span class="line">cd apr-util-1.5.3</span><br><span class="line">./configure --with-apr=/usr/local/apr</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h1 id="下载sqllite"><a href="#下载sqllite" class="headerlink" title="下载sqllite"></a>下载sqllite</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip sqlite-amalgamation-3080401.zip</span><br><span class="line">mv sqlite-amalgamation-3080401 sqlite-amalgamation</span><br><span class="line">mv sqlite-amalgamation subversion-1.8.8/	// 将其复制到subversion源码目录下</span><br></pre></td></tr></table></figure>

<h1 id="安装subversion"><a href="#安装subversion" class="headerlink" title="安装subversion"></a>安装subversion</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar zvxf subversion-1.7.16.tar.gz</span><br><span class="line">./configure --with-ssl --with-neon --with-apr=/usr/local/apr --with-apr-util=/usr/local/apr</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>然后再执行<code>svn --version</code>命令可以看到已经包含了https协议。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://itekblog.com/key-usage-violation-in-certificate-has-been-detected-centos/">SSL handshake failed: SSL error: Key usage violation in certificate has been detected CentOS</a></p>
<h1 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h1><p><a href="http://pan.baidu.com/s/1qWNhAqS">需要的安装包下载</a></p>
]]></content>
  </entry>
  <entry>
    <title>CentOS中将光盘作为安装源</title>
    <url>/post/centos_yum_iso/</url>
    <content><![CDATA[<p>本文是VMWare下的CentOS操作系统将yum源更改为光盘的实例，光盘的iso文件存放在宿主机器上，通过VMWare的共享文件夹功能与CentOS系统共享文件。CentOS中共享文件夹的存放路径为&#x2F;mnt&#x2F;hgfs中。CentOS的光盘为两张，分别为CentOS-6.5-x86_64-bin-DVD1.iso、CentOS-6.5-x86_64-bin-DVD2.iso。注意LiveCD版的CentOS系统盘是不可以作为yum源的。</p>
<h1 id="挂载光盘"><a href="#挂载光盘" class="headerlink" title="挂载光盘"></a>挂载光盘</h1><ol>
<li><code>mkdir -p /media/cdrom;mkdir -p /media/CentOS</code>，创建挂载两个挂载目录，分别挂载DVD1和DVD2。</li>
<li>执行<code>mount /mnt/hgfs/iso/CentOS-6.5-x86_64-bin-DVD1.iso /media/cdrom/ -o loop;mount /mnt/hgfs/iso/CentOS-6.5-x86_64-bin-DVD2.iso /media/CentOS/ -o loop;</code>，将iso挂载到创建的目录下。</li>
<li>执行<code>df -h</code>命令即可看到挂载的文件系统，输出如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/mnt/hgfs/iso/CentOS-6.5-x86_64-bin-DVD1.iso  4.2G  4.2G     0 100% /media/cdrom</span><br><span class="line">/mnt/hgfs/iso/CentOS-6.5-x86_64-bin-DVD2.iso  1.2G  1.2G     0 100% /media/CentOS</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="设置本地yum源"><a href="#设置本地yum源" class="headerlink" title="设置本地yum源"></a>设置本地yum源</h1><p>在&#x2F;etc&#x2F;yum.repos.d目录下CentOS-Base.repo记录着yum通过网络更新的源，CentOS-Media.repo记录着通过本地文件更新的源。其中CentOS-Media.repo文件的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># CentOS-Media.repo</span><br><span class="line">#</span><br><span class="line">#  This repo can be used with mounted DVD media, verify the mount point for</span><br><span class="line">#  CentOS-6.  You can use this repo and yum to install items directly off the</span><br><span class="line">#  DVD ISO that we release.</span><br><span class="line">#</span><br><span class="line"># To use this repo, put in your DVD and use it with the other repos too:</span><br><span class="line">#  yum --enablerepo=c6-media [command]</span><br><span class="line">#</span><br><span class="line"># or for ONLY the media repo, do this:</span><br><span class="line">#</span><br><span class="line">#  yum --disablerepo=\* --enablerepo=c6-media [command]</span><br><span class="line"></span><br><span class="line">[c6-media]</span><br><span class="line">name=CentOS-$releasever - Media</span><br><span class="line">baseurl=file:///media/CentOS/</span><br><span class="line">        file:///media/cdrom/</span><br><span class="line">        file:///media/cdrecorder/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure>

<p>其中已经包含了&#x2F;media&#x2F;cdrom路径和&#x2F;media&#x2F;CentOS路径，至此配置已经完毕。</p>
<p>安装软件需要通过命令<code>yum --disablerepo=\* --enablerepo=c6-media [command]</code>，执行<code>yum [command]</code>命令时还是联网执行。</p>
<h1 id="设置开启启动自动挂载iso文件"><a href="#设置开启启动自动挂载iso文件" class="headerlink" title="设置开启启动自动挂载iso文件"></a>设置开启启动自动挂载iso文件</h1><p>在&#x2F;etc&#x2F;fstab文件中的末尾增加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/mnt/hgfs/iso/CentOS-6.5-x86_64-bin-DVD1.iso /media/cdrom/ iso9660 loop 0 0</span><br><span class="line">/mnt/hgfs/iso/CentOS-6.5-x86_64-bin-DVD2.iso /media/CentOS/ iso9660 loop 0 0</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>证书技术</title>
    <url>/post/certificate/</url>
    <content><![CDATA[<h1 id="使用openssl创建自签名证书"><a href="#使用openssl创建自签名证书" class="headerlink" title="使用openssl创建自签名证书"></a>使用openssl创建自签名证书</h1><p>创建CA</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">openssl genrsa <span class="literal">-out</span> root.key <span class="number">4096</span></span><br><span class="line">openssl req <span class="literal">-new</span> <span class="literal">-x509</span> <span class="literal">-days</span> <span class="number">1000</span> <span class="literal">-key</span> root.key <span class="literal">-out</span> root.crt</span><br><span class="line">openssl x509 <span class="literal">-text</span> <span class="operator">-in</span> root.crt <span class="literal">-noout</span></span><br></pre></td></tr></table></figure>
<p>创建私钥和公钥文件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用来产生私钥文件server.key</span></span><br><span class="line">openssl genrsa <span class="literal">-out</span> server.key <span class="number">2048</span></span><br><span class="line"><span class="comment"># 产生公钥文件</span></span><br><span class="line">openssl rsa <span class="operator">-in</span> server.key <span class="literal">-pubout</span> <span class="literal">-out</span> server.pem</span><br></pre></td></tr></table></figure>
<p>创建签名请求</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">openssl req <span class="literal">-new</span> <span class="literal">-key</span> server.key <span class="literal">-out</span> server.csr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看创建的签名请求</span></span><br><span class="line">openssl req <span class="literal">-noout</span> <span class="literal">-text</span> <span class="operator">-in</span> server.csr</span><br></pre></td></tr></table></figure>
<p>创建自签名证书<br>新建自签名证书的附加信息server.ext，内容如下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints=CA:FALSE</span><br><span class="line">keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[<span class="type">alt_names</span>]</span><br><span class="line">DNS.<span class="number">1</span> = localhost</span><br><span class="line">IP.<span class="number">2</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">IP.<span class="number">3</span> = <span class="number">10.66</span>.<span class="number">3.6</span></span><br></pre></td></tr></table></figure>

<p>使用ca签发ssl证书，此时会产生server.crt文件，即为证书文件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">openssl x509 <span class="literal">-req</span> <span class="operator">-in</span> server.csr <span class="literal">-out</span> server.crt <span class="literal">-days</span> <span class="number">3650</span> \</span><br><span class="line">  <span class="literal">-CAcreateserial</span> <span class="literal">-CA</span> root.crt <span class="literal">-CAkey</span> root.key \</span><br><span class="line">  <span class="literal">-CAserial</span> serial <span class="literal">-extfile</span> server.ext</span><br></pre></td></tr></table></figure>

<p>查看证书文件内容</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">openssl x509 <span class="operator">-in</span> server.crt   <span class="literal">-noout</span> <span class="literal">-text</span></span><br></pre></td></tr></table></figure>

<p>使用ca校验证书是否通过</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">openssl verify <span class="literal">-CAfile</span> root.crt server.crt</span><br></pre></td></tr></table></figure>

<h1 id="使用cfssl签发证书"><a href="#使用cfssl签发证书" class="headerlink" title="使用cfssl签发证书"></a>使用cfssl签发证书</h1><p>cfssl是CloudFlare开源的一款tls工具，使用go语言编写，地址：<a href="https://github.com/cloudflare/cfssl%E3%80%82">https://github.com/cloudflare/cfssl。</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>mac用户：brew install cfssl</p>
<p>linux用户可以直接下载二进制文件：<a href="https://github.com/cloudflare/cfssl/releases">https://github.com/cloudflare/cfssl/releases</a></p>
<h2 id="签发证书"><a href="#签发证书" class="headerlink" title="签发证书"></a>签发证书</h2><p>待补充</p>
<h1 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h1><p>证书按照格式可以分为二进制和文本文件两种格式。</p>
<p>二进制格式分为：</p>
<ol>
<li><em>.der或者</em>.cer：用来存放证书信息，不包含私钥。</li>
</ol>
<p>文本格式分为：</p>
<ol>
<li><em>.pem：存放证书或者私钥。一般是</em>.key文件存放私钥信息。对于pem或者key文件，如果存在<strong>——BEGIN CERTIFICATE——</strong>，则说明这是一个证书文件。如果存在<strong>—–BEGIN RSA PRIVATE KEY—–</strong>，则说明这是一个私钥文件。</li>
<li>*.key：用来存放私钥文件。</li>
<li>*.crt：证书请求文件，格式的开头为：—–BEGIN CERTIFICATE REQUEST—–</li>
</ol>
<h2 id="证书格式的转换"><a href="#证书格式的转换" class="headerlink" title="证书格式的转换"></a>证书格式的转换</h2><p>将cert证书转换为pem格式</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">openssl rsa <span class="operator">-in</span> server.key <span class="literal">-text</span> &gt; server<span class="literal">-key</span>.pem</span><br><span class="line">openssl x509 <span class="operator">-in</span> server.crt <span class="literal">-out</span> server.pem</span><br></pre></td></tr></table></figure>
<p>将pem格式转换为cert格式</p>
<h1 id="证书查看"><a href="#证书查看" class="headerlink" title="证书查看"></a>证书查看</h1><p>查看特定域名的证书内容：<code>echo | openssl s_client  -connect www.baidu.com:443 -servername www.baidu.com 2&gt;/dev/null | openssl x509 -noout -text</code></p>
<p>获取特定域名的证书内容：<code>openssl s_client -servername www.baidu.com -connect www.baidu.com:443 &lt;/dev/null | sed -ne &#39;/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p&#39;</code></p>
<h1 id="证书的使用"><a href="#证书的使用" class="headerlink" title="证书的使用"></a>证书的使用</h1><p>curl命令关于证书的用法：</p>
<ul>
<li>–cacert：指定ca来校验server端的证书合法性</li>
<li>–cert：指定客户端的证书文件，用在双向认证mTLS中</li>
<li>–key：私钥文件名，用在双向认证mTLS中</li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://gist.github.com/liuguangw/4d4b87b750be8edb700ff94c783b1dd4">https://gist.github.com/liuguangw/4d4b87b750be8edb700ff94c783b1dd4</a></li>
<li><a href="https://coolshell.cn/articles/21708.html">https://coolshell.cn/articles/21708.html</a></li>
<li><a href="https://help.aliyun.com/document_detail/160093.html">https://help.aliyun.com/document_detail&#x2F;160093.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>cgdb的使用</title>
    <url>/post/cgdb/</url>
    <content><![CDATA[<p>长期以来在使用gdb调试代码的时候都会因为调试代码的时候查看代码不方便而烦恼，gdb的list命令不够好用。而且网上的教程中也确实不容易发现可以替代gdb的好的终端下的调试工具，对于图形界面的集成开发环境（比如Eclipse CDT）和图形界面的调试工具（比如DDD）不在本文讨论的范围内，毕竟很多时候连接linux的时候还是终端方式的居多。</p>
<h1 id="tui模式"><a href="#tui模式" class="headerlink" title="tui模式"></a>tui模式</h1><p>直到后来偶然间发现了gdb的<code>-tui</code>参数，该参数通过文本用户界面模式进行调试代码，使用起来确实方便了许多，再也不用边调试边list代码了，该模式已经满足了我的边调试边查看代码的需求。另外，gdbtui命令也可完成相同的功能。一个tui调试模式的界面如下：</p>
<p><img src="http://beej.us/guide/bggdb/gdbwinss.png" alt="gdb -tui"></p>
<p>虽然，tui模式大大的提供了调试的友好性，但是仍然有一些缺点。比如显示的代码无法语法高亮，虽然会很影响用户体验，但是我毕竟是一名后台开发的程序员，这点可以忽略不计。源码布局和gdb命令布局之间切换不够方便，这点也不要紧，毕竟可以切换，只是需要输入两个单词就可以切换了。最最有问题的就是，该命令使用的时curses库，当用ssh通过windows下的SecureCRT或者putty连接进行调试时，源码布局部分往往不能够自动刷新，需要手工输入<code>CTRL+L</code>来刷新，具体的原理我没有去深究。</p>
<h1 id="cgdb"><a href="#cgdb" class="headerlink" title="cgdb"></a>cgdb</h1><p>主要是本着解决gdb tui中的源码布局不能自动刷新的问题，本文的重点<code>cgdb</code>命令终于闪亮登场了。该命令不仅解决了源码布局自动刷新问题，同时也支持了语法高亮，同时源码查看支持vi的部分命令。功能基本跟vimgdb相近，但是安装更容易，在ubuntu下只需执行<code>sudo apt-get install cgdb</code>即可。</p>
<p><img src="https://cgdb.github.io/images/screenshot_debugging.png" alt="cgdb"></p>
<p>下面是一些常用命令：</p>
<p>ESC：切换焦点到源码模式，在该界面中可以使用vi的常用命令</p>
<p>i：切换焦点到gdb模式</p>
<p>o：打开文件对话框，选择要显示的代码文件，按ESC取消</p>
<p>空格：在当前行设置一个断点</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://beej.us/guide/bggdb/">Beej’s Quick Guide to GDB</a><br><a href="https://cgdb.github.io/">cgdb</a></p>
]]></content>
  </entry>
  <entry>
    <title>k8s多集群管理方案 - clusternet</title>
    <url>/post/clusternet/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>腾讯云开源的k8s多集群管理方案，可发布应用到多个k8s集群。<br><a href="https://github.com/clusternet/clusternet">https://github.com/clusternet/clusternet</a><br>GitHub Star：891</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/clusternet1.png" alt="image.png"><br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/clusternet2.png" alt="image.png"><br>包含clusternet-hub和clusternet-agent两个组件。</p>
<p>clusternet-hub部署在父集群，用途：</p>
<ul>
<li>接收子集群的注册请求，并为每个自己群创建namespace、serviceaccount等资源</li>
<li>提供父集群跟各个子集群的长连接</li>
<li>提供restful api来访问各个子集群，同时支持子集群的互访</li>
</ul>
<p>clusternet-agent部署在子集群，用途：</p>
<ul>
<li>自动注册子集群到父集群</li>
<li>心跳报告到中心集群，包括k8s版本、运行平台、健康状态等</li>
<li>通过websocket协议跟父集群通讯</li>
</ul>
<h1 id="CRD抽象"><a href="#CRD抽象" class="headerlink" title="CRD抽象"></a>CRD抽象</h1><h2 id="ClusterRegistrationRequest"><a href="#ClusterRegistrationRequest" class="headerlink" title="ClusterRegistrationRequest"></a>ClusterRegistrationRequest</h2><p>clusternet-agent在父集群中创建的CR，一个k8s集群一个</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: clusters.clusternet.io/v1beta1</span><br><span class="line">kind: ClusterRegistrationRequest</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    clusters.clusternet.io/cluster<span class="literal">-id</span>: <span class="number">2</span>bcd48d2<span class="literal">-0ead-45f7-938b-5af6af7da5fd</span></span><br><span class="line">    clusters.clusternet.io/cluster<span class="literal">-name</span>: clusternet<span class="literal">-cluster-pmlbp</span></span><br><span class="line">    clusters.clusternet.io/registered<span class="literal">-by</span>: clusternet<span class="literal">-agent</span></span><br><span class="line">  name: clusternet<span class="literal">-2bcd48d2-0ead-45f7-938b-5af6af7da5fd</span></span><br><span class="line">spec:</span><br><span class="line">  clusterId: <span class="number">2</span>bcd48d2<span class="literal">-0ead-45f7-938b-5af6af7da5fd</span></span><br><span class="line">  clusterName: clusternet<span class="literal">-cluster-pmlbp</span> <span class="comment"># 集群名称</span></span><br><span class="line">  clusterType: EdgeCluster <span class="comment"># 集群类型</span></span><br><span class="line">  syncMode: Dual</span><br><span class="line">status:</span><br><span class="line">  caCertificate: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKY201bGRHVnpNQjRYRFRJeE1USXhNekV3TWpjeE5Wb1hEVE14TVRJeE1URXdNamN4TlZvd0ZURVRNQkVHQTFVRQpBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTHVCCmJwdXNaZXM5RXFXaEw1WUVGb2c4eHRJai9jbFh2S1lTMnZYbGR4cUt1MUR3VHV3aUcxZUN4VGlHa2dLQXVXd1IKVFFheEh5aGY3U29lc0hqMG43NnFBKzhQT05lS1VGdERJOWVzejF2WTF5bXFoUHR0QVo0cGhkWmhmbXJjZTJLRQpuMS84MzNWbWlXd0pSZmNWcEJtTU52MjFYMVVwNWp6RGtncS9tY0JOOGN0ZU5PMEpKNkVVeTE2RXZLbjhyWG90ClErTW5PUHE4anFNMzJjRFFqYWVEdGxvM2kveXlRd1NMa2wzNFo4aElwZDZNWWVSTWpXcmhrazF4L0RYZjNJK3IKOGs5S1FBbEsvNWZRMXk5NHYwT25TK0FKZTliczZMT2srYVFWYm5SbExab2E2aVZWbUJNam03UjBjQ2w0Y1hpRwpyekRnN1ZLc3lsY1o3aGFRRTNFQ0F3RUFBYU5DTUVBd0RnWURWUjBQQVFIL0JBUURBZ0trTUE4R0ExVWRFd0VCCi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZPaGwxMHUwNnJvenZJUm9XVmpNYlVPMzFDbERNQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFBQytqMXpPQVZYVXpNUFJ0U29Kd3JhMU1FSkJOUTNMWitmWnZRYjdIbk53b00zaCthMgoyc25yUitSWTYrOFFDbXVKeis1eU5yYStEZDlnNzQ1Q0hDaFpVZzlsY3RjQTRzZVR5OXZqcUVQNVBNSzEvbi9PCnFEcDQyMUpqTjYvUXJmamIvbVM0elUvZXNGZGowQXRYQ0FLMWJsNmF0ai9jZXVBbzh1bTRPaUVlNnJhanBYTHUKWFlmQ1FVZFV5TWpQdEZHTDMwNytna0RpdlVsdXk3RkQ4aUpURTh2QWpxOVBXOW40SmxFMjdQWXR5QnNocy9XSApCZ2czQjZpTG10SjZlNzJiWnA3ZmptdmJWTC9VdkxzYXZqRXltZDhrMnN1bFFwQUpzeVJrMkEzM1g3NWJpS0RGCk1CU29DaHc3U2JMSkJrN0FNckRzTjd1Q2U3WWVIWGdZemdhRAotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==</span><br><span class="line">  dedicatedNamespace: clusternet<span class="literal">-sdqrh</span></span><br><span class="line">  managedClusterName: clusternet<span class="literal">-cluster-pmlbp</span></span><br><span class="line">  result: Approved</span><br><span class="line">  token: ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWkNJNkluZFpWMUV6UmxCbFdUUldWa1Y0UmxBeWMzaDJOV3RuUzBabVJsaG9jWG94TkhKM2JtUkxiRTlrYUZVaWZRLmV5SnBjM01pT2lKcmRXSmxjbTVsZEdWekwzTmxjblpwWTJWaFkyTnZkVzUwSWl3aWEzVmlaWEp1WlhSbGN5NXBieTl6WlhKMmFXTmxZV05qYjNWdWRDOXVZVzFsYzNCaFkyVWlPaUpqYkhWemRHVnlibVYwTFhOa2NYSm9JaXdpYTNWaVpYSnVaWFJsY3k1cGJ5OXpaWEoyYVdObFlXTmpiM1Z1ZEM5elpXTnlaWFF1Ym1GdFpTSTZJbU5zZFhOMFpYSnVaWFF0YmpneWFHc3RkRzlyWlc0dGN6SnpjRFVpTENKcmRXSmxjbTVsZEdWekxtbHZMM05sY25acFkyVmhZMk52ZFc1MEwzTmxjblpwWTJVdFlXTmpiM1Z1ZEM1dVlXMWxJam9pWTJ4MWMzUmxjbTVsZEMxdU9ESm9heUlzSW10MVltVnlibVYwWlhNdWFXOHZjMlZ5ZG1salpXRmpZMjkxYm5RdmMyVnlkbWxqWlMxaFkyTnZkVzUwTG5WcFpDSTZJamN3TWpRMk1tTTBMV0prTlRFdE5HVXpNeTA1WXpnekxUWmpPV1F6TUdGall6bG1aU0lzSW5OMVlpSTZJbk41YzNSbGJUcHpaWEoyYVdObFlXTmpiM1Z1ZERwamJIVnpkR1Z5Ym1WMExYTmtjWEpvT21Oc2RYTjBaWEp1WlhRdGJqZ3lhR3NpZlEuUjJCdEQ1YzQxRm1seC1hTEFKSWQzbGxvOThSY25TakVUak5pSnVuTXg1US1jYXhwc3VkamUxekVtUF9mTHR6TjU4d21Dd3RXcHpoaXhSMWFTUHE5LXJTRlBIYzk3aDlTT3daZGdicC10alFBSjA4dllfYWdiVFRKLU1WN1dpN0xQVzRIcmt1U3RlemUzVHh2RW11NWwySlpzbG5UTXdkR3NGRVlVZzVfeWFoLUQwQ2pnTkZlR1ljUjJ1TlJBWjdkNW00Q1c5VmRkdkNsanNqRE5WX1k0RkFEbGo2cHgzSlh0SDQ4U1ZUd254TS1sNHl0eXBENjZFbG1PYXpUMmRwSWd4eWNSZ0tJSUlacWNQNnZVc0ZOM1Zka21ZZ29ydy1NSUcwc25YdzFaZ1lwRk9SUDJRa3hjd2NOUVVOTjh6VUZqSUZSSmdSSFdjNlo4aXd2eURnZTVn</span><br></pre></td></tr></table></figure>
<h2 id="ClusterRole和Role"><a href="#ClusterRole和Role" class="headerlink" title="ClusterRole和Role"></a>ClusterRole和Role</h2><p>ClusterRegistrationRequest被接收后会创建ClusterRole</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    clusternet.io/autoupdate: <span class="string">&quot;true&quot;</span></span><br><span class="line">  labels:</span><br><span class="line">    clusternet.io/created<span class="literal">-by</span>: clusternet<span class="literal">-hub</span></span><br><span class="line">    clusters.clusternet.io/bootstrapping: rbac<span class="literal">-defaults</span></span><br><span class="line">    clusters.clusternet.io/cluster<span class="literal">-id</span>: <span class="number">2</span>bcd48d2<span class="literal">-0ead-45f7-938b-5af6af7da5fd</span></span><br><span class="line">  name: clusternet<span class="literal">-2bcd48d2-0ead-45f7-938b-5af6af7da5fd</span></span><br><span class="line">rules:</span><br><span class="line">- apiGroups:</span><br><span class="line">  - clusters.clusternet.io</span><br><span class="line">  resources:</span><br><span class="line">  - clusterregistrationrequests</span><br><span class="line">  verbs:</span><br><span class="line">  - create</span><br><span class="line">  - get</span><br><span class="line">- apiGroups:</span><br><span class="line">  - proxies.clusternet.io</span><br><span class="line">  resourceNames:</span><br><span class="line">  - <span class="number">2</span>bcd48d2<span class="literal">-0ead-45f7-938b-5af6af7da5fd</span></span><br><span class="line">  resources:</span><br><span class="line">  - sockets</span><br><span class="line">  verbs:</span><br><span class="line">  - <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>
<p>并会在cluster对应的namespace下创建Role</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: Role</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    clusternet.io/autoupdate: <span class="string">&quot;true&quot;</span></span><br><span class="line">  labels:</span><br><span class="line">    clusternet.io/created<span class="literal">-by</span>: clusternet<span class="literal">-hub</span></span><br><span class="line">    clusters.clusternet.io/bootstrapping: rbac<span class="literal">-defaults</span></span><br><span class="line">  name: clusternet<span class="literal">-managedcluster-role</span></span><br><span class="line">  namespace: clusternet<span class="literal">-sdqrh</span></span><br><span class="line">rules:</span><br><span class="line">- apiGroups:</span><br><span class="line">  - <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  resources:</span><br><span class="line">  - <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  verbs:</span><br><span class="line">  - <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="ManagedCluster"><a href="#ManagedCluster" class="headerlink" title="ManagedCluster"></a>ManagedCluster</h2><p>clusternet-hub在接受ClusterRegistrationRequest后，会创建一个ManagedCluster。一个k8s集群一个namespace</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: clusters.clusternet.io/v1beta1</span><br><span class="line">kind: ManagedCluster</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    clusternet.io/created<span class="literal">-by</span>: clusternet<span class="literal">-agent</span></span><br><span class="line">    clusters.clusternet.io/cluster<span class="literal">-id</span>: <span class="number">2</span>bcd48d2<span class="literal">-0ead-45f7-938b-5af6af7da5fd</span></span><br><span class="line">    clusters.clusternet.io/cluster<span class="literal">-name</span>: clusternet<span class="literal">-cluster-pmlbp</span></span><br><span class="line">  name: clusternet<span class="literal">-cluster-pmlbp</span></span><br><span class="line">  namespace: clusternet<span class="literal">-sdqrh</span></span><br><span class="line">spec:</span><br><span class="line">  clusterId: <span class="number">2</span>bcd48d2<span class="literal">-0ead-45f7-938b-5af6af7da5fd</span></span><br><span class="line">  clusterType: EdgeCluster</span><br><span class="line">  syncMode: Dual</span><br><span class="line">status:</span><br><span class="line">  allocatable:</span><br><span class="line">    cpu: <span class="number">7600</span>m</span><br><span class="line">    memory: <span class="string">&quot;30792789992&quot;</span></span><br><span class="line">  apiserverURL: https://<span class="number">10.233</span>.<span class="number">0.1</span>:<span class="number">443</span> <span class="comment"># default/kubernetes的service clusterip</span></span><br><span class="line">  appPusher: true</span><br><span class="line">  capacity:</span><br><span class="line">    cpu: <span class="string">&quot;8&quot;</span></span><br><span class="line">    memory: <span class="number">32192720</span>Ki</span><br><span class="line">  clusterCIDR: <span class="number">10.233</span>.<span class="number">0.0</span>/<span class="number">18</span></span><br><span class="line">  conditions:</span><br><span class="line">  - lastTransitionTime: <span class="string">&quot;2021-12-15T07:47:10Z&quot;</span></span><br><span class="line">    message: managed cluster is ready.</span><br><span class="line">    reason: ManagedClusterReady</span><br><span class="line">    status: <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="built_in">type</span>: Ready</span><br><span class="line">  healthz: true</span><br><span class="line">  heartbeatFrequencySeconds: <span class="number">180</span></span><br><span class="line">  k8sVersion: v1.<span class="number">21.5</span></span><br><span class="line">  lastObservedTime: <span class="string">&quot;2021-12-15T07:47:10Z&quot;</span></span><br><span class="line">  livez: true</span><br><span class="line">  nodeStatistics:</span><br><span class="line">    readyNodes: <span class="number">1</span></span><br><span class="line">  parentAPIServerURL: https://<span class="number">172.21</span>.<span class="number">115.160</span>:<span class="number">6443</span>  <span class="comment"># 父集群地址</span></span><br><span class="line">  platform: linux/amd64</span><br><span class="line">  readyz: true</span><br><span class="line">  serviceCIDR: <span class="number">10.233</span>.<span class="number">64.0</span>/<span class="number">18</span></span><br><span class="line">  useSocket: true</span><br></pre></td></tr></table></figure>
<h2 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h2><p>应用发布的抽象，人工提交到环境中。要发布的资源即可以是helm chart，也可以是原生的k8s对象。clusternet在部署的时候会查看部署的优先级，并且支持weight，优先部署cluster级别的资源，这点跟helm部署的逻辑一致。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps.clusternet.io/v1alpha1</span><br><span class="line">kind: Subscription</span><br><span class="line">metadata:</span><br><span class="line">  name: app<span class="literal">-demo</span></span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  <span class="comment"># 定义应用要发布到哪个k8s集群</span></span><br><span class="line">  subscribers: <span class="comment"># defines the clusters to be distributed to</span></span><br><span class="line">    - clusterAffinity:</span><br><span class="line">        matchLabels:</span><br><span class="line">          clusters.clusternet.io/cluster<span class="literal">-id</span>: dc91021d<span class="literal">-2361-4f6d-a404-7c33b9e01118</span> <span class="comment"># PLEASE UPDATE THIS CLUSTER-ID TO YOURS!!!</span></span><br><span class="line">	<span class="comment"># 定义了要发布哪些资源</span></span><br><span class="line">  feeds: <span class="comment"># defines all the resources to be deployed with</span></span><br><span class="line">    - apiVersion: apps.clusternet.io/v1alpha1</span><br><span class="line">      kind: HelmChart</span><br><span class="line">      name: mysql</span><br><span class="line">      namespace: default</span><br><span class="line">    - apiVersion: v1</span><br><span class="line">      kind: Namespace</span><br><span class="line">      name: foo</span><br><span class="line">    - apiVersion: v1</span><br><span class="line">      kind: Service</span><br><span class="line">      name: my<span class="literal">-nginx-svc</span></span><br><span class="line">      namespace: foo</span><br><span class="line">    - apiVersion: apps/v1</span><br><span class="line">      kind: Deployment</span><br><span class="line">      name: my<span class="literal">-nginx</span></span><br><span class="line">      namespace: foo</span><br></pre></td></tr></table></figure>
<h2 id="HelmChart"><a href="#HelmChart" class="headerlink" title="HelmChart"></a>HelmChart</h2><p>Subscriber发布的一个子资源之一，对应一个helm chart的完整描述</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps.clusternet.io/v1alpha1</span><br><span class="line">kind: HelmChart</span><br><span class="line">metadata:</span><br><span class="line">  name: mysql</span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  repo: https://charts.bitnami.com/bitnami</span><br><span class="line">  chart: mysql</span><br><span class="line">  version: <span class="number">8.6</span>.<span class="number">2</span></span><br><span class="line">  targetNamespace: abc</span><br></pre></td></tr></table></figure>
<h2 id="Localization"><a href="#Localization" class="headerlink" title="Localization"></a>Localization</h2><p>差异化不同于其他集群的配置，用来描述namespace级别的差异化配置。</p>
<h2 id="Globalization"><a href="#Globalization" class="headerlink" title="Globalization"></a>Globalization</h2><p>用来描述不同集群的cluster级别的差异化配置。</p>
<h2 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h2><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>跟Base对象根据Localization和Globalization渲染得到的最终要发布到集群中的最终对象。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>本文使用kind进行测试，使用kind创建两个k8s集群host和member1，两个集群的apiserver均监听在宿主机的端口，确保从一个集群可以访问到另外一个集群的apiserver。</p>
<p>在父集群执行如下命令安装clusternet管控组件：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">helm repo add clusternet https://clusternet.github.io/charts</span><br><span class="line">helm install clusternet<span class="literal">-hub</span> <span class="literal">-n</span> clusternet<span class="literal">-system</span> <span class="literal">--create-namespace</span> clusternet/clusternet<span class="literal">-hub</span></span><br><span class="line">kubectl apply <span class="operator">-f</span> https://raw.githubusercontent.com/clusternet/clusternet/main/manifests/samples/cluster_bootstrap_token.yaml</span><br></pre></td></tr></table></figure>
<p>会在clusternet-system namespace下创建deployment clusternet-hub。</p>
<p>最后一条命令，会创建一个secret，其中的token信息为07401b.f395accd246ae52d，在子集群注册的时候需要用到。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  <span class="comment"># Name MUST be of form &quot;bootstrap-token-&lt;token id&gt;&quot;</span></span><br><span class="line">  name: bootstrap<span class="literal">-token-07401b</span></span><br><span class="line">  namespace: kube<span class="literal">-system</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Type MUST be &#x27;bootstrap.kubernetes.io/token&#x27;</span></span><br><span class="line"><span class="built_in">type</span>: bootstrap.kubernetes.io/token</span><br><span class="line">stringData:</span><br><span class="line">  <span class="comment"># Human readable description. Optional.</span></span><br><span class="line">  description: <span class="string">&quot;The bootstrap token used by clusternet cluster registration.&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Token ID and secret. Required.</span></span><br><span class="line">  token<span class="literal">-id</span>: <span class="number">07401</span>b</span><br><span class="line">  token<span class="literal">-secret</span>: f395accd246ae52d</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Expiration. Optional.</span></span><br><span class="line">  expiration: <span class="number">2025</span><span class="literal">-05-10T03</span>:<span class="number">22</span>:<span class="number">11</span>Z</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Allowed usages.</span></span><br><span class="line">  usage<span class="literal">-bootstrap-authentication</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line">  usage<span class="literal">-bootstrap-signing</span>: <span class="string">&quot;true&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Extra groups to authenticate the token as. Must start with &quot;system:bootstrappers:&quot;</span></span><br><span class="line">  auth<span class="literal">-extra-groups</span>: system:bootstrappers:clusternet:<span class="built_in">register-cluster</span><span class="literal">-token</span></span><br></pre></td></tr></table></figure>

<p>在子集群执行如下命令，其中parentURL要修改为父集群的apiserver地址</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">helm repo add clusternet https://clusternet.github.io/charts</span><br><span class="line">helm install clusternet<span class="literal">-agent</span> <span class="literal">-n</span> clusternet<span class="literal">-system</span> <span class="literal">--create-namespace</span> \</span><br><span class="line">  <span class="literal">--set</span> parentURL=https://<span class="number">10.0</span>.<span class="number">248.96</span>:<span class="number">8443</span> \</span><br><span class="line">  <span class="literal">--set</span> registrationToken=<span class="number">07401</span>b.f395accd246ae52d \</span><br><span class="line">  clusternet/clusternet<span class="literal">-agent</span></span><br></pre></td></tr></table></figure>
<p>其中parentURL为父集群的apiserver地址，registrationToken为父集群注册的token信息。</p>
<h1 id="访问子集群"><a href="#访问子集群" class="headerlink" title="访问子集群"></a>访问子集群</h1><h2 id="kubectl-clusternet命令行方式访问"><a href="#kubectl-clusternet命令行方式访问" class="headerlink" title="kubectl-clusternet命令行方式访问"></a>kubectl-clusternet命令行方式访问</h2><p>安装kubectl krew插件，参考 <a href="https://krew.sigs.k8s.io/docs/user-guide/setup/install/">https://krew.sigs.k8s.io/docs/user-guide/setup/install/</a>，执行如下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">yum install git <span class="literal">-y</span></span><br><span class="line">(</span><br><span class="line">  <span class="built_in">set</span> <span class="literal">-x</span>; <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$</span>(mktemp -d)&quot;</span> &amp;&amp;</span><br><span class="line">  OS=<span class="string">&quot;<span class="variable">$</span>(uname | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)&quot;</span> &amp;&amp;</span><br><span class="line">  ARCH=<span class="string">&quot;<span class="variable">$</span>(uname -m | sed -e &#x27;s/x86_64/amd64/&#x27; -e &#x27;s/\(arm\)\(64\)\?.*/\1\2/&#x27; -e &#x27;s/aarch64<span class="variable">$</span>/arm64/&#x27;)&quot;</span> &amp;&amp;</span><br><span class="line">  KREW=<span class="string">&quot;krew-<span class="variable">$</span>&#123;OS&#125;_<span class="variable">$</span>&#123;ARCH&#125;&quot;</span> &amp;&amp;</span><br><span class="line">  <span class="built_in">curl</span> <span class="literal">-fsSLO</span> <span class="string">&quot;https://github.com/kubernetes-sigs/krew/releases/latest/download/<span class="variable">$</span>&#123;KREW&#125;.tar.gz&quot;</span> &amp;&amp;</span><br><span class="line">  tar zxvf <span class="string">&quot;<span class="variable">$</span>&#123;KREW&#125;.tar.gz&quot;</span> &amp;&amp;</span><br><span class="line">  ./<span class="string">&quot;<span class="variable">$</span>&#123;KREW&#125;&quot;</span> install krew</span><br><span class="line">)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$&#123;PATH&#125;:$&#123;HOME&#125;/.krew/bin&quot;&#x27;</span> &gt;&gt;  ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>安装kubectl插件clusternet：kubectl krew install clusternet</p>
<p>使用kubectl clusternet get可以看到发布的应用，非发布的应用看不到。</p>
<h2 id="代码层面访问子集群"><a href="#代码层面访问子集群" class="headerlink" title="代码层面访问子集群"></a>代码层面访问子集群</h2><p>可以参照例子：<a href="https://github.com/clusternet/clusternet/blob/main/examples/clientgo/demo.go#L42-L45">https://github.com/clusternet/clusternet/blob/main/examples/clientgo/demo.go#L42-L45</a></p>
<p>改动代码非常小，仅需要获取到对应集群的config信息即可。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">config, err := rest.InClusterConfig()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		klog.Error(err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// This is the ONLY place you need to wrap <span class="keyword">for</span> Clusternet</span><br><span class="line">	config.Wrap(func(rt http.RoundTripper) http.RoundTripper &#123;</span><br><span class="line">		<span class="keyword">return</span> clientgo.NewClusternetTransport(config.Host, rt)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	// now we could create and visit all the resources</span><br><span class="line">	client := kubernetes.NewForConfigOrDie(config)</span><br><span class="line">	_, err = client.CoreV1().Namespaces().Create(context.TODO(), &amp;corev1.Namespace&#123;</span><br><span class="line">		ObjectMeta: metav1.ObjectMeta&#123;</span><br><span class="line">			Name: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;, metav1.CreateOptions&#123;&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="应用发布"><a href="#应用发布" class="headerlink" title="应用发布"></a>应用发布</h1><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/clusternet3.png" alt="image.png"><br>在主集群提交如下的yaml文件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: apps.clusternet.io/v1alpha1</span><br><span class="line">kind: Subscription</span><br><span class="line">metadata:</span><br><span class="line">  name: app<span class="literal">-demo</span></span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  subscribers: <span class="comment"># defines the clusters to be distributed to</span></span><br><span class="line">    - clusterAffinity:</span><br><span class="line">        matchLabels:</span><br><span class="line">          clusters.clusternet.io/cluster<span class="literal">-id</span>: dc91021d<span class="literal">-2361-4f6d-a404-7c33b9e01118</span> <span class="comment"># PLEASE UPDATE THIS CLUSTER-ID TO YOURS!!!</span></span><br><span class="line">  feeds: <span class="comment"># defines all the resources to be deployed with</span></span><br><span class="line">    - apiVersion: apps.clusternet.io/v1alpha1</span><br><span class="line">      kind: HelmChart</span><br><span class="line">      name: mysql</span><br><span class="line">      namespace: default</span><br><span class="line">    - apiVersion: v1</span><br><span class="line">      kind: Namespace</span><br><span class="line">      name: foo</span><br><span class="line">    - apiVersion: apps/v1</span><br><span class="line">      kind: Service</span><br><span class="line">      name: my<span class="literal">-nginx-svc</span></span><br><span class="line">      namespace: foo</span><br><span class="line">    - apiVersion: apps/v1</span><br><span class="line">      kind: Deployment</span><br><span class="line">      name: my<span class="literal">-nginx</span></span><br><span class="line">      namespace: foo</span><br></pre></td></tr></table></figure>

<h1 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h1><p>在主集群实现了两个aggregated apiservice</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: apiregistration.k8s.io/v1</span><br><span class="line">kind: APIService</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    meta.helm.sh/release<span class="literal">-name</span>: clusternet<span class="literal">-hub</span></span><br><span class="line">    meta.helm.sh/release<span class="literal">-namespace</span>: clusternet<span class="literal">-system</span></span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/instance: clusternet<span class="literal">-hub</span></span><br><span class="line">    app.kubernetes.io/managed<span class="literal">-by</span>: Helm</span><br><span class="line">    app.kubernetes.io/name: clusternet<span class="literal">-hub</span></span><br><span class="line">    helm.sh/chart: clusternet<span class="literal">-hub-0</span>.<span class="number">2.1</span></span><br><span class="line">  name: v1alpha1.proxies.clusternet.io</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">group</span>: proxies.clusternet.io</span><br><span class="line">  groupPriorityMinimum: <span class="number">1000</span></span><br><span class="line">  insecureSkipTLSVerify: true</span><br><span class="line">  service:</span><br><span class="line">    name: clusternet<span class="literal">-hub</span></span><br><span class="line">    namespace: clusternet<span class="literal">-system</span></span><br><span class="line">    port: <span class="number">443</span></span><br><span class="line">  version: v1alpha1</span><br><span class="line">  versionPriority: <span class="number">100</span></span><br></pre></td></tr></table></figure>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: apiregistration.k8s.io/v1</span><br><span class="line">kind: APIService</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    meta.helm.sh/release<span class="literal">-name</span>: clusternet<span class="literal">-hub</span></span><br><span class="line">    meta.helm.sh/release<span class="literal">-namespace</span>: clusternet<span class="literal">-system</span></span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/instance: clusternet<span class="literal">-hub</span></span><br><span class="line">    app.kubernetes.io/managed<span class="literal">-by</span>: Helm</span><br><span class="line">    app.kubernetes.io/name: clusternet<span class="literal">-hub</span></span><br><span class="line">    helm.sh/chart: clusternet<span class="literal">-hub-0</span>.<span class="number">2.1</span></span><br><span class="line">  name: v1alpha1.shadow</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">group</span>: shadow</span><br><span class="line">  groupPriorityMinimum: <span class="number">1</span></span><br><span class="line">  insecureSkipTLSVerify: true</span><br><span class="line">  service:</span><br><span class="line">    name: clusternet<span class="literal">-hub</span></span><br><span class="line">    namespace: clusternet<span class="literal">-system</span></span><br><span class="line">    port: <span class="number">443</span></span><br><span class="line">  version: v1alpha1</span><br><span class="line">  versionPriority: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/BSgb2uoAuHbxQOUvn8fEsA">https://mp.weixin.qq.com/s/BSgb2uoAuHbxQOUvn8fEsA</a></li>
</ul>
]]></content>
      <tags>
        <tag>多集群</tag>
      </tags>
  </entry>
  <entry>
    <title>CNCF Landscape解读</title>
    <url>/post/cncf-landscape/</url>
    <content><![CDATA[<h1 id="什么是CNCF-Landscape？"><a href="#什么是CNCF-Landscape？" class="headerlink" title="什么是CNCF Landscape？"></a>什么是CNCF Landscape？</h1><p>CNCF（Cloud Native Computing Foundation）为云原生计算基金会的英文缩写，致力于云原生技术的普及和推广。</p>
<p>CNCF Landscape为CNCF的一个重要项目，为了帮助企业和个人开发者快速了解云原生技术的全貌，该项目维护在<a href="https://github.com/cncf/landscape">GitHub</a>。CNCF Landscape的最重要的两个产出物为路线图和愿景图。</p>
<h1 id="CNCF-Landscape路线图"><a href="#CNCF-Landscape路线图" class="headerlink" title="CNCF Landscape路线图"></a>CNCF Landscape路线图</h1><p><img src="https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png"></p>
<p>路线图的目的是指导用户使用云原生技术的路径和开源项目。其中包括了10个步骤。</p>
<h1 id="CNCF-Landscape愿景图"><a href="#CNCF-Landscape愿景图" class="headerlink" title="CNCF Landscape愿景图"></a>CNCF Landscape愿景图</h1><p>将云原生技术进行了分层分类，可以非常清晰的将云原生技术展示给用户。类似于软件架构中，又称“方块图”、“砌砖图”。<br><img src="https://landscape.cncf.io/images/landscape.png"></p>
<p>精简版图形如下：</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/cncf_landscape2.png"></p>
<h2 id="供给层（provisioning）"><a href="#供给层（provisioning）" class="headerlink" title="供给层（provisioning）"></a>供给层（provisioning）</h2><p>愿景图的第一层，是云原生平台和云原生应用的基础。</p>
<h3 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h3><p>关键词：IaC（基础设施即代码）、声明式配置</p>
<p>用来加速计算机资源的创建和配置，资源包括虚拟机、网络、防火墙规则、负载均衡等。只需要点击下按钮，即可自动化创建对应的资源，用来降低人工的维护。</p>
<p>典型工具代表：Terraform、Chef、Ansible、Puppet</p>
<p>CNCF项目列表：</p>
<table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Akri</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>CDK for Kubernetes</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Cloud Custodian</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>KubeDL</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>KubeEdge</td>
<td>孵化</td>
<td>华为开源的边缘计算项目</td>
</tr>
<tr>
<td>Metal3-io</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>OpenYurt</td>
<td>沙箱</td>
<td>阿里云开源的边缘计算项目</td>
</tr>
<tr>
<td>SuperEdge</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Tinkerbell</td>
<td>沙箱</td>
<td></td>
</tr>
</tbody></table>
<h3 id="容器镜像仓库"><a href="#容器镜像仓库" class="headerlink" title="容器镜像仓库"></a>容器镜像仓库</h3><p>用来存储和拉取容器镜像，最简单的项目如docker官方的单机版的docker registry，所有的公有云厂商也都有自己的工具。</p>
<p>CNCF项目包括：</p>
<table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://goharbor.io/">Harbor</a></td>
<td>毕业</td>
<td>由vmware打造的镜像仓库，提供了很多企业级的特性，广受企业内部使用。</td>
</tr>
<tr>
<td><a href="https://d7y.io/">Dragonfly</a></td>
<td>孵化</td>
<td>阿里开源的基于P2P技术做镜像分发项目，在大规模集群的场景下效果会比较明显。</td>
</tr>
</tbody></table>
<h3 id="安全合规"><a href="#安全合规" class="headerlink" title="安全合规"></a>安全合规</h3><p>关键词：镜像扫描、镜像签名、策略管理、审计、证书管理、代码扫描、漏洞扫描、网络层安全</p>
<p>用来监控、增强应用和平台的安全性，包括从容器到k8s的运行时环境均会涉及到。</p>
<p>CNCF项目包括：</p>
<table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td><a href="%5Bcert-manager%5D(https://cert-manager.io/)">cert-manager</a></td>
<td>沙箱</td>
<td>证书签发工具，部署在k8s之上，通过抽象CRD Certificate来管理证书，也可以用来管理Ingress的证书</td>
</tr>
<tr>
<td>Confidential Containers</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Curiefense</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Dex</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Falco</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>in-toto</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>Keylime</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Kyverno</td>
<td>沙箱</td>
<td>基于k8s的策略引擎工具，通过抽象CRD ClusterPolicy的方式来声明策略，在运行时通过webhook的技术来执行策略。相比于opa &amp; gatekeeper，更加k8s化，但却没有编程语言的灵活性。</td>
</tr>
<tr>
<td>Notary</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>Open Policy Agent (OPA)</td>
<td>毕业</td>
<td>基于Rego语言的策略引擎，编程能力非常强大</td>
</tr>
<tr>
<td>Parsec</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>[The Update Framework (TUF)](<a href="https://theupdateframework.io/">The Update Framework</a>)</td>
<td>毕业</td>
<td></td>
</tr>
</tbody></table>
<h3 id="秘钥和身份管理"><a href="#秘钥和身份管理" class="headerlink" title="秘钥和身份管理"></a>秘钥和身份管理</h3><p>关键词：秘钥、身份、Secret、访问控制、认证、授权</p>
<p>CNCF项目包括：</p>
<table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Athenz</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>SPIFFE</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>SPIRE</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>Teller</td>
<td>沙箱</td>
<td></td>
</tr>
</tbody></table>
<h2 id="运行时层（Runtime）"><a href="#运行时层（Runtime）" class="headerlink" title="运行时层（Runtime）"></a>运行时层（Runtime）</h2><h3 id="云原生存储"><a href="#云原生存储" class="headerlink" title="云原生存储"></a>云原生存储</h3><p>关键词：PV、CSI、备份和恢复</p>
<p>云原生架构下，存储类的工具主要涉及到如下几个方面：</p>
<ol>
<li>为容器提供云原生的存储。由于容器具有灵活、弹性的特点，云原生的存储相比传统存储会更复杂。</li>
<li>需要有统一的接口。这块基本都会使用k8s的CSI接口。另外，minio提供了S3协议的接口。</li>
<li>备份和还原功能。例如Velero可以用来备份k8s本身和容器使用到的存储。</li>
</ol>
<p>CNCF项目包括：</p>
<table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>CubeFS</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>K8up</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Longhorn</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>OpenEBS</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>ORAS</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Piraeus Datastore</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Rook</td>
<td>毕业</td>
<td></td>
</tr>
<tr>
<td>Vineyard</td>
<td>沙箱</td>
<td></td>
</tr>
</tbody></table>
<h3 id="容器运行时"><a href="#容器运行时" class="headerlink" title="容器运行时"></a>容器运行时</h3><p>容器运行时的三个主要特征：标准化、安全、隔离性。Containerd和CRI-O为容器运行时的标准实现方案，业界类似KataContainer的方式为将VM作为容器运行时，gVisor方案则在OS和容器中间增加了额外的安全层。</p>
<p>发展趋势：</p>
<ol>
<li>基于 MicroVM 的安全容器技术，通过虚拟化和容器技术的结合，可以提升更高的安全性。比如 KataContainer。</li>
<li>操作系统的虚拟化程度进一步增加。Linux 4.5 版本的 CGroup V2 技术逐渐成熟，进一步提升了容器的隔离能力。Docker 提供了 rootless 技术，可以以非 root 用户运行，提升了容器的安全性。</li>
<li>WebAssembly技术作为跨平台的容器技术可能会作为新的挑战者出现。</li>
</ol>
<table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Containerd</td>
<td>毕业</td>
<td></td>
</tr>
<tr>
<td><a href="%5Bcri-o%5D(https://cri-o.io/)">CRI-O</a></td>
<td>孵化</td>
<td>k8s的CRI的轻量级实现，支持runc和kata作为容器运行时</td>
</tr>
<tr>
<td>Inclavare Containers</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>rkt</td>
<td>归档</td>
<td>CoreOS公司主导研发的容器引擎，昔日的Docker竞争对手，目前已经没落，已经被CNCF归档</td>
</tr>
<tr>
<td>WasmEdge Runtime</td>
<td>沙箱</td>
<td></td>
</tr>
</tbody></table>
<h3 id="云原生网络"><a href="#云原生网络" class="headerlink" title="云原生网络"></a>云原生网络</h3><p>关键词：SDN、CNI、Overlay网络</p>
<p>云原生网络具体指的是容器网络，k8s定义了CNI的网络规范，开源项目只需要实现CNI的网络规范即可，社区有非常多的CNI项目可以选择，比如Calico、Flannel、Weave Net等。网络分为Underlay和Overlay网络，其中容器网络为SDN网络，以overlay网络居多。</p>
<table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Antrea</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Cilium</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/cni-genie/CNI-Genie">CNI-Genie</a></td>
<td>沙箱</td>
<td>华为云开源的多网络平面的项目，该项目并非具体的网络插件实现，而是k8s的CNI和具体网络插件实现的中间层，可以实现同一个节点上有多种网络插件的实现，支持同一个pod中有多个网卡。</td>
</tr>
<tr>
<td><a href="https://github.com/containernetworking/cni">CNI（Container Network Interface）</a></td>
<td>孵化</td>
<td>k8s的容器网络规范，指的一提的是在[plugins](<a href="https://github.com/containernetworking/plugins">containernetworking&#x2F;plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)</a>)项目中，提供了很多k8s内置的简单容器插件，比如macvlan、bandwidth等</td>
</tr>
<tr>
<td>Kube-OVN</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Network Service Mesh</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Submariner</td>
<td>沙箱</td>
<td>Rancher公司开源的项目，用来解决k8s的多集群场景下的跨集群互通问题</td>
</tr>
</tbody></table>
<h2 id="编排和管理层（Orchestration-amp-Management）"><a href="#编排和管理层（Orchestration-amp-Management）" class="headerlink" title="编排和管理层（Orchestration &amp; Management）"></a>编排和管理层（Orchestration &amp; Management）</h2><h3 id="调度和编排"><a href="#调度和编排" class="headerlink" title="调度和编排"></a>调度和编排</h3><p>在单机的系统中，操作系统会来调度系统中运行的所有的进程，允许某个时间点调度某个进程到某个cpu上面。在集群的环境中，同样需要调度容器在某个时间点运行在某台主机的某个cpu上。</p>
<p>在云原生社区基本上形成以k8s为生态的调度和编排，主要的发展方向为：</p>
<ul>
<li>扩展k8s自身的功能。</li>
<li>k8s的多集群方向。</li>
</ul>
<table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Crossplane</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>Fluid</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Karmada</td>
<td>沙箱</td>
<td>华为云开源的k8s多集群管理项目，用来管理多个k8s集群。自己实现了一套完整的apiserver、scheduler、controller-manager，用来多k8s集群的调度。</td>
</tr>
<tr>
<td>kube-rs</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Kubernetes</td>
<td>毕业</td>
<td>CNCF的最重要项目，在容器编排领域具有绝对的统治地位。俗称“现代数据中心的操作系统”</td>
</tr>
<tr>
<td>Open Cluster Management</td>
<td>沙箱</td>
<td>Redhat主导的k8s多集群项目</td>
</tr>
<tr>
<td>Volcano</td>
<td>孵化</td>
<td>华为云开源的基于k8s的容器批量计算平台，常用于大数据、AI领域。k8s默认的Job设计较为简单，无法满足很多批处理场景。Volcano通过CRD扩展的方式定义了Queue、PodGroup、VolcanoJob等实现对批处理作业的抽象，并通过调度器扩展的方式来大幅提升pod的调度效率。</td>
</tr>
<tr>
<td>wasmCloud</td>
<td>沙箱</td>
<td></td>
</tr>
</tbody></table>
<h3 id="调协和服务发现"><a href="#调协和服务发现" class="headerlink" title="调协和服务发现"></a>调协和服务发现</h3><p>该领域主要包含两类工具：</p>
<ol>
<li>服务发现引擎。</li>
<li>域名解析服务。比如CoreDNS。</li>
</ol>
<table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>CoreDNS</td>
<td>毕业</td>
<td></td>
</tr>
<tr>
<td>etcd</td>
<td>毕业</td>
<td></td>
</tr>
<tr>
<td>k8gb</td>
<td>沙箱</td>
<td></td>
</tr>
</tbody></table>
<h3 id="远程过程调用（RPC）"><a href="#远程过程调用（RPC）" class="headerlink" title="远程过程调用（RPC）"></a>远程过程调用（RPC）</h3><p>用于进程间通讯的框架，主要解决的问题：</p>
<ol>
<li>提供了框架，使开发者编码更简单。</li>
<li>提供了结构化的通讯协议。</li>
</ol>
<table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>gRPC</td>
<td>孵化</td>
<td>业界使用较为广泛的RPC框架</td>
</tr>
</tbody></table>
<h3 id="服务代理"><a href="#服务代理" class="headerlink" title="服务代理"></a>服务代理</h3><p>通常又称为负载均衡，从协议上来划分，可以分为四层负载均衡和七层负载均衡。</p>
<table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>BFE</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Contour</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>Envoy</td>
<td>毕业</td>
<td></td>
</tr>
<tr>
<td>OpenELB</td>
<td>沙箱</td>
<td></td>
</tr>
</tbody></table>
<h3 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h3><p>相比于七层负载均衡，API网关还提供了更多高级特性，比如认证、鉴权、限流等。</p>
<table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Emissary-Ingress</td>
<td>孵化</td>
<td></td>
</tr>
</tbody></table>
<h3 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h3><p>值得注意的是，业内最为流行的istio项目并不在该范围内。</p>
<table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Kuma</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Linkerd</td>
<td>毕业</td>
<td>流行的服务网格项目</td>
</tr>
<tr>
<td>Meshery</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Open Service Mesh</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Service Mesh Interface</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Service Mesh Performance</td>
<td>沙箱</td>
<td></td>
</tr>
</tbody></table>
<h2 id="应用定义和应用部署"><a href="#应用定义和应用部署" class="headerlink" title="应用定义和应用部署"></a>应用定义和应用部署</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>SchemaHero</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>TiKV</td>
<td>毕业</td>
<td>国内公司PingCAP开源的分布式kv数据库</td>
</tr>
<tr>
<td><a href="https://vitess.io/zh/">Vitess</a></td>
<td>毕业</td>
<td>用来扩展mysql集群的数据库解决方案，突破单mysql集群的性能瓶颈</td>
</tr>
</tbody></table>
<h3 id="流式计算和消息"><a href="#流式计算和消息" class="headerlink" title="流式计算和消息"></a>流式计算和消息</h3><table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://cloudevents.io/">CloudEvents</a></td>
<td>孵化</td>
<td>仅描述了事件的数据规范，并非具体的实现</td>
</tr>
<tr>
<td>NATS</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>Pravega</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Strimzi</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Tremor</td>
<td>沙箱</td>
<td></td>
</tr>
</tbody></table>
<h3 id="应用定义和镜像构建"><a href="#应用定义和镜像构建" class="headerlink" title="应用定义和镜像构建"></a>应用定义和镜像构建</h3><table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Artifact Hub</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Backstage</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>Buildpacks</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>Devfile</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Helm</td>
<td>毕业</td>
<td>k8s的应用打包工具</td>
</tr>
<tr>
<td>Krator</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>KubeVela</td>
<td>沙箱</td>
<td>阿里云开源的基于OAM的应用模型的实现，用来做应用的发布，同时支持多集群</td>
</tr>
<tr>
<td>KubeVirt</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>KUDO</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Nocalhost</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td><a href="%5Bhttps://operatorframework.io%5D(https://operatorframework.io/)">Operator Framework</a></td>
<td>孵化</td>
<td>用来开发基于k8s CRD的operator框架，功能跟k8s亲生的kubebuilder非常相似</td>
</tr>
<tr>
<td>Porter</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sealer</td>
<td>沙箱</td>
<td>阿里云开源的集群部署工具，理念比较先进，通过升维的方式可以通过类似Dockerfile的方式来构建集群镜像，并可以通过类似docker run的方式一键拉起完成的一套基于k8s的集群环境</td>
</tr>
<tr>
<td>Serverless Workflow</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Telepresence</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="持续集成和持续交付"><a href="#持续集成和持续交付" class="headerlink" title="持续集成和持续交付"></a>持续集成和持续交付</h3><table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Argo</td>
<td>孵化</td>
<td>k8s上应用广泛的工作流引擎</td>
</tr>
<tr>
<td>Brigade</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Flux</td>
<td>孵化</td>
<td>gitops工具</td>
</tr>
<tr>
<td>Keptn</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>OpenGitOps</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td><a href="https://openkruise.io/zh/">OpenKruise</a></td>
<td>沙箱</td>
<td>基于k8s能力扩展的组件，通过CRD的方式定义了很多对象，用来增强k8s的workload能力。该组件放到该领域下有些不合适。</td>
</tr>
</tbody></table>
<h2 id="可观测和分析"><a href="#可观测和分析" class="headerlink" title="可观测和分析"></a>可观测和分析</h2><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Cortex</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>Fonio</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Kuberhealthy</td>
<td>沙箱</td>
<td>k8s的巡检工具，用来检查k8s的健康状态。支持以插件的方式接入巡检脚本。</td>
</tr>
<tr>
<td><a href="https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md">OpenMetrics</a></td>
<td>沙箱</td>
<td>从Prometheus项目中发展出来的监控数据格式标准，该项目仅定义标准，非实现。</td>
</tr>
<tr>
<td>Pixie</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Prometheus</td>
<td>毕业</td>
<td>云原生领域事实上的监控标准</td>
</tr>
<tr>
<td>Skooner</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Thanos</td>
<td>孵化</td>
<td>prometheus的集群化方案</td>
</tr>
<tr>
<td>Trickster</td>
<td>沙箱</td>
<td></td>
</tr>
</tbody></table>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.fluentd.org/">Fluentd</a></td>
<td>毕业</td>
<td>日志收集工具</td>
</tr>
</tbody></table>
<h3 id="分布式会话跟踪"><a href="#分布式会话跟踪" class="headerlink" title="分布式会话跟踪"></a>分布式会话跟踪</h3><table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Jaeger</td>
<td>毕业</td>
<td>User开源的完整的分布式会话跟踪项目</td>
</tr>
<tr>
<td><a href="https://opentelemetry.io/">OpenTelemetry</a></td>
<td>孵化</td>
<td>同时集成了监控、日志和分布式会话跟踪三个领域的数据收集工具，大有一统可观察性领域的趋势。</td>
</tr>
<tr>
<td><a href="https://opentracing.io/">OpenTracing</a></td>
<td>归档</td>
<td>已经完全被OpenTelemetry取代</td>
</tr>
</tbody></table>
<h3 id="混沌引擎"><a href="#混沌引擎" class="headerlink" title="混沌引擎"></a>混沌引擎</h3><table>
<thead>
<tr>
<th>CNCF项目</th>
<th>项目阶段</th>
<th>项目介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Chaos Mesh</td>
<td>孵化</td>
<td></td>
</tr>
<tr>
<td>Chaosblade</td>
<td>沙箱</td>
<td></td>
</tr>
<tr>
<td>Litmus</td>
<td>沙箱</td>
<td></td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://landscape.cncf.io/">Cloud Native Landscape</a></li>
<li><a href="https://mp.weixin.qq.com/s/RPuzsVOyFGtqPdcqZqF_1Q">云原生全景图详解系列（一）：带你了解云原生技术图谱</a></li>
<li><a href="https://mp.weixin.qq.com/s/NrW9-cJ1Lg-VF0WK8kPb7w">云原生全景图详解系列（二）：供应层</a></li>
<li><a href="https://mp.weixin.qq.com/s/Q3USUso_PqeTrpNW8mIDhA">云原生全景图详解系列（三）：运行时层</a></li>
<li><a href="https://mp.weixin.qq.com/s/2G4uvqo9_mEbRPh9MfnUmw">云原生全景图详解系列（四）：编排和管理层</a></li>
<li><a href="https://mp.weixin.qq.com/s/Zkj0jQC1QOXFLkhCc0zlug">云原生全景图详解系列（五）：应用程序定义和开发层</a></li>
<li><a href="https://mp.weixin.qq.com/s/73AjqjDG7VuFjtYgCBhHDg">云原生全景图详解（六）｜托管 Kubernetes 和 PaaS 解决什么问题</a></li>
<li><a href="https://mp.weixin.qq.com/s/vJwqf9S8l9KpymmAAWACxw">云原生全景图详解（七）：可观察性是什么，有哪些相关工具</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>公司问题及经验总结</title>
    <url>/post/company_question/</url>
    <content><![CDATA[<p>我在软件行业工作已经有五个年头了，在现在这家公司已经有两个年头了。虽然身为公司的研发部经理可以参与公司的一些决定，但是没有绝对的话语权，对于公司的很多决定我深知是错误的，虽然后来也证明是错误的，但是我仍然无能为力。这里总结一下在公司中遇到的问题。</p>
<p>宁可招聘一个技术水平高的也不愿招聘三个技术水平低的。在工作中能够非常有力的证明这一点，三个刚工作的技术人员，尤其对于C++这样门槛稍微高一些，需要工作经验来弥补C++中坑的语言，三个C++技术人员远没有一个高水平的工作效率高，因为三个菜鸟需要将大牛踩过的坑全部踩一遍，踩过多少坑就代表走了多少弯路。</p>
<p>兴趣是最大的老师。我带过不少人，很多都是新人，我给他们制定了学习计划，期望他们能够在业余时间多学习，但实际上哪有几个人能够充分利用业余时间的。我就非常怀疑他们对技术的兴趣问题，如果他们对技术不感兴趣那为什么要加入该行业，为没有兴趣的工作而工作就是自己对自己耍流氓。如果他们对技术感兴趣，那只能说明他们业余时间中有更大的诱惑。</p>
<p>在招聘中不要过于在意金钱，便宜无好货在招聘行业中仍然非常适用。在招聘中千万不要吝惜给员工的那点钱，因为一千块钱而错失一个好的员工是非常不值得的。</p>
<p>盈利模式决定了公司对产品的态度。我所在的软件行业属于传统的软件行业，传统软件行业的盈利模式为销售，由于软件具有可复制性的特点，因此只要一套产品卖的越多就赚的越多。对于传统软件行业的产品使用者很多情况下就是几个人，至少跟互联网产品的用户数量不在一个量级。使用的人数决定了传统软件行业的用户体验可以做的很烂，技术水平可以不用那么高，只要能用就行，慢点无所谓，只要能卖出去就行了。身为一个技术人员，一个对技术有追求的技术人员，这令我非常反感，我做技术我不能对技术无所谓，我讨厌听到无所谓这样的字眼。</p>
<p>一定要明确公司的定位，明白什么时候应该干什么，什么应该干，野心太大也是问题。公司处于成长阶段提出了今年营业额比去年增长10倍的目标，我听到之后就是嗤之以鼻，这压根就是不可能的任务，而事实证明这也根本不可能完成，实际上当年营业额仅比去年增长了一倍。</p>
<p>一家公司一定要有自己的明确产品线，要抵住外界的诱惑。公司的产品线本来是非常明确的，后来由于客户需求和各种方面的原因，开始考虑疯狂扩展产品，这就造成了本来人手就紧蹙的情况下，没有时间去改善现有的系统，不得不去研发新的产品。自己没有的产品甚至跟客户合作或者完全购买别人的产品，导致公司很多人都在考虑跟其他公司合作的事宜。结果可想而知，新产品的销售并不理想，旧有的产品升级维护的也开始变慢。ps：我是非常讨厌在技术上跟其他公司之间考虑合作的问题，因为这从本质上讲并没有产生任何的社会价值，技术上必然涉及到接口的问题，只要是接口必然会有很多细节问题，这些往往会出现技术人员扯皮的问题，一个问题你可以解决他也可以解决，但是谁都不愿意解决，你说烦不烦。</p>
<p>技术人员后来要么转行要么做管理了。在济南技术人员就这两种出路吧，没见过多少大龄的程序员，很多情况下写着写着程序突然发现自己转为公司的中层了，比如我，并逐渐参与公司的事务。很多对程序不感兴趣的，可能就直接换个行业或者转行做销售了。</p>
<p>有些人再怎么培养也成不了高手。在工作我发现，有些人即使有了几年的工作经验，对公司的产品也非常了解，但是在解决问题的时候总是找不到点子上，占了一大堆资源，最后解决起问题来即慢又绕弯路，还留下一堆bug。对于这部分人，我想说也许这个行业不适合你。</p>
<p>领导千万不可三天两头一个想法，这在员工看来就是一个不靠谱的领导。谁都不愿意追随一个拿着自己当猴耍的领导，一会一个想法只能说明领导不够成熟，不适合做领导。跟随杰出的人，为杰出的人工作。</p>
<p>搞公司最好不要搞施工太久的。公司很多做工程的都在为现场的情况忙碌，一个点架设完毕后往往还需要耗费大量的时间来维护，维护对于公司而言牵涉到精力太大，尽量避免需要整天跟客户打交道和整天维护的业务。</p>
<p>专科生是很难撑起一家科技企业。虽然我不完全认同学历就能决定能力，但学历跟能力之间是成正比关系的。我的朋友中有专科生在工作几年后可以做专业的视频教程，并且业余时间写过几部玄幻小说。由于学习经历的不同这就造就了科班出身的程度不同，自然能力之间是有差异的。虽然中国的大学教育跟工作很脱节，但是在工作中还是能够跟大学教育挂起钩来的。学历跟素质之间也是成正比关系的，这里的素质体现在工作中就包括了工作中的责任心，工作态度等方面，这里就不展开了，要展开的话我可以举出非常多活生生的例子。因此，我非常不提倡在公司招聘中招聘专科生。我发现在很多情况下，很多专科人员是连普通话都不会的，操着各种方言或各种被普通话的方言。基本上能不能说普通话也是一个断定人素质的标准，扩展到其他行业同样适用。</p>
<p>也许本文的观点有些偏激，没错我就是一个偏激的IT工程师，就酱。</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>通过命令编译java程序</title>
    <url>/post/compile_java_code/</url>
    <content><![CDATA[<p>通过Eclipse编写java程序久了，发现已经不会用命令来编译java程序了。今天在windows下搭建了一个solr环境，想放到linux下去跑一下，在windows上打成jar包后放在linux下不能运行，是时候回顾一下java的编译命令了。而且网上的资料比较零散，没有特别系统的资料。</p>
<p>本文在linux测试，同windows下的命令行工具差别不大。</p>
<h1 id="编译并执行单个文件"><a href="#编译并执行单个文件" class="headerlink" title="编译并执行单个文件"></a>编译并执行单个文件</h1><p>1. 在目录下<code>~/test_java/com/kuring</code>下新建HelloWorld.java的文件，文件内容为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HellowWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2. 在目录<code>~/test_java</code>下执行<code>javac com/kuring/HelloWorld.java</code>命令来编译文件。此时会在HelloWorld.java文件所在的目录下生成HelloWorld.class的二进制文件。</p>
<p>3. 在目录<code>~/test_java</code>下执行<code>java com.kuring.HelloWorld</code>来执行HelloWorld.class。屏幕会输出<code>hello world</code>，说明文件执行成功。<br>也可以在任意路径下指定classpath路径来执行，命令为<code>java -classpath  ~/test_java com.kuring.HelloWorld</code>，其中classpath指定了类的搜索路径。</p>
<h1 id="编译并执行多个文件"><a href="#编译并执行多个文件" class="headerlink" title="编译并执行多个文件"></a>编译并执行多个文件</h1><p>1. 在目录下<code>~/test_java/com/kuring</code>下新建HelloWorld2.java和Main.java的文件，HelloWorld2.java文件内容为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HellowWorld2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello world too&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main.java的文件内容为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">HelloWorld2</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloWorld2</span>();</span><br><span class="line">		hello.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2. 在目录<code>~/test_java</code>下执行<code>javac com/kuring/Main.java</code>命令来编译文件。此时会在Main.java文件所在的目录下生成Main.class和HelloWorld2.class两个文件，可以看出javac有自动推导编译的功能。</p>
<p>3. 在目录<code>~/test_java</code>下执行<code>java com.kuring.Main</code>。屏幕会输出<code>hello world too</code>，说明文件执行成功。</p>
<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>将上述例子中的程序打成jar包，可以在<code>~/test_java</code>目录下通过执行命令<code>jar cvf my.jar com</code>来生成jar文件。其中my.jar为要生成的jar文件的名字。<br>通过<code>java -classpath my.jar com.kuring.Main</code>来执行jar文件。<br>上述命令需要指定要执行的类名Main，如果想通过<code>java -jar my.jar</code>命令即可执行程序需要在jar包的META-INF&#x2F;MANIFEST.MF文件中增加一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Main-Class: SolrTest</span><br></pre></td></tr></table></figure>
<p>来执行含有main函数的类。然后通过<code>jar -cfm my.jar MANIFEST.MF路径 要打包的目录或文件</code>来重新生成jar包。这样就可以通过<code>java -jar my.jar</code>来执行jar包了。</p>
<p>关于如何创建并执行引用了其他jar包的jar包，可以参考我的另外一篇博客《<a href="/post/solr_setup">在Linux上搭建solr环境</a>》，这里不再赘述。</p>
<h1 id="常用jar命令"><a href="#常用jar命令" class="headerlink" title="常用jar命令"></a>常用jar命令</h1><table border="1" cellpadding="3" cellspacing="0" summary="" width="100%">
    <tr>
        <td><strong>功能</strong></td>
        <td><strong>命令</strong></td>
    </tr>
    <tr>
        <td>用一个单独的文件创建一个 JAR 文件</td>
        <td>jar cf jar-file input-file...</td>
    </tr>
    <tr>
        <td>用一个目录创建一个 JAR 文件</td>
        <td>jar cf jar-file dir-name</td>
    </tr>
    <tr>
        <td>创建一个未压缩的 JAR 文件</td>
        <td>jar cf0 jar-file dir-name</td>
    </tr>
    <tr>
        <td>更新一个 JAR 文件</td>
        <td>jar uf jar-file input-file...</td>
    </tr>
    <tr>
        <td>查看一个 JAR 文件的内容</td>
        <td>jar tf jar-file</td>
    </tr>
    <tr>
        <td>提取一个 JAR 文件的内容</td>
        <td>jar xf jar-file</td>
    </tr>
    <tr>
        <td>从一个 JAR 文件中提取特定的文件</td>
        <td>jar xf jar-file archived-file...</td>
    </tr>
    <tr>
        <td>运行一个打包为可执行 JAR 文件的应用程序</td>
        <td>java -jar app.jar</td>
    </tr>
</table>

<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="http://www.ibm.com/developerworks/cn/java/j-jar/">JAR 文件揭密</a><br><a href="http://blog.sina.com.cn/s/blog_774c75080100q73w.html">Java程序的编译、执行和打包</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>sync.Cond的例子</title>
    <url>/post/cond-example/</url>
    <content><![CDATA[<p>sync.Cond类似于pthread中的条件变量，但等待的为goroutine，而不是线程。比较难理解的为Wait函数，在调用该函数时必须L为Lock状态，调用Wait函数后，goroutine会自动解锁，并等待条件的到来，等条件到来后会重新加锁。</p>
<p>代码量并不多，下面是去掉注释后的代码。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sync</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy</span><br><span class="line"></span><br><span class="line">	<span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">	L Locker</span><br><span class="line"></span><br><span class="line">	notify  notifyList</span><br><span class="line">	checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	t := runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">	runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line">	c.L.Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() &#123;</span><br><span class="line">	c.checker.check()</span><br><span class="line">	runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copyChecker holds back pointer to itself to detect object copying.</span></span><br><span class="line"><span class="keyword">type</span> copyChecker <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *copyChecker)</span></span> check() &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &amp;&amp;</span><br><span class="line">		!atomic.CompareAndSwapUintptr((*<span class="type">uintptr</span>)(c), <span class="number">0</span>, <span class="type">uintptr</span>(unsafe.Pointer(c))) &amp;&amp;</span><br><span class="line">		<span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync.Cond is copied&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// noCopy may be embedded into structs which must not be copied</span></span><br><span class="line"><span class="comment">// after the first use.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// See https://github.com/golang/go/issues/8005#issuecomment-190753527</span></span><br><span class="line"><span class="comment">// for details.</span></span><br><span class="line"><span class="keyword">type</span> noCopy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock is a no-op used by -copylocks checker from `go vet`.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span></span> Lock() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>具体的使用例子如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mutex := &amp;sync.Mutex&#123;&#125;</span><br><span class="line">	cond := sync.NewCond(mutex)</span><br><span class="line"></span><br><span class="line">	wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	wait := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		fmt.Println(<span class="string">&quot;start chan &quot;</span>, i)</span><br><span class="line">		cond.L.Lock()</span><br><span class="line">		<span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;chan %d wait before\n&quot;</span>, i)</span><br><span class="line">		c &lt;- i</span><br><span class="line">		<span class="comment">// Wait是理解起来稍微麻烦的点，Cond.Wait会自动释放锁等待信号的到来，当信号到来后，第一个获取到信号的Wait将继续往下执行并从新上锁</span></span><br><span class="line">		cond.Wait()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;chan %d wait end\n&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	signal := <span class="function"><span class="keyword">func</span><span class="params">(count <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;read chan %d ready\n&quot;</span>, &lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;call signal&quot;</span>)</span><br><span class="line">		cond.Signal()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	broadcast := <span class="function"><span class="keyword">func</span><span class="params">(count <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;read chan %d ready\n&quot;</span>, &lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;call broadcast&quot;</span>)</span><br><span class="line">		cond.Broadcast()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> wait(<span class="number">0</span>, c)</span><br><span class="line">	<span class="keyword">go</span> signal(<span class="number">1</span>, c)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;signal test finished\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">	count := <span class="number">3</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> wait(i, c)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> broadcast(count, c)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>conntrack介绍</title>
    <url>/post/conntrack/</url>
    <content><![CDATA[<img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/Netfilter-packet-flow.svg">

<p>conntrack是netfilter提供的连接跟踪机制，允许内核识别出数据包属于哪个连接。是iptables实现状态匹配(-m state)以及nat的基础，由单独的内核模块nf_conntrack实现。</p>
<p>conntrack在图中有两处，一处位于prerouting，一处位于output。主机自身进程产生的数据包会经过output链的conntrack，主机的网络设备接收到的数据包会通过prerouting链的conntrack。</p>
<p>每个通过conntrack的数据包，内核会判断是否为新的连接。如果是新的连接，则在连接跟踪表中插入一条记录。如果是已有连接，会更新连接跟踪表中的记录。</p>
<p>需要特别注意的是，conntrack并不会修改数据包，如dnat、snat，而仅仅是维护连接跟踪表。</p>
<h2 id="连接跟踪表的内容"><a href="#连接跟踪表的内容" class="headerlink" title="连接跟踪表的内容"></a>连接跟踪表的内容</h2><p><code>/proc/net/nf_conntrack</code>可以看到连接跟踪表的所有内容，通过hash表来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipv4     2 tcp      6 117 TIME_WAIT src=10.45.4.124 dst=10.45.8.10 sport=36903 dport=8080 src=10.45.8.10 dst=10.45.4.124 sport=8080 dport=36903 [ASSURED] mark=0 zone=0 use=2</span><br></pre></td></tr></table></figure>

<ul>
<li>117: 该连接的生存时间，每个连接都有一个timeout值，可以通过内核参数进行设置，如果超过该时间还没有报文到达，该连接将会删除。如果有新的数据到达，该计数会被重置。</li>
<li>TIME_WAIT: 当前该连接的最新状态</li>
</ul>
<h2 id="涉及到的内核参数"><a href="#涉及到的内核参数" class="headerlink" title="涉及到的内核参数"></a>涉及到的内核参数</h2><ul>
<li><code>net.netfilter.nf_conntrack_buckets</code>: 用来设置hash表的大小</li>
<li><code>net.netfilter.nf_conntrack_max</code>: 用来设置连接跟踪表的数据条数上限</li>
</ul>
<h2 id="iptables与conntrack的关系"><a href="#iptables与conntrack的关系" class="headerlink" title="iptables与conntrack的关系"></a>iptables与conntrack的关系</h2><p>iptables使用<code>-m state</code>模块来从连接跟踪表查找数据包的状态，上面例子中的<code>TIME_WAIT</code>即为连接跟踪表中的状态，但这些状态对应到iptable中就只有五种状态。特别需要注意的是，这五种状态是跟具体的协议是tcp、udp无关的。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>匹配连接的第一个包</td>
</tr>
<tr>
<td>ESTABLISHED</td>
<td>NEW状态后，如果对端有回复包，此时连接状态为NEW</td>
</tr>
<tr>
<td>RELATED</td>
<td>不是太好理解，当已经有一个状态为ESTABLISHED连接后，如果又产生了一个新的连接并且跟此时关联的，那么该连接就是RELATED状态的。对于ftp协议而言，有控制连接和数据连接，控制连接要先建立为ESTABLISHED，数据连接就变为控制连接的RELATED。那么conntrack怎么能够识别到两个连接是有关联的呢，即能够识别出协议相关的内容，这就需要通过扩展模块来完成了，比如ftp就需要nf_conntrack_ftp</td>
</tr>
<tr>
<td>INVALID</td>
<td>无法识别的或者有状态的数据包</td>
</tr>
<tr>
<td>UNTRACKED</td>
<td>匹配带有NOTRACK标签的数据包，raw表可以将数据包标记为NOTRACK，这种数据包的连接状态为NOTRACK</td>
</tr>
</tbody></table>
<h2 id="conntrack-tools"><a href="#conntrack-tools" class="headerlink" title="conntrack-tools"></a>conntrack-tools</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看连接跟踪表</span><br><span class="line">conntrack -L</span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://opengers.github.io/openstack/openstack-base-netfilter-framework-overview/">云计算底层技术-netfilter框架研究</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>部署java应用到容器</title>
    <url>/post/container-java/</url>
    <content><![CDATA[<p>java 8u131之后的版本开始支持容器特性，之前的版本中并不支持容器相关的特性。</p>
<h2 id="java基础知识"><a href="#java基础知识" class="headerlink" title="java基础知识"></a>java基础知识</h2><p>JVM默认的最大堆内存大小为系统内存的1&#x2F;4，可以使用参数<code>-XX:MaxRAMFraction=1</code>表示将所有可用内存作为最大堆。</p>
<p>cgroup的限制在docker中能够看到，通过查看&#x2F;sys&#x2F;fs&#x2F;cgroup目录下的文件可以获取。</p>
<p>JVM的用户地址空间分为JVM数据区和direct memory。JVM数据区由heap、stack等组成，GC是操作的这一片内存。direct memory是额外划分出来的一片内存空间，需要手工管理内存的申请和释放。</p>
<p>direct memory使用<code>Unsafe.allocateMemory</code>和<code>Unsafe.setMemory</code>来申请和设置内存，是直接使用了C语言中的malloc来申请内存。由jvm参数<code>MaxDirectMemorySize</code>来限制direct memory可使用的内存大小。</p>
<h2 id="java-lt-8u131"><a href="#java-lt-8u131" class="headerlink" title="java &lt; 8u131"></a>java &lt; 8u131</h2><p>没有对容器的任何支持，对cpu和内存的限制需要通过jvm的参数来配置。</p>
<p>java中并不能看到内存资源的限制，会存在使用内存超过限制而被OOM的问题。可通过在程序中设置<code>-Xmx</code>来解决该问题。</p>
<p>JVM GC（垃圾对象回收）对Java程序执行性能有一定的影响。默认的JVM使用公式“ParallelGCThreads &#x3D; (ncpus &lt;&#x3D; 8) ? ncpus : 3 + ((ncpus * 5) &#x2F; 8)” 来计算做并行GC的线程数，其中ncpus是JVM发现的系统CPU个数。一旦容器中JVM发现了宿主机的CPU个数（通常比容器实际CPU限制多很多），这就会导致JVM启动过多的GC线程，直接的结果就导致GC性能下降。Java服务的感受就是延时增加，TP监控曲线突刺增加，吞吐量下降。</p>
<p>显式的传递JVM启动参数<code>-XX:ParallelGCThreads</code>告诉JVM应该启动几个并行GC线程。它的缺点是需要业务感知，为不同配置的容器传不同的JVM参数。</p>
<h2 id="java9-and-java-gt-x3D-8u131"><a href="#java9-and-java-gt-x3D-8u131" class="headerlink" title="java9 and java &gt;&#x3D; 8u131"></a>java9 and java &gt;&#x3D; 8u131</h2><p>增加了<code>XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap</code>参数来检查内存限制。JVM中可以看到cgroup中的内存限制。</p>
<p>可以根据容器中的cpu限制来动态设置GC线程数，不再需要单独设置<code>-XX:ParallelGCThreads</code>。</p>
<h2 id="java10"><a href="#java10" class="headerlink" title="java10"></a>java10</h2><p>jvm参数<code>XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap</code>已经默认开启，但新增加<code>-XX:-UseContainerSupport</code>参数来更好支持容器，支持内存和cpu。</p>
<p>在开启<code>-XX:-UseContainerSupport</code>的同时，<code>XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap</code>会被关闭。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://blogs.oracle.com/java-platform-group/java-se-support-for-docker-cpu-and-memory-limits">Java SE support for Docker CPU and memory limits</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=1&sn=92dcd59d05984eaa036e7fa804fccf20&chksm=bd12a5778a652c61f4a181c1967dbcf120dd16a47f63a5779fbf931b476e6e712e02d7c7e3a3&mpshare=1&scene=1&srcid=1115JtuwzXeezCv5UkmOcrFw%23rd">美团容器平台架构及容器技术实践</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>coolshell博客解谜题游戏</title>
    <url>/post/coolshell_puzzle/</url>
    <content><![CDATA[<p>有些闲暇时间了解了下酷壳的谜题活动，共10道题，每道题都不是非常简单，我这里参考着攻略做了下。</p>
<h1 id="字符替换题"><a href="#字符替换题" class="headerlink" title="字符替换题"></a>字符替换题</h1><p>我编写的C++语言程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">change</span><span class="params">(<span class="type">char</span> input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *after = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *before = <span class="string">&quot;pvwdgazxubqfsnrhocitlkeymj&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(before); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (before[i] == input)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> after[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *input = <span class="string">&quot;Wxgcg txgcg ui p ixgff, txgcg ui p epm. I gyhgwt mrl lig txg ixgff wrsspnd tr irfkg txui hcrvfgs, nre, hfgpig tcm liunz txg crt13 ra \&quot;ixgff\&quot; tr gntgc ngyt fgkgf.&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *output = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(input) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(input); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        output[i] = <span class="built_in">change</span>(input[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    output[<span class="built_in">strlen</span>(input)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好久没有用shell了，又写了个shell版本的解题方法，该问题可能有更简单的shell解决办法，我这里肯定写复杂了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">result=<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">change</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    result=<span class="variable">$1</span></span><br><span class="line">    before=<span class="string">&#x27;pvwdgazxubqfsnrhocitlkeymj&#x27;</span></span><br><span class="line">    after=<span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> ((i=<span class="number">0</span>; i &lt;= <span class="variable">$&#123;#before&#125;</span>; i++))</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="variable">$&#123;before:<span class="variable">$&#123;i&#125;</span>:1&#125;</span> = <span class="variable">$&#123;1&#125;</span> ]]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            result=<span class="variable">$&#123;after:<span class="variable">$&#123;i&#125;</span>:1&#125;</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input=<span class="string">&#x27;Wxgcg txgcg ui p ixgff, txgcg ui p epm. I gyhgwt mrl lig txg ixgff wrsspnd tr irfkg txui hcrvfgs, nre, hfgpig tcm liunz txg crt13 ra &quot;ixgff&quot; tr gntgc ngyt fgkgf.&#x27;</span></span><br><span class="line"></span><br><span class="line">output=<span class="string">&#x27;&#x27;</span></span><br><span class="line">j=0</span><br><span class="line"><span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$j</span>&quot;</span> -le <span class="variable">$&#123;#input&#125;</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    change <span class="string">&quot;<span class="variable">$&#123;input:<span class="variable">$&#123;j&#125;</span>:1&#125;</span>&quot;</span></span><br><span class="line">    output=<span class="string">&quot;<span class="variable">$&#123;output&#125;</span><span class="variable">$&#123;result&#125;</span>&quot;</span></span><br><span class="line">    j=$((j+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;output&#125;</span></span><br></pre></td></tr></table></figure>

<p>关于rol13的转码可以采用<a href="http://rot13.de/index.php">rot13</a>这个网址来在线转码。</p>
<h1 id="穷举变量题"><a href="#穷举变量题" class="headerlink" title="穷举变量题"></a>穷举变量题</h1><p>该题需要不断的请求url来获取最终的网址，我这里写一个shell脚本来穷举。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">res=2014</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$&#123;#res&#125;</span> &gt; 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">res=`curl -s <span class="string">&quot;http://fun.coolshell.cn/n/<span class="variable">$&#123;res&#125;</span>&quot;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$res</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>得到答案tree</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://fun.coolshell.cn/">游戏页面</a><br><a href="http://blog.e10t.net/coolshell-puzzle-game-walkthrough/">CoolShell puzzle game 攻略</a><br><a href="http://joseph.yy.blog.163.com/blog/static/5097395920147782756165/">我也不产生代码 – Coolshell 谜题一游 </a></p>
]]></content>
  </entry>
  <entry>
    <title>C++11中的右值引用</title>
    <url>/post/cpp11_right_reference/</url>
    <content><![CDATA[<p>在C++98中有左值和右值的概念，不过这两个概念对于很多程序员并不关心，因为不知道这两个概念照样可以写出好程序。在C++11中对右值的概念进行了增强，我个人理解这部分内容是C++11引入的特性中最难以理解的了。该特性的引入至少可以解决C++98中的移动语义和完美转发问题，若你还不清楚这两个问题是什么，请向下看。</p>
<p>温馨提示，由于内容比较难懂，请仔细看。C++已经够复杂了，C++11中引入的新特性令C++更加复杂了。在学习本文的时候一定要理解清楚左值、右值、左值引用和右值引用。</p>
<h1 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h1><p>首先看一个C++98中的关于函数返回类对象的例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">MyString</span>() &#123; </span><br><span class="line">        _data = <span class="literal">nullptr</span>; </span><br><span class="line">        _len = <span class="number">0</span>; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Constructor is called!\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* p) &#123; </span><br><span class="line">        _len = <span class="built_in">strlen</span> (p); </span><br><span class="line">        _init_data(p); </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor is called! this-&gt;_data: &quot;</span> &lt;&lt; (<span class="type">long</span>)_data &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; str) &#123; </span><br><span class="line">        _len = str._len; </span><br><span class="line">        _init_data(str._data); </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Constructor is called! src: &quot;</span> &lt;&lt; (<span class="type">long</span>)str._data &lt;&lt; <span class="string">&quot; dst: &quot;</span> &lt;&lt; (<span class="type">long</span>)_data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123; </span><br><span class="line">        <span class="keyword">if</span> (_data)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;DeConstructor is called! this-&gt;_data: &quot;</span> &lt;&lt; (<span class="type">long</span>)_data &lt;&lt; endl; </span><br><span class="line">            <span class="built_in">free</span>(_data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;DeConstructor is called!&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; str) &#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123; </span><br><span class="line">            _len = str._len; </span><br><span class="line">            _init_data(str._data); </span><br><span class="line">        &#125; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Assignment is called! src: &quot;</span> &lt;&lt; (<span class="type">long</span>)str._data &lt;&lt; <span class="string">&quot; dst&quot;</span> &lt;&lt; (<span class="type">long</span>)_data &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">operator</span> <span class="type">const</span> <span class="type">char</span> *() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">char</span> *_data; </span><br><span class="line">    <span class="type">size_t</span>   _len; </span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _init_data(<span class="type">const</span> <span class="type">char</span> *s) &#123; </span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_len+<span class="number">1</span>]; </span><br><span class="line">        <span class="built_in">memcpy</span>(_data, s, _len); </span><br><span class="line">        _data[_len] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">middle</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    MyString a = <span class="built_in">foo</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该例子在编译器没有进行优化的情况下会输出以下内容，我在输出的内容中做了注释处理，如果连这个例子的输出都看不懂，建议再看一下C++的语法了。我这里使用的编译器命令为<code>g++ test.cpp -o main -g -fno-elide-constructors</code>，之所以要加上<code>-fno-elide-constructors</code>选项时因为g++编译器默认情况下会对函数返回类对象的情况作<em>返回值优化</em>处理，这不是我们讨论的重点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">29483024</span> <span class="comment">// middle对象的构造函数</span></span><br><span class="line">Copy Constructor is called! src: <span class="number">29483024</span> dst: <span class="number">29483056</span> <span class="comment">// 临时对象的构造，通过middle对象调用复制构造函数</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">29483024</span> <span class="comment">// middle对象的析构</span></span><br><span class="line">Copy Constructor is called! src: <span class="number">29483056</span> dst: <span class="number">29483024</span>	<span class="comment">// a对象构造，通过临时对象调用复制构造函数</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">29483056</span> <span class="comment">// 临时对象析构</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">29483024</span> <span class="comment">// a对象析构</span></span><br></pre></td></tr></table></figure>

<p>在上述例子中，临时对象的构造、复制和析构操作所带来的效率影响一直是C++中为人诟病的问题，临时对象的构造和析构操作均对堆上的内存进行操作，而如果_data的内存过大，势必会非常影响效率。从程序员的角度而言，该临时对象是透明的。而这一问题正是C++11中需要解决的问题。</p>
<p>在C++11中解决该问题的思路为，引入了移动构造函数，移动构造函数的定义如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MyString</span>(MyString &amp;&amp;str) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Move Constructor is called! src: &quot;</span> &lt;&lt; (<span class="type">long</span>)str._data &lt;&lt; endl;</span><br><span class="line">    _len = str._len;</span><br><span class="line">    _data = str._data;</span><br><span class="line">    str._data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在移动构造函数中我们窃取了str对象已经申请的内存，将其拿为己用，并将str申请的内存给赋值为nullptr。移动构造函数和复制构造函数的不同之处在于移动构造函数的参数使用*&amp;&amp;*，这就是下文要讲解的右值引用符号。参数不再是const，因为在移动构造函数需要修改右值str的内容。</p>
<p>移动构造函数的调用时机为用来构造临时变量和用临时变量来构造对象的时候移动语义会被调用。可以通过下面的输出结果看到，我们所使用的编译参数为<code>g++ test.cpp -o main -g -fno-elide-constructors --std=c++11</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">22872080</span> <span class="comment">// middle对象构造</span></span><br><span class="line">Move Constructor is called! src: <span class="number">22872080</span> <span class="comment">// 临时对象通过移动构造函数构造，将middle申请的内存窃取</span></span><br><span class="line">DeConstructor is called! <span class="comment">// middle对象析构</span></span><br><span class="line">Move Constructor is called! src: <span class="number">22872080</span> <span class="comment">// 对象a通过移动构造函数构造，将临时对象的内存窃取</span></span><br><span class="line">DeConstructor is called! <span class="comment">// 临时对象析构</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">22872080</span> <span class="comment">// 对象a析构</span></span><br></pre></td></tr></table></figure>

<p>通过输出结果可以看出，整个过程中仅申请了一块内存，这也正好符合我们的要求了。</p>
<h1 id="C-98中的左值和右值"><a href="#C-98中的左值和右值" class="headerlink" title="C++98中的左值和右值"></a>C++98中的左值和右值</h1><p>我们先来看下C++98中的左值和右值的概念。左值和右值最直观的理解就是一条语句等号左边的为左值，等号右边的为右值，而事实上该种理解是错误的。左值：可以取地址，有名字的值，是一个指向某内存空间的表达式，可以使用&amp;操作符获取内存地址。右值：不能取地址，即非左值的都是右值，没有名字的值，是一个临时值，表达式结束后右值就没有意义了。我想通过下面的例子，读者可以清楚的理解左值和右值了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lvalues:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">i = <span class="number">43</span>; <span class="comment">// i是左值</span></span><br><span class="line"><span class="type">int</span>* p = &amp;i; <span class="comment">// i是左值</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">foo</span>() = <span class="number">42</span>; <span class="comment">// foo()返回引用类型是左值</span></span><br><span class="line"><span class="type">int</span>* p1 = &amp;<span class="built_in">foo</span>(); <span class="comment">// foo()可以取地址是左值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rvalues:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foobar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">j = <span class="built_in">foobar</span>(); <span class="comment">// foobar()是右值</span></span><br><span class="line"><span class="type">int</span>* p2 = &amp;<span class="built_in">foobar</span>(); <span class="comment">// 编译错误，foobar()是右值不能取地址</span></span><br><span class="line">j = <span class="number">42</span>; <span class="comment">// 42是右值</span></span><br></pre></td></tr></table></figure>

<h1 id="C-11右值引用和移动语义"><a href="#C-11右值引用和移动语义" class="headerlink" title="C++11右值引用和移动语义"></a>C++11右值引用和移动语义</h1><p>在C++98中有引用的概念，对于<code>const int &amp;m = 1</code>，其中m为引用类型，可以对其取地址，故为左值。在C++11中，引入了右值引用的概念，使用*&amp;&amp;*来表示。在引入了右值引用后，在函数重载时可以根据是左值引用还是右值引用来区分。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(MyString &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;left reference&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(MyString &amp;&amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;right reference&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="function">MyString <span class="title">a</span><span class="params">(<span class="string">&quot;456&quot;</span>)</span></span>; </span><br><span class="line">    <span class="built_in">fun</span>(a); <span class="comment">// 左值引用，调用void fun(MyString &amp;str)</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="built_in">foo</span>()); <span class="comment">// 右值引用，调用void fun(MyString &amp;&amp;str)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在绝大多数情况下，这种通过左值引用和右值引用重载函数的方式仅会在类的构造函数和赋值操作符中出现，被例子仅是为了方便采用函数的形式，该种形式的函数用到的比较少。上述代码中所使用的将资源从一个对象到另外一个对象之间的转移就是移动语义。这里提到的资源是指类中的在堆上申请的内存、文件描述符等资源。</p>
<p>前面已经介绍过了移动构造函数的具体形式和使用情况，这里对移动赋值操作符的定义再说明一下，并将main函数的内容也一起更改，将得到如下输出结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) &#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Move Operator= is called! src: &quot;</span> &lt;&lt; (<span class="type">long</span>)str._data &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123; </span><br><span class="line">        <span class="keyword">if</span> (_data != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(_data);</span><br><span class="line">        &#125;</span><br><span class="line">        _len = str._len;</span><br><span class="line">        _data = str._data;</span><br><span class="line">        str._len = <span class="number">0</span>;</span><br><span class="line">        str._data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    MyString b;</span><br><span class="line">    b = <span class="built_in">foo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果，整个过程仅申请了一个内存地址</span></span><br><span class="line">Constructor is called! <span class="comment">// 对象b构造函数调用</span></span><br><span class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">14835728</span> <span class="comment">// middle对象构造</span></span><br><span class="line">Move Constructor is called! src: <span class="number">14835728</span> <span class="comment">// 临时对象通过移动构造函数由middle对象构造</span></span><br><span class="line">DeConstructor is called! <span class="comment">// middle对象析构</span></span><br><span class="line">Move Operator= is called! src: <span class="number">14835728</span> <span class="comment">// 对象b通过移动赋值操作符由临时对象赋值</span></span><br><span class="line">DeConstructor is called! <span class="comment">// 临时对象析构</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">14835728</span> <span class="comment">// 对象b析构函数调用</span></span><br></pre></td></tr></table></figure>

<p>在C++中对一个变量可以通过const来修饰，而const和引用是对变量约束的两种方式，为并行存在，相互独立。因此，就可以划分为了const左值引用、非const左值引用、const右值引用和非const右值引用四种类型。其中左值引用的绑定规则和C++98中是一致的。</p>
<p>非const左值引用只能绑定到非const左值，不能绑定到const右值、非const右值和const左值。这一点可以通过const关键字的语义来判断。</p>
<p>const左值引用可以绑定到任何类型，包括const左值、非const左值、const右值和非const右值，属于万能引用类型。其中绑定const右值的规则比较少见，但是语法上是可行的，比如<code>const int &amp;a = 1</code>，只是我们一般都会直接使用<code>int &amp;a = 1</code>了。</p>
<p>非const右值引用不能绑定到任何左值和const右值，只能绑定非const右值。</p>
<p>const右值引用类型仅是为了语法的完整性而设计的， 比如可以使用<code>const MyString &amp;&amp;right_ref = foo()</code>，但是右值引用类型的引入主要是为了移动语义，而移动语义需要右值引用是可以被修改的，因此const右值引用类型没有实际意义。</p>
<p>我们通过表格的形式对上文中提到的四种引用类型可以绑定的类型进行总结。</p>
<table>
<thead>
<tr>
<th>引用类型&#x2F;是否绑定</th>
<th>非const左值</th>
<th>const左值</th>
<th>非const右值</th>
<th>const右值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>非const左值引用</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>无</td>
</tr>
<tr>
<td>const左值引用</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>全能绑定类型，绑定到const右值的情况比较少见</td>
</tr>
<tr>
<td>非const右值引用</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>C++11中引入的特性，用于移动语义和完美转发</td>
</tr>
<tr>
<td>const值引用</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>没有实际意义，为了语法完整性而存在</td>
</tr>
</tbody></table>
<p>下面针对上述例子，我们看一下foo函数绑定参数的情况。</p>
<p>如果只实现了<code>void foo(MyString &amp;str)</code>，而没有实现<code>void fun(MyString &amp;&amp;str)</code>，则和之前一样foo函数的实参只能是非const左值。</p>
<p>如果只实现了<code>void foo(const MyString &amp;str)</code>，而没有实现<code>void fun(MyString &amp;&amp;str)</code>，则和之前一样foo函数的参数即可以是左值又可以是右值，因为const左值引用是万能绑定类型。</p>
<p>如果只实现了<code>void foo(MyString &amp;&amp;str)</code>，而没有实现<code>void fun(MyString &amp;str)</code>，则foo函数的参数只能是非const右值。</p>
<h1 id="强制移动语义std-move"><a href="#强制移动语义std-move" class="headerlink" title="强制移动语义std::move()"></a>强制移动语义std::move()</h1><p>前文中我们通过右值引用给类增加移动构造函数和移动赋值操作符已经解决了函数返回类对象效率低下的问题。那么还有什么问题没有解决呢？</p>
<p>在C++98中的swap函数的实现形式如下，在该函数中我们可以看到整个函数中的变量a、b、c均为左值，无法直接使用前面移动语义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">( T&amp; a, T&amp; b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">c</span><span class="params">(a)</span></span>; </span><br><span class="line">    a=b;</span><br><span class="line">    b=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果该函数中能够使用移动语义是非常合适的，仅是为了交换两个变量，却要反复申请和释放资源。按照前面的知识变量c不可能为非const右值引用，因为变量a为非const左值，非const右值引用不能绑定到任何左值。</p>
<p>在C++11的标准库中引入了std::move()函数来解决该问题，该函数的作用为将其参数转换为右值。在C++11中的swap函数就可以更改为了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">c</span><span class="params">(std::move(a))</span></span>; </span><br><span class="line">    a=std::<span class="built_in">move</span>(b); </span><br><span class="line">    b=std::<span class="built_in">move</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用了move语义以后,swap函数的效率会大大提升，我们更改main函数后测试如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// move函数</span></span><br><span class="line">    <span class="function">MyString <span class="title">d</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">e</span><span class="params">(<span class="string">&quot;456&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">swap</span>(d, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果，通过输出结果可以看出对象交换是成功的</span></span><br><span class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">38469648</span> <span class="comment">// 对象d构造</span></span><br><span class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">38469680</span> <span class="comment">// 对象e构造</span></span><br><span class="line">Move Constructor is called! src: <span class="number">38469648</span> <span class="comment">// swap函数中的对象c通过移动构造函数构造</span></span><br><span class="line">Move Operator= is called! src: <span class="number">38469680</span> <span class="comment">// swap函数中的对象a通过移动赋值操作符赋值</span></span><br><span class="line">Move Operator= is called! src: <span class="number">38469648</span> <span class="comment">// swap函数中的对象b通过移动赋值操作符赋值</span></span><br><span class="line">DeConstructor is called! <span class="comment">// swap函数中的对象c析构</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">38469648</span> <span class="comment">// 对象e析构</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">38469680</span> <span class="comment">// 对象d析构</span></span><br></pre></td></tr></table></figure>

<h1 id="右值引用和右值的关系"><a href="#右值引用和右值的关系" class="headerlink" title="右值引用和右值的关系"></a>右值引用和右值的关系</h1><p>这个问题就有点绕了，需要开动思考一下右值引用和右值是啥含义了。读者会凭空的认为右值引用肯定是右值，其实不然。我们在之前的例子中添加如下代码，并将main函数进行修改如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_rvalue_rref</span><span class="params">(MyString &amp;&amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;tmp object construct start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    MyString tmp = str;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;tmp object construct finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_rvalue_rref</span>(<span class="built_in">foo</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">28913680</span></span><br><span class="line">Move Constructor is called! src: <span class="number">28913680</span></span><br><span class="line">DeConstructor is called!</span><br><span class="line">tmp object construct start</span><br><span class="line">Copy Constructor is called! src: <span class="number">28913680</span> dst: <span class="number">28913712</span> <span class="comment">// 可以看到这里调用的是复制构造函数而不是移动构造函数</span></span><br><span class="line">tmp object construct finish</span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">28913712</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">28913680</span></span><br></pre></td></tr></table></figure>

<p>我想程序运行的结果肯定跟大多数人想到的不一样，“Are you kidding me?不是应该调用移动构造函数吗？为什么调用了复制构造函数？”。关于右值引用和左右值之间的规则是：</p>
<blockquote>
<p>如果右值引用有名字则为左值，如果右值引用没有名字则为右值。</p>
</blockquote>
<p>通过规则我们可以发现，在我们的例子中右值引用str是有名字的，因此为左值，tmp的构造会调用复制构造函数。之所以会这样，是因为如果tmp构造的时候调用了移动构造函数，则调用完成后str的申请的内存自己已经不可用了，如果在该函数中该语句的后面在调用str变量会出现我们意想不到的问题。鉴于此，我们也就能够理解为什么有名字的右值引用是左值了。如果已经确定在tmp构造语句的后面不需要使用str变量了，可以使用std::move()函数将str变量从左值转换为右值，这样tmp变量的构造就可以使用移动构造函数了。</p>
<p>而如果我们调用的是<code>MyString b = foo()</code>语句，由于foo()函数返回的是临时对象没有名字属于右值，因此b的构造会调用移动构造函数。</p>
<p>该规则非常的重要，要想能够正确使用右值引用，该规则必须要掌握，否则写出来的代码会有一个大坑。</p>
<h1 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h1><p>前面已经介绍了本文的两大主题之一的移动语义，还剩下完美转发机制。完美转发机制通常用于库函数中，至少在我的工作中还是很少使用的。如果实在不想理解该问题，可以不用向下看了。在泛型编程中，经常会遇到的一个问题是怎样将一组参数原封不动的转发给另外一个函数。这里的原封不动是指，如果函数是左值，那么转发给的那个函数也要接收一个左值；如果参数是右值，那么转发给的函数也要接收一个右值；如果参数是const的，转发给的函数也要接收一个const参数；如果参数是非const的，转发给的函数也要接收一个非const值。</p>
<p>该问题看上去非常简单，其实不然。看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> &amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;lvalue ref&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> &amp;&amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;rvalue ref&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const lvalue ref&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;&amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const rvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T t)</span> </span>&#123; <span class="built_in">fun</span>(t); &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="number">10</span>);           <span class="comment">// rvalue ref</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(a);            <span class="comment">// lvalue ref</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(std::<span class="built_in">move</span>(a)); <span class="comment">// rvalue ref</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(b);            <span class="comment">// const lvalue ref</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(std::<span class="built_in">move</span>(b)); <span class="comment">// const rvalue ref</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们想达到的目的是PerfectForward模板函数能够完美转发参数t到fun函数中。上述例子中的PerfectForward函数必然不能够达到此目的，因为PerfectForward函数的参数为左值类型，调用的fun函数也必然为<code>void fun(int &amp;)</code>。且调用PerfectForward之前就产生了一次参数的复制操作，因此这样的转发只能称之为正确转发，而不是完美转发。要想达到完美转发，需要做到像转发函数不存在一样的效率。</p>
<p>因此，我们考虑将PerfectForward函数的参数更改为引用类型，因为引用类型不会有额外的开销。另外，还需要考虑转发函数PerfectForward是否可以接收引用类型。如果转发函数PerfectForward仅能接收左值引用或右值引用的一种，那么也无法实现完美转发。</p>
<p>我们考虑使用<code>const T &amp;t</code>类型的参数，因为我们在前文中提到过，const左值引用类型可以绑定到任何类型。但是这样目标函数就不一定能接收const左值引用类型的参数了。const左值引用属于左值，非const左值引用和非const右值引用是无法绑定到const左值的。</p>
<p>如果将参数t更改为非const右值引用、const右值也是不可以实现完美转发的。</p>
<p>在C++11中为了能够解决完美转发问题，引入了更为复杂的规则：引用折叠规则和特殊模板参数推导规则。</p>
<h2 id="引用折叠推导规则"><a href="#引用折叠推导规则" class="headerlink" title="引用折叠推导规则"></a>引用折叠推导规则</h2><p>为了能够理解清楚引用折叠规则，还是通过以下例子来学习。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>&amp; TR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b = a;</span><br><span class="line">    <span class="type">int</span> &amp; &amp;c = a;  <span class="comment">// 编译器报错，不可以对引用再显示添加引用</span></span><br><span class="line">    TR &amp;d = a;     <span class="comment">// 通过typedef定义的类型隐式添加引用是可以的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++中，不可以在程序中对引用再显示添加引用类型，对于<code>int &amp; &amp;c</code>的声明变量方式，编译器会提示错误。但是如果在上下文中（包括使用模板实例化、typedef、auto类型推断等）出现了对引用类型再添加引用的情况，编译器是可以编译通过的。具体的引用折叠规则如下，可以看出一旦引用中定义了左值类型，折叠规则总是将其折叠为左值引用。这就是引用折叠规则的全部内容了。另外折叠规则跟变量的const特性是没有关系的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A&amp; &amp; =&gt; A&amp;</span><br><span class="line">A&amp; &amp;&amp; =&gt; A&amp;</span><br><span class="line">A&amp;&amp; &amp; =&gt; A&amp;</span><br><span class="line">A&amp;&amp; &amp;&amp; =&gt; A&amp;&amp;</span><br></pre></td></tr></table></figure>

<h2 id="特殊模板参数推导规则"><a href="#特殊模板参数推导规则" class="headerlink" title="特殊模板参数推导规则"></a>特殊模板参数推导规则</h2><p>下面我们再来学习特殊模板参数推导规则，考虑下面的模板函数，模板函数接收一个右值引用作为模板参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>说白点，特殊模板参数推导规则其实就是引用折叠规则在模板参数为右值引用时模板情况下的应用，是引用折叠规则的一种情况。我们结合上文中的引用折叠规则，</p>
<ol>
<li>如果foo的实参是上文中的A类型的左值时，T的类型就为A&amp;。根据引用折叠规则，最后foo的参数类型为A&amp;。</li>
<li>如果foo的实参是上文中的A类型的右值时，T的类型就为A&amp;&amp;。根据引用折叠规则，最后foo的参数类型为A&amp;&amp;。</li>
</ol>
<h2 id="解决完美转发问题"><a href="#解决完美转发问题" class="headerlink" title="解决完美转发问题"></a>解决完美转发问题</h2><p>我们已经学习了模板参数为右值引用时的特殊模板参数推导规则，那么我们利用刚学习的知识来解决本文中待解决的完美转发的例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> &amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;lvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> &amp;&amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;rvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const lvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;&amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const rvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template&lt;typename T&gt;</span></span><br><span class="line"><span class="comment">//void PerfectForward(T t) &#123; fun(t); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用引用折叠规则代替了原有的不完美转发机制</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; <span class="built_in">fun</span>(<span class="built_in">static_cast</span>&lt;T &amp;&amp;&gt;(t)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="number">10</span>);           <span class="comment">// rvalue ref，折叠后t类型仍然为T &amp;&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(a);            <span class="comment">// lvalue ref，折叠后t类型为T &amp;</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(std::<span class="built_in">move</span>(a)); <span class="comment">// rvalue ref，折叠后t类型为T &amp;&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(b);            <span class="comment">// const lvalue ref，折叠后t类型为const T &amp;</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(std::<span class="built_in">move</span>(b)); <span class="comment">// const rvalue ref，折叠后t类型为const T &amp;&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子中已经对完美转发的各种情况进行了说明，这里需要对PerfectForward模板函数中的static_cast进行说明。static_cast仅是对传递右值时起作用。我们看一下当参数为右值时的情况，这里的右值包括了const右值和非const右值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数为右值，引用折叠规则引用前</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> &amp;&amp; &amp;&amp;T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(<span class="type">int</span> &amp;&amp; &amp;&amp;t)</span> </span>&#123; <span class="built_in">fun</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&amp; &amp;&amp;&gt;(t)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用折叠规则应用后</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> &amp;&amp;T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(<span class="type">int</span> &amp;&amp;t)</span> </span>&#123; <span class="built_in">fun</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(t)); &#125;</span><br></pre></td></tr></table></figure>

<p>可能读者仍然没有发现上述例子中的问题，“不用static_cast进行强制类型转换不是也可以吗？”。别忘记前文中仍然提到一个右值引用和右值之间关系的规则，<code>如果右值引用有名字则为左值，如果右值引用没有名字则为右值。</code>。这里的变量t虽然为右值引用，但是是左值。如果我们想继续向fun函数中传递右值，就需要使用static_cast进行强制类型转换了。</p>
<p>其实在C++11中已经为我们封装了std::forward函数来替代我们上文中使用的static_cast类型转换，该例子中使用std::forward函数的版本变为了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; <span class="built_in">fun</span>(std::forward&lt;T&gt;(t)); &#125;</span><br></pre></td></tr></table></figure>

<p>对于上文中std::move函数的实现也是使用了引用折叠规则，实现方式跟std::forward一致。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol>
<li>《深入理解C++11-C++11新特性解析与应用》</li>
<li><a href="http://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/">C++11 标准新特性: 右值引用与转移语义</a></li>
<li><a href="http://www.zhihu.com/question/22111546">如何评价 C++11 的右值引用（Rvalue reference）特性？</a></li>
<li><a href="http://blog.bitdewy.me/blog/2013/07/08/cpp11-perfect-forward/">C++11 完美转发</a></li>
<li><a href="http://thbecker.net/articles/rvalue_references/section_01.html#section_01">C++ Rvalue References Explained</a></li>
<li><a href="http://jxq.me/2012/06/06/%E8%AF%91%E8%AF%A6%E8%A7%A3c%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">详解C++右值引用</a> （对C++ Rvalue References Explained的翻译）</li>
</ol>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>ecs的Linux主机上快速创建测试k8s集群</title>
    <url>/post/create_test_k8s/</url>
    <content><![CDATA[<p>经常有快速创建一个测试k8s集群的场景，为了能够快速完成，整理了如下的命令，即可在主机上快速启动一个k8s集群。部分命令需要外网访问，推荐直接使用海外的主机。</p>
<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>下面命令可以安装最新版本的docker-ce</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line">systemctl enable docker &amp;&amp; systemctl start docker</span><br><span class="line">yum install vim git make -y</span><br></pre></td></tr></table></figure>
<h2 id="安装特定版本的docker"><a href="#安装特定版本的docker" class="headerlink" title="安装特定版本的docker"></a>安装特定版本的docker</h2><p>如果要安装特定版本的docker-ce，可以使用如下方法。</p>
<p>使用如下命令查询yum源中的docker-ce版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line">Last metadata expiration check: 0:00:27 ago on Sat 09 Apr 2022 12:39:09 AM CST.</span><br><span class="line">docker-ce.x86_64                3:20.10.9-3.el8                 docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.8-3.el8                 docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.7-3.el8                 docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:20.10.6-3.el8                 docker-ce-stable</span><br></pre></td></tr></table></figure>

<p>选择特定版本的docker-ce和docker-ce-cli，执行如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure>


<h1 id="安装kubectl-kind-helm"><a href="#安装kubectl-kind-helm" class="headerlink" title="安装kubectl kind helm"></a>安装kubectl kind helm</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装kubectl</span><br><span class="line">curl -LO &quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl&quot;</span><br><span class="line">chmod +x kubectl</span><br><span class="line">mv kubectl /usr/bin/</span><br><span class="line"># 如果找不到rpm包，可以通过网络安全 rpm -ivh http://mirror.centos.org/centos/7/os/x86_64/Packages/bash-completion-2.1-8.el7.noarch.rpm</span><br><span class="line">yum install -y bash-completion</span><br><span class="line">echo -e &#x27;\n# kubectl&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &#x27;source &lt;(kubectl completion bash)&#x27; &gt;&gt;~/.bash_profile</span><br><span class="line">echo &#x27;alias k=kubectl&#x27; &gt;&gt;~/.bash_profile</span><br><span class="line">echo &#x27;complete -F __start_kubectl k&#x27; &gt;&gt;~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br><span class="line"># 安装helm</span><br><span class="line">wget https://get.helm.sh/helm-v3.7.2-linux-amd64.tar.gz</span><br><span class="line">tar zvxf helm-v3.7.2-linux-amd64.tar.gz</span><br><span class="line">mv linux-amd64/helm /usr/bin/</span><br><span class="line">rm -rf linux-amd64</span><br><span class="line"></span><br><span class="line"># 安装kubectx kubens</span><br><span class="line">git clone https://github.com/ahmetb/kubectx /tmp/kubectx</span><br><span class="line">cp /tmp/kubectx/kubens /usr/bin/kns</span><br><span class="line">cp /tmp/kubectx/kubectx /usr/bin/kctx</span><br><span class="line">wget https://github.com/junegunn/fzf/releases/download/0.29.0/fzf-0.29.0-linux_amd64.tar.gz -P /tmp</span><br><span class="line">tar zvxf /tmp/fzf-0.29.0-llinux_amd64.tar.gz -C /tmp/</span><br><span class="line">mv /tmp/fzf /usr/local/bin/</span><br><span class="line"></span><br><span class="line"># 安装kind</span><br><span class="line">curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.18.0/kind-linux-amd64</span><br><span class="line">chmod +x ./kind</span><br><span class="line">mv ./kind /usr/local/bin/</span><br><span class="line">echo -e &quot;\n# kind&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &#x27;source &lt;(kind completion bash)&#x27; &gt;&gt;~/.bash_profile</span><br></pre></td></tr></table></figure>

<h1 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h1><p>其中将apiServerAddress指定为了本机，即创建出来的k8s集群仅允许本集群内访问。如果要是需要多个k8s集群之间的互访场景，由于kind拉起的k8s运行在docker容器中，而docker容器使用的是容器网络，此时如果设置apiserver地址为127.0.0.1，那么集群之间就没法直接通讯了，此时需要指定一个可以在docker容器中访问的宿主机ip地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if=eth0</span><br><span class="line">ip=`ifconfig $if|grep inet|grep -v 127.0.0.1|grep -v inet6|awk &#x27;&#123;print $2&#125;&#x27;|tr -d &quot;addr:&quot;`</span><br><span class="line">cat &gt; kind.conf &lt;&lt;EOF</span><br><span class="line">kind: Cluster</span><br><span class="line">apiVersion: kind.x-k8s.io/v1alpha4</span><br><span class="line">name: kind</span><br><span class="line">nodes:</span><br><span class="line">- role: control-plane</span><br><span class="line">  # 如果需要 ingress，则需要指定该参数</span><br><span class="line">  kubeadmConfigPatches:</span><br><span class="line">  - |</span><br><span class="line">    kind: InitConfiguration</span><br><span class="line">    nodeRegistration:</span><br><span class="line">      kubeletExtraArgs:</span><br><span class="line">        node-labels: &quot;ingress-ready=true&quot;</span><br><span class="line">  extraPortMappings:</span><br><span class="line">  - containerPort: 80</span><br><span class="line">    hostPort: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">  - containerPort: 443</span><br><span class="line">    hostPort: 443</span><br><span class="line">    protocol: TCP</span><br><span class="line">  # 指定 k8s 版本，默认不指定</span><br><span class="line">  # image: kindest/node:v1.23.17</span><br><span class="line">- role: worker</span><br><span class="line">- role: worker</span><br><span class="line">- role: worker</span><br><span class="line">networking:</span><br><span class="line">  apiServerAddress: &quot;$ip&quot;</span><br><span class="line">  apiServerPort: 6443</span><br><span class="line">EOF</span><br><span class="line">kind create cluster --config kind.conf</span><br></pre></td></tr></table></figure>

<p>如果使用 nginx ingress，额外执行命令 <code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml</code></p>
<h1 id="其他周边工具"><a href="#其他周边工具" class="headerlink" title="其他周边工具"></a>其他周边工具</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装kustomize</span><br><span class="line">curl -s &quot;https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh&quot;  | bash</span><br><span class="line">mv kustomize /usr/local/bin/</span><br><span class="line"></span><br><span class="line"># 安装golang</span><br><span class="line">wget https://go.dev/dl/go1.17.5.linux-amd64.tar.gz -P /opt</span><br><span class="line">tar zvxf /opt/go1.17.5.linux-amd64.tar.gz -C /opt/</span><br><span class="line">mkdir /opt/gopath</span><br><span class="line">echo -e &#x27;\n# golang&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &#x27;export GOROOT=/opt/go&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &#x27;export GOPATH=/opt/gopath&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &#x27;export PATH=$PATH:$GOPATH/bin:$GOROOT/bin&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br><span class="line"># 安装controller-gen，会将controller-gen命令安装到GOPATH/bin目录下</span><br><span class="line">go install sigs.k8s.io/controller-tools/cmd/controller-gen@latest</span><br><span class="line"></span><br><span class="line"># 安装dlv工具</span><br><span class="line">go install github.com/go-delve/delve/cmd/dlv@latest</span><br></pre></td></tr></table></figure>

<h2 id="安装krew"><a href="#安装krew" class="headerlink" title="安装krew"></a>安装krew</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(</span><br><span class="line">  set -x; cd &quot;$(mktemp -d)&quot; &amp;&amp;</span><br><span class="line">  OS=&quot;$(uname | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)&quot; &amp;&amp;</span><br><span class="line">  ARCH=&quot;$(uname -m | sed -e &#x27;s/x86_64/amd64/&#x27; -e &#x27;s/\(arm\)\(64\)\?.*/\1\2/&#x27; -e &#x27;s/aarch64$/arm64/&#x27;)&quot; &amp;&amp;</span><br><span class="line">  KREW=&quot;krew-$&#123;OS&#125;_$&#123;ARCH&#125;&quot; &amp;&amp;</span><br><span class="line">  curl -fsSLO &quot;https://github.com/kubernetes-sigs/krew/releases/latest/download/$&#123;KREW&#125;.tar.gz&quot; &amp;&amp;</span><br><span class="line">  tar zxvf &quot;$&#123;KREW&#125;.tar.gz&quot; &amp;&amp;</span><br><span class="line">  ./&quot;$&#123;KREW&#125;&quot; install krew</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">echo -e &#x27;\n# kubectl krew&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">echo &#x27;export PATH=&quot;$&#123;KREW_ROOT:-$HOME/.krew&#125;/bin:$PATH&quot;&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>

<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul>
<li><a href="https://kind.sigs.k8s.io/">kind</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Container Runtime Interface(CRI)</title>
    <url>/post/cri/</url>
    <content><![CDATA[<p>CRI为k8s提供的kubelet扩展接口，用来支持多种容器运行时。CRI协议为protobuf格式，kubelet作为客户端，容器运行时作为服务端，两者通过gRpc协议通讯。下面主要解读 <a href="https://github.com/kubernetes/cri-api/blob/c75ef5b/pkg/apis/runtime/v1/api.proto">CRI的协议定义</a></p>
<h2 id="spec解读"><a href="#spec解读" class="headerlink" title="spec解读"></a>spec解读</h2><h3 id="RuntimeService"><a href="#RuntimeService" class="headerlink" title="RuntimeService"></a>RuntimeService</h3><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/cri-api-to-construct.png" alt="https://github.com/kata-containers/kata-containers/blob/main/docs/design/arch-images/api-to-construct.png"></p>
<p>包括了Pod和容器相关的操作。</p>
<p>Pod相关的操作包括：</p>
<ol>
<li>启：RunPodSandbox</li>
<li>停：StopPodSandbox</li>
<li>删：RemovePodSandbox</li>
<li>查：PodSandboxStatus、ListPodSandbox、ListPodSandboxStats、PodSandboxStats</li>
</ol>
<p>容器相关的操作：</p>
<ol>
<li>增、启：CreateContainer、StartContainer</li>
<li>停：StopContainer</li>
<li>删：RemoveContainer</li>
<li>查：ListContainers、ContainerStatus、</li>
<li>改：UpdateContainerResources</li>
<li>控：ReopenContainerLog、ExecSync、Exec、Attach、PortForward</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Runtime service defines the public APIs for remote container runtimes</span></span><br><span class="line">service RuntimeService <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Version returns the runtime name, runtime version, and runtime API version.</span></span><br><span class="line">    rpc Version(VersionRequest) returns (VersionResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RunPodSandbox creates and starts a pod-level sandbox. Runtimes must ensure</span></span><br><span class="line">    <span class="comment">// the sandbox is in the ready state on success.</span></span><br><span class="line">    rpc RunPodSandbox(RunPodSandboxRequest) returns (RunPodSandboxResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// StopPodSandbox stops any running process that is part of the sandbox and</span></span><br><span class="line">    <span class="comment">// reclaims network resources (e.g., IP addresses) allocated to the sandbox.</span></span><br><span class="line">    <span class="comment">// If there are any running containers in the sandbox, they must be forcibly</span></span><br><span class="line">    <span class="comment">// terminated.</span></span><br><span class="line">    <span class="comment">// This call is idempotent, and must not return an error if all relevant</span></span><br><span class="line">    <span class="comment">// resources have already been reclaimed. kubelet will call StopPodSandbox</span></span><br><span class="line">    <span class="comment">// at least once before calling RemovePodSandbox. It will also attempt to</span></span><br><span class="line">    <span class="comment">// reclaim resources eagerly, as soon as a sandbox is not needed. Hence,</span></span><br><span class="line">    <span class="comment">// multiple StopPodSandbox calls are expected.</span></span><br><span class="line"></span><br><span class="line">    rpc StopPodSandbox(StopPodSandboxRequest) returns (StopPodSandboxResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="comment">// RemovePodSandbox removes the sandbox. If there are any running containers</span></span><br><span class="line">    <span class="comment">// in the sandbox, they must be forcibly terminated and removed.</span></span><br><span class="line">    <span class="comment">// This call is idempotent, and must not return an error if the sandbox has</span></span><br><span class="line">    <span class="comment">// already been removed.</span></span><br><span class="line"></span><br><span class="line">    rpc RemovePodSandbox(RemovePodSandboxRequest) returns (RemovePodSandboxResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="comment">// PodSandboxStatus returns the status of the PodSandbox. If the PodSandbox is not</span></span><br><span class="line">    <span class="comment">// present, returns an error.</span></span><br><span class="line"></span><br><span class="line">    rpc PodSandboxStatus(PodSandboxStatusRequest) returns (PodSandboxStatusResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ListPodSandbox returns a list of PodSandboxes.</span></span><br><span class="line">    rpc ListPodSandbox(ListPodSandboxRequest) returns (ListPodSandboxResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// CreateContainer creates a new container in specified PodSandbox</span></span><br><span class="line">    rpc CreateContainer(CreateContainerRequest) returns (CreateContainerResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// StartContainer starts the container.</span></span><br><span class="line">    rpc StartContainer(StartContainerRequest) returns (StartContainerResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// StopContainer stops a running container with a grace period (i.e., timeout).</span></span><br><span class="line">    <span class="comment">// This call is idempotent, and must not return an error if the container has</span></span><br><span class="line">    <span class="comment">// already been stopped.</span></span><br><span class="line">    <span class="comment">// The runtime must forcibly kill the container after the grace period is</span></span><br><span class="line">    <span class="comment">// reached.</span></span><br><span class="line">    rpc StopContainer(StopContainerRequest) returns (StopContainerResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RemoveContainer removes the container. If the container is running, the</span></span><br><span class="line">    <span class="comment">// container must be forcibly removed.</span></span><br><span class="line">    <span class="comment">// This call is idempotent, and must not return an error if the container has</span></span><br><span class="line">    <span class="comment">// already been removed.</span></span><br><span class="line"></span><br><span class="line">    rpc RemoveContainer(RemoveContainerRequest) returns (RemoveContainerResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ListContainers lists all containers by filters.</span></span><br><span class="line">    rpc ListContainers(ListContainersRequest) returns (ListContainersResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ContainerStatus returns status of the container. If the container is not</span></span><br><span class="line">    <span class="comment">// present, returns an error.</span></span><br><span class="line">    rpc ContainerStatus(ContainerStatusRequest) returns (ContainerStatusResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// UpdateContainerResources updates ContainerConfig of the container.</span></span><br><span class="line">    rpc UpdateContainerResources(UpdateContainerResourcesRequest) returns (UpdateContainerResourcesResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReopenContainerLog asks runtime to reopen the stdout/stderr log file</span></span><br><span class="line">    <span class="comment">// for the container. This is often called after the log file has been</span></span><br><span class="line">    <span class="comment">// rotated. If the container is not running, container runtime can choose</span></span><br><span class="line">    <span class="comment">// to either create a new log file and return nil, or return an error.</span></span><br><span class="line">    <span class="comment">// Once it returns error, new container log file MUST NOT be created.</span></span><br><span class="line">    rpc ReopenContainerLog(ReopenContainerLogRequest) returns (ReopenContainerLogResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ExecSync runs a command in a container synchronously.</span></span><br><span class="line">    rpc ExecSync(ExecSyncRequest) returns (ExecSyncResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exec prepares a streaming endpoint to execute a command in the container.</span></span><br><span class="line">    rpc Exec(ExecRequest) returns (ExecResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach prepares a streaming endpoint to attach to a running container.</span></span><br><span class="line">    rpc Attach(AttachRequest) returns (AttachResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// PortForward prepares a streaming endpoint to forward ports from a PodSandbox.</span></span><br><span class="line">    rpc PortForward(PortForwardRequest) returns (PortForwardResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ContainerStats returns stats of the container. If the container does not</span></span><br><span class="line">    <span class="comment">// exist, the call returns an error.</span></span><br><span class="line">    rpc ContainerStats(ContainerStatsRequest) returns (ContainerStatsResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ListContainerStats returns stats of all running containers.</span></span><br><span class="line">    rpc ListContainerStats(ListContainerStatsRequest) returns (ListContainerStatsResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// PodSandboxStats returns stats of the pod sandbox. If the pod sandbox does not</span></span><br><span class="line">    <span class="comment">// exist, the call returns an error.</span></span><br><span class="line">    rpc PodSandboxStats(PodSandboxStatsRequest) returns (PodSandboxStatsResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ListPodSandboxStats returns stats of the pod sandboxes matching a filter.</span></span><br><span class="line">    rpc ListPodSandboxStats(ListPodSandboxStatsRequest) returns (ListPodSandboxStatsResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// UpdateRuntimeConfig updates the runtime configuration based on the given request.</span></span><br><span class="line">    rpc UpdateRuntimeConfig(UpdateRuntimeConfigRequest) returns (UpdateRuntimeConfigResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Status returns the status of the runtime.</span></span><br><span class="line">    rpc Status(StatusRequest) returns (StatusResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="ImageService"><a href="#ImageService" class="headerlink" title="ImageService"></a>ImageService</h3><p>跟镜像相关的操作，包括了</p>
<ol>
<li>增：PullImage</li>
<li>查：ListImages、ImageStatus和ImageFsInfo</li>
<li>删：RemoveImage</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ImageService defines the public APIs for managing images.</span></span><br><span class="line">service ImageService <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// ListImages lists existing images.</span></span><br><span class="line">    rpc ListImages(ListImagesRequest) returns (ListImagesResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ImageStatus returns the status of the image. If the image is not</span></span><br><span class="line">    <span class="comment">// present, returns a response with ImageStatusResponse.Image set to</span></span><br><span class="line">    <span class="comment">// nil.</span></span><br><span class="line">    rpc ImageStatus(ImageStatusRequest) returns (ImageStatusResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// PullImage pulls an image with authentication config.</span></span><br><span class="line">    rpc PullImage(PullImageRequest) returns (PullImageResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RemoveImage removes the image.</span></span><br><span class="line">    <span class="comment">// This call is idempotent, and must not return an error if the image has</span></span><br><span class="line">    <span class="comment">// already been removed.</span></span><br><span class="line">    rpc RemoveImage(RemoveImageRequest) returns (RemoveImageResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ImageFSInfo returns information of the filesystem that is used to store images.</span></span><br><span class="line">    rpc ImageFsInfo(ImageFsInfoRequest) returns (ImageFsInfoResponse) <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="CRI-CLI"><a href="#CRI-CLI" class="headerlink" title="CRI CLI"></a>CRI CLI</h2><p>CRI 自带了命令行工具 crictl。</p>
<p>Linux 下安装脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VERSION=&quot;v1.26.0&quot; # check latest version in /releases page</span><br><span class="line">wget https://github.com/kubernetes-sigs/cri-tools/releases/download/$VERSION/crictl-$VERSION-linux-amd64.tar.gz</span><br><span class="line">sudo tar zxvf crictl-$VERSION-linux-amd64.tar.gz -C /usr/local/bin</span><br><span class="line">rm -f crictl-$VERSION-linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>cue语言（个人笔记）</title>
    <url>/post/cuelang/</url>
    <content><![CDATA[<p>cue为使用golang编写的一款配置语言。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>mac用户执行：<code>brew install cue-lang/tap/cue</code>，其他操作系统用户可以直接使用源码安装：<code>go install cuelang.org/go/cmd/cue@latest</code></p>
<h1 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h1><p>创建如下文件first.cue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a: 1.5</span><br><span class="line">a: float</span><br><span class="line">b: 1</span><br><span class="line">b: int</span><br><span class="line">d: [1, 2, 3]</span><br><span class="line">g: &#123;</span><br><span class="line">    h: &quot;abc&quot;</span><br><span class="line">&#125;</span><br><span class="line">e: string</span><br></pre></td></tr></table></figure>

<ul>
<li>cue fmt first.cue：对代码进行格式化</li>
<li>cue vet first.cue：校验语法的正确性</li>
<li>cue eval first.cue：获得渲染结果</li>
<li>cue export first.cue：将渲染结果以json格式的形式导出，如果指定参数–out yaml，则可以以yaml方式导出。如果要导出某个变量，可以使用-e参数来指定变量。</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><p>支持的数据类型包括：float、int、string、array、bool、struct、null、自定义数据类型</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">float</span></span><br><span class="line"><span class="attr">a:</span> <span class="number">1.5</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">int</span></span><br><span class="line"><span class="attr">b:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">string</span></span><br><span class="line"><span class="attr">c:</span> <span class="string">&quot;blahblahblah&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">array</span></span><br><span class="line"><span class="attr">d:</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">bool</span></span><br><span class="line"><span class="attr">e:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">struct</span></span><br><span class="line"><span class="attr">f:</span> &#123;</span><br><span class="line">    <span class="attr">a:</span> <span class="number">1.5</span></span><br><span class="line">    <span class="attr">b:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">d:</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="attr">g:</span> &#123;</span><br><span class="line">        <span class="attr">h:</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">j:</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">表示两种类型的值，即可以是string，也可以是int</span></span><br><span class="line"><span class="attr">h:</span> <span class="string">string</span> <span class="string">|</span> <span class="string">int</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">表示k的默认值为1，且类型为int</span></span><br><span class="line"><span class="attr">k:</span> <span class="string">*1</span> <span class="string">|</span> <span class="string">int</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">自定义数据类型</span></span><br><span class="line"><span class="comment">#abc: string</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更复杂的自定义数据类型如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#abc: &#123;</span></span><br><span class="line">  <span class="attr">x:</span> <span class="string">int</span></span><br><span class="line">  <span class="attr">y:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">z:</span> &#123;</span><br><span class="line">    <span class="attr">a:</span> <span class="string">float</span></span><br><span class="line">    <span class="attr">b:</span> <span class="string">bool</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="定义cue模板"><a href="#定义cue模板" class="headerlink" title="定义cue模板"></a>定义cue模板</h2><p>文件deployment.cue定义如下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">自定义结构体类型</span></span><br><span class="line"><span class="comment">#parameter: &#123;</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">string</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">template:</span> &#123;</span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">&quot;apps/v1&quot;</span></span><br><span class="line">    <span class="attr">kind:</span>       <span class="string">&quot;Deployment&quot;</span></span><br><span class="line">    <span class="attr">spec:</span> &#123;</span><br><span class="line">        <span class="attr">selector: matchLabels:</span> &#123;</span><br><span class="line">            <span class="attr">&quot;app.oam.dev/component&quot;:</span> <span class="string">parameter.name</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">template:</span> &#123;</span><br><span class="line">            <span class="attr">metadata: labels:</span> &#123;</span><br><span class="line">                <span class="attr">&quot;app.oam.dev/component&quot;:</span> <span class="string">parameter.name</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attr">spec:</span> &#123;</span><br><span class="line">                <span class="attr">containers:</span> [&#123;</span><br><span class="line">                    <span class="attr">name:</span>  <span class="string">parameter.name</span>  <span class="string">//</span> <span class="string">引用自定义结构体变量parameter</span></span><br><span class="line">                    <span class="attr">image:</span> <span class="string">parameter.image</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">parameter:&#123;</span></span><br><span class="line">   <span class="attr">name:</span> <span class="string">&quot;mytest&quot;</span></span><br><span class="line">   <span class="attr">image:</span> <span class="string">&quot;nginx:v1&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>执行 cue export deployment.cue -e template –out yaml 可获取到渲染结果。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://cuelang.org/docs/install/">Getting Started</a></li>
<li><a href="https://kubevela.io/zh/docs/platform-engineers/cue/basic">CUE语言基础入门</a></li>
<li><a href="https://cuetorials.com/zh/introduction/">Cuetorials</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>打场的记忆</title>
    <url>/post/dachang/</url>
    <content><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1535126602397&di=58075292f772c85ec1a51f59c9c38c95&imgtype=0&src=http://s3.sinaimg.cn/mw690/001pMv9Lzy74tldB2sq32&690"></p>
<p>晚上在工位上安静地看着技术文档，不知为何脑中突然闪现了小时候打场的场景，那段记忆并无特殊之处，但大概是那片金黄色的背景和村民脸上丰收的喜悦以及村民之间的和谐相处的画面突然浮现在了我的眼前，让我不由得想写点什么以便回忆那段近乎忘却的回忆。</p>
<p>说起“打场”这个词，可能很多人都不太熟悉，其实这个词也已经很多年我都没有接触过了，我甚至都不知道现在农村老家的村民们还是否会时长提起这个词语。我甚至不知道这个词是不是我们那地域性的方言，这些都不重要了。以下内容摘自百度百科：</p>
<blockquote>
<p>打场[dǎ cháng]，指把收割下来带壳的粮食平摊在场院里，用马拉磙子，或者用小型拖拉机，碾压这些粮食，使之脱去外壳，这一系列活动就叫打场。</p>
</blockquote>
<p>我的家在山东，小的时候还没有那么多的农业经济作物，地里更多的农作物以小麦和玉米为主，一年两季。农作物的种植周期跟二十四节气是息息相关的，每年的二十四节气的芒种左右是小麦丰收的季节，时间大概在高考前后。比我大一点的应该还有麦假，就是在收麦子的时候不上学了回家帮着收麦子，我没怎么有印象我有过麦假。</p>
<p>小时候的机械化程度低，甚至谈不上机械化，收麦子这种活自然完全是人工完成的。在机械化程度还可以的今天，收麦子这种活在当时还是有着稍微繁琐的工序，也比较耗费人力，一到收麦子的时候，几乎家里所有的劳力都要出来干活了。</p>
<p>村里场地基本上都是挨着的，这应该是生产队时代的产物，那时候土地是公有的，场地自己要连成一片比较容易。后来土地开始分割给个人，这块场地仍然是保留的，只不过是场地被划分成了很多份，每家分上一点。</p>
<p>在打场那个年代，我是几乎很少参与过收麦子的活动，那时我还小，就是在场地里捣乱和瞎跑，还时不时让在场地里干活的村民调侃一番，毕竟小孩子活泼好动，村民们调侃一下解解乏也算是为他们做的一点点微不足道的贡献了。</p>
<p>收麦子的活第一步是割麦子，割麦子这个活我还正儿八经得干过几次，虽然每次干的时间都非常短。关于割麦子的画面，我脑海中浮现的是烈日当头，家人们带着帽子弓着背拿着镰刀一人一沟麦子往前赶，一会儿麦秸在怀里就抱不下了，然后将麦秸放下继续往前赶。那时候的帽子几乎全部是用草编织成的，两根绳子沿着帽檐搭下来系在下巴上，很是牢固，即使低着头帽子也不会掉下来。我干活的时候每次负责的那一沟麦子总是割的最慢的，几乎要慢一倍的样子，而且是干的最差的，背后总会留下一些麦子没有割下来，到现在我也仍然好奇，他们是怎么干的这么快的，我感觉当时已经尽最大的努力了，而这仅是他们的正常速度。</p>
<p>在麦子割完后，就需要将麦子放到集中的晒干了。之所以要晒干，是因为要是麦秸不晒干，麦粒是很难从麦秸上拖不下来的。而要晒干，那么多麦秸就需要一片地方来晾晒麦秸和麦粒。那时候还没怎么有柏油路，家里也很少有水泥的房顶，为了能够有晾晒的地方，村里有一片地就是场地，在收麦子的时候专门用来收麦子的，收完麦子后再种其他作物。之所以场地是集中式的，这还要从生产队时代说起，那时候土地都是公有的，自然场地就会划到一块比较容易，后来土地慢慢私有后，这些土地仍然是作为场地，只是被划的一小块一小块的。</p>
<p>割麦子的时候偶尔会碰到鹌鹑蛋，这也是一些额外的小收获，但遗憾的是从没看到过鹌鹑。</p>
<p>场地要想能晾晒麦秸和麦粒，自然就需要特别的平整，而要想土地特别的平整，在石器时代，仅有一个办法，那就是用轱辘一遍一遍的撵，一般至少需要两个人用绳子拉着轱辘满地里转，要想将土地撵的特别平整且不能有缝隙，哪怕一个麦粒掉在地上能够看的见捡的起来，想想都不是一件特别容易的事情，尤其是刚开始土地特别不平的时候。</p>
<p>并非所有的麦秸都是需要在场地里暴晒的，这个要看麦秸的干燥程度，有些麦秸割完后已经非常干燥了，就不需要再暴晒了。</p>
<p>干燥的麦秸在干燥后就需要将麦粒从麦秸上分离出来，毕竟农民们想要的是麦粒，那才是实打实的粮食。要想麦粒从麦秸上分离，这时候仍然是重量级的轱辘上场，这时候场地相对平整了，自然拉起来会省力气很多，我也曾经拉过一次，但每次都是拉一会就不知道去哪里玩了，小孩子干这么枯燥的事情自然没有耐心。</p>
<p>拖完粒的麦秸一般是就地放到的场地的地头上，为了省空间，会将麦秸垛起来，一个剁的高度差不多在两三米高的样子，差不多是农民拿着叉子往上扔麦秸扔不上去的高度，叉子的长度差不多在两米高的样子。</p>
<p>白天的时间是晒麦粒的最佳时机，到了傍晚时分就需要将晒的麦粒堆起来盖住，这个时候也是场上人最多的时候，几乎每家的地里都有人在忙着。我脑中闪现的场景就是在这个时候，村民们在场地上忙来忙去，边干活边聊着天，扯东扯西的。我在场地上跑来跑去，从这个地里跑到另外一家，时不时村民们还会那我来开个玩笑。累了靠着垛儿打个滚，不一会体力就恢复了，想来那时体力真是好。那时虽然很多事情还不懂，但我确实能从中体会村民们丰收的喜悦。</p>
<p>麦子收完后，用轱辘碾压了无数遍的场地也就失去了存在的价值，村民们在场地上该种点其他作物就种上其他作物了，总之场地不会空闲特别久。场地上总会落下一些麦粒，雨后空闲的场地上的缝隙处时长会生出新的绿油油的麦苗。</p>
<p>现在随着机械化的进步，收麦子这种事自然不需要手工割麦子了，晒麦子的地方也开始变多了，柏油路上，自家的房顶上，自家的院子里都是及其不错的晒麦子的地方，打场这种原始的方式也自然就退出了历史的舞台，而且再也不会回来。</p>
<p>但就是那幅金黄色的画面却在我的记忆中留下了一道抹不去的色彩，让我时长回忆起来那温馨的画面。纵科技的发展，村民们的亲情却在变淡，该进城的都进城了，该出去打工的都出去打工了，一年村民们都见不上几回。也许将来村落的概念会消失，也许人与人之间的关系会更淡，但我曾经经历过村落时代的美好，也许这就足够了。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux下磁盘常用命令</title>
    <url>/post/disk-command/</url>
    <content><![CDATA[<h1 id="查看磁盘是否为ssd"><a href="#查看磁盘是否为ssd" class="headerlink" title="查看磁盘是否为ssd"></a>查看磁盘是否为ssd</h1><p>如果其中的rota值为1，说明为hdd磁盘；如果rota值为0，说明为ssd。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># lsblk -o name,size,type,rota,mountpoint</span><br><span class="line">NAME    SIZE TYPE ROTA MOUNTPOINT</span><br><span class="line">vdc      20G disk    1 /var/lib/kubelet/pods/eea3a54c-b211-4ee3-bcbe-70ba3fe84c05/volumes/kubernetes.io~csi/d-t4n36xdqey47v9e0ej8r/mount</span><br><span class="line">vda     120G disk    1</span><br><span class="line">└─vda1  120G part    1 /</span><br></pre></td></tr></table></figure>

<p>但该规则在很多虚拟机的场景下并不成立，即使虚拟机的磁盘为ssd，但rota值仍然为1。可以通过修改rota的值的方式来标记磁盘的类型：echo ‘0’&gt; &#x2F;sys&#x2F;block&#x2F;vdd&#x2F;queue&#x2F;rotational</p>
<h1 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h1><p>只能观察磁盘整体性能，不能看到进程级别的</p>
<ul>
<li>iops &#x3D; r&#x2F;s+w&#x2F;s</li>
<li>吞吐量 &#x3D; rkB&#x2F;s + wkB&#x2F;s</li>
<li>响应时间 &#x3D; r_await + w_await</li>
</ul>
<p>iostat -xm $interval: interval为秒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ iostat -xm 1</span><br><span class="line">Linux 3.10.0-327.10.1.el7.x86_64 (103-17-52-sh-100-I03.yidian.com)      12/11/2016      _x86_64_        (32 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           4.99    0.00    1.46    0.01    0.00   93.54</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rMB/s    wMB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00     0.26    0.02    1.62     0.00     0.02    29.31     0.00    0.89    3.37    0.87   0.05   0.01</span><br><span class="line">sdb               0.00     0.81   10.23   67.59     1.19    29.07   796.57     0.01    0.10    0.85    2.85   0.19   1.46</span><br></pre></td></tr></table></figure>

<ul>
<li>r&#x2F;s: 每秒发送给磁盘的读请求数</li>
<li>w&#x2F;s: 每秒发送给磁盘的写请求数</li>
<li>rMB&#x2F;s: 每秒从磁盘读取的数据量</li>
<li>wMB&#x2F;s: 每秒向磁盘写入的数据量</li>
<li>%iowait：cpu等待磁盘时间</li>
<li>%util：表示磁盘使用率，该值较大说明磁盘性能存在问题，io队列不为空的时间。由于存在并行io，100%不代表磁盘io饱和</li>
<li>r_await：读请求处理完成时间，包括队列中的等待时间和设备实际处理时间，单位为毫秒</li>
<li>w_await：写请求处理完成时间，包括队列中的等待时间和设备实际处理时间，单位为毫秒</li>
<li>svctm: 瓶颈每次io操作的时间，单位为毫秒，可以反映出磁盘的瓶颈</li>
<li>avgrq-sz：平均每次请求的数据大小</li>
<li>avgqu-sz：平均请求io队列长度</li>
<li>svctm：处理io请求所需要的平均时间，不包括等待时间，单位为毫秒</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ iostat -d -x 1</span><br><span class="line">Linux 3.10.0-327.10.1.el7.x86_64 (103-17-42-sh-100-i08.yidian.com)      01/19/2019      _x86_64_        (24 CPU)</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.00     7.58    0.31  266.07     9.54   888.01     6.74     0.03    0.12    8.84    0.11   0.03   0.90</span><br><span class="line">sdb               0.00     0.67    4.39   40.68   386.20  9277.38   428.79     0.03    0.64    3.10    0.37   0.30   1.33</span><br><span class="line">sdd               0.00     0.82    5.08   66.78   451.99 15587.89   446.42     0.02    0.30    3.50    0.05   0.28   2.01</span><br><span class="line">sde               0.00     0.67    4.14   53.77   312.74 12121.84   429.43     0.00    0.03    4.00    1.44   0.30   1.72</span><br><span class="line">sdc               0.00     0.50    0.05   27.47     2.74  6098.56   443.28     0.03    0.95   12.42    0.93   0.21   0.58</span><br><span class="line">sdf               0.00     0.47    1.07   34.58    57.05  7504.68   424.24     0.00    0.05    2.60    2.63   0.25   0.88</span><br><span class="line">sdg               0.00     0.72    0.14   63.87    13.79 14876.74   465.22     0.03    0.42   10.57    0.40   0.19   1.24</span><br><span class="line">sdj               0.00     0.79    1.85   37.81   206.01  7881.89   407.90     0.03    0.67    2.27    0.59   0.36   1.42</span><br><span class="line">sdi               0.00     0.65    0.29   59.54    22.01 13501.71   452.05     0.01    0.25    5.27    0.22   0.19   1.14</span><br><span class="line">sdk               0.00     0.50    0.30   29.46    16.74  6330.68   426.57     0.05    1.58    4.03    1.55   0.24   0.70</span><br><span class="line">sdm               0.00     0.63    0.73   55.70    63.73 13008.16   463.34     0.02    0.35    5.98    0.28   0.23   1.29</span><br><span class="line">sdh               0.00     0.47    0.06   15.68     5.16  2970.09   378.01     0.03    1.82    7.22    1.80   0.27   0.42</span><br><span class="line">sdl               0.00     0.56    1.32   38.14    81.04  8945.16   457.50     0.09    2.22    4.30    2.15   0.19   0.76</span><br></pre></td></tr></table></figure>

<ul>
<li>wrqm: 每秒合并的写请求数</li>
<li>rrqm：每秒合并的读请求数</li>
</ul>
<h1 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h1><p>如果要想查看进程级别的磁盘 io 使用情况，可以使用 <code>pidstat -d</code> 指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pidstat -d 1</span><br><span class="line">Linux 3.10.0-1160.88.1.el7.x86_64 (izbp1feliilr5yri84y6saz)     05/08/2023      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">09:44:24 AM   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">09:44:25 AM     0       371      0.00    184.91      0.00  jbd2/vda1-8</span><br><span class="line">09:44:25 AM     0      1395      0.00     22.64      7.55  rsyslogd</span><br><span class="line">09:44:25 AM     0     19053      0.00      3.77      0.00  jbd2/dm-0-8</span><br><span class="line">09:44:25 AM  1000     25479      0.00      3.77      0.00  org_start</span><br><span class="line">09:44:25 AM  1000     25754      0.00      3.77      0.00  org_start</span><br><span class="line">09:44:25 AM     0     38784      0.00    505.66      0.00  systemd-journal</span><br><span class="line">09:44:25 AM     0     40474      0.00    143.40      0.00  jbd2/dm-1-8</span><br><span class="line">09:44:25 AM     0     41130      0.00     11.32      0.00  jbd2/dm-2-8</span><br><span class="line">09:44:25 AM  1000     41675      0.00      3.77      0.00  start</span><br><span class="line">09:44:25 AM     0     41730      0.00      3.77      0.00  org_start</span><br></pre></td></tr></table></figure>

<h1 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h1><p>该命令可以查看所有进程读写 io 情况，该命令通常 os 不会默认安装。在 CentOS 下可以执行 <code>yum install iotop</code> 命令安装。</p>
]]></content>
  </entry>
  <entry>
    <title>做自己</title>
    <url>/post/do_your_self/</url>
    <content><![CDATA[<p>最近有同事想离职了，上午在跟领导一番谈话之后又有些犹豫了。大概领导会说些公司状况及个人发展之类的话语来说服同事不要离职，用大腿想想都知道的事。同事肯定会说自己的几个抱怨，领导肯定会一一还击，到最后领导领导一摊手“看没什么顾虑的吧，年轻人就是冲动，你再想想吧，先回去好好干活吧”。</p>
<p>我在这里想说的事不要管别人怎么想，做自己，坚持自己的想法。</p>
<p>一千个人眼里有一千个郭美美。有人说郭美美的自拍照真漂亮，有人说郭美美卸妆之后直接毁三观，有人说是郭美美毁掉了红十字会，有人说没有郭美美红十字会一样玩完，有人说郭美美炫富就是为了出名，有人说郭美美是偶像，有人说郭美美是呕像，有人说郭美美为咱们的游戏代言应该很棒，有人说…</p>
<p>同一件事情在不同人眼里就会有不同的看法。当然我的观点，在别人看来也许是那么的反感或不屑一顾。</p>
<p>做技术的天天跟机器打交道，往往语言表达能力较弱，不善辩，更别提忽悠别人了。经过领导只言片语的轰炸，自己已经是茫然不知所措，自己最初的坚持在渐渐退去，别人的想法正在填充你的大脑，恭喜你被洗脑了。但是这种洗脑往往是暂时性的，往往当是生效，事后理性分析一下觉得“不对啊，我当时怎么了”。所以搞传销的一培训就是在一个鸟拉屎的地方培训上几个月来彻底洗脑。</p>
<p>我还好，至少我会坚持自己的观点。记得我上次离职时，领导找我谈话，领导叽里呱啦说了很多，我明知道不对头，但却愣是无力反驳，那时候心里的就想说“求求你，别说了”。</p>
<p>离职对同事自身而言是好事。同事工作两年，在公司工作一年多了，由于公司业绩差，工资非但没有涨过，最近甚至都拖欠了一个月的工资了，而且如果待在公司未来一年内都不涨工资的可能性极大。换个工作薪水可以提高，更可以接触到新鲜的技术，对自己无论在物质还是在技术上都是有利无害。我可以想到的唯一坏处就是舍不得公司，舍不得同事，舍不得那个靠窗的小办公桌。可是这些算个屁，公司的发展跟普通员工毛关系都没有，公司好坏员工拿到的都是稀薄的工资，何况公司已经发不下工资来了，是公司待你不厚道。感情在涉及到金钱后往往变得一文不值。</p>
<p>就公司而言是坏事。公司恨不得不发你工资光给公司干活。领导之所以留你是因为你对公司的业务熟悉，公司如果再重新招人没个一个月的时间很难上手。假如换成了在公司里天天闲的蛋疼的人提离职，公司可能就巴不得立马卷铺盖走人。领导留人只能说明领导对你的肯定，其他的说明不了什么。公司的前途未卜，领导凭什么忽悠员工留下来？</p>
<p>这是一个相互炒鱿鱼的时代。员工跟公司之间是对等的关系，公司对员工不满意可以解除合同，员工对公司不满意照样可以将公司炒掉换个新鲜的工作。</p>
<p>做自己，坚持自己的观点，适当聆听别人的建议，才会赢！</p>
]]></content>
      <tags>
        <tag>杂谈 工作</tag>
      </tags>
  </entry>
  <entry>
    <title>docker bridge network</title>
    <url>/post/docker-bridge-network/</url>
    <content><![CDATA[<p>docker bridge是默认的网络模式</p>
<h2 id="容器访问外网"><a href="#容器访问外网" class="headerlink" title="容器访问外网"></a>容器访问外网</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/docker_bridge_network.png"></p>
<p>默认情况下，容器即可访问外网。</p>
<p>启动一个容器：<code>docker run -d nginx</code></p>
<p>容器中访问外网的请求如<a href="http://www.baidu.com,内核协议栈根据路由信息,会选择默认路由,将请求发送到容器中的eth0网卡,目的mac地址为网关172.17.0.1的mac地址./">www.baidu.com，内核协议栈根据路由信息，会选择默认路由，将请求发送到容器中的eth0网卡，目的mac地址为网关172.17.0.1的mac地址。</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>

<p>eth0网卡接收到数据包后，会将数据包转发到veth pair的另外一端，即宿主机网络中的veth6b173fd设备。</p>
<p>veth6b173fd设备是挂在网桥上的，会将数据包转发到网桥br0，br0即为网关172.17.0.1。</p>
<p>br0接收到数据包后，会将数据包转发给内核协议栈。</p>
<p>宿主机上的&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward为1，表示转发功能开启，即目的ip不是本机的会根据路由规则进行转发，而不是丢弃。</p>
<p>仅在宿主机上开启了ip_forward后，包即使转发了，还是无法回来的，因为包中的源ip地址为172.17.0.1，是私有网段的ip地址。需要做一次SNAT才可以，docker会在iptabels的nat表中的postrouting链中增加SNAT规则，下面规则的意思是源地址为172.17.0.0&#x2F;16的会做一次地址伪装，即SNAT。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># iptables -nL -t nat</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0</span><br></pre></td></tr></table></figure>

<p>在eth0网卡上抓包，可以发现源ip已经是eth0的网卡ip地址。</p>
<h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>命令格式：<code>-p $&#123;host_port&#125;:$&#123;container_port&#125;</code></p>
<p>启动一个容器：<code>docker run -d -p 8080:80 nginx</code></p>
<p>查看本地的iptables规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ iptables -nL -t nat</span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DOCKER     all  --  0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DOCKER     all  --  0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0</span><br><span class="line">MASQUERADE  tcp  --  172.17.0.2           172.17.0.2           tcp dpt:80</span><br><span class="line"></span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">RETURN     all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">## prerouting链引用，外面发往本机的8080端口的数据包，会dnat为172.17.0.2:80</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:8080 to:172.17.0.2:80</span><br></pre></td></tr></table></figure>

<h2 id="丢包问题"><a href="#丢包问题" class="headerlink" title="丢包问题"></a>丢包问题</h2><p>SNAT在并发比较高的情况下，会存在少量的丢包现象，具体原因跟conntrack模式的实现有关。conntrack在SNAT端口的分配和插入conntrack表之间有个延时，如果在这中间存在冲突的话会导致插入失败，从而出现丢包的问题。</p>
<p>该问题没有根治的解决办法，能大大缓解的解决办法为使用iptabels的–random-fully选项，SNAT选择端口为随机，大大降低出现冲突的概率。</p>
]]></content>
  </entry>
  <entry>
    <title>Dockerfile中的ENTRYPOINT与CMD</title>
    <url>/post/docker-entrypoint-cmd/</url>
    <content><![CDATA[<p>在Dockerfile中ENTRYPOINT与CMD的功能类似，同时再加上<code>docker run</code>后面追加的容器启动参数，是极其容易混淆的。而且又掺杂着exec模式和shell模式。</p>
<p>这里先说几个结论，有了结论再跟进下面的例子来理解会更容易一些：</p>
<ol>
<li>实际上docker容器进程的完整启动参数为<code>ENTRYPOINT CMD</code>，如果没有指定ENTRYPOINT，docker会提供一个隐式的值<code>/bin/sh -c</code>。</li>
<li><code>docker run</code>后面跟的容器启动参数仅会覆盖CMD部分。</li>
</ol>
<h2 id="exec模式与shell模式"><a href="#exec模式与shell模式" class="headerlink" title="exec模式与shell模式"></a>exec模式与shell模式</h2><p>CMD和ENTRYPOINT两个命令均支持exec模式和shell模式。</p>
<p>exec模式格式类似<code>CMD [ &quot;top&quot; ]</code>，当容器启动时，top命令的进程号为1。</p>
<p>为了能够获取到环境变量，通常的写法为<code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code>，此时1号进程为sh。</p>
<p>shell模式的写法为<code>CMD top</code>，docker会以<code>/bin/sh -c top</code>的方式来执行命令，此时容器的1号进程为sh。</p>
<p>如果需要容器进程处理外部信号的情况下，shell模式下信号实际上时发送给了sh，而不是容器中的应用进程。</p>
<p>因此比较推荐使用exec模式，shell模式实际使用较少。</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><ul>
<li>CMD [“param1”, “param2”] 为ENTRYPOINT提供默认参数，需要指定ENTRYPOINT</li>
<li>CMD [“executable”,”param1”,”param2”] exec模式</li>
<li>CMD command param1 param2 shell模式</li>
</ul>
<p>CMD为容器提供默认的启动命令，如果在启动容器时通过命令行指定了的启动参数，则该启动参数会覆盖CMD默认的启动参数。</p>
<h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p>不能被<code>docker run</code>增加的参数覆盖，启动时要执行ENTRYPOINT的参数。</p>
<ul>
<li>ENTRYPOINT [“executable”, “param1”, “param2”] exec模式</li>
<li>ENTRYPOINT command param1 param2 shell模式</li>
</ul>
<h3 id="exec模式"><a href="#exec模式" class="headerlink" title="exec模式"></a>exec模式</h3><p>当为exec模式时，容器启动时，在命令行上添加的参数会被追加到ENTRYPOINT的参数列表中。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line">ENTRYPOINT [ &quot;echo&quot;, &quot;hello&quot; ]</span><br></pre></td></tr></table></figure>

<p>执行<code>docker run --rm 0d89e8d4425a world</code>，会输出<code>hello world</code></p>
<h3 id="shell模式"><a href="#shell模式" class="headerlink" title="shell模式"></a>shell模式</h3><p>当ENTRYPOINT为shell模式时，docker run启动后追加的参数会被忽略。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line"></span><br><span class="line">ENTRYPOINT echo hello</span><br></pre></td></tr></table></figure>

<p>执行<code>docker run --rm 0841e19b4d2e world</code>仅输出<code>hello</code>。</p>
<h3 id="ENTRYPOINT命令的覆盖"><a href="#ENTRYPOINT命令的覆盖" class="headerlink" title="ENTRYPOINT命令的覆盖"></a>ENTRYPOINT命令的覆盖</h3><p>ENTRYPOINT的命令可以通过<code>docker run</code>中增加<code>--entrypoint</code>选项来使用命令行中指定的参数覆盖ENTRYPOINT的参数。</p>
<h2 id="ENTRYPOINT与CMD的组合使用"><a href="#ENTRYPOINT与CMD的组合使用" class="headerlink" title="ENTRYPOINT与CMD的组合使用"></a>ENTRYPOINT与CMD的组合使用</h2><p>当同时指定CMD和ENTRYPOINT模式时，实际上为<code>ENTRYPOINT CMD</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [ &quot;echo&quot;, &quot;hello&quot; ]</span><br><span class="line">CMD [ &quot;world&quot; ]</span><br></pre></td></tr></table></figure>

<p><code>docker run --rm 7edf658370d9</code>会输出<code>hello world</code>，而<code>docker run --rm 7edf658370d9 kitty</code>会输出<code>hello kitty</code>。</p>
<p>更复杂的情况可以参照下图：</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/entrypoint-cmd.png" alt="https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact"></p>
<h2 id="如何查看ENTRYPOINT和CMD"><a href="#如何查看ENTRYPOINT和CMD" class="headerlink" title="如何查看ENTRYPOINT和CMD"></a>如何查看ENTRYPOINT和CMD</h2><p>可以通过<code>docker history $&#123;image&#125; --no-trunc</code>来查生成镜像的所有Dockerfile命令</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://docs.docker.com/engine/reference/builder/#entrypoint">Dockerfile reference</a></li>
<li><a href="https://www.cnblogs.com/sparkdev/p/8461576.html">Dockerfile 中的 CMD 与 ENTRYPOINT</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>docker镜像</title>
    <url>/post/docker-image/</url>
    <content><![CDATA[<h2 id="多架构镜像"><a href="#多架构镜像" class="headerlink" title="多架构镜像"></a>多架构镜像</h2><h3 id="查看镜像的多架构信息"><a href="#查看镜像的多架构信息" class="headerlink" title="查看镜像的多架构信息"></a>查看镜像的多架构信息</h3><p>可以使用 <code>docker manifest inspect $image</code> 命令来查看，manifest为docker的体验特性，在Linux系统下开启，需要在本地创建 ~&#x2F;.docker&#x2F;config.json 文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;experimental&quot;: &quot;enabled&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好的方式为开启docker daemon的特性，修改 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;experimental&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>例如执行 <code>docker manifest inspect golang:alpine</code> 可以看到golang 官方的docker镜像包含了多架构信息，每个架构下会对应一个sha256值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;schemaVersion&quot;: 2,</span><br><span class="line">   &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.list.v2+json&quot;,</span><br><span class="line">   &quot;manifests&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,</span><br><span class="line">         &quot;size&quot;: 1365,</span><br><span class="line">         &quot;digest&quot;: &quot;sha256:725f8fd50191209a4c4a00def1d93c4193c4d0a1c2900139daf8f742480f3367&quot;,</span><br><span class="line">         &quot;platform&quot;: &#123;</span><br><span class="line">            &quot;architecture&quot;: &quot;amd64&quot;,</span><br><span class="line">            &quot;os&quot;: &quot;linux&quot;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,</span><br><span class="line">         &quot;size&quot;: 1365,</span><br><span class="line">         &quot;digest&quot;: &quot;sha256:5adcff3a3e757841a6c7b07f1986b2a36cb0afaf47025e78bb17358eda2d541a&quot;,</span><br><span class="line">         &quot;platform&quot;: &#123;</span><br><span class="line">            &quot;architecture&quot;: &quot;arm&quot;,</span><br><span class="line">            &quot;os&quot;: &quot;linux&quot;,</span><br><span class="line">            &quot;variant&quot;: &quot;v6&quot;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,</span><br><span class="line">         &quot;size&quot;: 1365,</span><br><span class="line">         &quot;digest&quot;: &quot;sha256:84a1e4174b934fbf8f1dfe9f7353a5be449096b6f2273d6af5a364ffd6bf8f15&quot;,</span><br><span class="line">         &quot;platform&quot;: &#123;</span><br><span class="line">            &quot;architecture&quot;: &quot;arm&quot;,</span><br><span class="line">            &quot;os&quot;: &quot;linux&quot;,</span><br><span class="line">            &quot;variant&quot;: &quot;v7&quot;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,</span><br><span class="line">         &quot;size&quot;: 1365,</span><br><span class="line">         &quot;digest&quot;: &quot;sha256:86cfea5046e196f5061324c93f25ef05e1df58ba96721e0c0b42cc6e0cf22e49&quot;,</span><br><span class="line">         &quot;platform&quot;: &#123;</span><br><span class="line">            &quot;architecture&quot;: &quot;arm64&quot;,</span><br><span class="line">            &quot;os&quot;: &quot;linux&quot;,</span><br><span class="line">            &quot;variant&quot;: &quot;v8&quot;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,</span><br><span class="line">         &quot;size&quot;: 1365,</span><br><span class="line">         &quot;digest&quot;: &quot;sha256:5ad072476cb8b51dddaf4142789f1528c7d48a3a0c31941a5ce21177c8e47259&quot;,</span><br><span class="line">         &quot;platform&quot;: &#123;</span><br><span class="line">            &quot;architecture&quot;: &quot;386&quot;,</span><br><span class="line">            &quot;os&quot;: &quot;linux&quot;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,</span><br><span class="line">         &quot;size&quot;: 1365,</span><br><span class="line">         &quot;digest&quot;: &quot;sha256:fca6cbe2f1fb9095eac2669c0be58b482135f9cf7196d51ac7338ea3e7c556c7&quot;,</span><br><span class="line">         &quot;platform&quot;: &#123;</span><br><span class="line">            &quot;architecture&quot;: &quot;ppc64le&quot;,</span><br><span class="line">            &quot;os&quot;: &quot;linux&quot;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         &quot;mediaType&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;,</span><br><span class="line">         &quot;size&quot;: 1365,</span><br><span class="line">         &quot;digest&quot;: &quot;sha256:3f7ac24ca4b3ce61b51439cb59b57a8151ba60bd73a0e33cc06020dda6b692cb&quot;,</span><br><span class="line">         &quot;platform&quot;: &#123;</span><br><span class="line">            &quot;architecture&quot;: &quot;s390x&quot;,</span><br><span class="line">            &quot;os&quot;: &quot;linux&quot;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gcr.io 可以在 console 上直接看到信息，比如: <a href="https://console.cloud.google.com/gcr/images/k8s-artifacts-prod/us/ingress-nginx%2Fnginx@sha256:1ef404b5e8741fe49605a1f40c3fdd8ef657aecdb9526ea979d1672eeabd0cd9/details?tab=pull">nginx镜像</a></p>
<h3 id="多架构镜像的构建"><a href="#多架构镜像的构建" class="headerlink" title="多架构镜像的构建"></a>多架构镜像的构建</h3><p>可以使用docker buildx命令，比如 <code>docker buildx build -t &lt;image-name&gt; --platform=linux/arm64,linux/amd64 . --push</code> 可以同时构建出arm64和amd64的镜像。</p>
<h2 id="查看镜像的构建历史"><a href="#查看镜像的构建历史" class="headerlink" title="查看镜像的构建历史"></a>查看镜像的构建历史</h2><p>可以使用 <code>docker history --no-trunc $&#123;image&#125;</code> 来查看镜像的每层构建命令</p>
<h2 id="通过代理拉取镜像"><a href="#通过代理拉取镜像" class="headerlink" title="通过代理拉取镜像"></a>通过代理拉取镜像</h2><p>创建或者修改&#x2F;etc&#x2F;docker&#x2F;daemon.json文件，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https://mirror.baidubce.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启docker后通过<code>docker info</code>命令查看输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker info</span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  https://hub-mirror.c.163.com/</span><br><span class="line">  https://mirror.baidubce.com/</span><br><span class="line"> Live Restore Enabled: false</span><br></pre></td></tr></table></figure>

<h2 id="常用基础镜像"><a href="#常用基础镜像" class="headerlink" title="常用基础镜像"></a>常用基础镜像</h2><ul>
<li>nicolaka&#x2F;netshoot：包含了丰富的网络命令，排查网络问题非常方便</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://docs.docker.com/registry/spec/manifest-v2-2/">Image Manifest V 2, Schema 2</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>docker私有仓库搭建</title>
    <url>/post/docker-registry/</url>
    <content><![CDATA[<p>为了其他主机可访问docker registry，必须采用https协议。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/docker_registry/certs</span><br><span class="line">signdomain=103-17-184-lg-201-k08</span><br><span class="line">openssl req -nodes -subj &quot;/C=CN/ST=BeiJing/L=BeiJing/CN=$signdomain&quot; -newkey rsa:4096 -keyout ~/docker_registry/certs/$signdomain.key -out ~/docker_registry/certs/$signdomain.csr</span><br><span class="line">openssl x509 -req -days 3650 -in ~/docker_registry/certs/$signdomain.csr -signkey ~/docker_registry/certs/$signdomain.key -out ~/docker_registry/certs/$signdomain.crt</span><br></pre></td></tr></table></figure>

<p>从docker hub拉取registry镜像，并启动镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always --name registry \</span><br><span class="line">  -v /data/docker_registry:/var/lib/registry \</span><br><span class="line">  -v /home/worker/docker_registry/certs:/certs \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/103-17-184-lg-201-k08.yidian.com.crt \</span><br><span class="line">  -e REGISTRY_HTTP_TLS_KEY=/certs/103-17-184-lg-201-k08.yidian.com.key \</span><br><span class="line">  registry:2</span><br></pre></td></tr></table></figure>

<p>停止registry镜像并删除的命令为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop registry &amp;&amp; docker rm -v registry</span><br></pre></td></tr></table></figure>

<p>下载最新的centos7镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull centos:7.3.1611</span><br></pre></td></tr></table></figure>

<p>将centos7镜像增加tag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker tag centos:7.3.1611 103-17-184-lg-201-k08.yidian.com:5000/centos:7.3</span><br><span class="line"></span><br><span class="line"># 可以看到列表中会多出一个镜像</span><br><span class="line">[root@103-17-184-lg-201-k08 data]# docker images</span><br><span class="line">REPOSITORY                                     TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/registry                             2                   047218491f8c        4 weeks ago         33.17 MB</span><br><span class="line">103-17-184-lg-201-k08.yidian.com:5000/centos   7.3                 67591570dd29        3 months ago        191.8 MB</span><br><span class="line">docker.io/centos                               7.3.1611            67591570dd29        3 months ago        191.8 MB</span><br></pre></td></tr></table></figure>

<p>docker push命令仅支持https协议，签名已经启动了自签名的https协议的registry，为了能够让docker能够信任registry，需要在&#x2F;etc&#x2F;docker&#x2F;certs.d&#x2F;目录下增加相应的crt文件，增加后的目录结构为&#x2F;etc&#x2F;docker&#x2F;certs.d&#x2F;103-17-184-lg-201-k08.yidian.com:5000&#x2F;103-17-184-lg-201-k08.yidian.com.crt，添加完成后需要重启docker服务。</p>
<p>将image push到registry</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker push 103-17-184-lg-201-k08.yidian.com:5000/centos:7.3 </span><br></pre></td></tr></table></figure>

<h1 id="api"><a href="#api" class="headerlink" title="api"></a>api</h1><ul>
<li>列出images：<a href="https://10.103.17.184:5000/v2/_catalog">https://10.103.17.184:5000/v2/_catalog</a></li>
<li>列出image的tags：<a href="https://10.103.17.184:5000/v2/centos/tags/list">https://10.103.17.184:5000/v2/centos/tags/list</a></li>
</ul>
<p>可以直接通过curl命令来访问api：<code>curl --cacert 103-17-184-lg-201-k08.yidian.com.crt -v https://103-17-184-lg-201-k08.yidian.com:5000/v2</code></p>
<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul>
<li><a href="https://hub.docker.com/_/registry/">registry</a></li>
<li><a href="http://www.cnblogs.com/fengzheng/p/5168951.html">docker创建私有仓库</a></li>
<li><a href="https://docs.docker.com/registry/">Docker Registry</a>（官方教程）</li>
<li><a href="https://docs.docker.com/registry/spec/api/">Registry API</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>kubernetes中pod无法删除的问题排查</title>
    <url>/post/docker-rm-failed/</url>
    <content><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.2.1511 (Core)</span><br><span class="line"></span><br><span class="line">$ uname -a</span><br><span class="line">Linux c3-a05-136-45-10.com 3.10.0-327.el7.x86_64 #1 SMP Thu Nov 19 22:10:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line">$ docker info | grep &quot;Storage Driver&quot;</span><br><span class="line">Storage Driver: devicemapper</span><br></pre></td></tr></table></figure>

<p>在CentOS7.2的系统上，发现有一部分pod在delete后一直处于Terminating状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods -o wide</span><br><span class="line">NAME                                 READY     STATUS        RESTARTS   AGE       IP        NODE          NOMINATED NODE</span><br><span class="line">httpserver-prod-1-6cb97dfbcc-25dsh   0/1       Terminating   0          55d       &lt;none&gt;    10.136.45.6   &lt;none&gt;</span><br><span class="line">httpserver-prod-1-6cb97dfbcc-f9flb   0/1       Terminating   0          54d       &lt;none&gt;    10.136.45.4   &lt;none&gt;</span><br><span class="line">httpserver-prod-1-6cb97dfbcc-m7sl4   0/1       Terminating   0          55d       &lt;none&gt;    10.136.45.6   &lt;none&gt;</span><br><span class="line">httpserver-prod-1-6cb97dfbcc-pqpht   0/1       Terminating   0          55d       &lt;none&gt;    10.136.45.6   &lt;none&gt;</span><br><span class="line">httpserver-prod-1-6cb97dfbcc-r987g   0/1       Terminating   0          55d       &lt;none&gt;    10.136.45.4   &lt;none&gt;</span><br><span class="line">httpserver-prod-1-6cb97dfbcc-zghhr   0/1       Terminating   0          54d       &lt;none&gt;    10.136.45.6   &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>查看docker的日志发现有如下报错信息如下，含义为在删除pod时由于&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay&#x2F;*&#x2F;merged目录被其他应用占用，从而导致容器无法清除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jan 30 14:57:47 c3-a05-136-45-4.com dockerd[1510]: time=&quot;2019-01-30T14:57:47.704641914+08:00&quot; level=error msg=&quot;Error removing mounted layer e6b7378c58a34cb42c6fa7924f7a52b7a19a64b2166d7a56f363e73ecba6e5a9: remove /var/lib/docker/overlay/98a56d695c9e3d0b6a9f3b5e0e60abf7cdb3ce73e976b00e36ca59028e585a36/merged: device or resource busy&quot;</span><br><span class="line">Jan 30 14:57:47 c3-a05-136-45-4.com dockerd[1510]: time=&quot;2019-01-30T14:57:47.704772288+08:00&quot; level=error msg=&quot;Handler for DELETE /v1.31/containers/e6b7378c58a34cb42c6fa7924f7a52b7a19a64b2166d7a56f363e73ecba6e5a9 returned error: driver \&quot;overlay\&quot; failed to remove root filesystem for e6b7378c58a34cb42c6fa7924f7a52b7a19a64b2166d7a56f363e73ecba6e5a9: remove /var/lib/docker/overlay/98a56d695c9e3d0b6a9f3b5e0e60abf7cdb3ce73e976b00e36ca59028e585a36/merged: device or resource busy&quot;</span><br><span class="line">Jan 30 14:57:48 c3-a05-136-45-4.com dockerd[1510]: time=&quot;2019-01-30T14:57:48.228837657+08:00&quot; level=error msg=&quot;Error removing mounted layer 2851b80d5c45d1cac3e7384116da0ad022af21701f9aa0d9ba3598efd5723030: remove /var/lib/docker/overlay/0ff0f98e1abf43c10711f2804cae3cf37efd597016d38b4753e2af19c2e27eb9/merged: device or resource busy&quot;</span><br><span class="line">Jan 30 14:57:48 c3-a05-136-45-4.com dockerd[1510]: time=&quot;2019-01-30T14:57:48.228953497+08:00&quot; level=error msg=&quot;Handler for DELETE /v1.31/containers/2851b80d5c45d1cac3e7384116da0ad022af21701f9aa0d9ba3598efd5723030 returned error: driver \&quot;overlay\&quot; failed to remove root filesystem for 2851b80d5c45d1cac3e7384116da0ad022af21701f9aa0d9ba3598efd5723030: remove /var/lib/docker/overlay/0ff0f98e1abf43c10711f2804cae3cf37efd597016d38b4753e2af19c2e27eb9/merged: device or resource busy&quot;</span><br></pre></td></tr></table></figure>

<p>通过<code>docker ps -a</code>看到容器的状态为”Removal In Progress”。通过<code>docker inspect</code>可以看到容器的进程已经退出了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                                                  COMMAND                  CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">e6b7378c58a3        golang-httpserver        &quot;/bin/sh -c &#x27;go ru...&quot;   7 weeks ago         Removal In Progress                           k8s_golang-httpserver_httpserver-prod-1-6cb97dfbcc-f9flb_default_9e3d2cbb-f9d4-11e8-b61c-f01fafd10a1b_0</span><br><span class="line"></span><br><span class="line"># docker inspect e6b7378c58a3 --format &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>使用<code>docker rm</code>命令删除容器会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker rm e6b7378c58a3</span><br><span class="line">Error response from daemon: driver &quot;overlay&quot; failed to remove root filesystem for e6b7378c58a34cb42c6fa7924f7a52b7a19a64b2166d7a56f363e73ecba6e5a9: remove /var/lib/docker/overlay/98a56d695c9e3d0b6a9f3b5e0e60abf7cdb3ce73e976b00e36ca59028e585a36/merged: device or resource busy</span><br></pre></td></tr></table></figure>

<p>通过<code>kubectl delete pods</code>命令虽然可以强制删除pod，但在宿主机上仍然能看到容器的状态为”Removal In Progress”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl delete pods  httpserver-prod-1-6cb97dfbcc-f9flb --grace-period=0 --force</span><br><span class="line">warning: Immediate deletion does not wait for confirmation that the running resource has been terminated. The resource may continue to run on the cluster indefinitely.</span><br><span class="line">pod &quot;httpserver-prod-1-6cb97dfbcc-f9flb&quot; force deleted</span><br></pre></td></tr></table></figure>

<p>通过搜索挂载目录的信息，可以找到是哪个进程挂载了该目录。可以看到是ntpd服务挂载了该目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># grep -nr 98a56 /proc/*/mountinfo</span><br><span class="line">/proc/2725007/mountinfo:48:296 183 0:183 / /var/lib/docker/overlay/98a56d695c9e3d0b6a9f3b5e0e60abf7cdb3ce73e976b00e36ca59028e585a36/merged rw,relatime shared:88 - overlay overlay rw,lowerdir=/var/lib/docker/overlay/5e2a5f7af24e555a5afacd6a8faa406b42c51d7f2bb4cde22adcea22e0153583/root,upperdir=/var/lib/docker/overlay/98a56d695c9e3d0b6a9f3b5e0e60abf7cdb3ce73e976b00e36ca59028e585a36/upper,workdir=/var/lib/docker/overlay/98a56d695c9e3d0b6a9f3b5e0e60abf7cdb3ce73e976b00e36ca59028e585a36/work</span><br><span class="line"></span><br><span class="line"># ps -ef | grep 2725007</span><br><span class="line">ntp      2725007       1  0 Jan07 ?        00:00:02 /usr/sbin/ntpd -u ntp:ntp -g</span><br><span class="line"></span><br><span class="line"># ntpd进程的启动时间在容器启动之后</span><br><span class="line"># ps -ef | grep ntpd</span><br><span class="line">root     1179644   18205  0 19:52 pts/1    00:00:00 grep --color=auto -d skip -i ntpd</span><br><span class="line">ntp      3853149       1  0 Jan07 ?        00:00:02 /usr/sbin/ntpd -u ntp:ntp -g</span><br></pre></td></tr></table></figure>

<p>查看ntpd.service文件内容如下，其中<code>PrivateTmp=true</code>，该选项用于控制服务是否使用单独的tmp目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Network Time Service</span><br><span class="line">After=syslog.target ntpdate.service sntp.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/ntpd</span><br><span class="line">ExecStart=/usr/sbin/ntpd -u ntp:ntp $OPTIONS</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在系统上启动一个容器，此时ntpd必须处于running状态</span><br><span class="line">$ docker run -d httpserver:1 /bin/sh -c &quot;while : ; do sleep 1000 ; done&quot;</span><br><span class="line"></span><br><span class="line"># 启动容器</span><br><span class="line">$ docker run -d httpserver:1 /bin/sh -c &quot;while : ; do sleep 1000 ; done&quot;</span><br><span class="line">200222b438aac43bbe32a6c54e31ced0848482b9dec3e519d2f847c70c1ce801</span><br><span class="line"></span><br><span class="line"># 重启ntpd</span><br><span class="line">$ systemctl restart ntpd</span><br><span class="line"></span><br><span class="line">$ docker stop 200222b438aa</span><br><span class="line"></span><br><span class="line"># 此时容器的相关信息还存在</span><br><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                               COMMAND                  CREATED              STATUS                       PORTS               NAMES</span><br><span class="line">200222b438aa        httpserver:1    &quot;/bin/sh -c &#x27;while...&quot;   About a minute ago   Exited (137) 7 seconds ago                       hardcore_yalow</span><br><span class="line"></span><br><span class="line"># 强制删除容器失败</span><br><span class="line">$ docker rm -f 200222b438aa</span><br><span class="line">Error response from daemon: driver &quot;devicemapper&quot; failed to remove root filesystem for 200222b438aac43bbe32a6c54e31ced0848482b9dec3e519d2f847c70c1ce801: remove /var/lib/docker/devicemapper/mnt/e53342aa9cf5f43e73b6596f88939b8d3fdefaf1ca03ee95a24d867e1de6c522: device or resource busy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 此时容器处于Removal In Progress状态</span><br><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                               COMMAND                  CREATED             STATUS                PORTS               NAMES</span><br><span class="line">200222b438aa        httpserver:1    &quot;/bin/sh -c &#x27;while...&quot;   2 minutes ago       Removal In Progress                       hardcore_yalow</span><br><span class="line"></span><br><span class="line"># 再次重启ntpd进程</span><br><span class="line">$ systemctl restart ntpd</span><br><span class="line"></span><br><span class="line"># 强制删除成功</span><br><span class="line">$ docker rm 200222b438aa</span><br><span class="line">200222b438aa</span><br></pre></td></tr></table></figure>

<p>经在如下版本的CentOS7系统实验，该问题不存在。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ uname -a</span><br><span class="line">Linux localhost.localdomain 3.10.0-862.9.1.el7.x86_64 #1 SMP Mon Jul 16 16:29:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line">$ cat /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.5.1804 (Core)</span><br><span class="line"></span><br><span class="line">$ docker info | grep &quot;Storage Driver&quot;</span><br><span class="line">Storage Driver: overlay2</span><br></pre></td></tr></table></figure>

<h2 id="问题产生原因"><a href="#问题产生原因" class="headerlink" title="问题产生原因"></a>问题产生原因</h2><p>此问题为Systemd启用PrivateTmp选项后，导致mount namespace的一处内核bug。</p>
<h2 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h2><p>在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service的[Service]中增加<code>MountFlags=slave</code>，并重新启动docker服务，注意重启docker后，容器会重启。</p>
<p>当然也可以通过重启ntpd服务的方式来临时解决问题，但当下次删除容器时还需要重启ntpd。</p>
<p>还有一种办法是修改ntpd.service中的<code>PrivateTmp=true</code>，然后重启ntpd服务。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="http://blog.kissingwolf.com/2017/09/09/Docker-%E6%95%85%E9%9A%9C%EF%BC%88device-or-resource-busy%EF%BC%89/">Docker 故障（device or resource busy）</a></p>
]]></content>
  </entry>
  <entry>
    <title>修改eclipse主题</title>
    <url>/post/eclipse_theme/</url>
    <content><![CDATA[<p>Eclipse默认提供的主题过于刺眼，自己比较习惯黑色背景色。本文分享下修改Eclipse主题的步骤。我所使用的Eclipse版本为Kepler。相关的说明在插件的网站都有相关说明，本文不再赘述。安装完插件后的效果图如下：</p>
<p><img src="http://kuring.qiniudn.com/eclipse_theme.png" alt="我的Eclipse效果图"></p>
<h1 id="安装Eclipse-Color-Theme插件"><a href="#安装Eclipse-Color-Theme插件" class="headerlink" title="安装Eclipse Color Theme插件"></a>安装Eclipse Color Theme插件</h1><p>该插件仅会更新编辑栏中的背景颜色和字体颜色等信息，不会修改Eclipse的整体主题颜色。该插件网址为：<a href="https://github.com/eclipse-color-theme/eclipse-color-theme%E3%80%82">https://github.com/eclipse-color-theme/eclipse-color-theme。</a></p>
<h1 id="安装Eclipse-UI-Themes主题"><a href="#安装Eclipse-UI-Themes主题" class="headerlink" title="安装Eclipse UI Themes主题"></a>安装Eclipse UI Themes主题</h1><p>该插件会更新除编辑栏之外的其他Eclipse背景色等信息，其Github地址为：<a href="http://eclipsecolorthemes.org/%E3%80%82">http://eclipsecolorthemes.org/。</a></p>
<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p>为了方便使用，我这里备份了插件放在百度网盘共享，相关插件下载地址：<a href="http://pan.baidu.com/s/1eQnDI86">http://pan.baidu.com/s/1eQnDI86</a></p>
]]></content>
  </entry>
  <entry>
    <title>在Eclipse中安装viplugin插件</title>
    <url>/post/eclipse_viplugin/</url>
    <content><![CDATA[<p>从官方网站下载最新的viplugin插件：viPlugin_2.12.0。</p>
<p>将viPlugin_2.12.0.zip文件解压到eclipse安装目录下的dropins目录下。</p>
<p>该插件为收费插件，在eclipse安装的根目录下新建viPlugin2.lic文件，文件内容为:_q1MHdGlxh7nCyn_FpHaVazxTdn1tajjeIABlcgJBc20<br>_。</p>
<p>重启eclipse后即可生效。</p>
<p>官方参考文档地址：<a href="http://www.viplugin.com/files/User_Manual_viPlugin.pdf">http://www.viplugin.com/files/User_Manual_viPlugin.pdf</a></p>
<hr>
<p>相关下载：<a href="http://pan.baidu.com/s/1kT4uStT">viPlugin_2.12.0.zip</a></p>
]]></content>
  </entry>
  <entry>
    <title>ELK解析nginx日志</title>
    <url>/post/elk_nginx/</url>
    <content><![CDATA[<p>ELK解析nginx日志</p>
<p>最近使用ELK搭建了一个nginx的日志解析环境，中间遇到一些挫折，好不容易搭建完毕，有必要记录一下。</p>
<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><p>nginx配置文件中的日志配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">log_format  main  &#x27;$remote_addr [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">access_log /var/log/nginx/access.log  main;</span><br></pre></td></tr></table></figure>

<h1 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h1><p>由于是测试环境，我这里使用logstash读取nginx日志文件的方式来获取nginx的日志，并且仅读取了nginx的access log，对于error log没有关心。</p>
<p>使用的logstash版本为2.2.0，在log stash程序目录下创建conf文件夹，用于存放解析日志的配置文件，并在其中创建文件test.conf，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">        path =&gt; [&quot;/var/log/nginx/access.log&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">        match =&gt; &#123;</span><br><span class="line">            &quot;message&quot; =&gt; &quot;%&#123;IPORHOST:clientip&#125; \[%&#123;HTTPDATE:time&#125;\] \&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\&quot; %&#123;NUMBER:http_status_code&#125; %&#123;NUMBER:bytes&#125; \&quot;(?&lt;http_referer&gt;\S+)\&quot; \&quot;(?&lt;http_user_agent&gt;\S+)\&quot; \&quot;(?&lt;http_x_forwarded_for&gt;\S+)\&quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;10.103.17.4:9200&quot;]</span><br><span class="line">        index =&gt; &quot;logstash-nginx-test-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">        workers =&gt; 1</span><br><span class="line">        flush_size =&gt; 1</span><br><span class="line">        idle_flush_time =&gt; 1</span><br><span class="line">        template_overwrite =&gt; true</span><br><span class="line">    &#125;</span><br><span class="line">    stdout&#123;codec =&gt; rubydebug&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>需要说明的是，filter字段中的grok部分，由于nginx的日志是格式化的，logstash解析日志的思路为通过正则表达式来匹配日志，并将字段保存到相应的变量中。logstash中使用grok插件来解析日志，grok中message部分为对应的grok语法，并不完全等价于正则表达式的语法，在其中增加了变量信息。</p>
<p>具体grok语法不作过多介绍，可以通过logstash的官方文档中来了解。但grok语法中的变量类型如IPORHOST并未找到具体的文档，只能通过在logstash的安装目录下通过<code>grep -nr &quot;IPORHOST&quot; .</code>来搜索具体的含义。</p>
<p>配置文件中的stdout部分用于打印grok解析结果的信息，在调试阶段一定要打开。</p>
<p>可以通过<a href="http://grokconstructor.appspot.com/do/match">这里</a>来验证grok表达式的语法是否正确，编写grok表达式的时候可以在这里编写和测试。</p>
<p>对于elasticsearch部分不做过多介绍，网上容易找到资料。</p>
<h1 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h1><p>kibana不做过多介绍，使用可以查看官方文档和自己摸索。</p>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-grok.html">logstash中的grok插件介绍</a></p>
]]></content>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title>farbox与jekyll对比</title>
    <url>/post/farbox%E4%B8%8Ejekyll%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>前端时间折腾了一段时间的Github博客，终于搞明白了jekyll，开始写了一篇博客发现问题比较多。比如中文编码问题，Github对makedown的支持问题，Github的文章同步问题，网速问题。总体而言，感觉用Github来写博客还不是非常满意。</p>
<p>今天下午偶然想起了前段时间看过faxbox的一篇文章，今天下载下来尝试，果然非常酷。优点如下：</p>
<ul>
<li>博客放在了Dropbox不会丢失。<del>当然没有Github酷，Github可以通过版本管理来查看历史版本。</del>貌似Dropbox本身有版本管理的功能。</li>
<li>写博客的方式简捷。Github的jekyll还需要利用rake命令来创建文章，这样才能保证文章的头部含有YAML标签。而faxbox直接编辑文本文件即可。</li>
<li>文本编辑器给力。可以通过实时预览功能查看makedown的解析情况，当然也可以通过在线的makedown编辑器<a href="http://benweet.github.io/stackedit/">stackedit</a>来编写makedown。</li>
<li>网速比Github快。测试一下感觉网速还比较快。</li>
<li>可以修改模板，fork模板的方式简捷更酷。</li>
<li>对中文的支持好。因为本来就是本土化的软件当然对中文全力支持。</li>
<li>代码语法高亮。测试了一下默认的模板支持语法高亮。</li>
<li>自带的模板更漂亮。自带的模版虽然不多，但是有说明是适合博客还是相册。</li>
<li>网站自带网站分析工具。可以通过简单的浏览网页就可以知道网站的访问情况，虽然farbox在访问量达到1W之后要收费，按照目前的价格，但是我个人觉得比较值，希望farbox能够一直坚持做下去。做的好我愿意付费。</li>
</ul>
<p>缺点：</p>
<ul>
<li><del>经过一下午的了解，暂时没有发现博客可以分类的功能，不过这个功能我暂时可以不需要。以后准备先写些博客在Github和Faxbox上同步更新，以便多比较比较这两种Geek的写博客方式。</del>后来发现是有文章分类功能的，具体操作为将文章放入不同的文件夹中，文件夹的名字即为分类的名字，这种方式比jekyll的YAML语法方式要好用。</li>
<li>感觉评论功能有点鸡肋。博客还没写完有事工作，准备续写时发现有人留言指正错误，想回复谢谢，发现无法直接回复。用多说代替之，方法为直接将多说的js脚本存入新建的comment_js.md文件中即可，非常简洁。</li>
<li>Linux下的用户不太方便。由于farbox软件仅有windows版和mac版，dropbox在linux有相应版本，在linux下的用户不能享受到farbox编辑工具带来的方便。相反在linux下结合git和vim来编写博客却比较方便。</li>
</ul>
<p>PS：<br>Github博客地址：<a href="kuring.github.com">kuring.github.com</a><br>Fixbox博客地址：<a href="kuring.github.com">kuring.faxbox.com</a></p>
]]></content>
  </entry>
  <entry>
    <title>firewalld</title>
    <url>/post/firewalld/</url>
    <content><![CDATA[<p>在RHEL7系统中，firewalld和iptabels两个防火墙的服务并存，firewalld通过调用iptables命令来实现，firewalld和iptables均用来维护系统的netfilter规则，底层实现为内核的netfilter模块。</p>
<p>firewalld为systemd项目的一部分，为python语言实现，跟iptables相比，使用上更加人性化，提供了更高层次的抽象，用户不用关心netfilter的链和表的概念。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/firewalld-structure.png"></p>
<p>最上层为用户界面层，提供了firewall-cmd和firewall-offline-cmd两个命令行工具，其中firewall-cmd为最主要的命令行工具。firewall-config为GUI工具。用户界面层通过firewalld提供的D-Bus接口进行通讯。</p>
<p>firewalld为daemon进程，其中zone、service、ipset等为firewalld抽象的概念。在接收到用户界面层的命令后，一方面需要将操作保存到本地文件，另外还需要调用更底层的如iptables、ipset、ebtables等命令来产生规则，最终在内核层的netfilter模块生效。</p>
<h2 id="firewalld的管理"><a href="#firewalld的管理" class="headerlink" title="firewalld的管理"></a>firewalld的管理</h2><p>在RHEL7系统下，firewalld作为systemd家族的一员会默认安装。其service文件定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /usr/lib/systemd/system/firewalld.service </span><br><span class="line">[Unit]</span><br><span class="line">Description=firewalld - dynamic firewall daemon</span><br><span class="line">Before=network-pre.target</span><br><span class="line">Wants=network-pre.target</span><br><span class="line">After=dbus.service</span><br><span class="line">After=polkit.service</span><br><span class="line">Conflicts=iptables.service ip6tables.service ebtables.service ipset.service</span><br><span class="line">Documentation=man:firewalld(1)</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=-/etc/sysconfig/firewalld</span><br><span class="line">ExecStart=/usr/sbin/firewalld --nofork --nopid $FIREWALLD_ARGS</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line"># supress to log debug and error output also to /var/log/messages</span><br><span class="line">StandardOutput=null</span><br><span class="line">StandardError=null</span><br><span class="line">Type=dbus</span><br><span class="line">BusName=org.fedoraproject.FirewallD1</span><br><span class="line">KillMode=mixed</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">Alias=dbus-org.fedoraproject.FirewallD1.service</span><br></pre></td></tr></table></figure>

<p>查看firewall-cmd的运行状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ firewall-cmd --state</span><br><span class="line">not running</span><br></pre></td></tr></table></figure>

<p>在安装完firewalld后，会在&#x2F;usr&#x2F;lib&#x2F;firewalld&#x2F;目录下产生默认的配置，该部分配置不可修改。同时会在&#x2F;etc&#x2F;firewalld目录下产生firewalld的配置，该部分配置会覆盖&#x2F;usr&#x2F;lib&#x2F;firewalld&#x2F;下的配置。&#x2F;etc&#x2F;firewalld目录下的文件内容如下，其中firewalld.conf文件为最主要的配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls </span><br><span class="line">firewalld.conf  helpers  icmptypes  ipsets  lockdown-whitelist.xml  services  zones</span><br></pre></td></tr></table></figure>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>firewalld抽象了zone、service、ipset、helper、icmptypes几个概念。</p>
<h3 id="zone"><a href="#zone" class="headerlink" title="zone"></a>zone</h3><p>firewalld 将网络按照安全等级划分了不同的zone，zone的定义位于&#x2F;usr&#x2F;lib&#x2F;firewalld&#x2F;zones&#x2F;目录下，文件格式为xml，包括了如下的zone。</p>
<ol>
<li>drop：只允许出向，任何入向的网络数据包被丢弃，不会回复icmp报文。</li>
<li>block：任何入向的网络数据包均会被拒绝，会回复icmp报文。</li>
<li>public：公共区域网络流量。不信任网络上的流量，选择接收入向的网络流量。</li>
<li>external：不信任网络上的流量，选择接收入向的网络流量。</li>
<li>DMZ：隔离区域，内网和外网增加的一层网络，起到缓冲作用。选择接收入向的网络连接。</li>
<li>work：办公网络，信任网络流量，选择接收入向的网络流量。</li>
<li>home：家庭网络，信任网络流量，选择接收入向的网络流量。</li>
<li>internal：内部网络，信任网络流量，选择接收入向的网络流量。</li>
<li>trusted：信任区域。所有网络连接可接受。</li>
</ol>
<p>firewalld的默认zone为public，zone目录下的public.xml的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;zone&gt;</span><br><span class="line">  &lt;short&gt;Public&lt;/short&gt;</span><br><span class="line">  &lt;description&gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt;</span><br><span class="line">  &lt;service name=&quot;ssh&quot;/&gt;</span><br><span class="line">  &lt;service name=&quot;dhcpv6-client&quot;/&gt;</span><br><span class="line">  &lt;service name=&quot;cockpit&quot;/&gt;</span><br><span class="line">&lt;/zone&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到Public zone关联了三个service对象 ssh、dhcpv6-client、cockpit。没有匹配到该zone的流量，默认情况下会被拒绝。</p>
<p>在配置文件&#x2F;etc&#x2F;firewalld&#x2F;firewalld.conf中，通过DefaultZone字段指定的默认zone为public。即如果开启了firewalld规则，那么默认仅会放行访问上述三个服务的流量。执行 iptables-save 命令实际上并为看到任何的iptables规则，说明firewalld是直接调用内核的netfilter来实现的。</p>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>service为firewalld对运行在宿主机上的进程的抽象，并在zone文件中跟zone进行绑定。比如ssh.xml的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;service&gt;</span><br><span class="line">  &lt;short&gt;SSH&lt;/short&gt;</span><br><span class="line">  &lt;description&gt;Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.&lt;/description&gt;</span><br><span class="line">  &lt;port protocol=&quot;tcp&quot; port=&quot;22&quot;/&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>

<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="向某个zone内增加端口号"><a href="#向某个zone内增加端口号" class="headerlink" title="向某个zone内增加端口号"></a>向某个zone内增加端口号</h3><p>执行 <code>firewall-cmd --permanent --zone=public --add-port=80/tcp</code> 即可向public zone内增加80端口号。同时可以在 &#x2F;etc&#x2F;firewalld&#x2F;zones&#x2F;public.xml 文件中看到新增加了80端口号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat public.xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;zone&gt;</span><br><span class="line">  &lt;short&gt;Public&lt;/short&gt;</span><br><span class="line">  &lt;description&gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt;</span><br><span class="line">  &lt;service name=&quot;ssh&quot;/&gt;</span><br><span class="line">  &lt;service name=&quot;dhcpv6-client&quot;/&gt;</span><br><span class="line">  &lt;service name=&quot;cockpit&quot;/&gt;</span><br><span class="line">  &lt;port port=&quot;80&quot; protocol=&quot;tcp&quot;/&gt;</span><br><span class="line">&lt;/zone&gt;</span><br></pre></td></tr></table></figure>

<p>参数 <code>--permanent</code> 为固化到文件中，如果不增加该参数重启firewalld进程后配置会失效。</p>
<h3 id="获取当前zone信息"><a href="#获取当前zone信息" class="headerlink" title="获取当前zone信息"></a>获取当前zone信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ firewall-cmd --get-active-zones</span><br><span class="line">public</span><br><span class="line">  interfaces: eth0</span><br></pre></td></tr></table></figure>

<p>每个网络设备可以属于不同的zone，可以根据网络设备名来查询所属的zone</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ firewall-cmd --get-zone-of-interface=eth0</span><br><span class="line">public</span><br></pre></td></tr></table></figure>

<h3 id="设置当前默认zone"><a href="#设置当前默认zone" class="headerlink" title="设置当前默认zone"></a>设置当前默认zone</h3><p>该命令会自动修改&#x2F;etc&#x2F;firewalld&#x2F;firewalld.conf配置文件中的DefaultZone字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ firewall-cmd --set-default-zone=trusted</span><br></pre></td></tr></table></figure>

<h3 id="查看当前配置规则"><a href="#查看当前配置规则" class="headerlink" title="查看当前配置规则"></a>查看当前配置规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ firewall-cmd --list-all</span><br><span class="line">public (active)</span><br><span class="line">  target: default</span><br><span class="line">  icmp-block-inversion: no</span><br><span class="line">  interfaces: eth0</span><br><span class="line">  sources: </span><br><span class="line">  services: cockpit dhcpv6-client ssh</span><br><span class="line">  ports: 80/tcp</span><br><span class="line">  protocols: </span><br><span class="line">  masquerade: no</span><br><span class="line">  forward-ports: </span><br><span class="line">  source-ports: </span><br><span class="line">  icmp-blocks: </span><br><span class="line">  rich rules: </span><br></pre></td></tr></table></figure>

<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://firewalld.org/">firewalld官方文档</a></li>
<li><a href="https://www.certdepot.net/rhel7-get-started-firewalld/">RHEL7: How to get started with Firewalld</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Flux（学习笔记）</title>
    <url>/post/flux/</url>
    <content><![CDATA[<h1 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h1><p>Flux为一款GitOPS的发布工具，应用信息全部放到git仓库中，一旦git仓库中应用信息有新的提交，Flux即可在k8s中发布新的部署。支持kustomize和helm chart形式的应用。目前该项目为CNCF的孵化项目。</p>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ol>
<li>已经存在k8s集群</li>
<li>可以获取到Github的个人token</li>
</ol>
<h2 id="安装flux-cli"><a href="#安装flux-cli" class="headerlink" title="安装flux cli"></a>安装flux cli</h2><p>执行如下命令安装flux cli</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">curl</span> <span class="string">-s</span> <span class="string">https://fluxcd.io/install.sh</span> <span class="string">|</span> <span class="string">sudo</span> <span class="string">bash</span></span><br></pre></td></tr></table></figure>
<p>将如下内容追到到文件~&#x2F;.bash_profile</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.</span> <span class="string">&lt;(flux</span> <span class="string">completion</span> <span class="string">bash)</span></span><br></pre></td></tr></table></figure>
<h2 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h2><p>bootstrap操作会在k8s集群中安装flux到flux-system下，并且会通过git的方式来管理其自身。这里直接采用github，首先要获取到token，并设置为环境变量。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">export</span> <span class="string">GITHUB_TOKEN=xxx</span></span><br></pre></td></tr></table></figure>
<p>并执行如下命令开始bootstrap</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">flux</span> <span class="string">bootstrap</span> <span class="string">github</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--owner=kuring</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--repository=flux-learn</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--path=clusters/my-cluster</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--personal</span></span><br></pre></td></tr></table></figure>
<p>会自动创建github repo，并且会在main分支的clusters&#x2F;my-cluster&#x2F;flux-system下创建三个文件：</p>
<ul>
<li>gotk-components.yaml：flux的组件yaml</li>
<li>gotk-sync.yaml</li>
<li>kustomization.yaml：使用kustomization来个性化flux组件</li>
</ul>
<p>会安装如下组件到k8s中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">k</span> <span class="string">get</span> <span class="string">deployment</span> <span class="string">-n</span> <span class="string">flux-system</span> </span><br><span class="line"><span class="string">NAME</span>                      <span class="string">READY</span>   <span class="string">UP-TO-DATE</span>   <span class="string">AVAILABLE</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">helm-controller</span>           <span class="number">1</span><span class="string">/1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="string">27m</span></span><br><span class="line"><span class="string">kustomize-controller</span>      <span class="number">1</span><span class="string">/1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="string">27m</span></span><br><span class="line"><span class="string">notification-controller</span>   <span class="number">1</span><span class="string">/1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="string">27m</span></span><br><span class="line"><span class="string">source-controller</span>         <span class="number">1</span><span class="string">/1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="string">27m</span></span><br></pre></td></tr></table></figure>
<p>也可以使用更简单的方式<code>flux install</code>来安装flux，该命令不会将flux的安装信息存放到git仓库中，而是会直接安装。</p>
<h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><p>将上述的github项目copy到本地，需要特别注意的是github不允许使用密码来认证，需要在输入密码的地方输入token。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/kuring/flux-learn</span></span><br><span class="line"><span class="string">cd</span> <span class="string">fleet-infra</span></span><br></pre></td></tr></table></figure>
<p>使用如下命令在git仓库中创建podinfo-source.yaml文件和kustomization文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">flux</span> <span class="string">create</span> <span class="string">source</span> <span class="string">git</span> <span class="string">podinfo</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--url=https://github.com/stefanprodan/podinfo</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--branch=master</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--interval=30s</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--export</span> <span class="string">&gt;</span> <span class="string">./clusters/my-cluster/podinfo-source.yaml</span></span><br><span class="line">  </span><br><span class="line"><span class="string">flux</span> <span class="string">create</span> <span class="string">kustomization</span> <span class="string">podinfo</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--target-namespace=default</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--source=podinfo</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--path=&quot;./kustomize&quot;</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--prune=true</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--interval=5m</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--export</span> <span class="string">&gt;</span> <span class="string">./clusters/my-cluster/podinfo-kustomization.yaml</span></span><br></pre></td></tr></table></figure>
<p>podinfo-source.yaml文件内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">source.toolkit.fluxcd.io/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">GitRepository</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">podinfo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">  <span class="attr">ref:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://github.com/stefanprodan/podinfo</span></span><br></pre></td></tr></table></figure>
<p>podinfo-kustomization.yaml文件内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kustomize.toolkit.fluxcd.io/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Kustomization</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">podinfo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">5m0s</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">./kustomize</span></span><br><span class="line">  <span class="attr">prune:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sourceRef:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">GitRepository</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">podinfo</span></span><br><span class="line">  <span class="attr">targetNamespace:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>
<p>执行如下命令将文件提供到git仓库</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">git</span> <span class="string">add</span> <span class="string">-A</span> <span class="string">&amp;&amp;</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&quot;Add podinfo GitRepository&quot;</span></span><br><span class="line"><span class="string">git</span> <span class="string">push</span></span><br></pre></td></tr></table></figure>
<p>查看podinfo的部署状态，说明已经自动部署成功。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">flux</span> <span class="string">get</span> <span class="string">kustomizations</span> <span class="string">--watch</span></span><br><span class="line"><span class="string">NAME</span>    <span class="string">REVISION</span>        <span class="string">SUSPENDED</span>       <span class="string">READY</span>   <span class="string">MESSAGE</span>                          </span><br><span class="line"><span class="attr">podinfo master/bf09377  False           True    Applied revision:</span> <span class="string">master/bf09377</span></span><br><span class="line"><span class="attr">flux-system     main/81f2115    False   True    Applied revision:</span> <span class="string">main/81f2115</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改podinfo-kustomization.yaml文件内容如下，并重新提交到git仓库</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kustomize.toolkit.fluxcd.io/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Kustomization</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">podinfo</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">flux-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">interval:</span> <span class="string">5m0s</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">./kustomize</span></span><br><span class="line">  <span class="attr">prune:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">sourceRef:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">GitRepository</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">podinfo</span></span><br><span class="line">  <span class="attr">targetNamespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">patches:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">patch:</span> <span class="string">|-</span></span><br><span class="line"><span class="string">        apiVersion: autoscaling/v2beta2</span></span><br><span class="line"><span class="string">        kind: HorizontalPodAutoscaler</span></span><br><span class="line"><span class="string">        metadata:</span></span><br><span class="line"><span class="string">          name: podinfo</span></span><br><span class="line"><span class="string">        spec:</span></span><br><span class="line"><span class="string">          minReplicas: 3             </span></span><br><span class="line"><span class="string"></span>      <span class="attr">target:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">podinfo</span></span><br><span class="line">        <span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br></pre></td></tr></table></figure>
<p>过会可以看到环境中的hpa最小副本数已经变更为3.</p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul>
<li><a href="https://fluxcd.io/">https://fluxcd.io/</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>一个傻×对股市的吐槽</title>
    <url>/post/foolish_talk_stock/</url>
    <content><![CDATA[<p><img src="/ref/life/foolish_talk_stock.jpg" alt="Image Title"></p>
<p>这是来自一个保守主义者的geeker的傻X的吐槽。</p>
<p>最近股市暴跌，我却在思考为何有股票这个东西。我从未入市且对股市一点兴趣都没有甚至是反感。我所认识的股市游戏规则就是价位低的时候大股东入市，价位高的时候大股东抛售，大股东一吐一吞钱到手了，股民被掏空了。很多股民却用侥幸心理来入市，有赔有赚，出市的时候裤子都赔进去了。</p>
<p>搞不懂那么多经济学专家、博士、硕士、学士，却搞不定一个经济学。若是真搞不懂，索性就不要去研究，反正学了也白学，浪费这个资源误人歧途干啥。一个砖家说熊，另一个砖家说牛，相互对掐有意思吗？</p>
<p>为什么搞股市这个东西，这是嫌经济学不够复杂吗？股市难道能推动人类社会的进步？股市是企业融资的一种手段，而能上市的公司往往是相对不太缺钱的，而最缺钱的是小型创业公司。这也就早就了很多公司把上市套现作为了一个目标，这不明摆着投机取巧，一夜暴富。传销是集合了底层的力量资金而构成了金字塔，企业通过上市手段获取到了股民的资本来运作而发展自身，只不过金字塔只有两层罢了。</p>
<p>假如没有股市，很多上班族就会坐在办公桌上安心工作，而不用时时刻刻关心着像过山车一样的死难看的折线，也不用设个老板键提心吊胆的担心自己的boss悄悄走到自己的面前。难道安安心心全身心投入工作不是更好？</p>
<p>假如没有股市，或许就少了一个行业，一部分人就可以全身心投入到其他行业，带动其他行业的发展，推动历史进步，岂不快哉！</p>
<p>假如没有股市，就不会有人赚发了之后，别人也总想着不劳而获，间接助长了人们投机取巧的气焰。</p>
<p>假如没有股市，就不会因此而发家，当然这是少数。郭美美的母亲也不会用4万块钱赚到100万，也不会有郭美美的今天，也不会有红十字会的今天，当然这只是个笑话。没有股市郭照样可以炫富，因为人家本来就不是靠的股市。没有股市红十字会照样会没落，因为他们的本质就是那样。</p>
<p>假如没有股市，就不会有人因为股市而跳楼的新闻，就不会有人将养老钱都搭进去了，就不会…</p>
<p>请不要职责我，因为我是一个傻X，永远不要和傻子讲道理，否则你也会变成一个傻X！</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>根据pid获取到pod名称</title>
    <url>/post/get_pod_by_pid/</url>
    <content><![CDATA[<p>在k8s的运维过程中，经常会有根据pid获取到pod名称的需求。比如某个pid占用cpu特别高，想知道是哪个pod里面的进程。</p>
<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>查看进程的cgroup信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /proc/5760/cgroup </span><br><span class="line">11:rdma:/</span><br><span class="line">10:hugetlb:/apsara_k8s/kubepods/burstable/podf87c35b4-c170-4e1c-a726-d839e2fe6bea/17e15f78a43b2ddc7caff93bcc03d5ca7f5249fbee4c2ade5c3c96a7279af0a3</span><br><span class="line">9:freezer:/apsara_k8s/kubepods/burstable/podf87c35b4-c170-4e1c-a726-d839e2fe6bea/17e15f78a43b2ddc7caff93bcc03d5ca7f5249fbee4c2ade5c3c96a7279af0a3</span><br><span class="line">8:pids:/apsara_k8s/kubepods/burstable/podf87c35b4-c170-4e1c-a726-d839e2fe6bea/17e15f78a43b2ddc7caff93bcc03d5ca7f5249fbee4c2ade5c3c96a7279af0a3</span><br><span class="line">7:perf_event:/apsara_k8s/kubepods/burstable/podf87c35b4-c170-4e1c-a726-d839e2fe6bea/17e15f78a43b2ddc7caff93bcc03d5ca7f5249fbee4c2ade5c3c96a7279af0a3</span><br><span class="line">6:blkio:/apsara_k8s/kubepods/burstable/podf87c35b4-c170-4e1c-a726-d839e2fe6bea/17e15f78a43b2ddc7caff93bcc03d5ca7f5249fbee4c2ade5c3c96a7279af0a3</span><br><span class="line">5:devices:/apsara_k8s/kubepods/burstable/podf87c35b4-c170-4e1c-a726-d839e2fe6bea/17e15f78a43b2ddc7caff93bcc03d5ca7f5249fbee4c2ade5c3c96a7279af0a3</span><br><span class="line">4:memory:/apsara_k8s/kubepods/burstable/podf87c35b4-c170-4e1c-a726-d839e2fe6bea/17e15f78a43b2ddc7caff93bcc03d5ca7f5249fbee4c2ade5c3c96a7279af0a3</span><br><span class="line">3:cpuset,cpu,cpuacct:/apsara_k8s/kubepods/burstable/podf87c35b4-c170-4e1c-a726-d839e2fe6bea/17e15f78a43b2ddc7caff93bcc03d5ca7f5249fbee4c2ade5c3c96a7279af0a3</span><br><span class="line">2:net_cls,net_prio:/apsara_k8s/kubepods/burstable/podf87c35b4-c170-4e1c-a726-d839e2fe6bea/17e15f78a43b2ddc7caff93bcc03d5ca7f5249fbee4c2ade5c3c96a7279af0a3</span><br><span class="line">1:name=systemd:/apsara_k8s/kubepods/burstable/podf87c35b4-c170-4e1c-a726-d839e2fe6bea/17e15f78a43b2ddc7caff93bcc03d5ca7f5249fbee4c2ade5c3c96a7279af0a3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中的 <code>17e15f78a43b2ddc7caff93bcc03d5ca7f5249fbee4c2ade5c3c96a7279af0a3</code> 即为容器的id，可以如下的命令直接获取到容器的pid</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CID=$(cat /proc/5760/cgroup | awk -F &#x27;/&#x27; &#x27;&#123;print $6&#125;&#x27;)</span><br><span class="line">echo $&#123;CID:0:8&#125;</span><br></pre></td></tr></table></figure>

<p>继续执行如下命令查看docker的label</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker  inspect 17e15f --format &quot;&#123;&#123;json .Config.Labels&#125;&#125;&quot; </span><br></pre></td></tr></table></figure>

<p>其中io.kubernetes.pod.namespace为pod所在的namespace，io.kubernetes.pod.name为pod的name。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://icloudnative.io/posts/find-kubernetes-pod-info-from-process-id/">Kubernetes 教程：根据 PID 获取 Pod 名称</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Github Kubernetes SIGs组织下的项目（持续更新）</title>
    <url>/post/github-kubernetes-sigs-projects/</url>
    <content><![CDATA[<h1 id="apiserver-builder-alpha"><a href="#apiserver-builder-alpha" class="headerlink" title="apiserver-builder-alpha"></a><a href="https://github.com/kubernetes-sigs/apiserver-builder-alpha">apiserver-builder-alpha</a></h1><p>k8s提供了aggregated apiserver的方式来扩容api，该项目提供了代码生成器、基础library来供开发AA使用。</p>
<p>该项目的定位跟kubebuilder比较类似，kubebuilder用来生成CRD的框架，该项目用来生成AA的框架。</p>
<p>相关资料：</p>
<ul>
<li>[Set up an Extension API Server](Set up an Extension API Server)</li>
</ul>
<h1 id="cluster-api-provider-nested"><a href="#cluster-api-provider-nested" class="headerlink" title="cluster-api-provider-nested"></a><a href="https://github.com/kubernetes-sigs/cluster-api-provider-nested/tree/main/virtualcluster?spm=a2c4g.11186623.0.0.23054a15YVTwkg">cluster-api-provider-nested</a></h1><p>在同一个k8s集群内提供多租户的特性，每个租户具有独立的api-server、controller-manager和scheduler。</p>
<h1 id="cluster-proportional-autoscaler"><a href="#cluster-proportional-autoscaler" class="headerlink" title="cluster-proportional-autoscaler"></a><a href="https://github.com/kubernetes-sigs/cluster-proportional-autoscaler">cluster-proportional-autoscaler</a></h1><p>k8s默认提供了hpa机制，可以根据pod的负载情况来对workload进行自动的扩缩容。同时以单独的autoscaler项目提供了vpa功能的支持。</p>
<p>该项目提供提供了类似pod水平扩容的机制，跟hpa不同的是，pod的数量由集群中的节点规模来自动扩缩容pod。特别适合负载跟集群规模的变化成正比的服务，比如coredns、nginx ingress等服务。</p>
<p>hpa功能k8s提供了CRD来作为hpa的配置，本项目没有单独的CRD来定义配置，而是通过在启动的时候指定参数，或者配置放到ConfigMap的方式。而且一个cluster-proportional-autoscaler实例仅能针对一个workload。</p>
<h1 id="kube-batch"><a href="#kube-batch" class="headerlink" title="kube-batch"></a><a href="https://github.com/kubernetes-sigs/kube-batch">kube-batch</a></h1><p>k8s的调度器扩展，实现了Gang Scheduling特性（一组pod必须同时被调度成功，或者处于pending状态），适用于批处理系统。</p>
<p>由于该组件是以单独调度器的形式存在，会跟k8s默认的kube-scheduler并存，因为两个调度器之间并不能相互感知，在两个调度器并存的情况下会存在一定的冲突。</p>
<h1 id="prometheus-adapter"><a href="#prometheus-adapter" class="headerlink" title="prometheus-adapter"></a><a href="https://github.com/kubernetes-sigs/prometheus-adapter">prometheus-adapter</a></h1><p>k8s要实现hpa（水平自动扩容）的功能，需要监控指标。k8s的监控指标分为核心指标和自定义指标两大类。其中核心指标由metrics-server组件从kubelet、cadvisor等组件来获取，并通过aggregated apiserver的形式暴露给k8s，aggregated api的group信息为metrics.k8s.io。</p>
<p>自定义监控指标则由group custom.metrics.k8s.io对通过aggregated api暴露。本项目即为自定义监控指标的aggregated apiserver的实现。</p>
<p>相关参考：<a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics">Horizontal Pod Autoscaling</a></p>
<h1 id="scheduler-plugins"><a href="#scheduler-plugins" class="headerlink" title="scheduler-plugins"></a><a href="https://github.com/kubernetes-sigs/scheduler-plugins">scheduler-plugins</a></h1><p>k8s从1.16版本开始提供了新的调度框架Kubernetes Schduling Framework机制，用户可以基于此项目来开发自己的插件。该项目可以直接构建出kube-scheduler的新镜像。</p>
<p>相关参考：<a href="https://developer.aliyun.com/article/766273">进击的Kubernetes调度系统（一）：Scheduling Framework</a></p>
<h1 id="sig-storage-local-static-provisioner"><a href="#sig-storage-local-static-provisioner" class="headerlink" title="sig-storage-local-static-provisioner"></a><a href="https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner">sig-storage-local-static-provisioner</a></h1><p>k8s提供了local pv功能可以用来给pod挂载本地的数据盘，具体的local pv的定义如下所示，pv中包含了要亲和的节点信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: example-pv</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 100Gi</span><br><span class="line">  volumeMode: Filesystem</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce</span><br><span class="line">  persistentVolumeReclaimPolicy: Delete</span><br><span class="line">  storageClassName: local-storage</span><br><span class="line">  local:</span><br><span class="line">    path: /mnt/disks/ssd1</span><br><span class="line">  nodeAffinity:</span><br><span class="line">    required:</span><br><span class="line">      nodeSelectorTerms:</span><br><span class="line">      - matchExpressions:</span><br><span class="line">        - key: kubernetes.io/hostname</span><br><span class="line">          operator: In</span><br><span class="line">          values:</span><br><span class="line">          - example-node</span><br></pre></td></tr></table></figure>

<p>但要使用local pv功能，必须要事先创建出pv才可以，k8s本身并没有提供动态创建pv的功能。</p>
<p>该工具可以根据配置的规则，自动将机器上符合条件的磁盘创建出local pv以供后续创建出的pod使用。</p>
<p>另外，Rancher提供了一个类似的项目，<a href="https://github.com/rancher/local-path-provisioner">local-path-provisioner</a>，该项目已经被拉起k8s开发环境的开源项目kind使用。</p>
<p>相关参考：<a href="https://help.aliyun.com/document_detail/178475.html">LocalVolume数据卷</a></p>
]]></content>
  </entry>
  <entry>
    <title>在github上同步fork的项目</title>
    <url>/post/github_fork_sync/</url>
    <content><![CDATA[<p>在github上可以fork别人的项目成为自己的项目，但是当fork的项目更新后自己fork的项目应该怎么怎么更新呢？我从网上看到了两种方式，一种是采用github的web界面中的操作来实现，具体是通过“Pull Request”功能来实现；另外一种是通过在本地合并代码分支的方式来解决。本文将采用第二种方式，以我最近fork的项目为例来说明。</p>
<h1 id="将fork后自己的项目clone到本地"><a href="#将fork后自己的项目clone到本地" class="headerlink" title="将fork后自己的项目clone到本地"></a>将fork后自己的项目clone到本地</h1><p>执行<code>git clone https://github.com/kuring/leetcode.git</code>即可将自己fork的代码更新到本地。</p>
<p>fork完成后的远程分支和所有分支情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kuring@T420:/data/git/leetcode$ git remote -v</span><br><span class="line">origin	https://github.com/kuring/leetcode.git (fetch)</span><br><span class="line">origin	https://github.com/kuring/leetcode.git (push)</span><br><span class="line">kuring@T420:/data/git/leetcode$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>

<h1 id="将fork之前的项目clone到本地"><a href="#将fork之前的项目clone到本地" class="headerlink" title="将fork之前的项目clone到本地"></a>将fork之前的项目clone到本地</h1><p>将fork之前的项目添加到本地的远程分支haoel中，执行<code>git remote add haoel https://github.com/haoel/leetcode</code>。</p>
<p>再查看一下远程分支和所有分支情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kuring@T420:/data/git/leetcode$ git remote -v</span><br><span class="line">haoel	https://github.com/haoel/leetcode (fetch)</span><br><span class="line">haoel	https://github.com/haoel/leetcode (push)</span><br><span class="line">origin	https://github.com/kuring/leetcode.git (fetch)</span><br><span class="line">origin	https://github.com/kuring/leetcode.git (push)</span><br><span class="line">kuring@T420:/data/git/leetcode$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>

<h1 id="将远程代码halel分支fetch到本地"><a href="#将远程代码halel分支fetch到本地" class="headerlink" title="将远程代码halel分支fetch到本地"></a>将远程代码halel分支fetch到本地</h1><p>执行<code>git fetch haoel</code>，此时的所有分支情况如下，可以看出多了一个remotes&#x2F;haoel&#x2F;master分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kuring@T420:/data/git/leetcode$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/haoel/master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>

<h1 id="将halel分支merge到本地的分支"><a href="#将halel分支merge到本地的分支" class="headerlink" title="将halel分支merge到本地的分支"></a>将halel分支merge到本地的分支</h1><p>执行<code>git merge remotes/haoel/master</code>，此时发现有冲突，提示内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uring@T420:/data/git/leetcode$ git merge haoel/master</span><br><span class="line">自动合并 src/reverseInteger/reverseInteger.cpp</span><br><span class="line">冲突（内容）：合并冲突于 src/reverseInteger/reverseInteger.cpp</span><br><span class="line">自动合并失败，修正冲突然后提交修正的结果。</span><br></pre></td></tr></table></figure>

<p>之所以出现上述错误，这是由于我在fork之后在本地修正了源代码中的一处bug，而在fork之后到现在的时间间隔内原作者haoel也正好修正了该bug。打开文件后发现存在如下的内容，其实就是代码风格的问题，我这里将错误进行修正。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">36 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD                                                                                                                                                                </span><br><span class="line">37     while( x != 0 )&#123;</span><br><span class="line">38 =======</span><br><span class="line">39     while( x != 0)&#123;</span><br><span class="line">40 &gt;&gt;&gt;&gt;&gt;&gt;&gt; haoel/master</span><br></pre></td></tr></table></figure>

<p>如果没有冲突的情况下通过merge命令即会将haoel&#x2F;master分支合并master分支并执行commit操作。可以通过<code>git status</code>命令看到当前冲突的文件和已经修改的文件。执行<code>git status</code>命令可以看到如下内容，说明未冲突的文件已经在暂存区，冲突的文件需要修改后执行add操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kuring@T420:/data/git/leetcode$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">您的分支与上游分支 &#x27;origin/master&#x27; 一致。</span><br><span class="line"></span><br><span class="line">您有尚未合并的路径。</span><br><span class="line">  （解决冲突并运行 &quot;git commit&quot;）</span><br><span class="line"></span><br><span class="line">要提交的变更：</span><br><span class="line"></span><br><span class="line">	修改:         src/3Sum/3Sum.cpp</span><br><span class="line">	修改:         src/4Sum/4Sum.cpp</span><br><span class="line">	修改:         src/LRUCache/LRUCache.cpp</span><br><span class="line">	......	// 此处省略了很多重复的</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">未合并的路径：</span><br><span class="line">  （使用 &quot;git add &lt;file&gt;...&quot; 标记解决方案）</span><br><span class="line"></span><br><span class="line">	双方修改：     src/reverseInteger/reverseInteger.cpp</span><br></pre></td></tr></table></figure>

<p>解决完冲突后执行add操作后再通过<code>git status</code>命令查看的内容如下。通过<code>git status</code>命令却看不到已经解决的冲突文件，对于这一点我还是很理解，参考文章中的<a href="http://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6">Git 分支 - 分支的新建与合并</a>是可以看到已经解决的冲突文件的，因为执行<code>git add</code>后将解决完成冲突的文件放到了暂存区中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kuring@T420:/data/git/leetcode$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">您的分支与上游分支 &#x27;origin/master&#x27; 一致。</span><br><span class="line"></span><br><span class="line">所有冲突已解决但您仍处于合并中。</span><br><span class="line">  （使用 &quot;git commit&quot; 结束合并）</span><br><span class="line"></span><br><span class="line">要提交的变更：</span><br><span class="line"></span><br><span class="line">	修改:         src/3Sum/3Sum.cpp</span><br><span class="line">	修改:         src/4Sum/4Sum.cpp</span><br><span class="line">	修改:         src/LRUCache/LRUCache.cpp</span><br><span class="line">	......	// 此处省略了很多重复的</span><br><span class="line">	......</span><br></pre></td></tr></table></figure>

<p>这里冲突后merge操作并没有执行commit操作，需要解决冲突后再手工执行commit操作，此时整个的同步操作就已经完成了。</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>如果隔一段时间后又需要同步项目了仅需要执行<code>git fetch haoel</code>命令以下的操作即可。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6">Git 分支 - 分支的新建与合并</a></li>
<li><a href="http://www.cnblogs.com/rubylouvre/archive/2013/01/24/2874694.html">如何在github上fork一个项目来贡献代码以及同步原作者的修改</a></li>
<li><a href="http://blog.csdn.net/do_it__/article/details/7836513">Github上更新自己fork的代码</a></li>
</ul>
<p>由于git命令较多，为了便于查阅增加一处git data transprot commands</p>
<p><img src="http://kuring.qiniudn.com/git_data_transport_commands.png" alt="Git图解"></p>
]]></content>
  </entry>
  <entry>
    <title>hexo添加gitment评论系统</title>
    <url>/post/gitment/</url>
    <content><![CDATA[<p>曾经使用多说和网易云评论作为博客的评论系统，不幸都相继倒闭后，博客就一直没有评论系统。虽博客的访问量可以忽略不计，但本着折腾和好奇的原则，还是折腾一下gitment。</p>
<h1 id="更新hexo-theme-next主题"><a href="#更新hexo-theme-next主题" class="headerlink" title="更新hexo-theme-next主题"></a>更新hexo-theme-next主题</h1><p>最新版本的next主题已经默认支持gitment，需要将next主题升级到最新版本。</p>
<p>我的hexo-theme-next使用单独的git项目进行管理，git地址为：<a href="https://github.com/kuring/hexo-theme-next%E3%80%82%E6%8E%A5%E4%B8%8B%E6%9D%A5%E9%9C%80%E8%A6%81%E5%B0%86fork%E5%87%BA%E6%9D%A5%E7%9A%84git%E9%A1%B9%E7%9B%AE%E8%B7%9Fnext%E7%9A%84git%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5%E3%80%82">https://github.com/kuring/hexo-theme-next。接下来需要将fork出来的git项目跟next的git项目进行同步。</a></p>
<ol>
<li><p>在本地创建名字为upstream的remote，指向地址为：<code>git remote add upstream https://github.com/theme-next/hexo-theme-next.git</code></p>
</li>
<li><p>拉取next项目到本地分支，本地的分支，执行<code>git fetch upstream</code></p>
</li>
<li><p>将upsteam&#x2F;master分支合并到master分支上</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line"># 由于修改了_config.yml文件，存在冲突，合并失败</span><br><span class="line">lvkai@osx:~/blog/kuring/themes/hexo-theme-next% git merge upstream/master                                                                                                128 ↵</span><br><span class="line">Removing source/css/_common/components/third-party/gentie.styl</span><br><span class="line">Removing layout/_third-party/comments/gentie.swig</span><br><span class="line">Auto-merging _config.yml</span><br><span class="line">CONFLICT (content): Merge conflict in _config.yml</span><br><span class="line">Removing README.en.md</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>解决冲突后提交并将master分支push到github仓库</li>
</ol>
<h1 id="注册gitment"><a href="#注册gitment" class="headerlink" title="注册gitment"></a>注册gitment</h1><p>前往：<a href="https://github.com/settings/profile">https://github.com/settings/profile</a></p>
<p>Developer settings -&gt; Register a new application</p>
<p>在界面中输入如下内容：</p>
<p><img src="/images/gitment-1.png" alt="image"></p>
<p>获取到Client ID和Client Secret.</p>
<h1 id="新建github-repo"><a href="#新建github-repo" class="headerlink" title="新建github repo"></a>新建github repo</h1><p>创建新的github项目：<a href="https://github.com/kuring/gitment-comments">https://github.com/kuring/gitment-comments</a></p>
<h1 id="在next主题中设置gitment"><a href="#在next主题中设置gitment" class="headerlink" title="在next主题中设置gitment"></a>在next主题中设置gitment</h1><p>next主题的配置文件为theme&#x2F;next&#x2F;_config.yml，修改其中的gitment设置如下，</p>
<ol>
<li>client_id为在github中注册所获取到的client id</li>
<li>client_secret为在github中注册所获取到的client secret</li>
<li>github_repo为上面新创建的github repo名称</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Gitment</span><br><span class="line"># Introduction: https://imsun.net/posts/gitment-introduction/</span><br><span class="line">gitment:</span><br><span class="line">  enable: true</span><br><span class="line">  mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span><br><span class="line">  count: true # Show comments count in post meta area</span><br><span class="line">  lazy: false # Comments lazy loading with a button</span><br><span class="line">  cleanly: false # Hide &#x27;Powered by ...&#x27; on footer, and more</span><br><span class="line">  language: # Force language, or auto switch by theme</span><br><span class="line">  github_user: kuring # MUST HAVE, Your Github ID</span><br><span class="line">  github_repo: gitment-comments # MUST HAVE, The repo you use to store Gitment comments</span><br><span class="line">  client_id: xxx # MUST HAVE, Github client id for the Gitment</span><br><span class="line">  client_secret: xxxx # EITHER this or proxy_gateway, Github access secret token for the Gitment</span><br><span class="line">  proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect</span><br><span class="line">  redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled</span><br></pre></td></tr></table></figure>

<p>执行<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code>重新生成页面并在本地运行，可以看到gitment组件已经可以显示了，但是提示<code>Error: Comments Not Initialized</code>错误，点击login，然后允许认证，即可消除该错误。</p>
<p>在界面上添加评论后，可以在github repo的issuse中看到，整个搭建完毕。</p>
]]></content>
  </entry>
  <entry>
    <title>go mod使用</title>
    <url>/post/go-mod/</url>
    <content><![CDATA[<p>go mod从1.11开始已经成为了go的默认包管理工具，本文记录go mod的一些使用经验。</p>
<p>要想使用go mod，需要将go升级到1.11或者更高版本。</p>
<p>在没有go mod之前，项目源码必须是放在GOPATH目录下的，有了go mod之后项目即可以放在GOPATH目录下，也可以放在非GOPATH的目录下，在GOPATH目录下在执行时需要指定环境变量<code>GO111MODULE=on</code>,具体的写法可以是<code>GO111MODULE=on go mod init</code></p>
<p>由于众所周知的原因，go的包相对还是比较难下载的，很多情况下还是需要vendor目录存在的，并将vendor目录中的包一并提交到代码库中。可以使用<code>go mod vendor</code>命令来完成，执行该命令后会将本地下载的包copy到vendor目录下。</p>
<h2 id="坑1-提示unknown-revision"><a href="#坑1-提示unknown-revision" class="headerlink" title="坑1 提示unknown revision"></a>坑1 提示unknown revision</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># GO111MODULE=on go get gitlab.aa-inc.com/bb@v2</span><br><span class="line">go: finding gitlab.aa-inc.com/bb v2</span><br><span class="line">go: finding gitlab.aa-inc.com v2</span><br><span class="line">go get gitlab.aa-inc.com/bb@v2: unknown revision v2</span><br></pre></td></tr></table></figure>

<p>在获取单个包的时候提示<code>unknown revision</code>错误，后发现是go get默认是使用的https协议，而不是git协议，而git仓库的https协议不支持导致的，解决办法为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global url.&quot;git@gitlab.aa-inc.com:&quot;.insteadOf &quot;https://gitlab.aa-inc.com/&quot;</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/65916369">Go 每日漫谈——Go Module 的一些坑</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Golang中的异常处理机制</title>
    <url>/post/golang-error/</url>
    <content><![CDATA[<p>异常处理分为error和defer和recover两类，其中error用来处理可预期的异常，recover用来处理意外的异常。</p>
<h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><p>支持多个返回值，可以将业务的返回值和错误的返回值分开，很多都会返回两个值。如果不使用error返回值，可以用_变量来忽略。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parseConfig returns a parsed configuration for an Azure cloudprovider config file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseConfig</span><span class="params">(configReader io.Reader)</span></span> (*Config, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> config Config</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> configReader == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;config, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	configContents, err := ioutil.ReadAll(configReader)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	err = yaml.Unmarshal(configContents, &amp;config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The resource group name may be in different cases from different Azure APIs, hence it is converted to lower here.</span></span><br><span class="line">	<span class="comment">// See more context at https://github.com/kubernetes/kubernetes/issues/71994.</span></span><br><span class="line">	config.ResourceGroup = strings.ToLower(config.ResourceGroup)</span><br><span class="line">	<span class="keyword">return</span> &amp;config, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br />error的几种使用方式：</p>
<table>
<thead>
<tr>
<th>使用error的方式</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>errors.New</td>
<td>简单静态字符串的错误，没有额外的信息</td>
<td>errors.New(“shell not specified”)</td>
</tr>
<tr>
<td><a href="https://golang.org/pkg/fmt/#Errorf">fmt.Errorf</a></td>
<td>用于格式化的错误字符串</td>
<td>fmt.Errorf(“failed to start kubernetes.io&#x2F;kube-apiserver-client-kubelet certificate controller: %v”, err)</td>
</tr>
<tr>
<td>实现Error()方法的自定义类型</td>
<td>客户段需要检测并处理该错误时使用该方式</td>
<td>见下文自定义error</td>
</tr>
<tr>
<td>Error wrapping</td>
<td>Go 1.13支持的特性</td>
<td></td>
</tr>
</tbody></table>
<h3 id="errors-New"><a href="#errors-New" class="headerlink" title="errors.New"></a>errors.New</h3><p>原则：</p>
<ul>
<li>不要在客户端判断error中的包含字符串信息。</li>
</ul>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errors.New(<span class="string">&quot;could not open&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">use</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err.Error() == <span class="string">&quot;could not open&quot;</span> &#123;</span><br><span class="line">      <span class="comment">// handle</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</td><td>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ErrCouldNotOpen = errors.New(<span class="string">&quot;could not open&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrCouldNotOpen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package bar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := foo.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> errors.Is(err, foo.ErrCouldNotOpen) &#123;</span><br><span class="line">    <span class="comment">// handle</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unknown error&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</td></tr>
</tbody></table>


<p>当然也可以使用自定义error类型，但此时由于要实现自定义error类型，代码量会增加。</p>
<h3 id="自定义error"><a href="#自定义error" class="headerlink" title="自定义error"></a>自定义error</h3><p>error是个接口，可以用来扩展自定义的错误处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: k8s.io/kubernetes/pkg/volume/util/nestedpendingoperations/nestedpendingoperations.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewAlreadyExistsError returns a new instance of AlreadyExists error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAlreadyExistsError</span><span class="params">(operationName <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> alreadyExistsError&#123;operationName&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsAlreadyExists returns true if an error returned from</span></span><br><span class="line"><span class="comment">// NestedPendingOperations indicates a new operation can not be started because</span></span><br><span class="line"><span class="comment">// an operation with the same operation name is already executing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsAlreadyExists</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> alreadyExistsError:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> alreadyExistsError <span class="keyword">struct</span> &#123;</span><br><span class="line">	operationName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ <span class="type">error</span> = alreadyExistsError&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(err alreadyExistsError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(</span><br><span class="line">		<span class="string">&quot;Failed to create operation with name %q. An operation with that name is already executing.&quot;</span>,</span><br><span class="line">		err.operationName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以延伸出更复杂一些的树形error体系：<br /></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package net</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">error</span></span><br><span class="line">    Timeout() <span class="type">bool</span>   <span class="comment">// Is the error a timeout?</span></span><br><span class="line">    Temporary() <span class="type">bool</span> <span class="comment">// Is the error temporary?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UnknownNetworkError <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e UnknownNetworkError)</span></span> Error() <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e UnknownNetworkError)</span></span> Temporary() <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e UnknownNetworkError)</span></span> Timeout() <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<h3 id="Error-Wrapping"><a href="#Error-Wrapping" class="headerlink" title="Error Wrapping"></a>Error Wrapping</h3><p>error类型仅包含一个字符串类型的信息，如果函数的调用栈信息为A -&gt; B -&gt; C，如果函数C返回err，在函数A处打印err信息，那么很难判断出err的真正出错位置，不利于快速定位问题。我们期望的效果是在函数A出打印err，能够精确的找到err的源头。<br /><br><br />为了解决上述问题，需要error类型在函数调用栈之间传递，有如下解决方法：</p>
<ul>
<li>使用fmt.Errorf()函数来增加额外的信息</li>
<li>使用Error Wrapping  <ul>
<li>golang 1.13支持%w</li>
<li><a href="https://github.com/pkg/errors">https://github.com/pkg/errors</a></li>
</ul>
</li>
</ul>
<p><br />使用fmt.Errorf()来封装error信息，基于已经存在的error再产生一个新的error类型，需要避免error中包含冗余信息。<br /></p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// err: failed to call api: connection refused</span></span><br><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">&quot;failed to create new store: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</td><td>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// err: call api: connection refused</span></span><br><span class="line">s, err := store.New()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(</span><br><span class="line">        <span class="string">&quot;new store: %s&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<tr><td>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">failed to create new store: failed to call api: connection refused</span><br><span class="line">error中会有很多的冗余信息</span><br></pre></td></tr></table></figure>
</td><td>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new store: call api: connection refused</span><br><span class="line">error中没有冗余信息，同时包含了调用栈信息</span><br></pre></td></tr></table></figure>
</td></tr>
</tbody></table>

<p>但使用fmt.Errorf()来全新封装的error信息的缺点也非常明显，丢失了最初的err信息，已经在中间转换为了全新的err。</p>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型转换如果类型不正确，会导致程序crash，必须使用类型判断来判断类型的正确性。<br /></p>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := i.(<span class="type">string</span>)</span><br></pre></td></tr></table></figure>
</td><td>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t, ok := i.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">  <span class="comment">// handle the error gracefully</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</td></tr>
</tbody></table>

<h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><p>用于处理运行时的异常情况。<br /><img src="https://intranetproxy.alipay.com/skylark/lark/0/2021/png/220839/1615386682235-b67733ca-036d-40d3-a895-c6b65a58f9d3.png#align=left&display=inline&height=563&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1060&originWidth=887&size=418096&status=done&style=none&width=471" alt="image.png"><br />使用原则</p>
<ul>
<li>不要使用panic，在kubernetes项目中几乎没有使用panic的场景</li>
<li>即使使用panic后，一定要使用recover会捕获异常</li>
<li>在测试用例中可以使用panic</li>
</ul>
<table>
<thead><tr><th>Bad</th><th>Good</th></tr></thead>
<tbody>
<tr><td>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;an argument is required&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  run(os.Args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</td><td>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;an argument is required&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := run(os.Args[<span class="number">1</span>:]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintln(os.Stderr, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</td></tr>
</tbody></table>

<h2 id="client-go"><a href="#client-go" class="headerlink" title="client-go"></a>client-go</h2><p>client-go利用队列来进行重试<br /><br><br /><a href="https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go#L93">https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go#L93</a></p>
<h2 id="kube-builder"><a href="#kube-builder" class="headerlink" title="kube-builder"></a>kube-builder</h2><p>kube-builder为client-go的更上次封装，本质上跟client-go利用队列来进行重试的机制完全一致。</p>
<h1 id="发生了错误后该如何处理"><a href="#发生了错误后该如何处理" class="headerlink" title="发生了错误后该如何处理"></a>发生了错误后该如何处理</h1><ul>
<li>打印错误日志</li>
<li>根据业务场景选择忽略或者自动重试</li>
<li>程序自己crash</li>
</ul>
<h1 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h1><ul>
<li>在编写代码时增加防御式编程意识，不能靠契约式编程。一个比较简单的判断错误处理情况的方法，看下代码中if语句占用的比例。<a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kubelet_volumes.go">https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kubelet_volumes.go</a></li>
<li>需求的评估周期中，不仅要考虑到软件开发完成的时间，同时要考虑到单元测试（单元测试用例的编写需要较长的时间）和集成测试的时间</li>
<li>单元测试覆盖率提升，测试场景要考虑到各种异常场景</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Golang GC</title>
    <url>/post/golang-gc/</url>
    <content><![CDATA[<h2 id="常用垃圾回收方法"><a href="#常用垃圾回收方法" class="headerlink" title="常用垃圾回收方法"></a>常用垃圾回收方法</h2><h3 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1.引用计数"></a>1.引用计数</h3><p>类似于C++中的智能指针，每个对象维护一个引用计数，当对象被销毁时引用计数减一，当引用计数为0时立即回收对象。</p>
<p>在PHP、Python中使用，适用于内存比较紧张和实时性比较高的系统。</p>
<p>缺点：</p>
<ol>
<li>由于频繁更新引用计数，降低了性能。</li>
<li>循环引用问题。解决办法为避免循环引用。</li>
</ol>
<h3 id="2-标记-mark-清除-sweep"><a href="#2-标记-mark-清除-sweep" class="headerlink" title="2.标记(mark)-清除(sweep)"></a>2.标记(mark)-清除(sweep)</h3><p>分为标记和清除两个阶段，算法在70年代就提出了，非常古老的算法。</p>
<p>该算法有一个标记初始的root区域，和一个受控堆区。root区域主要是程序当前的栈和全局数据区域。</p>
<p>从root区域开始遍历所有被引用的对象，所有被访问到的对象被标记为“被引用”，标记完成后对未被引用的对象进行内存回收。</p>
<p>缺点：</p>
<p>标记阶段，都会Stop The World，会大大降低性能。</p>
<h3 id="3-分代回收"><a href="#3-分代回收" class="headerlink" title="3.分代回收"></a>3.分代回收</h3><p>将堆划分为两个或者多个代空间，新创建的对象存放于新生代，随着垃圾回收的重复执行，生命周期较长的对象会被放到老年代中。新生代和老年代采用不同的垃圾回收策略。</p>
<h2 id="Go垃圾回收机制"><a href="#Go垃圾回收机制" class="headerlink" title="Go垃圾回收机制"></a>Go垃圾回收机制</h2><p>Go中采用三色标记算法，本质上还是标记清除算法，但是对标记阶段有改进。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/golang-gc.gif" alt="https://upload.wikimedia.org/wikipedia/commons/1/1d/Animation_of_tri-color_garbage_collection.gif"></p>
<p>步骤如下：</p>
<ol>
<li>开始时，所有的对象均为白色</li>
<li>从root开始扫描所有可达对象，标记为灰色，放入待处理队列。root包括了全局指针和goroutine栈上的指针。</li>
<li>从队列取出所有灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。</li>
<li>重复3，直到灰色队列为空。</li>
<li>将白色对象进行回收</li>
</ol>
<p>优点：用户程序和标记操作可以并行执行。</p>
<p>详细过程如下图：</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/golang-gc-2.png"></p>
<p>通过上图可以看出，STW有两个过程：</p>
<ol>
<li>gc开始的时候，需要一些准备工作，如开启write barrier</li>
<li>re-scan的过程</li>
</ol>
<p>每个对象需要一个标记位，go中并未将标记位存放于对象的内存区域中，而是采用非侵入式的标记位。go单独使用了标记位图区域来对应内存中的堆区域。</p>
<p>write barrier: 在运行垃圾回收算法的同时，应用程序在一直执行，上文中提到了写屏障write barrier用于将这些内存的操作记录下来。</p>
<h2 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h2><p>GC日志对于定位问题还是比较方便的</p>
<h3 id="1-开启GC日志"><a href="#1-开启GC日志" class="headerlink" title="1.开启GC日志"></a>1.开启GC日志</h3><p>可以增加环境变量<code>GODEBUG=gctrace=1</code>来开启gc日志，gc日志会打印到标准错误中。例如有如下的程序:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;time&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		s := make([]int, 10)</span><br><span class="line">		for i := 0; i &lt; 10000; i++ &#123;</span><br><span class="line">			s = append(s, i)</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(time.Nanosecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>GODEBUG=gctrace=1 go run gc.go</code>即可打印gc日志到标准错误中。</p>
<h2 id="2-GC日志的含义"><a href="#2-GC日志的含义" class="headerlink" title="2.GC日志的含义"></a>2.GC日志的含义</h2><p>可以参照<a href="https://godoc.org/runtime">runtime</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-&gt;#-&gt;# MB, # MB goal, # P</span><br><span class="line">where the fields are as follows:</span><br><span class="line">	gc #        the GC number, incremented at each GC</span><br><span class="line">	@#s         time in seconds since program start</span><br><span class="line">	#%          percentage of time spent in GC since program start</span><br><span class="line">	#+...+#     wall-clock/CPU times for the phases of the GC</span><br><span class="line">	#-&gt;#-&gt;# MB  heap size at GC start, at GC end, and live heap</span><br><span class="line">	# MB goal   goal heap size</span><br><span class="line">	# P         number of processors used</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<p>gc 11557 @179.565s 2%: 0.018+1.2+0.049 ms clock, 0.14+1.1&#x2F;2.3&#x2F;0.90+0.39 ms cpu, 13-&gt;14-&gt;7 MB, 14 MB goal, 8 P</p>
<h3 id="3-GC的监控"><a href="#3-GC的监控" class="headerlink" title="3.GC的监控"></a>3.GC的监控</h3><p>对于线上GC的监控，基本上读取runtime.MemStats结构中的内容，然后存储到时序数据库中。具体有如下两种获取方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 方式1</span><br><span class="line">memStats := &amp;runtime.MemStats&#123;&#125;</span><br><span class="line">runtime.ReadMemStats(memStats)</span><br><span class="line"></span><br><span class="line">// 方式2 json格式</span><br><span class="line">expvar.Get(&quot;memstats&quot;).String()</span><br></pre></td></tr></table></figure>

<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul>
<li><a href="https://blog.golang.org/ismmkeynote">Getting to Go: The Journey of Go’s Garbage Collector</a></li>
<li><a href="https://godoc.org/runtime">Go: runtime</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Golang面试题</title>
    <url>/post/golang-interview/</url>
    <content><![CDATA[<p>本文绝大多数题目来源于网络，部分题目为原创。</p>
<h2 id="slice相关"><a href="#slice相关" class="headerlink" title="slice相关"></a>slice相关</h2><h3 id="以下代码有什么问题，说明原因"><a href="#以下代码有什么问题，说明原因" class="headerlink" title="以下代码有什么问题，说明原因"></a>以下代码有什么问题，说明原因</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pase_student</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*student)</span><br><span class="line">	stus := []student&#123;</span><br><span class="line">		&#123;Name: <span class="string">&quot;zhou&quot;</span>, Age: <span class="number">24</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;li&quot;</span>, Age: <span class="number">23</span>&#125;,</span><br><span class="line">		&#123;Name: <span class="string">&quot;wang&quot;</span>, Age: <span class="number">22</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">		m[stu.Name] = &amp;stu</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次遍历的时候stu变量为值拷贝，stu变量的地址未改变，即&amp;stu未改变，遍历结束后stu指向stus中的最后一个元素。</p>
<p>使用<code>reflect.TypeOf(str)</code>打印出的类型为main.student，如果使用<code>stu.Age += 10</code>这样的语法是不会修改stus中的值的。</p>
<p>可修改为如下形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> stus &#123;</span><br><span class="line">    m[stus[i].Name] = &amp;stus[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有一个slice-of-object-遍历slice修改name为指定的值"><a href="#有一个slice-of-object-遍历slice修改name为指定的值" class="headerlink" title="有一个slice of object, 遍历slice修改name为指定的值"></a>有一个slice of object, 遍历slice修改name为指定的值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type foo struct &#123;</span><br><span class="line"> name string</span><br><span class="line"> value string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func mutate(s []foo, name string) &#123;</span><br><span class="line">// TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>意在考察range遍历的时候是值拷贝，以及slice的内部数据结构，slice的数据结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct    Slice</span><br><span class="line">&#123;    // must not move anything</span><br><span class="line">    byte*    array;        // actual data</span><br><span class="line">    uintgo    len;        // number of elements</span><br><span class="line">    uintgo    cap;        // allocated number of elements</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行append函数后会返回一个新的Slice对象，新的Slice对象跟旧Slice对象共用相同的数据存储，但是len的值并不相同。</p>
<p>该题目中，可以通过下面的方式来修改值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// range方式</span><br><span class="line">for i, _ := range s &#123;</span><br><span class="line">	s[i].name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// for i形式</span><br><span class="line">for i:=0; i&lt;len(s); i++ &#123;</span><br><span class="line">  s[i].name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从slice中找到一个元素匹配name，并将该元素的指针添加到一个新的slice中，返回新slice"><a href="#从slice中找到一个元素匹配name，并将该元素的指针添加到一个新的slice中，返回新slice" class="headerlink" title="从slice中找到一个元素匹配name，并将该元素的指针添加到一个新的slice中，返回新slice"></a>从slice中找到一个元素匹配name，并将该元素的指针添加到一个新的slice中，返回新slice</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func find(s []foo, name string) []*foo &#123;</span><br><span class="line">// TODO</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仍旧是考察range是值拷贝的用法，此处使用for i 循环即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func find(s []foo, name string) []*foo &#123;</span><br><span class="line">	res := []*foo&#123;&#125;</span><br><span class="line"></span><br><span class="line">	for i := 0; i &lt; len(s); i++ &#123;</span><br><span class="line">		if s[i].name == name &#123;</span><br><span class="line">			res = append(res, &amp;(s[i]))</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="下面输出什么内容"><a href="#下面输出什么内容" class="headerlink" title="下面输出什么内容"></a>下面输出什么内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func m(s []int) &#123;</span><br><span class="line">	s[0] = -1</span><br><span class="line">	s = append(s, 4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	s1 := []int&#123;1, 2, 3&#125;</span><br><span class="line">	m(s1)</span><br><span class="line">	s2 := make([]int, 3, 6)</span><br><span class="line">	m(s2)</span><br><span class="line">	s2 = append(s2, 7)</span><br><span class="line">	s3 := [3]int&#123;1, 2, 3&#125;</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	fmt.Println(s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slice的函数传递为值拷贝方式，在函数m中对下标为0的元素的修改会直接修改原slice中的值，因为slice中的指针指向的地址是相同的。</p>
<p>append之后的slice虽然可能是在原数组上增加了元素，但原slice中的len字段并没有变化。</p>
<p>make([]int, 3, 6)虽然指定了slice的cap，但对于append没有影响，还是会在slice中最后一个元素的下一个位置增加新元素。</p>
<p>数组由于是值拷贝，对新数组的修改不会影响到原数组。</p>
<p>输出内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[-1 2 3]</span><br><span class="line">[-1 0 0 7]</span><br><span class="line">[1 2 3]</span><br></pre></td></tr></table></figure>

<h3 id="下面输出什么内容-1"><a href="#下面输出什么内容-1" class="headerlink" title="下面输出什么内容"></a>下面输出什么内容</h3><p>该题目为我自己想出来的，非来自于互联网，意在考察对slice和append函数的理解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func f() &#123;</span><br><span class="line">	s1 := make([]int, 2, 8)</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	s2 := append(s1, 4)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	s3 := append(s1, 5)</span><br><span class="line">	fmt.Println(s3)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下，在执行第二个append后，第一个append在内存中增加的元素4会被5覆盖掉。执行结果可以通过<code>fmt.Println(s1, cap(s1), &amp;s1[0])</code>的形式将第一个元素的内存地址打印出来查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0 0 4]</span><br><span class="line">[0 0 5]</span><br><span class="line">[0 0 5]</span><br></pre></td></tr></table></figure>

<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><h3 id="以下代码输出内容："><a href="#以下代码输出内容：" class="headerlink" title="以下代码输出内容："></a>以下代码输出内容：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	runtime.GOMAXPROCS(1)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		fmt.Println(1)</span><br><span class="line">	&#125;()</span><br><span class="line">	for &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不会有任何输出</p>
<h2 id="下面输出的内容"><a href="#下面输出的内容" class="headerlink" title="下面输出的内容"></a>下面输出的内容</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span></span> ShowA() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;showA&quot;</span>)</span><br><span class="line">    p.ShowB()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span></span> ShowB() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;showB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">    People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Teacher)</span></span> ShowB() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;teacher showB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := Teacher&#123;&#125;</span><br><span class="line">    t.ShowA()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">showA</span><br><span class="line">showB</span><br></pre></td></tr></table></figure>

<p>有点出乎意料，可以举个反例，如果ShowA()方法会调用到Teacher类型的ShowB()方法，假设People和Teacher并不在同一个包中时，编译一定会出现错误。</p>
<p>Go中没有继承机制，只有组合机制。</p>
<h2 id="下面代码会触发异常吗？请详细说明"><a href="#下面代码会触发异常吗？请详细说明" class="headerlink" title="下面代码会触发异常吗？请详细说明"></a>下面代码会触发异常吗？请详细说明</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	runtime.GOMAXPROCS(1)</span><br><span class="line">	int_chan := make(chan int, 1)</span><br><span class="line">	string_chan := make(chan string, 1)</span><br><span class="line">	int_chan &lt;- 1</span><br><span class="line">	string_chan &lt;- &quot;hello&quot;</span><br><span class="line">	select &#123;</span><br><span class="line">	case value := &lt;-int_chan:</span><br><span class="line">		fmt.Println(value)</span><br><span class="line">	case value := &lt;-string_chan:</span><br><span class="line">		panic(value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会间歇性触发异常，select会随机选择。</p>
<h2 id="以下代码能编译过去吗？为什么？"><a href="#以下代码能编译过去吗？为什么？" class="headerlink" title="以下代码能编译过去吗？为什么？"></a>以下代码能编译过去吗？为什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type People interface &#123;</span><br><span class="line">	Speak(string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (stu *Student) Speak(think string) (talk string) &#123;</span><br><span class="line">	if think == &quot;bitch&quot; &#123;</span><br><span class="line">		talk = &quot;You are a good boy&quot;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		talk = &quot;hi&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var peo People = Student&#123;&#125;</span><br><span class="line">	think := &quot;bitch&quot;</span><br><span class="line">	fmt.Println(peo.Speak(think))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不能编译过去，提示<code>Stduent does not implement People (Speak method has pointer receiver)</code>，将Speak定义更改为<code>func (stu Stduent) Speak(think string) (talk string)</code>即可编译通过。</p>
<p>main的调用方式更改为如下也可以编译通过<code>var peo People = new(Stduent)</code>。</p>
<p><code>func (stu *Stduent) Speak(think string) (talk string)</code>是<code>*Student</code>类型的方法，不是<code>Stduent</code>类型的方法。</p>
<h2 id="下面输出什么"><a href="#下面输出什么" class="headerlink" title="下面输出什么"></a>下面输出什么</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">  &quot;fmt&quot;</span><br><span class="line">  &quot;time&quot;</span><br><span class="line">  &quot;runtime&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  runtime.GOMAXPROCS(1)</span><br><span class="line">  arr := [10000]int&#123;&#125;</span><br><span class="line">  for i:=0; i&lt;len(arr); i++ &#123;</span><br><span class="line">    arr[i] = i</span><br><span class="line">  &#125;</span><br><span class="line">  for _, a := range arr &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">      fmt.Println(a)</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">  for &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一直输出9999.涉及到goroutine的切换时机，仅系统调用或者有函数调用的情况下才会切换goroutine，for循环情况下一直没有系统调用或函数切换发生，需要等到for循环结束后才会启动新的goroutine。</p>
<h2 id="以下代码打印出来什么内容，说出为什么。。。"><a href="#以下代码打印出来什么内容，说出为什么。。。" class="headerlink" title="以下代码打印出来什么内容，说出为什么。。。"></a>以下代码打印出来什么内容，说出为什么。。。</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type People interface &#123;</span><br><span class="line">	Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (stu *Student) Show() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func live() People &#123;</span><br><span class="line">	var stu *Student</span><br><span class="line">	return stu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	if live() == nil &#123;</span><br><span class="line">		fmt.Println(&quot;AAAAAAA&quot;)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		fmt.Println(&quot;BBBBBBB&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印<code>BBBBBBB</code>。</p>
<h2 id="byte与rune的关系"><a href="#byte与rune的关系" class="headerlink" title="byte与rune的关系"></a>byte与rune的关系</h2><ul>
<li>byte alias for uint8</li>
<li>rune alias for uint32，用来表示unicode</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // range遍历为rune类型，输出int32</span><br><span class="line">    for _, w:=range &quot;123&quot; &#123;</span><br><span class="line">        fmt.Printf(&quot;%T&quot;, w)</span><br><span class="line">    &#125;</span><br><span class="line">    // 取数组为byte类型，输出uint8</span><br><span class="line">    fmt.Printf(&quot;%T&quot;, &quot;123&quot;[0])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写出打印的结果"><a href="#写出打印的结果" class="headerlink" title="写出打印的结果"></a>写出打印的结果</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	js := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">		&quot;name&quot;:&quot;11&quot;</span></span><br><span class="line"><span class="string">	&#125;`</span></span><br><span class="line">	<span class="keyword">var</span> p People</span><br><span class="line">	p.name = <span class="string">&quot;123&quot;</span></span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(js), &amp;p)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err: &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;people: &quot;</span>, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果为people:  {123}</p>
<h2 id="下面函数有什么问题？"><a href="#下面函数有什么问题？" class="headerlink" title="下面函数有什么问题？"></a>下面函数有什么问题？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func funcMui(x,y int)(sum int,error)&#123;</span><br><span class="line">    return x+y,nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数返回值命名 在函数有多个返回值时，只要有一个返回值有指定命名，其他的也必须有命名。 如果返回值有有多个返回值必须加上括号； 如果只有一个返回值并且有命名也需要加上括号； 此处函数第一个返回值有sum名称，第二个为命名，所以错误。</p>
<h2 id="以下函数输出什么"><a href="#以下函数输出什么" class="headerlink" title="以下函数输出什么"></a>以下函数输出什么</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	println(DeferFunc1(1))</span><br><span class="line">	println(DeferFunc2(1))</span><br><span class="line">	println(DeferFunc3(1))</span><br><span class="line">	println(DeferFunc4(1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DeferFunc1(i int) (t int) &#123;</span><br><span class="line">	t = i</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		t += 3</span><br><span class="line">	&#125;()</span><br><span class="line">	return t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DeferFunc2(i int) int &#123;</span><br><span class="line">	t := i</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		t += 3</span><br><span class="line">	&#125;()</span><br><span class="line">	return t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DeferFunc3(i int) (t int) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		t += i</span><br><span class="line">	&#125;()</span><br><span class="line">	return 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DeferFunc4(i int) (t int) &#123;</span><br><span class="line">	t = 10</span><br><span class="line">	return 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为: <code>4 1 3 2</code></p>
<p>return语句不是一个原子指令，分为两个阶段，执行return后面的表达式和返回表达式的结果。defer函数在返回表达式之前执行。</p>
<ol>
<li>执行return后的表达式给返回值赋值</li>
<li>调用defer函数</li>
<li>空的return</li>
</ol>
<p>DeferFunc1在第一步执行表达式后t&#x3D;1，执行defer后t&#x3D;4，返回值为4</p>
<p>DeferFunc2在第一步执行表达式后t&#x3D;1，执行defer后t&#x3D;4，返回值为第一步表达式的结果1</p>
<p>DeferFunc3在第一步表达式为t&#x3D;2，执行defer后t&#x3D;3，返回值为t&#x3D;3</p>
<p>DeferFunc4在第一步执行表达式后t&#x3D;2，返回值为t&#x3D;2</p>
<h2 id="是否可以编译通过？如果通过，输出什么？"><a href="#是否可以编译通过？如果通过，输出什么？" class="headerlink" title="是否可以编译通过？如果通过，输出什么？"></a>是否可以编译通过？如果通过，输出什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	sn1 := struct &#123;</span><br><span class="line">		age  int</span><br><span class="line">		name string</span><br><span class="line">	&#125;&#123;age: 11, name: &quot;qq&quot;&#125;</span><br><span class="line"></span><br><span class="line">	sn2 := struct &#123;</span><br><span class="line">		age  int</span><br><span class="line">		name string</span><br><span class="line">	&#125;&#123;age: 11, name: &quot;qq&quot;&#125;</span><br><span class="line"></span><br><span class="line">	sn3 := struct &#123;</span><br><span class="line">		name string</span><br><span class="line">		age  int</span><br><span class="line">	&#125;&#123;age: 11, name: &quot;qq&quot;&#125;</span><br><span class="line"></span><br><span class="line">	if sn1 == sn2 &#123;</span><br><span class="line">		fmt.Println(&quot;sn1 == sn2&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if sn1 == sn3 &#123;</span><br><span class="line">		fmt.Println(&quot;sn1 == sn3&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	sm1 := struct &#123;</span><br><span class="line">		age int</span><br><span class="line">		m   map[string]string</span><br><span class="line">	&#125;&#123;age: 11, m: map[string]string&#123;&quot;a&quot;: &quot;1&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">	sm2 := struct &#123;</span><br><span class="line">		age int</span><br><span class="line">		m   map[string]string</span><br><span class="line">	&#125;&#123;age: 11, m: map[string]string&#123;&quot;a&quot;: &quot;1&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">	if sm1 == sm2 &#123;</span><br><span class="line">		fmt.Println(&quot;sm1 == sm2&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体比较 进行结构体比较时候，只有相同类型的结构体才可以比较，结构体是否相同不但与属性类型个数有关，还与属性顺序相关。</p>
<p>还有一点需要注意的是结构体是相同的，但是结构体属性中有不可以比较的类型，如map,slice。 如果该结构属性都是可以比较的，那么就可以使用“&#x3D;&#x3D;”进行比较操作。</p>
<h2 id="是否可以编译通过？如果通过，输出什么？-1"><a href="#是否可以编译通过？如果通过，输出什么？-1" class="headerlink" title="是否可以编译通过？如果通过，输出什么？"></a>是否可以编译通过？如果通过，输出什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Foo(x interface&#123;&#125;) &#123;</span><br><span class="line">	if x == nil &#123;</span><br><span class="line">		fmt.Println(&quot;empty interface&quot;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;non-empty interface&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var x *int = nil</span><br><span class="line">	Foo(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出“non-empty interface”</p>
<h2 id="交替打印数字和字母"><a href="#交替打印数字和字母" class="headerlink" title="交替打印数字和字母"></a>交替打印数字和字母</h2><p>使用两个 goroutine 交替打印序列，一个 goroutine 打印数字， 另外一个 goroutine 打印字母， 最终效果为: <code>12AB34CD56EF78GH910IJ1112KL1314MN1516OP1718QR1920ST2122UV2324WX2526YZ2728</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	number, letter := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	wait := <span class="built_in">new</span>(sync.WaitGroup)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">		num := <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;-number</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d%d&quot;</span>, num, num+<span class="number">1</span>)</span><br><span class="line">			num += <span class="number">2</span></span><br><span class="line">			letter &lt;- <span class="literal">true</span></span><br><span class="line">			<span class="keyword">if</span> num &gt; <span class="number">28</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		wait.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">		begin := <span class="string">&#x27;A&#x27;</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			&lt;- letter</span><br><span class="line">			<span class="keyword">if</span> begin &lt; <span class="string">&#x27;Z&#x27;</span> &#123;</span><br><span class="line">				fmt.Printf(<span class="string">&quot;%c%c&quot;</span>, begin, begin+<span class="number">1</span>)</span><br><span class="line">				begin+=<span class="number">2</span></span><br><span class="line">				number &lt;- <span class="literal">true</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		wait.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	number &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	wait.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	wait.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="struct类型的方法调用"><a href="#struct类型的方法调用" class="headerlink" title="struct类型的方法调用"></a>struct类型的方法调用</h2><p>假设T类型的方法上接收器既有T类型的，又有<em>T指针类型的，那么就不可以在不能寻址的T值上调用</em>T接收器的方法。</p>
<p>请看代码,试问能正常编译通过吗？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Lili <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili *Lili)</span></span> fmtPointer()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;poniter&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili Lili)</span></span> fmtReference()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;reference&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    li := Lili&#123;&#125;</span><br><span class="line">    li.fmtPointer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能正常编译通过，并输出”poniter”</p>
<p>请接着看以下的代码，试问能编译通过？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Lili <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili *Lili)</span></span> fmtPointer()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;poniter&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Lili Lili)</span></span> fmtReference()&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;reference&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Lili&#123;&#125;.fmtPointer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不能编译通过。<br>“cannot call pointer method on Lili literal”<br>“cannot take the address of Lili literal”</p>
<p>其实在第一个代码示例中，main主函数中的“li”是一个变量，li的虽然是类型Lili，但是li是可以寻址的，&amp;li的类型是<em>Lili，因此可以调用</em>Lili的方法。</p>
<h2 id="golang-context包的用法"><a href="#golang-context包的用法" class="headerlink" title="golang context包的用法"></a>golang context包的用法</h2><ol>
<li>goroutine之间的传值</li>
<li>goroutine之间的控制</li>
</ol>
<h2 id="在单核cpu的情况下，下面输出什么内容？"><a href="#在单核cpu的情况下，下面输出什么内容？" class="headerlink" title="在单核cpu的情况下，下面输出什么内容？"></a>在单核cpu的情况下，下面输出什么内容？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	for _, i:=range []int&#123;1, 2, 3, 4, 5&#125; &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func() &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125; ()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考察golang的runtime机制，goroutine的切换时机只有在有系统调用或者函数调用时才会发生，本例子中的for循环结束之前不会发生goroutine的切换，所以最终输出结果为5.</p>
<h2 id="下面输出什么-1"><a href="#下面输出什么-1" class="headerlink" title="下面输出什么"></a>下面输出什么</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type People interface &#123;</span><br><span class="line">	Speak(string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Stduent struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (stu *Stduent) Speak(think string) (talk string) &#123;</span><br><span class="line">	if think == &quot;bitch&quot; &#123;</span><br><span class="line">		talk = &quot;You are a good boy&quot;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		talk = &quot;hi&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var peo People = Stduent&#123;&#125;</span><br><span class="line">	think := &quot;bitch&quot;</span><br><span class="line">	fmt.Println(peo.Speak(think))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译不通过，仅<code>*Student</code>实现了People接口，更改为<code>var peo People = &amp;Student&#123;&#125;</code>即可编译通过。</p>
<h2 id="下面输出什么-2"><a href="#下面输出什么-2" class="headerlink" title="下面输出什么"></a>下面输出什么</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">const cl = 100</span><br><span class="line"></span><br><span class="line">var bl = 123</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	println(&amp;bl, bl)</span><br><span class="line">	println(&amp;cl, cl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译失败，常量cl通常在预处理阶段会直接展开，无法取其地址。</p>
<h2 id="以下代码是否存在问题，请解释你的判断和理由"><a href="#以下代码是否存在问题，请解释你的判断和理由" class="headerlink" title="以下代码是否存在问题，请解释你的判断和理由"></a>以下代码是否存在问题，请解释你的判断和理由</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;sync&quot;</span><br><span class="line"></span><br><span class="line">func f(m sync.Mutex) &#123;</span><br><span class="line">   m.Lock()</span><br><span class="line">   defer m.Unlock()</span><br><span class="line"></span><br><span class="line">   // Do something...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mutex对象不能被值拷贝,后续传递需要使用指针的形式</p>
<h2 id="以下代码输出是什么-解释一下"><a href="#以下代码输出是什么-解释一下" class="headerlink" title="以下代码输出是什么 解释一下"></a>以下代码输出是什么 解释一下</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func    main()  &#123;</span><br><span class="line">    case1()</span><br><span class="line">    case2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func    case1() &#123;</span><br><span class="line">   s1   :=  make([]string,  1,  20)</span><br><span class="line">   s1[0]    =   &quot;hello&quot;</span><br><span class="line">   p1   :=  &amp;s1[0]</span><br><span class="line">   s1   =   append(s1,  &quot;world&quot;)</span><br><span class="line">   *p1  =   &quot;hello2&quot;</span><br><span class="line">   fmt.Printf(&quot;value    of  p1  is  %s, value   of  s1[0]   is  %s  \n&quot;,    *p1,    s1[0])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func    case2() &#123;</span><br><span class="line">   s1   :=  make([]string)</span><br><span class="line">   s1[0]    =   &quot;hello&quot;</span><br><span class="line">   p1   :=  &amp;s1[0]</span><br><span class="line">   s1   =   append(s1,  &quot;world&quot;)</span><br><span class="line">   *p1  =   &quot;hello2&quot;</span><br><span class="line">   fmt.Printf(&quot;value    of  p1  is  %s, value   of  s1[0]   is  %s  \n&quot;,    *p1,    s1[0])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题意在考察string和slice的数据结构，string的数据结构如下：</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/golang_string.png" alt="http://research.swtch.com/godata2.png"></p>
<p>case1的内存结构变化情况如下：</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/golang_interview_1.jpeg"></p>
<p>case2由于s1默认长度为0，直接使用s1[0]复制会出现panic错误。</p>
<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/26972862">golang 面试题
</a></li>
<li><a href="https://yushuangqi.com/blog/2017/golang-mian-shi-ti-da-an-yujie-xi.html?from=groupmessage&isappinstalled=0">Go面试题答案与解析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35058068">golang面试笔试题(第二版)</a></li>
<li><a href="https://github.com/lifei6671/interview-go">interview-go</a></li>
<li><a href="https://goquiz.github.io/">Awesome Go Interview Questions and Answers
</a></li>
<li><a href="http://blog.51cto.com/qiangmzsx/1957477">Golang面试题解析（二）</a></li>
<li><a href="http://www.wtnull.com/v/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang%E9%9D%A2%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89.html">Golang面试题解析（三）</a></li>
<li><a href="https://i6448038.github.io/2018/07/18/golang-mistakes/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io">golang错题集</a></li>
</ul>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang中的panic和recover用法</title>
    <url>/post/golang-panic/</url>
    <content><![CDATA[<p>golang中的panic用于异常处理，个人感觉没有try catch finally方式直观和易用。</p>
<p><code>func panic(v interface&#123;&#125;)</code>函数的作用为抛出一个错误信息，同时函数的执行流程会结束，但panic之前的defer语句会执行，之后该goroutine会立即停止执行，进而当前进程会退出执行。</p>
<p><code>func recover() interface&#123;&#125;</code>定义在panic之前的defer语句中，用于将panic()进行捕获，这样触发panic时，当前gotoutine不会被退出。</p>
<p>recover所返回的内容为panic的函数参数，如果没有捕获到panic，则返回nil。</p>
<p>注意：recover仅能定义在defer中使用，在普通语句中无法捕获recover异常。recover可以不跟panic定义在同一个函数中使用。</p>
<h2 id="example-1"><a href="#example-1" class="headerlink" title="example 1"></a>example 1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	defer fmt.Println(1)</span><br><span class="line">	fmt.Println(2)</span><br><span class="line">	panic(3)</span><br><span class="line">	fmt.Println(4)</span><br><span class="line">	defer fmt.Println(5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>panic()执行后，会先调用defer函数，然后打印<code>panic: 3</code>，当前goroutine退出，后续语句不再执行，程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">panic: 3</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">	/Users/lvkai/src_test/go/panic/panic.go:8 +0xd5</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<h2 id="example-2"><a href="#example-2" class="headerlink" title="example 2"></a>example 2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	func() &#123;</span><br><span class="line">		defer func() &#123;</span><br><span class="line">			if r := recover(); r != nil &#123;</span><br><span class="line">				fmt.Println(&quot;recover: &quot;, r)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		defer fmt.Println(1)</span><br><span class="line">		fmt.Println(2)</span><br><span class="line">		panic(3)</span><br><span class="line">		fmt.Println(4)</span><br><span class="line">		defer fmt.Println(5)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(6)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行panic后，触发当前函数中的defer中的recover函数，此时panic后的当前函数中的语句同样是不再执行，但当前goroutine不会退出。也就是说panic被recover后，会影响到当前函数中的后续语句的执行，但不影响当前goroutine的继续执行，输出内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">recover:  3</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h2 id="example-3"><a href="#example-3" class="headerlink" title="example 3"></a>example 3</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	func() &#123;</span><br><span class="line">		defer func() &#123;</span><br><span class="line">			if r := recover(); r != nil &#123;</span><br><span class="line">				fmt.Println(&quot;recover: &quot;, r)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		func() &#123;</span><br><span class="line">			defer fmt.Println(1)</span><br><span class="line">			panic(2)</span><br><span class="line">		&#125;()</span><br><span class="line">		fmt.Println(3)</span><br><span class="line">		defer fmt.Println(4)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>recover跟panic定义在不同的函数中，仍然可以发挥作用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">recover:  2</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>golang使用pprof分析程序性能瓶颈</title>
    <url>/post/golang-pprof/</url>
    <content><![CDATA[<p>golang中的pprof工具可以分析系统问题，开启pprof功能非常简单，即在import中增加<code>_ &quot;net/http/pprof&quot;</code>的导入即可，然后通过http调用<code>/debug/pprof</code>接口即可在web界面上看到pprof的相关信息。</p>
<p>golang 1.11版本中已经自带了火焰图功能，火焰图为性能分析的利器，可以快速找到程序性能的瓶颈。不再需要使用<a href="https://github.com/uber/go-torch">go-torch</a>项目。</p>
<p>查看火焰图需要用到Graphviz工具，该工具需要单独安装。</p>
<p>Graphviz工具运行的服务器系统为CentOS，使用下载<a href="https://graphviz.gitlab.io/pub/graphviz/stable/SOURCES/graphviz.tar.gz">源码包</a>的方式进行安装。</p>
<p>依次执行下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>本文的使用环境：服务器程序为transfer，运行在linux系统中。执行<code>go tool pprof</code>命令运行在linux服务器10.103.17.184上。</p>
<p>程序运行后调用程序的<code>/debug/pprof/profile</code>http接口，可获取到cpu profile数据文件。例如，在服务器上可以执行运行<code>wget http://10.103.34.138:3300/debug/pprof/profile</code>命令，将profile文件下载到另外一台分析的服务器上。</p>
<p>在分析服务器上执行<code>go tool pprof -http=&quot;10.103.17.184:20000&quot; transfer profile</code></p>
<p>在浏览器中打开<code>10.103.17.184:20000</code>即可得到性能分析的结果。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/pprof_graph.png" alt="调用关系图"></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/pprof_flame.png" alt="火焰图"></p>
<p>同样也可以在本机访问远程的程序暴露的pprof数据，使用命令如：go tool pprof -http :9090  <a href="http://10.66.161.43:10245/debug/pprof/heap">http://10.66.161.43:10245/debug/pprof/heap</a></p>
]]></content>
  </entry>
  <entry>
    <title>google autheticator应用现状</title>
    <url>/post/google-autheticator/</url>
    <content><![CDATA[<p>通过使用Google的登陆二步验证（即Google Authenticator服务），我们在登陆时需要输入额外由手机客户端生成的一次性密码。大大提高登陆的安全性。</p>
<p>实现Google Authenticator功能需要服务器端和客户端的支持。服务器端负责密钥的生成、验证一次性密码是否正确。客户端记录密钥后生成一次性密码。</p>
<p>google实现了基于时间的TOTP算法（Time-based One-time Password），客户端实现包括了android和ios。</p>
<p>算法为公开算法，google没有提供服务端的实现，各个语言都有单独的实现。自己系统使用可以直接使用网上的代码。</p>
<p>linux下有libpam-google-authenticator模块，可以使用yum或者源码编译安装，github上有源码，编译出来的为so文件，可以加到sshd的配置文件中，用于给sshd提供二次认证机制。</p>
<p>客户端和服务端存在时间差的问题，google authenticator的超时时间为30s，服务端可以使用两个30s的时间来验证，包括当前和上一个30s。</p>
]]></content>
  </entry>
  <entry>
    <title>用来排查k8s问题的常用grafana dashboard</title>
    <url>/post/grafana-dashboard-k8s/</url>
    <content><![CDATA[<p>排查k8s上问题通常需要监控的配合，而k8s上的监控标准为prometheus，prometheus的dashboard最通用的为grafana。本文用来记录排查k8s问题时经常遇到的dashboard，dashboard监控的数据来源包括node-exporter、metrics-server、kube-state-metrics等最场景。</p>
<h2 id="node-top监控"><a href="#node-top监控" class="headerlink" title="node top监控"></a>node top监控</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/grafana-dashboard1.jpg"></p>
<p><a href="https://kuring.oss-cn-beijing.aliyuncs.com/files/node%20top%E7%9B%91%E6%8E%A7-1647271172485.json">下载链接</a></p>
<h2 id="node上的pod监控"><a href="#node上的pod监控" class="headerlink" title="node上的pod监控"></a>node上的pod监控</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/grafana-dashboard2.jpg"></p>
<p><a href="https://kuring.oss-cn-beijing.aliyuncs.com/files/node%E4%B8%8A%E7%9A%84pod-1647271326652.json">下载链接</a></p>
]]></content>
  </entry>
  <entry>
    <title>grafana升级</title>
    <url>/post/grafana-upgrade/</url>
    <content><![CDATA[<p>本次grafana的升级从版本3.1.1，变更为4.4.3，涉及到一个大的版本跨度。同时之前在使用的存储为sqlite，趁着这次升级更改为mysql。</p>
<h1 id="grafana升级"><a href="#grafana升级" class="headerlink" title="grafana升级"></a>grafana升级</h1><p>直接从官网下载对应的4.4.3版本的二进制包，修改部分配置即可，该部分没任何难度。</p>
<h1 id="sqlite-to-mysql"><a href="#sqlite-to-mysql" class="headerlink" title="sqlite to mysql"></a>sqlite to mysql</h1><p>由于grafana使用的表结构在3.1.1到4.4.3之间有变更，不能直接将3.1.1版本的sqlite中的数据导入到4.4.3的mysql中。我的方法为先使用3.1.1版grafana将数据从sqlite导入到mysql中，然后再升级grafana的版本，grafana可以自动修改表结构。</p>
<p>在的mysql中创建grafana的数据库，并修改数据库的编码为utf-8.</p>
<p>修改grafana 3.1.1配置文件conf&#x2F;defaults.ini如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[database]</span><br><span class="line"># You can configure the database connection by specifying type, host, name, user and password</span><br><span class="line"># as separate properties or as on string using the url property.</span><br><span class="line"></span><br><span class="line"># Either &quot;mysql&quot;, &quot;postgres&quot; or &quot;sqlite3&quot;, it&#x27;s your choice</span><br><span class="line">type = mysql</span><br><span class="line">host = xx.xx.xx.xx:3306</span><br><span class="line">name = grafana</span><br><span class="line">user = dev</span><br><span class="line"># If the password contains # or ; you have to wrap it with triple quotes. Ex &quot;&quot;&quot;#password;&quot;&quot;&quot;</span><br><span class="line">password = dev</span><br></pre></td></tr></table></figure>

<p>启动grafana后会自动在grafana数据库中创建相应的表结构，接下来就是将sqlite中的数据导入到mysql中。</p>
<p>在data目录下增加如下脚本sqlitedump.sh，并执行<code>sh sqlitedump.sh grafana.db &gt; grafana.sql</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">DB=$1</span><br><span class="line">TABLES=$(sqlite3 $DB .tables | grep -v migration_log)</span><br><span class="line">for t in $TABLES; do</span><br><span class="line">    echo &quot;TRUNCATE TABLE $t;&quot;</span><br><span class="line">done</span><br><span class="line">for t in $TABLES; do</span><br><span class="line">    echo -e &quot;.mode insert $t\nselect * from $t;&quot;</span><br><span class="line">done | sqlite3 $DB</span><br></pre></td></tr></table></figure>

<p>然后将grafana.sql导入到新创建的mysql。</p>
<p>将grafana 3.1.1版本停掉，将grafana 4.4.3版本的配置指向到mysql数据库，启动grafana 4.4.3后，mysql中的表结构会自动变更。</p>
<p>至此，grafana的升级完成。</p>
]]></content>
  </entry>
  <entry>
    <title>在Linux上搭建Hadoop集群环境</title>
    <url>/post/hadoop_setup/</url>
    <content><![CDATA[<p>本文选择安装的hadoop版本为网上资料较多的0.20.2，对于不懂的新技术要持保守态度。遇到问题解决问题的痛苦远比体会用不着功能的新版本的快感来的更猛烈。</p>
<h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>本文选择了三台机器来搭建hadoop集群，1个Master和2个Slave。本文中的master主机即namenode所在的机器，slave即datanode所在的机器。节点的机器名和IP地址如下</p>
<table>
<tr>
    <td>机器名</td>
    <td>IP地址</td>
    <td>用途</td>
    <td>运行模块</td>
</tr>
<tr>
    <td>server206</td>
    <td>192.168.20.6</td>
    <td>Master</td>
    <td>NameNode、JobTracker、SecondaryNameNode</td>
</tr>
<tr>
    <td>ap1</td>
    <td>192.168.20.36</td>
    <td>Slave</td>
    <td>DataNode、TaskTracker</td>
</tr>
<tr>
    <td>ap2</td>
    <td>192.168.20.38</td>
    <td>Slave</td>
    <td>DataNode、TaskTracker</td>
</tr>
</table>


<h1 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h1><ol>
<li>检查本机是否已安装Java<br>在命令行中输入<code>java -version</code>判断是否已经安装。如果已经安装检查Java的版本，某些操作系统在安装的时候会安装Jdk，但可能版本会太低。如果版本过低，需要将旧的版本删除。在Redhat操作系统中可以通过rpm命令来删除系统自带的Jdk。</li>
<li>安装java<br>本文选择jdk1.6安装，将解压出的文件夹jdk1.6.0_10复制到&#x2F;usr&#x2F;java目录下。</li>
<li>设置java的环境变量<br>添加系统环境变量，修改&#x2F;etc&#x2F;profile文件，在文件末尾添加如下内容：<blockquote>
<p>export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.6.0_10<br>export CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JAVA_HOME&#x2F;lib&#x2F;dt.jar<br>export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH<br>export JRE_HOME&#x3D;$JAVA_HOME&#x2F;jre</p>
</blockquote>
 修改完profile文件后要执行<code>source /etc/profile</code>命令才能使刚才的修改在该命令行环境下生效。</li>
<li>检查java是否安装成功<br>在命令行中输入java -version、javac命令来查看是否安装成功及安装版本。</li>
</ol>
<h1 id="配置hosts文件"><a href="#配置hosts文件" class="headerlink" title="配置hosts文件"></a>配置hosts文件</h1><p>本步骤必须操作，需要root用户来操作，修改完成之后立即生效。在三台机器的&#x2F;etc&#x2F;hosts文件末尾添加如下内容：</p>
<blockquote>
<p>192.168.20.6   server206<br>192.168.20.36   ap1<br>192.168.20.38   ap2</p>
</blockquote>
<p>修改完成之后可以通过<code>ping 主机名</code>的方式来测试hosts文件是否正确。</p>
<h1 id="新建hadoop用户"><a href="#新建hadoop用户" class="headerlink" title="新建hadoop用户"></a>新建hadoop用户</h1><p>在三台机器上分别新建hadoop用户，该用户的目录为&#x2F;home&#x2F;hadoop。利用useradd命令来添加用户，利用passwd命令给用户添加密码。</p>
<h1 id="配置SSH免登录"><a href="#配置SSH免登录" class="headerlink" title="配置SSH免登录"></a>配置SSH免登录</h1><p>该步骤非必须，推荐配置，否则在Master上执行start-all.sh命令来启动hadoop集群的时候需要手动输入ssh密码，非常麻烦。<br>原理：用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求输入密码。<br>在本例中，需要实现的是192.168.20.6上的hadoop用户可以无密码登录自己、192.168.20.36和192.168.20.38的hadoop用户。需要将192.168.20.6上的ssh公钥复制到192.168.20.36和192.168.20.38机器上。</p>
<ol>
<li>在192.168.20.6上执行<code>ssh-keygen –t rsa</code>命令来生成ssh密钥对。会在&#x2F;home&#x2F;hadoop&#x2F;.ssh目录下生成id_rsa.pub和id_rsa两个文件，其中id_rsa.pub为公钥文件，id_rsa为私钥文件。</li>
<li>在192.168.20.6上执行<code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code>命令将公钥添加到授权的key里。</li>
<li>权限设置。在192.168.20.6上执行<code>chmod 600 ~/.ssh/authorized_keys</code>来修改authorized_keys文件的权限，执行<code>chmod 700 ~/.ssh</code>命令将.ssh文件夹的权限设置为700。如果权限不对无密码登录就配置不成功，而且没有错误提示，这一步特别注意。</li>
<li>在本机上测试是否设置无密码登录成功。在192.168.20.6上执行<code>ssh -p 本机SSH服务端口号 localhost</code>，如果不需要输入密码则登录成功。</li>
<li>利用scp命令将192.168.20.6上的公钥文件id_rsa.pub追加到192.168.20.36和192.168.20.38机器上的~&#x2F;.ssh&#x2F;authorized_keys文件中。scp命令的格式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -P ssh端口号 ~/.ssh/id_rsa.pub hadoop@192.168.20.36:~/id_rsa.pub</span><br></pre></td></tr></table></figure>
在192.168.20.36和192.168.20.38机器上分别执行<code>cat ~/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code>命令将192.168.20.6机器上的公钥添加到authorized_keys文件的尾部。</li>
<li>配置无密码登录完成，在Master机器上执行<code>ssh -P 本机SSH服务端口号 要连接的服务器IP地址</code>命令进行测试。</li>
</ol>
<h1 id="搭建单机版hadoop"><a href="#搭建单机版hadoop" class="headerlink" title="搭建单机版hadoop"></a>搭建单机版hadoop</h1><p>在192.168.20.6上首先搭建单机版hadoop进行测试。</p>
<ol>
<li>将hadoop-0.20.2.tar.gz文件解压到hadoop用户的目录下。</li>
<li>配置hadoop的环境变量。修改&#x2F;etc&#x2F;profile文件，在文件的下面加入如下：<blockquote>
<p>HADOOP_HOME&#x3D;&#x2F;home&#x2F;hadoop&#x2F;hadoop-0.20.2<br>export HADOOP_HOME<br>export HADOOP&#x3D;$HADOOP_HOME&#x2F;bin<br>export PATH&#x3D;$HADOOP:$PATH</p>
</blockquote>
</li>
</ol>
<p>修改完成之后执行<code>source /etc/profile</code>使修改的环境变量生效。<br>3. 配置hadoop用到的java环境变量<br>修改conf&#x2F;hadoop-env.sh文件，添加<code>export JAVA_HOME=/usr/java/jdk1.6.0_10</code>。<br>4. 修改conf&#x2F;core-site.xml的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.default.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; </span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt; </span><br><span class="line">        &lt;value&gt;1&lt;/value&gt; </span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/hadoop-0.20.2/tmp&lt;/value&gt; </span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>修改&#x2F;conf&#x2F;mapred-site.xml的内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;   </span><br><span class="line">        &lt;name&gt;mapred.job.tracker&lt;/name&gt;  </span><br><span class="line">        &lt;value&gt;localhost:9001&lt;/value&gt;   </span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li>
<li>至此单击版搭建完毕。可以通过hadoop自带的wordcount程序测试是否运行正常。下面为运行wordcount例子的步骤。</li>
<li>在hadoop目录下新建input文件夹。</li>
<li>将conf目录下的内容拷贝到input文件夹下，执行<code>cp conf/* input</code>。</li>
<li>通过start-all.sh脚本来启动单机版hadoop。</li>
<li>执行wordcount程序：<code>hadoop jar hadoop-0.20.2-examples.jar wordcount input output</code>。</li>
<li>通过stop-all.sh脚本来停止单机版hadoop。</li>
</ol>
<h1 id="搭建分布式hadoop"><a href="#搭建分布式hadoop" class="headerlink" title="搭建分布式hadoop"></a>搭建分布式hadoop</h1><p>在上述基础之上，在192.168.20.6上执行如下操作。<br>1. 修改&#x2F;home&#x2F;hadoop&#x2F;hadoop-0.20.2&#x2F;conf目录下的core-site.xml文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.default.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://192.168.20.6:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/hadoop-0.20.2/tmp&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>如没有配置hadoop.tmp.dir参数，此时系统默认的临时目录为：&#x2F;tmp&#x2F;hadoo-hadoop。而这个目录在每次重启后都会被干掉，必须重新执行format才行，否则会出错。<br>2. 修改&#x2F;home&#x2F;hadoop&#x2F;hadoop-0.20.2&#x2F;conf目录下的hdfs-site.xml文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;dfs.support.append&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>3. 修改&#x2F;home&#x2F;hadoop&#x2F;hadoop-0.20.2&#x2F;conf目录下的mapred-site.xml文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">            &lt;name&gt;mapred.job.tracker&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;http://192.168.20.6:9001&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>4. 修改&#x2F;home&#x2F;hadoop&#x2F;hadoop-0.20.2&#x2F;conf目录下的masters文件。<br>将Master机器的IP地址或主机名添加进文件，如192.168.20.6。<br>5. 修改&#x2F;home&#x2F;hadoop&#x2F;hadoop-0.20.2&#x2F;conf目录下的slaves文件。<em>Master主机特有</em><br>在其中将slave节点的Ip地址或主机名添加进文件中，本例中加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.20.36</span><br><span class="line">192.168.20.38</span><br></pre></td></tr></table></figure>
<p>6. hadoop主机的master主机已经配置完毕，利用scp命令将hadoop-0.20.2目录复制到两台slave机器的hadoop目录下。命令为：<code>scp -r /home/hadoop hadoop@服务器IP:/home/hadoop/</code>。注意slaves文件在master和slave机器上是不同的。</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul>
<li>hadoop dfsadmin -report 查看集群状态</li>
<li><a href="http://192.168.20.6:50070/dfshealth.jsp">http://192.168.20.6:50070/dfshealth.jsp</a>  查看NameNode状态</li>
<li><a href="http://192.168.20.6:50030/jobtracker.jsp">http://192.168.20.6:50030/jobtracker.jsp</a> Map&#x2F;Reduce管理</li>
<li>hadoop fs -mkdir input 在HDFS上创建文件夹</li>
<li>hadoop fs -put ~&#x2F;file&#x2F;file*.txt input 将文件放入HDFS文件系统中</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="http://www.cnblogs.com/xia520pi/archive/2012/05/16/2503949.html">细细品味Hadoop系列</a>。超详细的hadoop教程，作者非常用心。</li>
</ul>
<h1 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h1><p><a href="http://pan.baidu.com/share/link?shareid=1235031445&uk=3506813023">http://pan.baidu.com/share/link?shareid=1235031445&uk=3506813023</a> 提取码：v8ok</p>
]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase性能测试</title>
    <url>/post/hbase_test/</url>
    <content><![CDATA[<p>本文选择四台机器作为集群环境，hadoop采用0.20.2，HBase采用0.90.2，zookeeper采用独立安装的3.3.2稳定版。本文所采用的数据均为简单的测试数据，如果插入的数据量大可能会对结果产生影响。集群环境部署情况如下：</p>
<table>
<tr>
    <td>机器名</td>
    <td>IP地址</td>
    <td>用途</td>
    <td>Hadoop模块</td>
    <td>HBase模块</td>
    <td>ZooKeeper模块</td>
</tr>
<tr>
    <td>server206</td>
    <td>192.168.20.6</td>
    <td>Master</td>
    <td>NameNode、JobTracker、SecondaryNameNode</td>
    <td>HMaster</td>
    <td>QuorumPeerMain</td>
</tr>
<tr>
    <td>ap1</td>
    <td>192.168.20.36</td>
    <td>Slave</td>
    <td>DataNode、TaskTracker</td>
    <td>HRegionServer</td>
    <td>QuorumPeerMain</td>
</tr>
<tr>
    <td>ap2</td>
    <td>192.168.20.38</td>
    <td>Slave</td>
    <td>DataNode、TaskTracker</td>
    <td>HRegionServer</td>
    <td>QuorumPeerMain</td>
</tr>
<tr>
    <td>ap2</td>
    <td>192.168.20.8</td>
    <td>Slave</td>
    <td>DataNode、TaskTracker</td>
    <td>HRegionServer</td>
    <td>QuorumPeerMain</td>
</tr>
</table>

<h1 id="单线程插入100万行"><a href="#单线程插入100万行" class="headerlink" title="单线程插入100万行"></a>单线程插入100万行</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line">import org.apache.hadoop.hbase.HColumnDescriptor;</span><br><span class="line">import org.apache.hadoop.hbase.HTableDescriptor;</span><br><span class="line">import org.apache.hadoop.hbase.client.HBaseAdmin;</span><br><span class="line">import org.apache.hadoop.hbase.client.HTable;</span><br><span class="line">import org.apache.hadoop.hbase.client.Put;</span><br><span class="line">import org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class InsertRowThreadTest &#123;</span><br><span class="line">	</span><br><span class="line">	private static Configuration conf = null;</span><br><span class="line">	</span><br><span class="line">	private static String tableName = &quot;blog&quot;;</span><br><span class="line">	</span><br><span class="line">	static &#123;</span><br><span class="line">		Configuration conf1 = new Configuration();</span><br><span class="line">		conf1.set(&quot;hbase.zookeeper.quorum&quot;, &quot;server206,ap1,ap2&quot;);</span><br><span class="line">		conf1.set(&quot;hbase.zookeeper.property.clientPort&quot;, &quot;2181&quot;);</span><br><span class="line">        conf = HBaseConfiguration.create(conf1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param args</span><br><span class="line">	 * @throws Exception </span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 列族</span><br><span class="line">        String[] familys = &#123;&quot;article&quot;, &quot;author&quot;&#125;;</span><br><span class="line">        // 创建表</span><br><span class="line">        try &#123;</span><br><span class="line">        	HBaseAdmin admin = new HBaseAdmin(conf);</span><br><span class="line">        	if (admin.tableExists(tableName)) &#123;</span><br><span class="line">                System.out.println(&quot;表已经存在，首先删除表&quot;);</span><br><span class="line">                admin.disableTable(tableName);</span><br><span class="line">                admin.deleteTable(tableName);</span><br><span class="line">            &#125;</span><br><span class="line">        	</span><br><span class="line">            HTableDescriptor tableDesc = new HTableDescriptor(tableName);</span><br><span class="line">            for(int i=0; i&lt;familys.length; i++)&#123;</span><br><span class="line">            	HColumnDescriptor columnDescriptor = new HColumnDescriptor(familys[i]);</span><br><span class="line">                tableDesc.addFamily(columnDescriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            admin.createTable(tableDesc);</span><br><span class="line">            System.out.println(&quot;创建表成功&quot;);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 向表中插入数据</span><br><span class="line">		long time1 = System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;开始向表中插入数据，当前时间为:&quot; + time1);</span><br><span class="line">		</span><br><span class="line">		for (int i=0; i&lt;1; i++) &#123;</span><br><span class="line">			InsertThread thread = new InsertThread(i * 1000000, 1000000, &quot;thread&quot; + i, time1);</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static class InsertThread extends Thread &#123;</span><br><span class="line">		</span><br><span class="line">		private int beginSite;</span><br><span class="line">		</span><br><span class="line">		private int insertCount;</span><br><span class="line">				</span><br><span class="line">		private String name;</span><br><span class="line">		</span><br><span class="line">		private long beginTime;</span><br><span class="line">		</span><br><span class="line">		public InsertThread(int beginSite, int insertCount, String name, long beginTime) &#123;</span><br><span class="line">			this.beginSite = beginSite;</span><br><span class="line">			this.insertCount = insertCount;</span><br><span class="line">			this.name = name;</span><br><span class="line">			this.beginTime = beginTime;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		@Override</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			HTable table = null;</span><br><span class="line">			try &#123;</span><br><span class="line">				table = new HTable(conf, Bytes.toBytes(tableName));</span><br><span class="line">				table.setAutoFlush(false);</span><br><span class="line">				table.setWriteBufferSize(1 * 1024 * 1024);</span><br><span class="line">			&#125; catch (IOException e1) &#123;</span><br><span class="line">				e1.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			System.out.println(&quot;线程&quot; + name + &quot;从&quot; + beginSite + &quot;开始插入&quot;);</span><br><span class="line">			</span><br><span class="line">			List&lt;Put&gt; putList = new ArrayList&lt;Put&gt;();</span><br><span class="line">			for (int i=beginSite; i&lt;beginSite + insertCount; i++) &#123;</span><br><span class="line">				Put put = new Put(Bytes.toBytes(&quot;&quot; + i));</span><br><span class="line">				put.add(Bytes.toBytes(&quot;article&quot;), Bytes.toBytes(&quot;tag&quot;), Bytes.toBytes(&quot;hadoop&quot;));</span><br><span class="line">				putList.add(put);</span><br><span class="line">				if (putList.size() &gt; 10000) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						table.put(putList);</span><br><span class="line">						table.flushCommits();</span><br><span class="line">					&#125; catch (IOException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					putList.clear();</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(5);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				table.put(putList);</span><br><span class="line">				table.flushCommits();</span><br><span class="line">				table.close();</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				System.out.println(&quot;线程&quot; + name + &quot;失败&quot;);</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			long currentTime = System.currentTimeMillis();</span><br><span class="line">			System.out.println(&quot;线程&quot; + name + &quot;结束，用时&quot; + (currentTime - beginTime));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试5次的结果分布图如下：<br><img src="/ref/hadoop/hbase_test_1.png" alt="Image Title"><br>其中Y轴单位为毫秒。平均速度在1秒插入3万行记录。</p>
<h1 id="10个线程每个线程插入10万行"><a href="#10个线程每个线程插入10万行" class="headerlink" title="10个线程每个线程插入10万行"></a>10个线程每个线程插入10万行</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line">import org.apache.hadoop.hbase.HColumnDescriptor;</span><br><span class="line">import org.apache.hadoop.hbase.HTableDescriptor;</span><br><span class="line">import org.apache.hadoop.hbase.client.HBaseAdmin;</span><br><span class="line">import org.apache.hadoop.hbase.client.HTable;</span><br><span class="line">import org.apache.hadoop.hbase.client.Put;</span><br><span class="line">import org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class InsertRowThreadTest &#123;</span><br><span class="line">	</span><br><span class="line">	private static Configuration conf = null;</span><br><span class="line">	</span><br><span class="line">	private static String tableName = &quot;blog&quot;;</span><br><span class="line">	</span><br><span class="line">	static &#123;</span><br><span class="line">		Configuration conf1 = new Configuration();</span><br><span class="line">		conf1.set(&quot;hbase.zookeeper.quorum&quot;, &quot;server206,ap1,ap2&quot;);</span><br><span class="line">		conf1.set(&quot;hbase.zookeeper.property.clientPort&quot;, &quot;2181&quot;);</span><br><span class="line">        conf = HBaseConfiguration.create(conf1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param args</span><br><span class="line">	 * @throws Exception </span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 列族</span><br><span class="line">        String[] familys = &#123;&quot;article&quot;, &quot;author&quot;&#125;;</span><br><span class="line">        // 创建表</span><br><span class="line">        try &#123;</span><br><span class="line">        	HBaseAdmin admin = new HBaseAdmin(conf);</span><br><span class="line">        	if (admin.tableExists(tableName)) &#123;</span><br><span class="line">                System.out.println(&quot;表已经存在，首先删除表&quot;);</span><br><span class="line">                admin.disableTable(tableName);</span><br><span class="line">                admin.deleteTable(tableName);</span><br><span class="line">            &#125;</span><br><span class="line">        	</span><br><span class="line">            HTableDescriptor tableDesc = new HTableDescriptor(tableName);</span><br><span class="line">            for(int i=0; i&lt;familys.length; i++)&#123;</span><br><span class="line">            	HColumnDescriptor columnDescriptor = new HColumnDescriptor(familys[i]);</span><br><span class="line">                tableDesc.addFamily(columnDescriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            admin.createTable(tableDesc);</span><br><span class="line">            System.out.println(&quot;创建表成功&quot;);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 向表中插入数据</span><br><span class="line">		long time1 = System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;开始向表中插入数据，当前时间为:&quot; + time1);</span><br><span class="line">		</span><br><span class="line">		for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">			InsertThread thread = new InsertThread(i * 100000, 100000, &quot;thread&quot; + i, time1);</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static class InsertThread extends Thread &#123;</span><br><span class="line">		</span><br><span class="line">		private int beginSite;</span><br><span class="line">		</span><br><span class="line">		private int insertCount;</span><br><span class="line">				</span><br><span class="line">		private String name;</span><br><span class="line">		</span><br><span class="line">		private long beginTime;</span><br><span class="line">		</span><br><span class="line">		public InsertThread(int beginSite, int insertCount, String name, long beginTime) &#123;</span><br><span class="line">			this.beginSite = beginSite;</span><br><span class="line">			this.insertCount = insertCount;</span><br><span class="line">			this.name = name;</span><br><span class="line">			this.beginTime = beginTime;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		@Override</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			HTable table = null;</span><br><span class="line">			try &#123;</span><br><span class="line">				table = new HTable(conf, Bytes.toBytes(tableName));</span><br><span class="line">				table.setAutoFlush(false);</span><br><span class="line">				table.setWriteBufferSize(1 * 1024 * 1024);</span><br><span class="line">			&#125; catch (IOException e1) &#123;</span><br><span class="line">				e1.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			System.out.println(&quot;线程&quot; + name + &quot;从&quot; + beginSite + &quot;开始插入&quot;);</span><br><span class="line">			</span><br><span class="line">			List&lt;Put&gt; putList = new ArrayList&lt;Put&gt;();</span><br><span class="line">			for (int i=beginSite; i&lt;beginSite + insertCount; i++) &#123;</span><br><span class="line">				Put put = new Put(Bytes.toBytes(&quot;&quot; + i));</span><br><span class="line">				put.add(Bytes.toBytes(&quot;article&quot;), Bytes.toBytes(&quot;tag&quot;), Bytes.toBytes(&quot;hadoop&quot;));</span><br><span class="line">				putList.add(put);</span><br><span class="line">				if (putList.size() &gt; 10000) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						table.put(putList);</span><br><span class="line">						table.flushCommits();</span><br><span class="line">					&#125; catch (IOException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					putList.clear();</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(5);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				table.put(putList);</span><br><span class="line">				table.flushCommits();</span><br><span class="line">				table.close();</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				System.out.println(&quot;线程&quot; + name + &quot;失败&quot;);</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			long currentTime = System.currentTimeMillis();</span><br><span class="line">			System.out.println(&quot;线程&quot; + name + &quot;结束，用时&quot; + (currentTime - beginTime));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>耗时分布图为：<br><img src="/ref/hadoop/hbase_test_2.png" alt="Image Title"><br>结果比单线程插入有提升。</p>
<h1 id="20个线程每个线程插入5万行"><a href="#20个线程每个线程插入5万行" class="headerlink" title="20个线程每个线程插入5万行"></a>20个线程每个线程插入5万行</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.hbase.HBaseConfiguration;</span><br><span class="line">import org.apache.hadoop.hbase.HColumnDescriptor;</span><br><span class="line">import org.apache.hadoop.hbase.HTableDescriptor;</span><br><span class="line">import org.apache.hadoop.hbase.client.HBaseAdmin;</span><br><span class="line">import org.apache.hadoop.hbase.client.HTable;</span><br><span class="line">import org.apache.hadoop.hbase.client.Put;</span><br><span class="line">import org.apache.hadoop.hbase.util.Bytes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class InsertRowThreadTest &#123;</span><br><span class="line">	</span><br><span class="line">	private static Configuration conf = null;</span><br><span class="line">	</span><br><span class="line">	private static String tableName = &quot;blog&quot;;</span><br><span class="line">	</span><br><span class="line">	static &#123;</span><br><span class="line">		Configuration conf1 = new Configuration();</span><br><span class="line">		conf1.set(&quot;hbase.zookeeper.quorum&quot;, &quot;server206,ap1,ap2&quot;);</span><br><span class="line">		conf1.set(&quot;hbase.zookeeper.property.clientPort&quot;, &quot;2181&quot;);</span><br><span class="line">        conf = HBaseConfiguration.create(conf1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * @param args</span><br><span class="line">	 * @throws Exception </span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 列族</span><br><span class="line">        String[] familys = &#123;&quot;article&quot;, &quot;author&quot;&#125;;</span><br><span class="line">        // 创建表</span><br><span class="line">        try &#123;</span><br><span class="line">        	HBaseAdmin admin = new HBaseAdmin(conf);</span><br><span class="line">        	if (admin.tableExists(tableName)) &#123;</span><br><span class="line">                System.out.println(&quot;表已经存在，首先删除表&quot;);</span><br><span class="line">                admin.disableTable(tableName);</span><br><span class="line">                admin.deleteTable(tableName);</span><br><span class="line">            &#125;</span><br><span class="line">        	</span><br><span class="line">            HTableDescriptor tableDesc = new HTableDescriptor(tableName);</span><br><span class="line">            for(int i=0; i&lt;familys.length; i++)&#123;</span><br><span class="line">            	HColumnDescriptor columnDescriptor = new HColumnDescriptor(familys[i]);</span><br><span class="line">                tableDesc.addFamily(columnDescriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            admin.createTable(tableDesc);</span><br><span class="line">            System.out.println(&quot;创建表成功&quot;);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		// 向表中插入数据</span><br><span class="line">		long time1 = System.currentTimeMillis();</span><br><span class="line">		System.out.println(&quot;开始向表中插入数据，当前时间为:&quot; + time1);</span><br><span class="line">		</span><br><span class="line">		for (int i=0; i&lt;20; i++) &#123;</span><br><span class="line">			InsertThread thread = new InsertThread(i * 50000, 50000, &quot;thread&quot; + i, time1);</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static class InsertThread extends Thread &#123;</span><br><span class="line">		</span><br><span class="line">		private int beginSite;</span><br><span class="line">		</span><br><span class="line">		private int insertCount;</span><br><span class="line">				</span><br><span class="line">		private String name;</span><br><span class="line">		</span><br><span class="line">		private long beginTime;</span><br><span class="line">		</span><br><span class="line">		public InsertThread(int beginSite, int insertCount, String name, long beginTime) &#123;</span><br><span class="line">			this.beginSite = beginSite;</span><br><span class="line">			this.insertCount = insertCount;</span><br><span class="line">			this.name = name;</span><br><span class="line">			this.beginTime = beginTime;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		@Override</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			HTable table = null;</span><br><span class="line">			try &#123;</span><br><span class="line">				table = new HTable(conf, Bytes.toBytes(tableName));</span><br><span class="line">				table.setAutoFlush(false);</span><br><span class="line">				table.setWriteBufferSize(1 * 1024 * 1024);</span><br><span class="line">			&#125; catch (IOException e1) &#123;</span><br><span class="line">				e1.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			System.out.println(&quot;线程&quot; + name + &quot;从&quot; + beginSite + &quot;开始插入&quot;);</span><br><span class="line">			</span><br><span class="line">			List&lt;Put&gt; putList = new ArrayList&lt;Put&gt;();</span><br><span class="line">			for (int i=beginSite; i&lt;beginSite + insertCount; i++) &#123;</span><br><span class="line">				Put put = new Put(Bytes.toBytes(&quot;&quot; + i));</span><br><span class="line">				put.add(Bytes.toBytes(&quot;article&quot;), Bytes.toBytes(&quot;tag&quot;), Bytes.toBytes(&quot;hadoop&quot;));</span><br><span class="line">				putList.add(put);</span><br><span class="line">				if (putList.size() &gt; 10000) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						table.put(putList);</span><br><span class="line">						table.flushCommits();</span><br><span class="line">					&#125; catch (IOException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					putList.clear();</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(5);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				table.put(putList);</span><br><span class="line">				table.flushCommits();</span><br><span class="line">				table.close();</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				System.out.println(&quot;线程&quot; + name + &quot;失败&quot;);</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			long currentTime = System.currentTimeMillis();</span><br><span class="line">			System.out.println(&quot;线程&quot; + name + &quot;结束，用时&quot; + (currentTime - beginTime));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="/ref/hadoop/hbase_test_3.png" alt="Image Title"><br>执行结果跟10个线程效果差不多。</p>
<h1 id="10个线程每个线程插入100万行"><a href="#10个线程每个线程插入100万行" class="headerlink" title="10个线程每个线程插入100万行"></a>10个线程每个线程插入100万行</h1><p>代码跟前面例子雷同，为节约篇幅未列出。<br>执行结果如下：<br><img src="/ref/hadoop/hbase_test_4.png" alt="Image Title"></p>
<h1 id="20个线程每个线程插入50万行"><a href="#20个线程每个线程插入50万行" class="headerlink" title="20个线程每个线程插入50万行"></a>20个线程每个线程插入50万行</h1><p>执行结果如下：<br><img src="/ref/hadoop/hbase_test_5.png" alt="Image Title"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>多线程比单线程的插入效率有所提高，开10个线程与开20个线程的插入行效率差不多。</li>
<li>插入效率存在不稳定情况，通过折线图可以看出。</li>
</ul>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="/post/hadoop_setup">在Linux上搭建Hadoop集群环境</a><br><a href="/post/hbase_setup">在Linux上搭建HBase集群环境</a></p>
]]></content>
      <tags>
        <tag>Hadoop HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>一个实例讲解HTTP的断点续传</title>
    <url>/post/http_range/</url>
    <content><![CDATA[<p>本文以从服务器下载一个文件为例，讲解HTTP的断点续传功能。</p>
<p>客户端IP地址为：192.168.1.2<br>服务器IP地址为：192.168.1.3</p>
<h1 id="客户端向服务器发送请求"><a href="#客户端向服务器发送请求" class="headerlink" title="客户端向服务器发送请求"></a>客户端向服务器发送请求</h1><p>客户端向服务器发送的请求为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /deepc.a HTTP/1.1</span><br><span class="line">Host: 192.168.100.189</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.14 Safari/537.36</span><br><span class="line">Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</span><br></pre></td></tr></table></figure>

<p>从中可以看出请求的文件名为deepc.a文件。</p>
<h1 id="客户端向服务器发送具体请求"><a href="#客户端向服务器发送具体请求" class="headerlink" title="客户端向服务器发送具体请求"></a>客户端向服务器发送具体请求</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /deepc.a HTTP/1.1</span><br><span class="line">Host: 192.168.100.189</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.14 Safari/537.36</span><br><span class="line">Accept: */*</span><br><span class="line">Referer: http://192.168.100.189/deepc.a</span><br><span class="line">Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</span><br><span class="line">Range: bytes=0-32767</span><br></pre></td></tr></table></figure>

<p>Range字段表示请求文件的范围为0-32767。</p>
<h1 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h1><p>第一次服务器的HTTP响应报文如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /deepc.a HTTP/1.1</span><br><span class="line">Host: 192.168.1.3</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.14 Safari/537.36</span><br><span class="line">Accept: */*</span><br><span class="line">Referer: http://192.168.1.3/deepc.a</span><br><span class="line">Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</span><br><span class="line">Range: bytes=0-32767</span><br><span class="line"></span><br><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Date: Sun, 04 May 2014 05:14:54 GMT</span><br><span class="line">Server: Apache/2.4.4 (Win32) PHP/5.4.16</span><br><span class="line">Last-Modified: Sat, 03 May 2014 00:43:22 GMT</span><br><span class="line">ETag: &quot;7efce6-4f8742f6ed9b2&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 32768</span><br><span class="line">Content-Range: bytes 0-32767/8322278</span><br><span class="line">Keep-Alive: timeout=5, max=100</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>

<p>HTTP的状态为206，表示服务器已经处理了部分HTTP相应。其中Content-Range字段表示服务器已经响应了0-32767个字节的文件内容。8322278表示文件的总长度为8322278字节。</p>
<h1 id="客户端继续向服务器发送请求"><a href="#客户端继续向服务器发送请求" class="headerlink" title="客户端继续向服务器发送请求"></a>客户端继续向服务器发送请求</h1><p>客户端根据上次HTTP报文中服务器已经返回给的客户端的数据情况继续向服务器发送请求报文，向服务器发送的请求报文内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /deepc.a HTTP/1.1</span><br><span class="line">Host: 192.168.100.189</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.14 Safari/537.36</span><br><span class="line">Accept: */*</span><br><span class="line">Referer: http://192.168.100.189/deepc.a</span><br><span class="line">Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en;q=0.6</span><br><span class="line">Range: bytes=32768-8322277</span><br><span class="line">If-Range: &quot;7efce6-4f8742f6ed9b2&quot;</span><br><span class="line"></span><br><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Date: Sun, 04 May 2014 05:14:54 GMT</span><br><span class="line">Server: Apache/2.4.4 (Win32) PHP/5.4.16</span><br><span class="line">Last-Modified: Sat, 03 May 2014 00:43:22 GMT</span><br><span class="line">ETag: &quot;7efce6-4f8742f6ed9b2&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 8289510</span><br><span class="line">Content-Range: bytes 32768-8322277/8322278</span><br><span class="line">Keep-Alive: timeout=5, max=98</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>

<p>Content-Range的内容表示客户端向服务器请求文件中32768-8322277之间的字节数据。</p>
<h1 id="第二次服务器的HTTP响应报文如下："><a href="#第二次服务器的HTTP响应报文如下：" class="headerlink" title="第二次服务器的HTTP响应报文如下："></a>第二次服务器的HTTP响应报文如下：</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Date: Sun, 04 May 2014 05:14:54 GMT</span><br><span class="line">Server: Apache/2.4.4 (Win32) PHP/5.4.16</span><br><span class="line">Last-Modified: Sat, 03 May 2014 00:43:22 GMT</span><br><span class="line">ETag: &quot;7efce6-4f8742f6ed9b2&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 8289510</span><br><span class="line">Content-Range: bytes 32768-8322277/8322278</span><br><span class="line">Keep-Alive: timeout=5, max=98</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>

<p>表示服务器已经相应完成了32768-8322277之间的数据。</p>
]]></content>
  </entry>
  <entry>
    <title>大页内存</title>
    <url>/post/huge-page/</url>
    <content><![CDATA[<h2 id="大页内存介绍"><a href="#大页内存介绍" class="headerlink" title="大页内存介绍"></a>大页内存介绍</h2><p>一个操作系统上一台机器的物理内存是有限的，而操作系统上却运行着大量的进程，为了对进程屏蔽物理内存的差异，操作系统引入了虚拟内存的概念。Linux系统中虚拟内存是按照页的方式来进行管理的，每个页的默认大小为4K。如果物理内存非常大，就会导致虚拟内存和物理内存映射的页表（TLB）非常大。为了减少页表，一个可行的方法为增加页的大小。<br>​</p>
<p>可以通过如下命令来查看默认页大小：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">getconf</span> <span class="string">PAGE_SIZE</span></span><br><span class="line"><span class="number">4096</span></span><br></pre></td></tr></table></figure>
<p>在对内存要求特别严格的场景下，比如很多数据库的场景，都有巨页的需求，比如将页设置为1GB，甚至几十GB。<br>​</p>
<p>通常在大页内存的场景下，会将Linux的swap功能关闭，避免当页换出时导致的性能下降。<br>​</p>
<p>在Linux中Huge Page有2MB和1GB两种规则，其中2MB适用于GB级别的内存，1GB适用于TB级别的内存。<br>​</p>
<p>大页内存可以分为静态大页和透明大页两类。</p>
<ul>
<li>静态大页需要用户自行控制大页的分配、释放和使用。但该方式需要事先配置大页内存的量，因此用起来不够灵活。配置可以在系统启动的时候配置hugepages（页数量）和hugepagesz（页大小）两个参数。也可以使用修改内核参数的方式来预留。</li>
<li>透明大页由操作系统的后台内核线程khugepaged控制大页的分配、释放和使用。</li>
</ul>
<h2 id="静态大页内存操作"><a href="#静态大页内存操作" class="headerlink" title="静态大页内存操作"></a>静态大页内存操作</h2><p>预留大页内存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 20 &gt;  /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</span><br></pre></td></tr></table></figure>
<p>可以通过&#x2F;proc&#x2F;meminfo文件系统看到大页内存的使用情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/meminfo | grep Huge</span></span><br><span class="line">AnonHugePages:   2037760 kB</span><br><span class="line">HugePages_Total:      20 # 预先分配的大页数量</span><br><span class="line">HugePages_Free:       20 # 空闲大页数量</span><br><span class="line">HugePages_Rsvd:        0 </span><br><span class="line">HugePages_Surp:        0</span><br><span class="line">Hugepagesize:       2048 kB</span><br></pre></td></tr></table></figure>
<p>挂载hugetlb文件系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t hugetlbfs none /mnt/huge</span><br></pre></td></tr></table></figure>
<p>在应用程序中mmap映射hugetlb文件系统即可使用，对内存的操作类似于访问文件。</p>
<h2 id="透明大页内存操作（待补充）"><a href="#透明大页内存操作（待补充）" class="headerlink" title="透明大页内存操作（待补充）"></a>透明大页内存操作（待补充）</h2><p>cat &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled</p>
<h2 id="大页内存在k8s的支持情况"><a href="#大页内存在k8s的支持情况" class="headerlink" title="大页内存在k8s的支持情况"></a>大页内存在k8s的支持情况</h2><p>HugePage是k8s 1.9版本中引入的特性，1.10变为beta版本，1.23版本stable版本。k8s大于1.10版本该feature默认开启。</p>
<p>在节点上配置了大页内存后，kubelet会自动感知到大页内存的配置，会修改node配置。会在hugepages-2Mi中有对应的大页内存容量，memory字段会去掉对应的大页内存量。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">allocatable:</span></span><br><span class="line">  <span class="attr">cpu:</span> <span class="string">&quot;15&quot;</span></span><br><span class="line">  <span class="attr">ephemeral-storage:</span> <span class="string">41152812Ki</span></span><br><span class="line">  <span class="attr">hugepages-1Gi:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">  <span class="attr">hugepages-2Mi:</span> <span class="string">40Mi</span></span><br><span class="line">  <span class="attr">memory:</span> <span class="string">63998924Ki</span></span><br><span class="line">  <span class="attr">pods:</span> <span class="string">&quot;110&quot;</span></span><br><span class="line"><span class="attr">capacity:</span></span><br><span class="line">  <span class="attr">cpu:</span> <span class="string">&quot;16&quot;</span></span><br><span class="line">  <span class="attr">ephemeral-storage:</span> <span class="string">41152812Ki</span></span><br><span class="line">  <span class="attr">hugepages-1Gi:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">  <span class="attr">hugepages-2Mi:</span> <span class="string">40Mi</span></span><br><span class="line">  <span class="attr">memory:</span> <span class="string">64756684Ki</span></span><br><span class="line">  <span class="attr">pods:</span> <span class="string">&quot;110&quot;</span></span><br></pre></td></tr></table></figure>
<p>pod在使用大页内存的时候，需要以volume的方式挂载到pod中，pod对大页内存的使用跟普通文件系统相同。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux下网卡混杂模式</title>
    <url>/post/if-promiscuous/</url>
    <content><![CDATA[<p>网卡的混杂模式是指网卡将其接收的所有流量都交给cpu。非混杂模式下，网卡仅接收目的mac地址是自己mac地址的单播，以及多播和广播包，可以看出混杂模式是工作在二层的。</p>
<p>通过ifconfig eth0的方式，如果输出中包含了PROMISC字段，说明网卡处于混杂模式。但是如果ifconfig 命令的输出中未包含PROMISC字段，并不能说明网卡处于非混杂模式下。</p>
<p>可以通过查看 cat &#x2F;sys&#x2F;class&#x2F;net&#x2F;bond0&#x2F;flags 的输出得知，如果置位了0x100，说明处于混杂模式。</p>
]]></content>
  </entry>
  <entry>
    <title>深度探索C++对象模型读书笔记_第一章：关于对象</title>
    <url>/post/inside_the_c++_object_model_chapter_1/</url>
    <content><![CDATA[<p>C++对象模型是深入了解C++必须掌握知识，而《深度探索C++对象模型》一书基本是理解C++对象模型的必须之作。可惜本书看起来更像是作者Stanley B.Lippman的随笔，语言诙谐，跟作者的另外一本经典之作《C++ Primer》有着天壤之别，侯捷的翻译也是晦涩难懂，跟侯捷翻译的其他作品也有一定差距（这两位大师还真是凑到一块了），所以这本书看起来还是很吃力的。这里挑选文中重点记录笔记，忽略扯淡部分，以备忘。</p>
<h1 id="C-的额外开销"><a href="#C-的额外开销" class="headerlink" title="C++的额外开销"></a>C++的额外开销</h1><p>C++相比C语言多出了封装、继承和多态等特性，新特性的增加必然会以牺牲一部分性能为代价。额外开销主要是由virtual引起的，包括：</p>
<ul>
<li>虚函数机制：需要在运行期间动态绑定。</li>
<li>虚基类：多次出现在继承中的基类有一个单一且被共享的实体。</li>
</ul>
<h1 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h1><p>C++类成员变量包括：静态成员变量和非静态成员变量。成员函数包括：静态成员函数、非静态成员函数和虚函数。</p>
<h2 id="单一类的对象模型"><a href="#单一类的对象模型" class="headerlink" title="单一类的对象模型"></a>单一类的对象模型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Point</span>(<span class="type">float</span> xval);</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Point</span>();</span><br><span class="line">        <span class="function"><span class="type">float</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span></span>;            <span class="comment">/* 非静态成员函数 */</span>                                                                                                                         </span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">PointCount</span><span class="params">()</span></span>;    <span class="comment">/* 静态成员函数 */</span>  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span></span>;  <span class="comment">/* 虚函数 */</span>  </span><br><span class="line">        <span class="type">float</span> _x;                   <span class="comment">/* 非静态成员变量 */</span>  </span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> _point_count;    <span class="comment">/* 静态成员函数 */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类的c++对象模型如下图：<br><img src="/ref/c++/c++_object_model/chapter1_1.PNG" alt="Image Title"></p>
<p>通过图中可以看出：</p>
<ul>
<li>非静态数据成员直接放到了类的对象里面。</li>
<li>静态数据成员放到所有的类对象的外面，即静态存储区。</li>
<li>静态和非静态的成员函数放在类对象之外，即代码区。</li>
<li>如果类中存在虚函数，则会产生一个虚函数表（vtbl），表中的表项存储了指向虚函数的指针。在类对象的开始位置添加一个指向虚函数表的指针（vptr）。vptr的赋值由类的构造函数和赋值运算符自动完成。</li>
<li>虚函数表的第一项指向用来作为动态类型识别用的type_info对象。</li>
</ul>
<h1 id="C-支持的编程范式-programming-paradigms"><a href="#C-支持的编程范式-programming-paradigms" class="headerlink" title="C++支持的编程范式(programming paradigms)"></a>C++支持的编程范式(programming paradigms)</h1><ul>
<li>程序模型：通俗的理解成C语言的面向过程编程方式。</li>
<li>抽象数据类型模型：通过类封装成为了一种新的数据类型，该数据类型有别于基本数据类型。</li>
<li>面向对象模型：利用封装、继承和多态的特性。</li>
</ul>
<h1 id="C-支持多态的方式"><a href="#C-支持多态的方式" class="headerlink" title="C++支持多态的方式"></a>C++支持多态的方式</h1><ul>
<li>隐含的转换操作，例如通过父类的指针指向子类的对象。<code>shape *ps = new circle();</code></li>
<li>通过虚函数机制。</li>
<li>通过dynamic_cast强制类型转换。如<code>if (circle *pc = dynamic_cast&lt;circle*&gt;(ps))</code>。</li>
</ul>
<h1 id="类对象的内存构成"><a href="#类对象的内存构成" class="headerlink" title="类对象的内存构成"></a>类对象的内存构成</h1><ul>
<li>非静态数据成员。</li>
<li>由于内存对齐而添加到非静态数据成员中的空白。</li>
<li>为了支持虚机制（包括：虚函数和虚继承）而额外占用的内存。</li>
</ul>
<h1 id="利用工具查看对象模型"><a href="#利用工具查看对象模型" class="headerlink" title="利用工具查看对象模型"></a>利用工具查看对象模型</h1><p>查看C++类的对象模型有两种比较简便的方式，一种是使用Virtual Studio在调试模式下查看对象的组成，但是往往显示的对象不全;另外一种是通过Virtual Studio中cl命令来静态查看。</p>
<p>本文选择使用cl工具的方式，cl命令位于C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\bin目录下，为了方便使用可以将该变量添加到Path环境变量中。在命令行中执行cl命令，提示“计算机中丢失mspdb80.dll”，该文件位于C:\Program Files (x86)\Microsoft Visual Studio 9.0\Common7\IDE目录下，将msobj80.dll,mspdb80.dll,mspdbcore.dll,mspdbsrv.exe四个文件复制到C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\bin目录下即可。</p>
<p>通过<code>cl xxx.cpp /d1reportSingleClassLayoutXX</code>命令即可查看文件中类的对象模型，其中该命令最后的XX需要更换为要查看的类名，中间没有空格。</p>
<p>执行上述命令时提示：无法打开文件“LIBCMT.lib”。该文件位于C:\Program Files (x86)\Microsoft Visual Studio 9.0\VC\lib目录下，将该目录添加到环境变量lib中。重新打开命令行执行cl提示：无法打开文件“kernel32.lib”，将C:\Program Files\Microsoft SDKs\Windows\v6.0A\Lib添加lib环境变量中。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>深度探索C++对象模型读书笔记_第二章：构造函数语义学</title>
    <url>/post/inside_the_c++_object_model_chapter_2/</url>
    <content><![CDATA[<h1 id="2-1-默认构造函数的生成"><a href="#2-1-默认构造函数的生成" class="headerlink" title="2.1 默认构造函数的生成"></a>2.1 默认构造函数的生成</h1><p>只有当编译器需要默认构造函数的时候才会合成默认构造函数，并不是类只要没有定义默认构造函数编译器就会合成默认构造函数，而是只有以下四种情况编译器会生成默认构造函数。编译器合成的默认构造函数仅会处理类的基类对象和类中的数据成员对象，对于类中的普通类型的非静态数据成员并不会作任何处理。比如类中一个指针类型的数据成员，编译器合成的默认构造函数不会对该指针作任何处理，该指针就是一个野指针。</p>
<h2 id="带有默认构造函数的类成员对象"><a href="#带有默认构造函数的类成员对象" class="headerlink" title="带有默认构造函数的类成员对象"></a>带有默认构造函数的类成员对象</h2><p>一个类没有定义任何构造函数，该类中包含了一个带有默认构造函数（包括了合成的默认构造函数和定义的默认构造函数）的类成员对象，那么编译器需要为此类合成一个默认构造函数，合成默认构造函数的时机为该构造函数被调用时。合成的默认构造函数默认为内联函数，如果不适合使用内联函数，就合成explicit static的构造函数。</p>
<p>默认构造函数、复制构造函数和赋值操作符的生成都是inline。inline函数有静态链接，不会被当前文件之外的文件看到。如果函数过于复杂不适合生成inline函数，会生成一个explicit non_inline static实体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dopey</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Dopey</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneezy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Sneezy</span>(<span class="type">int</span>);</span><br><span class="line">	<span class="built_in">Sneezy</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bashful</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bashful</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snow_White</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dopey dopey;</span><br><span class="line">	Sneezy sneezy;</span><br><span class="line">	Bashful bashful;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mumble;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Snow_White snow_white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，foo()中需要调用Bashful的构造函数，编译器会为Bar类生成内联的默认构造函数。Bashful类会生成类似于下面的默认构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Bar::Bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dopey.Dopey::<span class="built_in">Dopey</span>();</span><br><span class="line">    sneezy.Sneezy::<span class="built_in">Sneezy</span>();</span><br><span class="line">    bashful.Bashful::<span class="built_in">Bashful</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认构造函数的生成原则为：如果类A中包含了一个或一个以上的类成员对象，那么类A的默认构造函数必须调用每一个类成员的默认构造函数。但是不会初始化普通类型的变量，因此在上例中必须手动初始化mumble变量。在编译器合成的默认构造函数中类成员变量的默认构造函数的调用次序为成员变量在类中的声明顺序，该顺序和类成员的构造函数初始化列表顺序是一致的。</p>
<p>如果Snow_White类定义了如下的默认构造函数，则编译器会自动在定义的构造函数中增加调用类成员变量的代码，调用类成员变量相应构造函数的顺序仍然和类成员变量在类中的声明顺序一致。</p>
<p>从中可以看出类成员变量的构造函数的调用要早于类构造函数的调用，这一点是在很多面试题中经常会见到的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义的默认构造函数，包含了类成员变量sneezy的初始化列表</span></span><br><span class="line">Snow_White::<span class="built_in">Snow_White</span>() : <span class="built_in">sneezy</span>(<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">	mumble = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器扩张后的默认构造函数</span></span><br><span class="line">Snow_White::<span class="built_in">Snow_White</span>() : <span class="built_in">sneezy</span>(<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">	dopey.Dopey::<span class="built_in">Dopey</span>();           <span class="comment">// 调用默认构造函数</span></span><br><span class="line">	sneezy.Sneezy::<span class="built_in">Sneezy</span>(<span class="number">1024</span>);    <span class="comment">// 自动调用合适的构造函数</span></span><br><span class="line">	bashful.Bashful::<span class="built_in">Bashful</span>();</span><br><span class="line">	mumble = <span class="number">2048</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带有默认构造函数的基类"><a href="#带有默认构造函数的基类" class="headerlink" title="带有默认构造函数的基类"></a>带有默认构造函数的基类</h2><p>在继承机制中，一个没有构造函数的子类继承自带有默认构造函数的基类，则子类的构造函数会被合成，并且会调用基类的默认构造函数。若子类没有定义默认构造函数，却定义了多个带参数的构造函数，编译器会扩张所有自定义的构造函数，将调用基类默认构造函数的代码添加到子类的构造函数的最前面。</p>
<p>从这里可以看出继承机制中，首先构造基类，后构造子类，这点也是面试题中经常遇到的。</p>
<h2 id="带有虚函数的类"><a href="#带有虚函数的类" class="headerlink" title="带有虚函数的类"></a>带有虚函数的类</h2><p>为了实现虚函数或虚继承机制，编译器需要为每一个类对象设定vptr（指向虚函数表的指针）的初始值，使其指向一个vtbl（虚函数表）的地址。如果类包含构造函数则编译器会生成一些代码来完成此工作；如果类没有任何构造函数，则编译器会在合成的默认构造函数中添加代码来完成此工作。</p>
<h2 id="带有虚基类的类"><a href="#带有虚基类的类" class="headerlink" title="带有虚基类的类"></a>带有虚基类的类</h2><p>需要维护内部指针来实现虚继承。</p>
<h1 id="2-2-复制构造函数的生成"><a href="#2-2-复制构造函数的生成" class="headerlink" title="2.2 复制构造函数的生成"></a>2.2 复制构造函数的生成</h1><p>复制构造函数被调用有三种情况：</p>
<ul>
<li>明确的一个对象的内容作为另外一个对象的初始值。如X xx &#x3D; x或X xx(x)。</li>
<li>对象作为参数传递给函数时。</li>
<li>类对象作为函数返回值时。</li>
</ul>
<h2 id="合成复制构造函数的情况"><a href="#合成复制构造函数的情况" class="headerlink" title="合成复制构造函数的情况"></a>合成复制构造函数的情况</h2><p>如果一个类没有提供显式的复制构造函数，同默认构造函数一样，只有编译器认为需要合成复制构造函数时，编译器才会合成一个。那么问题来了，什么时候编译器才合成复制构造函数呢？书中给出的答案为当一个类不展现出_bitwise copy semantics_<sup>1</sup>的时候。具体来说有以下四种情况，跟类的默认构造函数的合成基本一致。</p>
<ul>
<li>当类内包含一个类成员变量且类成员变量声明了复制构造函数。</li>
<li>当类继承的基类有复制构造函数（复制构造函数可以是显示声明或合成的）</li>
<li>一个类中包含了一个或多个虚函数</li>
<li>类继承自一个或多个虚基类</li>
</ul>
<p>其中前面两种情况必须将成员变量或基类的复制构造函数的调用插入到合成的复制构造函数中，因此不是按照按比特复制的。第三和第四点分别用下面两小节来说明。</p>
<h2 id="重新设定虚函数表的指针"><a href="#重新设定虚函数表的指针" class="headerlink" title="重新设定虚函数表的指针"></a>重新设定虚函数表的指针</h2><p>当编译器需要在类对象中设定一个指向虚函数表的指针时，该类就不能再使用按位复制的复制构造函数了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ZooAnimal</span>();</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">ZooAnimal</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bear</span> : <span class="keyword">public</span> ZooAnimal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bear</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// yogi的vptr指向Bear的虚函数表</span></span><br><span class="line">	Bear yogi;</span><br><span class="line">	<span class="comment">// franny的vptr指向ZooAnimal的虚函数表</span></span><br><span class="line">	ZooAnimal franny = yogi;</span><br><span class="line">	<span class="built_in">draw</span>(yogi);	<span class="comment">// 调用Bear::draw()</span></span><br><span class="line">	<span class="built_in">draw</span>(franny);	<span class="comment">// 调用ZooAnimal::draw()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/ref/c++/c++_object_model/chapter2_1.PNG" alt="Image Title"></p>
<p>合成出来的ZooAnimal的复制构造函数会明确设定对象的vptr指向ZooAnimal的虚函数表，而不是从右值中复制过来的值。</p>
<h2 id="处理virtual-base-class-subobjects"><a href="#处理virtual-base-class-subobjects" class="headerlink" title="处理virtual base class subobjects"></a>处理virtual base class subobjects</h2><p>虚基类的存在需要特别处理，一个类对象如果以另外一个类对象作为初始值，而后者有一个virtual base class subobjects，也会使按比特复制的复制构造函数失效。</p>
<p>每一个编译器都必须让派生的类对象的virtual base class subobjects位置在执行期准备完毕。按比特复制的复制构造函数可能会破坏virtual base class subobjects的位置，因此编译器必须在自己合成出来的复制构造函数中修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ZooAnimal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZooAnimal</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ZooAnimal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">animate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Raccoon</span> : <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Raccoon</span>();</span><br><span class="line">    <span class="built_in">Raccoon</span>(<span class="type">int</span> val);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedPanda</span> : <span class="keyword">public</span> Raccoon</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RedPanda</span>();</span><br><span class="line">    <span class="built_in">RedPanda</span>(<span class="type">int</span> val);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>文章的内容没有完全理解，虚继承机制使用较少，可以暂时不用理解。</p>
<h1 id="2-3-程序转化语意学"><a href="#2-3-程序转化语意学" class="headerlink" title="2.3 程序转化语意学"></a>2.3 程序转化语意学</h1><p>本节涉及到了编译器优化的相关细节，由于较容易理解，可以直接看书上内容，对工作帮助不大。包括类对象的初始化优化，函数参数的初始化优化，函数返回值的初始化优化，使用者层面的优化和编译器层面的优化。</p>
<p>如果不是上节指定的四种情况，不需要显示的声明复制构造函数，因为显示的声明的复制构造函数往往效率不如编译器合成的复制构造函数效率高。编译器合成的复制构造函数利用memcpy()或memset()函数来合成，效率最高。</p>
<h1 id="2-4-类成员的初始化列表"><a href="#2-4-类成员的初始化列表" class="headerlink" title="2.4 类成员的初始化列表"></a>2.4 类成员的初始化列表</h1><p>说到类成员的初始化列表必然想起一个经常出现的面试题：成员初始化列表的顺序是按照成员变量在类中声明的顺序。如果成员初始化列表的顺序和成员变量在类中声明的顺序不一致时某些编译器会提示警告。编译器将成员初始化列表的代码插入到构造函数的最开始位置，优先级跟调用类类型的成员变量的默认构造函数是一致的，都是跟类类型成员变量在类中的声明次序相关。</p>
<p>类成员初始化必须使用成员初始化列表的四种方式：</p>
<ul>
<li>初始化一个引用类型的成员变量</li>
<li>初始化一个const的成员变量</li>
<li>调用基类的构造函数，且基类的构造函数采用成员初始化列表的方式</li>
<li>调用类成员的构造函数，且类成员的构造函数采用成员初始化列表的方式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Word</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="built_in">Word</span>()</span><br><span class="line">	 &#123;</span><br><span class="line">	 	_name = <span class="number">0</span>;</span><br><span class="line">	 	_cnt = <span class="number">0</span>;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	String _name;</span><br><span class="line">	<span class="type">int</span> _cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此例子在构造函数中对成员变量进行测试，编译器对构造函数的扩张方式可能会生成如下的伪码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Word::<span class="built_in">Word</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_name.String::<span class="built_in">String</span>();</span><br><span class="line">	String temp = <span class="built_in">String</span>(<span class="number">0</span>);</span><br><span class="line">	_name.String::<span class="keyword">operator</span>=(temp);</span><br><span class="line">	temp.String::~<span class="built_in">String</span>();</span><br><span class="line">	_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数中生成了一个临时性的String对象，这浪费了一部分开销。如果将构造函数该成如下的定义方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Word</span>() : _name(<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> 	_cnt = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>即将其中的类成员变量更改为成员初始化列表的方式来初始化，编译器会自动将构造函数扩张为如下方式，这样减少了临时对象，提供了程序效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Word::<span class="built_in">Word</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_name.String::<span class="built_in">String</span>(<span class="number">0</span>);</span><br><span class="line">	_cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h1><p>下面例子是对本章内容的一个简单概况，也是面试题中经常碰到的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;                                                                                                                                                                           </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A\n&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;~A\n&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B_%d\n&quot;</span>, n); </span><br><span class="line">    &#125;   </span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;~B\n&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Base\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;~Base\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() : _m(<span class="number">1</span>), _b(_m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Derived\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;~Derived\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面两个类类型的成员遍历的构造函数的调用次序跟在类中的声明次序是相关的</span></span><br><span class="line">    B _b;   <span class="comment">// 类类型的类成员变量，初始化列表中包含该变量</span></span><br><span class="line">    A _a;   <span class="comment">// 类类型的类成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用基类的构造函数-&gt;调用子类类类型成员变量的构造函数-&gt;调用子类的构造函数</span></span><br><span class="line">    Derived derived;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据栈的特点，类析构的次序跟构造是相反的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码执行的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Base</span><br><span class="line">B_1</span><br><span class="line">A</span><br><span class="line">Derived</span><br><span class="line">~Derived</span><br><span class="line">~A</span><br><span class="line">~B</span><br><span class="line">~Base</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本章讲述了合成的默认构造函数、合成的复制构造函数和构造函数的成员初始化列表。其中如果类没有定义默认构造函数，只有在文中提到的四种情况下编译器才会合成默认构造函数。合成的复制构造函数在需要的时候编译器就会生成，默认是按对象比特复制的方式实现，有四种情况下编译器是不按照比特复制的方式。</p>
<hr>
<p>[1] bitwise copy semantics书中翻译为“位逐次拷贝”，就是按照内存中的字节进行复制类，感觉翻译不如不翻译好理解。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>深度探索C++对象模型读书笔记_第三章：数据语意学</title>
    <url>/post/inside_the_c++_object_model_chapter_3/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class X &#123;&#125;;</span><br><span class="line">class Y : public virtual X &#123;&#125;;</span><br><span class="line">class Z : public virtual X &#123;&#125;;</span><br><span class="line">class A : public Y, public Z &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>对于上述代码我在vs2008中的实验结果，X的大小为1，Y和Z的大小为4，A的大小为8。X的大小为1是因为编译器给空类了1字节的空间。Y和Z的大小为4是因为内部包含一个vbptr（指向虚基类的指针）占用了4个字节。A的大小包含了两个vbptr，分别指向虚基类的指针X。利用<code>cl main.cpp /d1reportSingleClassLayoutA </code>命令可以查看对象的内存布局，利用vs2008调试界面查看对象的内存布局往往是不全的，不推荐采用此种方式。下面为A的类布局。<br><img src="/ref/c++/c++_object_model/chapter3_1.PNG" alt="Image Title"></p>
<p>在64位的linux的g++下测试X、Y、Z、A的大小分别为1、8、8、16，这是因为指针的大小为8个字节。</p>
<p>一个类占用的空间比类本身非静态数据成员空间大的原因有如下两点：</p>
<ul>
<li>编译器自动加上额外的数据成员，用来支持某些语言特性，例如virtual特性。</li>
<li>内存边界调整的需要</li>
</ul>
<h1 id="3-1-数据成员的绑定"><a href="#3-1-数据成员的绑定" class="headerlink" title="3.1 数据成员的绑定"></a>3.1 数据成员的绑定</h1><p>味同嚼蜡的章节。</p>
<h1 id="3-2-数据成员的布局"><a href="#3-2-数据成员的布局" class="headerlink" title="3.2 数据成员的布局"></a>3.2 数据成员的布局</h1><p>数据成员在内存中的布局顺序跟数据成员在类中的声明顺序是一致的，而且现在的编译器都不关心数据成员在类中是public、protected还是private的。</p>
<p>为了内存对齐，编译器在变量之间插入了空白字节，不同的编译器内存对齐的原则并不一致。</p>
<p>为了实现虚函数机制，编译器插入了vptr成员变量。</p>
<p>以上这些内容，本章节并没有展开详解。</p>
<h1 id="3-3-数据成员变量的存取"><a href="#3-3-数据成员变量的存取" class="headerlink" title="3.3 数据成员变量的存取"></a>3.3 数据成员变量的存取</h1><p>数据成员包括静态数据成员和非静态数据成员。</p>
<p>静态数据成员变量放在静态存储区，不会造成任何空间或执行时间上的浪费。</p>
<p>对于非静态数据成员，无论成员变量是struct数据成员、类数据成员、单一继承、多重继承情况下执行效率完全一样。执行效率较静态数据成员变量稍低。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class  Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	 int a;</span><br><span class="line">	 int b;</span><br><span class="line">	 int c;</span><br><span class="line">&#125;;</span><br><span class="line">Test test;</span><br></pre></td></tr></table></figure>

<p>在上述例子中要想读取test.c的位置，编译器需要执行类似这样的操作：<code>&amp;test + &amp;Test::c</code>，可以看出对类中变量的存取成本多了一个算数运算。</p>
<p>对于虚拟继承的情况由于需要在运行期才能决定存取操作，需要一些额外的成本，在下文讨论。</p>
<h1 id="3-4-继承与数据成员"><a href="#3-4-继承与数据成员" class="headerlink" title="3.4 继承与数据成员"></a>3.4 继承与数据成员</h1><p>如果类中不包含继承机制，则数据成员的布局和struct中数据成员的布局是一致的。</p>
<p>本节将从单一继承但不包含虚函数、单一继承包含虚函数、多重继承、虚拟继承四个方面讨论数据成员变量。陈浩有几篇博文对此进行了详细的解释，比书上内容要易懂和全面，这几篇文章必看。</p>
<ul>
<li><a href="http://blog.csdn.net/haoel/article/details/1948051">C++ 虚函数表解析</a></li>
<li><a href="http://blog.csdn.net/haoel/article/details/3081328">C++ 对象的内存布局(上)</a></li>
<li><a href="http://blog.csdn.net/haoel/article/details/3081385">C++ 对象的内存布局(下)</a></li>
</ul>
<h2 id="单一继承且不包含虚函数"><a href="#单一继承且不包含虚函数" class="headerlink" title="单一继承且不包含虚函数"></a>单一继承且不包含虚函数</h2><p>书中举例解释了为什么类继承时类成员之间的填补空白会比单个类时要多，下图的内存布局图中Concrete3继承自Concrete2，Concrete2继承自Concrete1。Concrete3类占用的空间大小为：bit1占用的1个字节+3个字节的空白，bit2占用的1字节+3字节的空白，bit3占用的1字节+3字节空白。如果Concrete3不继承自任何对象，而是包含bit1、bit2、bit3三个变量，占用的空间大小为1+1+1+1&#x3D;4。</p>
<p><img src="/ref/c++/c++_object_model/chapter3_2.PNG" alt="Image Title"></p>
<p>之所以编译器在继承机制中会作如此处理，是为了在继承机制中对象之间的默认按比特复制操作更方便。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Concrete1 *p1 = <span class="keyword">new</span> Concrete1, *p2 = <span class="keyword">new</span> Concrete2;</span><br><span class="line">*p2 = *p1;	<span class="comment">// 此时编译器只需要按比特复制就可以了</span></span><br></pre></td></tr></table></figure>

<h2 id="单一继承包含虚函数"><a href="#单一继承包含虚函数" class="headerlink" title="单一继承包含虚函数"></a>单一继承包含虚函数</h2><p>假设有如下类定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Base\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Base\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="type">int</span> base_x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derived</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Derived\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Derived</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Derived\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> derived_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>则Derived类的对象模型如下，通过图可以非常清晰的理解单一继承包含虚函数的情况：</p>
<p><img src="http://kuring.qiniudn.com/inside_the_c++_object_model_3_1.PNG" alt="单一继承包含虚函数的对象模型"></p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Base1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Base1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="type">int</span> base1_x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Base2\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Base2\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">base2_not_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="type">int</span> base2_x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derived</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Derived\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Derived</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Derived\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">derived_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">base1_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> derived_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>则Vertex3d类的对象模型如下，同样通过图可以非常清晰的理解多重继承的情况：</p>
<p><img src="http://kuring.qiniudn.com/inside_the_c++_object_model_3_2.PNG" alt="多重继承"></p>
<h2 id="重复继承"><a href="#重复继承" class="headerlink" title="重复继承"></a>重复继承</h2><p>书中并没有涉及到重复继承，重复继承是指某个基类被间接重复继承了多次，属于重复继承和钻石级多重虚拟继承的过渡情况，有必要说明一下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">base_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="type">int</span> base_x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Base1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Base1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="type">int</span> base1_x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Base2\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Base2\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">base2_not_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="type">int</span> base2_x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derived</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Derived\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Derived</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Derived\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">derived_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">base1_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> derived_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过下图的对象模型可以看出，重复继承的类Base在Derived的实例中存在两份，要想直接更改Base类中的base_x变量的值，不能通过<code>derived.base_x = 1</code>直接赋值的方式，需要调用<code>derived.Base1::base_x = 1</code>的方式来更改，更改后的效果仅更改了Base1对象对应的Base类实例中的base_x的值。</p>
<p><img src="http://kuring.qiniudn.com/inside_the_c++_object_model_3_3.PNG" alt="重复继承"></p>
<h2 id="钻石型多重虚拟继承"><a href="#钻石型多重虚拟继承" class="headerlink" title="钻石型多重虚拟继承"></a>钻石型多重虚拟继承</h2><p>该种方式的继承已经是所有继承中最为复杂的了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base_virtual_func</span><span class="params">()</span> </span>&#123;&#125;	<span class="comment">// 虚基类最好是不再提供虚函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">base_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="type">int</span> base_x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Base1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Base1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="type">int</span> base1_x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Base2\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Base2\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//virtual void base_virtual_func() &#123;&#125;	// 由于是虚拟继承，不再能重复重载父类的虚函数了</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">base2_not_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="type">int</span> base2_x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derived</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Derived\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Derived</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;~Derived\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">derived_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">base1_virtual_func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> derived_y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在下图标出的区域中，我认为Base应该是不存在的，这里只是vs2013为了展示的考虑而添加上的。虚拟继承基类Base位于Derived类对象的除该成员外的最后位置。</p>
<p><img src="http://kuring.qiniudn.com/inside_the_c++_object_model_3_4.PNG" alt="虚拟继承"></p>
<h1 id="对象成员的效率"><a href="#对象成员的效率" class="headerlink" title="对象成员的效率"></a>对象成员的效率</h1><p>作者经过试验测试，继承下的类成员读写效率跟读写普通变量效率相差不大，虚拟继承对程序的读写效率有影响。这跟理论上相差不大。</p>
<h1 id="指向数据成员的指针"><a href="#指向数据成员的指针" class="headerlink" title="指向数据成员的指针"></a>指向数据成员的指针</h1><p>小技巧：可以通过<code>&amp;类名::变量名</code>的语法来获取类成员变量在类对象中的位置，即相对于类对象起始地址的偏移量。</p>
<p>书中后面的内容个人感觉没有必要看了。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>深度探索C++对象模型读书笔记_第四章：函数语意学</title>
    <url>/post/inside_the_c++_object_model_chapter_4/</url>
    <content><![CDATA[<h1 id="成员函数的各种调用方式"><a href="#成员函数的各种调用方式" class="headerlink" title="成员函数的各种调用方式"></a>成员函数的各种调用方式</h1><h2 id="非静态成员函数的调用方式"><a href="#非静态成员函数的调用方式" class="headerlink" title="非静态成员函数的调用方式"></a>非静态成员函数的调用方式</h2><p>在C++中必须要保证类的非静态成员函数必须和非成员函数的执行效率一致，在编译的过程中，编译期已经将类的非静态成员函数编译为了非成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	   <span class="keyword">return</span> a + size;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="type">int</span> a;</span><br><span class="line">	 <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述Test类中，编译器会在编译阶段对类中的成员函数做一些转换。下面列出了编译器可能会做出的变换，不同的编译器实现不太一致。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_TestFv</span><span class="params">(<span class="type">const</span> Test * <span class="type">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a + <span class="keyword">this</span>-&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_TestFv</span><span class="params">(Test * <span class="type">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add_Testi</span><span class="params">(<span class="type">int</span> size, Test * <span class="type">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;a + size;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>通过上面的变换可以总结出如下规律：</p>
<ul>
<li>将成员函数重新改写为一个外部函数，并且对函数的名字进行处理，使在程序中唯一。一种可能的处理办法就是将函数名更改为：函数名_类名_函数参数。这样即解决了类之间函数名相同的问题，又解决了类之间函数重载的问题。</li>
<li>在函数的参数末尾添加额外的this指针参数。对于const函数添加的this指针为双const类型，对于非const函数则添加的this指针为指向的内容可变的const指针。</li>
<li>在函数内对成员函数的存取采用this指针来实现。</li>
</ul>
<h2 id="虚成员函数"><a href="#虚成员函数" class="headerlink" title="虚成员函数"></a>虚成员函数</h2><p>虚函数如果是通过指针类型访问，需要在运行时动态决定指针指向的类型，因此需要访问虚函数表才能够获取正确的虚函数地址。访问虚函数的方式为<code>(*ptr-&gt;vptr[i])(ptr)</code>，其中i代表要调用的虚函数在虚函数表中的索引，最后一个ptr代表要调用虚函数的编译器添加的this指针参数。</p>
<p>关于虚成员函数的更详细问题会在下一个节中进行讨论。</p>
<h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>静态成员函数中没有this指针，可以理解成带类作用域的全局函数，执行效率跟全局函数一致。</p>
<h1 id="虚成员函数-1"><a href="#虚成员函数-1" class="headerlink" title="虚成员函数"></a>虚成员函数</h1><p>这部分内容是本书的核心内容，可以参考陈皓的博客相关文章，已经对C++中的虚成员函数和虚成员变量进行了说明。</p>
<ul>
<li><a href="http://blog.csdn.net/haoel/article/details/1948051">C++ 虚函数表解析</a></li>
<li><a href="http://blog.csdn.net/haoel/article/details/3081328">C++ 对象的内存布局(上)</a></li>
<li><a href="http://blog.csdn.net/haoel/article/details/3081385">C++ 对象的内存布局(下)</a></li>
</ul>
<h2 id="单一继承下的虚函数"><a href="#单一继承下的虚函数" class="headerlink" title="单一继承下的虚函数"></a>单一继承下的虚函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Point</span>()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Point&amp; <span class="title">mult</span><span class="params">(<span class="type">float</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> _x;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">y</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">z</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">float</span> x=<span class="number">0.0</span>) &#123;_x = x;&#125;</span><br><span class="line">	<span class="type">float</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2d</span> : <span class="keyword">public</span> Point</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Point2d</span>(<span class="type">float</span> x=<span class="number">0.0</span>, <span class="type">float</span> y=<span class="number">0.0</span>) : <span class="built_in">Point</span>(x), _y(y) &#123;&#125;</span><br><span class="line">	~<span class="built_in">Point2d</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Point2d&amp; <span class="title">mult</span><span class="params">(<span class="type">float</span>)</span></span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">y</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> _y;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">float</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point3d</span> : <span class="keyword">public</span> Point2d</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Point3d</span>(<span class="type">float</span> x=<span class="number">0.0</span>, <span class="type">float</span> y=<span class="number">0.0</span>, <span class="type">float</span> z=<span class="number">0.0</span>) : <span class="built_in">Point2d</span>(x, y), _z(z) &#123;&#125;</span><br><span class="line">	~<span class="built_in">Point3d</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Point3d &amp; <span class="title">mult</span><span class="params">(<span class="type">float</span>)</span> </span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">z</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> _z;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>三个类对应的虚函数表会转化成下图</p>
<p><img src="/ref/c++/c++_object_model/chapter4_1.PNG" alt="Image Title"></p>
<p>通过图中可以看出每个函数在虚函数表中的位置无论在基类还是在子类中位置总是固定的。图中的Point的实例应该是不存在的，因为类中含有纯虚函数mult。</p>
<p>要想调用ptr-&gt;z()就变得非常容易，可以在编译器就可以确定虚函数的调用。虽然ptr所指向的对象在编译器并不能确定，但是编译器可以将其转化成为(*ptr-&gt;vptr[4])(ptr)。因为z()函数总是在虚函数表中的第四个位置，唯一需要在执行期确定的就是ptr所指的对象的实际类型。</p>
<h2 id="多重继承下的虚函数"><a href="#多重继承下的虚函数" class="headerlink" title="多重继承下的虚函数"></a>多重继承下的虚函数</h2><p>避免重复造轮子，参考上面博文。</p>
<h2 id="虚拟继承下的虚函数"><a href="#虚拟继承下的虚函数" class="headerlink" title="虚拟继承下的虚函数"></a>虚拟继承下的虚函数</h2><p>避免重复造轮子，参考上面博文。</p>
<h1 id="函数的效率"><a href="#函数的效率" class="headerlink" title="函数的效率"></a>函数的效率</h1><p>非成员函数、静态成员函数、非静态成员函数都被转换成为了完全相同的形式。<br>inline函数的执行效率最高。<br>虚函数的效率最低。</p>
<h1 id="指向成员函数的指针"><a href="#指向成员函数的指针" class="headerlink" title="指向成员函数的指针"></a>指向成员函数的指针</h1><p>这里学习到一个新的语法，之前没有接触过。即指向类成员函数的指针及使用方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	virtual ~Point() &#123;&#125;</span><br><span class="line">	float x() &#123;return _x;&#125;</span><br><span class="line">public:</span><br><span class="line">	Point(float x=0.0)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = x;</span><br><span class="line">	&#125;</span><br><span class="line">	float _x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Point point(1.0);</span><br><span class="line">	float (Point::*p)();   // 定义指向成员函数的指针</span><br><span class="line">	p = &amp;Point::x;        // 为指向成员函数的指针赋值</span><br><span class="line">	cout &lt;&lt; (point.*p)();  // 调用指向类成员函数的指针</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果成员函数的指针并不用于虚函数、多重继承、虚基类等情况，则成员函数的指针效率跟非成员函数指针的效率一致。</p>
<h2 id="指向虚成员函数的指针"><a href="#指向虚成员函数的指针" class="headerlink" title="指向虚成员函数的指针"></a>指向虚成员函数的指针</h2><p>书中对于函数取地址的语法在gcc和vs2008下我试验不成功，语法错误。</p>
<h2 id="多重继承下指向成员函数的指针"><a href="#多重继承下指向成员函数的指针" class="headerlink" title="多重继承下指向成员函数的指针"></a>多重继承下指向成员函数的指针</h2><p>依赖于编译器的实现，用到的情况比较少，没仔细看。</p>
<h2 id="指向成员函数指针的效率"><a href="#指向成员函数指针的效率" class="headerlink" title="指向成员函数指针的效率"></a>指向成员函数指针的效率</h2><p>在引入了虚函数、多重继承、虚基类等情况后，指向成员函数的指针效率有所下降。</p>
<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><p>内联只是一个请求，编译器并不一定会将函数内联的展开。</p>
<h2 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h2><p>内联时每一个形参都会被对应的实参取代。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i &lt; j ? i : j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> minval;</span><br><span class="line">	<span class="type">int</span> val1 = <span class="number">1024</span>;</span><br><span class="line">	<span class="type">int</span> val2 = <span class="number">2048</span>;</span><br><span class="line">	minval = <span class="built_in">min</span>(val1, val2);</span><br><span class="line">	minval = <span class="built_in">min</span>(<span class="number">1024</span>, <span class="number">2048</span>);</span><br><span class="line">	minval = <span class="built_in">min</span>(<span class="built_in">foo</span>(), <span class="built_in">bar</span>() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>minval=min(val1, val2)</code>会被内联展开成<code>minval = val1 &lt; val2 ? val1 : val2</code>。<br><code>minval = min(1024, 2048)</code>会被扩展为<code>minval = 1024</code>。<br><code>minval = min(foo(), bar() + 1)</code>需要引入临时对象，被扩展为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int t1;</span><br><span class="line">int t2;</span><br><span class="line">minval = (t1 = foo()) , (t2 = bar() + 1), t1 &lt; t2 ? t1 : t2;</span><br></pre></td></tr></table></figure>

<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> minval = i &lt; j ? i : j;</span><br><span class="line">	<span class="keyword">return</span> minval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> minval;</span><br><span class="line">	<span class="type">int</span> val1 = <span class="number">1024</span>;</span><br><span class="line">	<span class="type">int</span> val2 = <span class="number">2048</span>;</span><br><span class="line">	minval = <span class="built_in">min</span>(val1, val2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内联函数中引入局部变量，内联函数在内联的时候局部变量会拥有一个唯一的名称。代码中的<code>minval = min(val1, val2)</code>会被内联为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _min_lv_minval;</span><br><span class="line">minval = (_min_lv_minval = val1 &lt; val2 ? val1 : val2), _min_lv_minval;</span><br></pre></td></tr></table></figure>

<p>内联函数可以代替C语言中的#define宏定义，但是当内联函数调用次数过多，会产生大量的扩展代码，使程序的大小变大。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>深度探索C++对象模型读书笔记_第五章：构造、析构、复制语意学</title>
    <url>/post/inside_the_c++_object_model_chapter_5/</url>
    <content><![CDATA[<h1 id="无继承情况下的对象构造"><a href="#无继承情况下的对象构造" class="headerlink" title="无继承情况下的对象构造"></a>无继承情况下的对象构造</h1><p>在《Unix环境高级编程》的7.6节中提到C程序的内存空间可以分为正文段、初始化数据段、非初始化数据段、栈、堆。其中初始化数据段包含程序中需明确赋初值的变量，如C语言中的全局变量<code>int maxcount = 99;</code>。非初始化数据段又称为bss（block started by symbol）段，在程序开始之前，内核将此段初始化为0或空指针，如出现在函数外面的<code>long sum[1000];</code>，该变量没有明确赋初值，因此放到了bss段中。<br>而在C++语言中，将所有的全局对象当做初始化过的数据来对待，因此不会将全局变量放到bss段中。</p>
<h2 id="POD数据类型"><a href="#POD数据类型" class="headerlink" title="POD数据类型"></a>POD数据类型</h2><p>书中提到Plain ol’ data，查了下应该叫Plain Old Data,简称POD，指C风格的struct结构体定义的数据结构，其中struct结构体中只能定义常规数据类型，不可以含有自定义数据类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct Point</span><br><span class="line">&#123;</span><br><span class="line">	float x, y, z;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line">Point global;</span><br><span class="line"></span><br><span class="line">Point foobar()</span><br><span class="line">&#123;</span><br><span class="line">	Point local;</span><br><span class="line">	Point *heap = new Point();</span><br><span class="line">	*heap = local;</span><br><span class="line">	delete heap;</span><br><span class="line">	return local;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看全局变量global，按照常规的理解，在程序启动的时候编译器会调用Point的合成的默认构造函数来初始化global变量，在程序退出时会调用Point的合成的析构函数来销毁global变量。实际上，C++编译器会将Point看成是一个POD对象，既不会调用合成的构造函数也不会调用合成的析构函数，但C++编译器会将global当成初始化过的数据来对待，不放入BSS段。</p>
<p>foobar函数中的local局部变量不会自动初始化，意味着local.x中的值是不可控的，但是local变量分配了栈空间。</p>
<p><code>*heap = local;</code>执行时仅简单执行按字节复制操作，不会产生赋值操作符，因为Point是一个POD类型。</p>
<p><code>return local;</code>同样仅通过字节复制操作产生一个临时对象。</p>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>这次将上面的Point类型从struct变换为class</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Point(float x=0.0, float y=0.0, float z=0.0) : _x(x), _y(y), _z(z)&#123;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	float _x, _y, _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上节中的foobar函数中，各个对象的默认复制构造函数、赋值操作符和析构函数仍然不会调用，因为调用是没有意义的，因此编译器干脆就不产生。</p>
<h2 id="为继承做准备"><a href="#为继承做准备" class="headerlink" title="为继承做准备"></a>为继承做准备</h2><p>再次更改Point类，引入虚函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Point(float x=0.0, float y=0.0) : _x(x), _y(y) &#123;&#125;</span><br><span class="line">	virtual float z();</span><br><span class="line">private:</span><br><span class="line">	float _x, _y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>引入虚函数后，类对象就需要一个vtbl来存放虚函数的地址，类对象中需要添加vptr指针。而vptr的初始化是在对象构造的时候，因此对象初始化的时候需要调用构造函数，同时默认构造函数和赋值构造函数会自动在构造函数的最前面插入初始化vptr的代码。</p>
<h1 id="继承体系下的对象构造"><a href="#继承体系下的对象构造" class="headerlink" title="继承体系下的对象构造"></a>继承体系下的对象构造</h1><p>C++时会自动扩充类的每一个构造函数。扩充步骤如下：</p>
<ol>
<li>如果类含有虚基类，则所有虚基类的构造函数被调用，调用顺序为从左到右，从最深到最浅。</li>
<li>如果类含有基类，则基类构造函数会被调用，以基类的声明顺序为顺序。</li>
<li>如果类对象中含有vptr，必须在初始化类的成员变量之前为vptr指定初值，使其指向vtbl。</li>
<li>将成员初始化列表中数据成员的初始化操作放入构造函数内部，并且按照成员在类中的声明顺序。</li>
<li>如果类成员变量不在构造函数的初始化列表中，但是成员变量含有默认构造函数，则默认构造函数必须被调用。</li>
</ol>
<h2 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h2><p>本小节将学习一下引入了虚继承机制之后构造函数的生成是什么样子的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Point(float x=0.0, float y=0.0) : _x(x), _y(y) &#123;&#125;</span><br><span class="line">	virtual float z();</span><br><span class="line">private:</span><br><span class="line">	float _x, _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Point3d : public virtual Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Point3d(float x=0.0, float y=0.0, float z=0.0)</span><br><span class="line">		: Point(x, y), _z(z) &#123;&#125;</span><br><span class="line">	~Point3d();</span><br><span class="line"></span><br><span class="line">	virtual float z() &#123;return _z;&#125;</span><br><span class="line">protected:</span><br><span class="line">	float _z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Vertex : virtual public Point </span><br><span class="line">&#123;</span><br><span class="line">	// 不是重点忽略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Vertex3d : public Point3d, public Vertex</span><br><span class="line">&#123;</span><br><span class="line">	// 不是重点忽略</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class PVertex : public Vertex3d</span><br><span class="line">&#123;</span><br><span class="line">	// 不是重点忽略</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类之间的继承关系如下图所示，已经属于最复杂的继承模型了。<br><img src="/ref/c++/c++_object_model/chapter5_1.PNG" alt="Image Title"><br>如果要构造Vertex3d的实例，在内存中必须仅能有一个Point类型的对象，而如果在Point3d和Vertex基类中都构造一个Point实例显然是不合适的。答案是编译器会在Vertex3d的构造函数中生成Point的对象，在Point3d和Vertex的构造函数中均不会生成Point的对象。Vertex3d和Point3d的构造函数伪码如下面所示，Vertex构造函数的伪码和Point3d类似，这里就不再列出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Point3d* Point3d::Point3d(Point3d *this, bool __most_derived, float x, float y, float z)</span><br><span class="line">&#123;</span><br><span class="line">	// 如果子类初始化基类则本构造函数不需要初始化基类</span><br><span class="line">	if (__most_derived != false)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;Point::Point(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	this-&gt;__vptr_Point3d = __vtbl_Point3d;	// 初始化指向本类的vptr</span><br><span class="line">	this-&gt;__vptr_Point3d_Point = __vtbl_Point3d_Point;	// 初始化指向基类的vptr</span><br><span class="line">	this-&gt;_z = z;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vertex3d* Vertex3d::Vertex3d(Vertex3d *this, bool __most_derived, float x, float y, float z)</span><br><span class="line">&#123;</span><br><span class="line">	if (__most_derived != false)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;Point::Point(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	this-&gt;Point3d::Point3d(false, x, y, z);</span><br><span class="line">	this-&gt;Vertex::Vertex(false, x, y);</span><br><span class="line">	// 初始化vptr</span><br><span class="line">	// 用户代码</span><br><span class="line">	return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器在类的构造函数中增加了一个bool变量来判断本类是否需要初始化基类，虚基类的初始化始终在继承最底层的类构造函数中初始化。对于PVertex类来说，Point类的构造函数在该类的构造函数中调用。</p>
<h2 id="vptr初始化语意学"><a href="#vptr初始化语意学" class="headerlink" title="vptr初始化语意学"></a>vptr初始化语意学</h2><p>vptr的在构造函数中的初始化时机为：在基类构造函数调用操作之后，在成员初始化列表和构造函数中显式代码之前。<br>构造函数的执行先后顺序为：</p>
<ol>
<li>所有虚基类、基类的构造函数会被调用。</li>
<li>对象的vptr初始化，指向相关的vtbl。</li>
<li>在构造函数内展开成员的初始化列表。</li>
<li>执行显式代码。</li>
</ol>
<h1 id="对象复制语意学"><a href="#对象复制语意学" class="headerlink" title="对象复制语意学"></a>对象复制语意学</h1>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>linux iowait</title>
    <url>/post/iowait/</url>
    <content><![CDATA[<p>iowait和load一样，都是非常容易让人产生误解的系统指标。</p>
<p>iowait表示cpu空闲且有未完成的io请求的时间，iowait高并不能反映出磁盘是系统的性能瓶颈。iowait高的时候cpu正处于空闲状态，没有任务可以执行。此时存在已经发出的磁盘io，此时的cpu空闲状态称之为iowait。本质上，iowait是一种特殊的cpu空闲状态。</p>
<p>iowait状态的cpu是运行在pid为0的idle线程上。</p>
<p>cpu此时之所以进入睡眠状态，是因为进程处于睡眠状态，在等待某个特定的事件（比如网络数据，io操作完成等）。</p>
<p>iowait仅能反应磁盘io的指标，并不能反应其他io设备的指标，比如网络丢包。</p>
<p>在io wait的进程处于不可中断状态，通过top命令可以看到进程状态为</p>
<p>由此可见，iowait包含的信息量非常少，仅凭iowait升高不能判断出系统io有问题。要想判断系统io有问题，还需要使用iostat等命令来查看系统的svctm、util、avgqu-sz等指标。</p>
<h2 id="case-1"><a href="#case-1" class="headerlink" title="case 1"></a>case 1</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/iowait1.png" alt="http://linuxperf.com/wp-content/uploads/2015/02/iowait1.png"></p>
<p>仅cpu的繁忙程度变化的情况下，会影响到iowait的值。</p>
<h2 id="case-2"><a href="#case-2" class="headerlink" title="case 2"></a>case 2</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/iowait2.png" alt="http://linuxperf.com/wp-content/uploads/2015/02/iowait.png"></p>
<p>在cpu繁忙程序不变的情况下，发起io请求的时间不同也会影响到iowait的值。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux IPIP隧道协议</title>
    <url>/post/ipip/</url>
    <content><![CDATA[<p>ipip协议为在ip协议报文的基础上继续封装ip报文，基于tun设备实现，是一种点对点的通讯技术。</p>
<h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p>ipip需要内核模块ipip的支持</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ modprobe ipip</span><br><span class="line">$ lsmod | grep ipip</span><br><span class="line">ipip                   13465  0</span><br><span class="line">tunnel4                13252  1 ipip</span><br><span class="line">ip_tunnel              25163  1 ipip</span><br></pre></td></tr></table></figure>

<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/ipip.png"></p>
<p>两台主机：172.16.5.126(host1)和172.16.5.127(host2)</p>
<p>在host1上创建tun1设备，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 用来创建tun1设备，并ipip协议的外层ip，目的ip为172.16.5.127， 源ip为172.16.5.126</span><br><span class="line">ip tunnel add tun1 mode ipip remote 172.16.5.127 local 172.16.5.126</span><br><span class="line"># 给tun1设备增加ip地址，并设置tun1设备的对端ip地址为10.10.200.10</span><br><span class="line">ip addr add 10.10.100.10 peer 10.10.200.10 dev tun1</span><br><span class="line">ip link set tun1 up</span><br><span class="line"></span><br><span class="line">$ ifconfig tun1</span><br><span class="line">tun1: flags=209&lt;UP,POINTOPOINT,RUNNING,NOARP&gt;  mtu 1480</span><br><span class="line">        inet 10.10.100.10  netmask 255.255.255.255  destination 10.10.200.10</span><br><span class="line">        tunnel   txqueuelen 1000  (IPIP Tunnel)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line"># 增加一条路由，所有到达10.10.200.10的请求会经过设备tun1</span><br><span class="line">$ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.16.7.253    0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">10.10.200.10    0.0.0.0         255.255.255.255 UH    0      0        0 tun1</span><br><span class="line">172.16.0.0      0.0.0.0         255.255.248.0   U     0      0        0 eth0</span><br></pre></td></tr></table></figure>

<p>同样在host2上创建tun1设备：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip tunnel add tun1 mode ipip remote 172.16.5.126 local 172.16.5.127</span><br><span class="line">ip addr add 10.10.200.10 peer 10.10.100.10 dev tun1</span><br><span class="line">ip link set tun1 up</span><br></pre></td></tr></table></figure>

<p>并分别在host1和host2上打开ip_forward功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 &gt;  /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>

<p>然后在host1上ping 10.10.200.10，可以ping通。</p>
<p>在host1的tun1上抓包，可以看到正常的ping包。</p>
<p>在host1的eth1上抓包，可以看到已经是ipip的数据包了。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/ipip-wireshark.jpg"></p>
<p><a href="https://kuring.oss-cn-beijing.aliyuncs.com/common/ipip-wireshark.jpg">tun1.pcap</a></p>
<p>清理现场分别在两台主机上执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip link delete tun0</span><br></pre></td></tr></table></figure>

<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://www.bbsmax.com/A/ke5jRmjV5r/">什么是 IP 隧道，Linux 怎么实现隧道通信？</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>iptables基础知识</title>
    <url>/post/iptables/</url>
    <content><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><h2 id="netfilter与iptables的关系"><a href="#netfilter与iptables的关系" class="headerlink" title="netfilter与iptables的关系"></a>netfilter与iptables的关系</h2><p>linux在内核中对数据包过滤和修改的模块为netfilter，netfilter模块本身并不对数据包进行过滤，只是允许将过滤数据包或修改数据包的函数hook到内核网络协议栈的适当位置。</p>
<img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/Netfilter-packet-flow.svg">

<p>iptables是用户态的工具，用于向netfilter中添加规则从而实现报文的过滤和修改等功能，工作在ip层。ebtables工作在数据链路层，用于处理以太网帧。</p>
<p>图中绿色代表iptables的表，可以看到有部分位于了数据链路层，之所以产生这种奇怪的架构，原因是bridge_nf模块，因为bridge工作在数据链路层，不一定会经过网络层，但仍然需要iptables的功能。详细信息可以在<a href="http://ebtables.netfilter.org/br_fw_ia/br_fw_ia.html">ebtables&#x2F;iptables interaction on a Linux-based bridge</a>中了解。</p>
<p>概念：tables -&gt; chains -&gt; rules</p>
<h1 id="iptabels介绍"><a href="#iptabels介绍" class="headerlink" title="iptabels介绍"></a>iptabels介绍</h1><h2 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h2><p>每个表都由一组内置的链，还可以添加用户自定义链，只是用户自定义链没有钩子可以触发，需要从其他链通过<code>-j</code>即JUMP进行触发。</p>
<ul>
<li>INPUT 链：发往本机的报文</li>
<li>OUTPUT 链：由本机发出的报文</li>
<li>FORWARD 链：经由本机转发的报文</li>
<li>PREROUTING 链：报文到达本机，进行路由决策之前</li>
<li>POSTROUTING 链：报文由本机发出，进行路由决策之后</li>
</ul>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/iptables1.png" alt="image"></p>
<p>从chain的角度考虑数据包的流向：</p>
<ul>
<li>到本机某进程的报文：PREROUTING -&gt; INPUT</li>
<li>由本机转发的报文：PREROUTING -&gt; FORWARD -&gt; POSTROUTING</li>
<li>由本机某进程发出的报文：OUTPUT -&gt; POSTROUTING</li>
</ul>
<p>当一个网络包进入一台机器的时候，首先拿下 MAC 头看看，是不是我的。如果是，则拿下 IP 头来。得到目标 IP 之后呢，就开始进行路由判断。在路由判断之前，这个节点我们称为 PREROUTING。如果发现 IP 是我的，包就应该是我的，就发给上面的传输层，这个节点叫作 INPUT。如果发现 IP 不是我的，就需要转发出去，这个节点称为 FORWARD。如果是我的，上层处理完毕完毕后，一般会返回一个处理结果，这个处理结果会发出去，这个节点称为 OUTPUT，无论是 FORWARD 还是 OUTPUT，都是路由判断之后发生的，最后一个节点是 POSTROUTING。</p>
<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><p>有了chain的概念后，为了便于chain中rule的管理，又引入了table的概念，用于存放相同功能的rule，不同功能的rule放到不同的table中。</p>
<p>包括：filter nat mangle raw</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>默认表，管理本机数据包的进出，用于实现包的过滤，对应内核模块iptables_filter</p>
<p>input：想要进入linux主机的包<br>output：linux主机要发送的包<br>forward：传递包到后端计算机，与nat table关联较多</p>
<h3 id="nat"><a href="#nat" class="headerlink" title="nat"></a>nat</h3><p>管理后端主机进出，与linux主机没有关系，与linux后的主机有关</p>
<p>prerouting：进行路由判断之前的规则(dnat&#x2F;redirect)<br>postrouting：路由判断之后执行的规则(snat&#x2F;masquerade)<br>output：与发出去的包有关</p>
<h3 id="mangle"><a href="#mangle" class="headerlink" title="mangle"></a>mangle</h3><p>较少使用，用于拆解报文，修改数据包，并重新封装。</p>
<h3 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h3><p>raw表的主要作用是允许我们给某些特定的数据包打上标记。</p>
<h2 id="rule"><a href="#rule" class="headerlink" title="rule"></a>rule</h2><p>包含了匹配条件和处理动作。</p>
<p>匹配条件包括：source ip、destination ip、source port、destination port</p>
<p>处理动作包括：</p>
<ul>
<li>accept: 将包交给协议栈</li>
<li>drop：直接丢弃数据包，不给任何回应</li>
<li>reject：拒绝数据包通过，并给一个响应信息，客户端会收到拒绝消息</li>
<li>queue: 交个某个用户态进程处理</li>
<li>dnat：目的地址转换</li>
<li>snat：源地址转换，必须要指定SNAT地址，即–to-source参数，可以是单个ip，也可以是网段。用在POSTROUTING链上。</li>
<li>masquerade: 源地址伪装，跟snat类似，不需要指定SNAT地址，会自动从服务器上获取SNAT的ip地址。如果有多个网卡的情况下，会使用路由选择算法。</li>
<li>mark: 对数据包进行打标签操作</li>
</ul>
<h2 id="table-filter-rule的关系"><a href="#table-filter-rule的关系" class="headerlink" title="table filter rule的关系"></a>table filter rule的关系</h2><p>这三者之间的关系还是相当的绕。</p>
<h3 id="链中的规则存在的表"><a href="#链中的规则存在的表" class="headerlink" title="链中的规则存在的表"></a>链中的规则存在的表</h3><p>chain中存放了rule，某些chain中注定不包含某些rule。例如prerouting链中的rule仅存在于nat raw mangle三张表中。</p>
<p>prerouting链中的规则存在的表：raw mangle nat<br>input链中的规则存在的表：mangle filter nat<br>forward链中的规则存在的表：mangle filter<br>output链中的规则存在的表：raw mangle filter nat<br>postrouting链中的规则存在的表：mangle nat</p>
<h3 id="表中的规则可以被哪些链使用"><a href="#表中的规则可以被哪些链使用" class="headerlink" title="表中的规则可以被哪些链使用"></a>表中的规则可以被哪些链使用</h3><p>raw表中的规则可以被链使用：prerouting output</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/iptables2.png" alt="image"></p>
<p>表的名字为小写，链的名字为大写</p>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>iptables 查询默认的表为filter，默认会列出表中所有链的规则</p>
<ul>
<li>-t 用于指定要操作的表，支持raw mangle filter nat，省略-t选项，默认使用filter表</li>
<li>-L 列出rule</li>
<li>-v 可查看更详细的信息</li>
<li>-n 规则中以ip地址的形式进行显示</li>
<li>–line-number 显示规则的编号</li>
<li>-x 包的计数以精确数字显示</li>
</ul>
<p><code>iptables -t filter -L</code>：从表的角度查询规则，用于查看filter表中的所有规则</p>
<p><code>iptables -L INPUT</code>: 从链的角度查询规则，用于查看INPUT链中的所有规则</p>
<p><code>iptables -vL INPUT</code>: 从链的角度查询规则，用于查看INPUT链中的所有规则，可查看更详细信息，包含了规则的匹配信息</p>
<p><code>iptables -nvL</code>：以精确数字显示</p>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul>
<li>-F: 清空规则</li>
<li>-I: 表示插入规则</li>
<li>-A: 表示以追加的方式插入规则</li>
<li><code>--dport</code>: 目的端口</li>
<li><code>--sport</code>: 源端口</li>
<li>-s: 源ip</li>
<li>-d: 目的ip</li>
<li><code>--match-set</code>：匹配ipset</li>
</ul>
<p><code>iptables -F INPUT</code>：清空filter表中的INPUT链中的所有规则。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul>
<li>-D: 删除规则，<code>iptables -D 链名 规则编号</code>，其中规则编号可以通过<code>--line-number</code>查看到。</li>
<li>-F: 清空规则，<code>iptables -F 链名 -t 表名</code></li>
<li>-X: 删除链 <code>iptables -X 链名 -t 表名</code></li>
</ul>
<h2 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h2><p>开启trace功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># centos7 系统下有效，centos6下内核模块为ipt_LOG</span><br><span class="line">$ modprobe nf_log_ipv4</span><br><span class="line"></span><br><span class="line"># 用来验证module是否加载成功</span><br><span class="line">$ sysctl net.netfilter.nf_log.2</span><br></pre></td></tr></table></figure>

<p>要开启icmp协议的追踪，执行如下的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -t raw -A OUTPUT -p icmp -m comment --comment &quot;TRACE&quot; -j TRACE</span><br><span class="line">iptables -t raw -A PREROUTING -p icmp -m comment --comment &quot;TRACE&quot; -j TRACE</span><br></pre></td></tr></table></figure>

<p>可以通过如下的命令看到插入的iptabels规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -t raw -nvL --line-number</span><br></pre></td></tr></table></figure>

<p>追踪日志最终会在&#x2F;var&#x2F;log&#x2F;message或者&#x2F;var&#x2F;log&#x2F;kern下看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Feb  6 11:22:04 c43k09006.cloud.k09.am17 kernel: TRACE: raw:PREROUTING:policy:3 IN=docker0 OUT= PHYSIN=bond0.9 MAC=02:42:30:fb:43:94:5c:c9:99:de:c4:8b:08:00 SRC=10.45.8.10 DST=10.45.4.99 LEN=84 TOS=0x00 PREC=0x00 TTL=62 ID=25550 DF PROTO=ICMP TYPE=0 CODE=0 ID=24191 SEQ=2</span><br></pre></td></tr></table></figure>

<p>格式这块的含义如下：</p>
<p>“TRACE: tablename:chainname:type:rulenum “ where type can be “rule” for plain rule, “return” for implicit rule at the end of a user defined chain and “policy” for the policy of the built in chains.</p>
<p>环境清理，删除刚刚创建的规则即可，其中1为规则的编号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可以通过此来查询之前创建的规则编号</span><br><span class="line">iptables -t raw --line-number -nvL</span><br><span class="line"># 删除规则</span><br><span class="line">iptables -t raw -D PREROUTING 1</span><br><span class="line">iptables -t raw -D OUTPUT 1</span><br></pre></td></tr></table></figure>

<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="试验1-基本规则管理"><a href="#试验1-基本规则管理" class="headerlink" title="试验1 基本规则管理"></a>试验1 基本规则管理</h2><h3 id="插入规则"><a href="#插入规则" class="headerlink" title="插入规则"></a>插入规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 清空filter表中的input链规则</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -F INPUT</span><br><span class="line"></span><br><span class="line"># 查看filter表中的详细规则，此时从其他机器上ping该ip是通的</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -nvL INPUT</span><br><span class="line">Chain INPUT (policy ACCEPT 7 packets, 388 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> </span><br><span class="line"># 增加规则，拒绝192.168.33.1上的请求</span><br><span class="line"># -I：表示插入</span><br><span class="line"># INPUT为要插入的链</span><br><span class="line"># -s：表示源ip地址</span><br><span class="line"># -j：表示要执行的动作</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -I INPUT -s 192.168.33.1 -j DROP</span><br><span class="line"></span><br><span class="line"># 再次查询filter表中的规则，此时192.168.33.1上的报文已经不通</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -nvL</span><br><span class="line">Chain INPUT (policy ACCEPT 107 packets, 6170 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">    0     0 DROP       all  --  *      *       192.168.33.1         0.0.0.0/0</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 56 packets, 4355 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"></span><br><span class="line"># appent一条接收192.168.33.1的请求规则</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -A INPUT -s 192.168.33.1 -j ACCEPT</span><br><span class="line"># 新增加的序号为2，192.168.33.1的包匹配到1后就停止往下走，因此192.168.33.1还是ping不通当前主机</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -nvL INPUT --line-number</span><br><span class="line">Chain INPUT (policy ACCEPT 65 packets, 3572 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">1        9   756 DROP       all  --  *      *       192.168.33.1         0.0.0.0/0</span><br><span class="line">2        0     0 ACCEPT     all  --  *      *       192.168.33.1         0.0.0.0/0</span><br><span class="line"></span><br><span class="line"># 插入一条ACCEPT rule，此时192.168.33.1可以ping通当前主机，新插入的规则优先</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -I INPUT -s 192.168.33.1 -j ACCEPT</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -nvL INPUT --line-number</span><br><span class="line">Chain INPUT (policy ACCEPT 7 packets, 388 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">1        0     0 ACCEPT     all  --  *      *       192.168.33.1         0.0.0.0/0</span><br><span class="line">2       10   840 DROP       all  --  *      *       192.168.33.1         0.0.0.0/0</span><br><span class="line">3        0     0 ACCEPT     all  --  *      *       192.168.33.1         0.0.0.0/0</span><br><span class="line"></span><br><span class="line"># 新插入一条accept 192.168.33.2的规则，插入位置为2，可以看到插入到2的位置了</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -I INPUT 2 -s 192.168.33.2 -j ACCEPT</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -nvL INPUT --line-number</span><br><span class="line">Chain INPUT (policy ACCEPT 7 packets, 388 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">1        1    84 ACCEPT     all  --  *      *       192.168.33.1         0.0.0.0/0</span><br><span class="line">2        0     0 ACCEPT     all  --  *      *       192.168.33.2         0.0.0.0/0</span><br><span class="line">3       10   840 DROP       all  --  *      *       192.168.33.1         0.0.0.0/0</span><br><span class="line">4        0     0 ACCEPT     all  --  *      *       192.168.33.1         0.0.0.0/0</span><br></pre></td></tr></table></figure>

<h3 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h3><p>接下在上面实验的基础上测试删除规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除刚刚创建的规则2</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -D INPUT 2</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -nvL INPUT --line-number</span><br><span class="line">Chain INPUT (policy ACCEPT 7 packets, 388 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">1        1    84 ACCEPT     all  --  *      *       192.168.33.1         0.0.0.0/0</span><br><span class="line">2       10   840 DROP       all  --  *      *       192.168.33.1         0.0.0.0/0</span><br><span class="line">3        0     0 ACCEPT     all  --  *      *       192.168.33.1         0.0.0.0/0</span><br><span class="line"></span><br><span class="line"># 删除source为192.168.33.1，动作为ACCEPT的规则，实际此时执行一次命令仅能删除一条</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -D INPUT -s 192.168.33.1 -j ACCEPT</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -nvL INPUT --line</span><br><span class="line">Chain INPUT (policy ACCEPT 13 packets, 736 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">1       11   936 DROP       all  --  *      *       192.168.33.1         0.0.0.0/0</span><br></pre></td></tr></table></figure>

<h3 id="修改规则"><a href="#修改规则" class="headerlink" title="修改规则"></a>修改规则</h3><p>在上面实验的基础上修改规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将规则动作从REJECT更改为REJECT</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -R INPUT 1 -s 192.168.33.1 -j REJECT</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -nvL INPUT --line</span><br><span class="line">Chain INPUT (policy ACCEPT 7 packets, 388 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">1        0     0 REJECT     all  --  *      *       192.168.33.1         0.0.0.0/0            reject-with icmp-port-unreachable</span><br><span class="line"></span><br><span class="line"># 每个链都有一个默认规则，当前INPUT链中的默认为ACCEPT</span><br><span class="line"># 以下可以修改INPUT链的默认规则为DROP，远程连接慎用，不要问我为什么</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -P INPUT DROP</span><br></pre></td></tr></table></figure>

<h3 id="保存规则"><a href="#保存规则" class="headerlink" title="保存规则"></a>保存规则</h3><p>防火墙的所有修改都是临时的，重启系统后会失效。iptables会读取&#x2F;etc&#x2F;sysconfig&#x2F;iptables中的规则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># iptables-save命令仅会打印当前的规则，需要使用重定向当前规则到文件中</span><br><span class="line">[root@localhost system]# iptables-save &gt; /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line"># 可以从规则文件中载入规则</span><br><span class="line">[root@localhost system]# iptables-restore &lt; /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure>

<h2 id="实验二-各类匹配条件的使用"><a href="#实验二-各类匹配条件的使用" class="headerlink" title="实验二 各类匹配条件的使用"></a>实验二 各类匹配条件的使用</h2><h3 id="匹配条件"><a href="#匹配条件" class="headerlink" title="匹配条件"></a>匹配条件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可一次性插入两条规则</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -I INPUT -s 192.168.33.1,192.168.33.2 -j DROP</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -nvL INPUT --line</span><br><span class="line">Chain INPUT (policy ACCEPT 31 packets, 1744 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">1        0     0 DROP       all  --  *      *       192.168.33.2         0.0.0.0/0</span><br><span class="line">2        0     0 DROP       all  --  *      *       192.168.33.1         0.0.0.0/0</span><br><span class="line"></span><br><span class="line"># 可指定ip网段</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -F INPUT</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -I INPUT -s 192.168.33.0/24 -j DROP</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -nvL INPUT --line</span><br><span class="line">Chain INPUT (policy ACCEPT 7 packets, 388 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">1        0     0 DROP       all  --  *      *       192.168.33.0/24      0.0.0.0/0</span><br><span class="line"></span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -I INPUT ! -s 192.168.33.0/24 -j DROP</span><br><span class="line">[vagrant@localhost ~]$ sudo iptables -t filter -nvL INPUT --line</span><br><span class="line">Chain INPUT (policy ACCEPT 19 packets, 1048 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">1        0     0 DROP       all  --  *      *      !10.0.2.0/24          0.0.0.0/0</span><br></pre></td></tr></table></figure>

<h3 id="协议类型"><a href="#协议类型" class="headerlink" title="协议类型"></a>协议类型</h3><p>使用-p来指定协议类型，支持tcp udp icmp等，不指定时默认匹配所有协议</p>
<h3 id="网卡接口"><a href="#网卡接口" class="headerlink" title="网卡接口"></a>网卡接口</h3><p><code>-i</code>来指定从某个网卡进入的流量，仅使用于PREROUTING INPUT FORWARD三条链。</p>
<p><code>-o</code>来指定从某个网络流出的流量，仅适用于FORWARD OUTPUT POSTROUTING三条链。</p>
<h2 id="实验三-扩展模块"><a href="#实验三-扩展模块" class="headerlink" title="实验三 扩展模块"></a>实验三 扩展模块</h2><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>使用了扩展模块tcp udp，默认可以省略</p>
<p><code>--dport</code>来匹配报文的目的端口，使用时必须指定协议，即<code>-p</code>选项。<br><code>--sport</code>来匹配报文的源端口，使用时必须指定协议，即<code>-p</code>选项。</p>
<p>端口可以指定范围，例如22:25表示22-25之间的所有端口，22,25表示22和25端口，还可以配合起来使用，比如22,80:88表示22和80-88之间的端口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可以指定目的端口的范围</span><br><span class="line">[root@localhost vagrant]# iptables -t filter -I INPUT -s 192.168.33.1 -p tcp --dport 22:25 -j REJECT</span><br><span class="line">[root@localhost vagrant]# iptables -t filter -nvL INPUT --line</span><br><span class="line">Chain INPUT (policy ACCEPT 70 packets, 4024 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">1        0     0 REJECT     tcp  --  *      *       192.168.33.1         0.0.0.0/0            tcp dpts:22:25 reject-with icmp-port-unreachable</span><br></pre></td></tr></table></figure>

<h3 id="iprange扩展模块"><a href="#iprange扩展模块" class="headerlink" title="iprange扩展模块"></a>iprange扩展模块</h3><p>iprange扩展模块可以指定一段连续的ip地址范围。</p>
<p><code>--src-range</code>和<code>--dst-range</code>用来指定源地址和目的范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost vagrant]# iptables -t filter -I INPUT -m iprange --src-range 192.168.33.1-192.168.33.10 -j DROP</span><br><span class="line">[root@localhost vagrant]# iptables -t filter -nvL INPUT --line</span><br><span class="line">Chain INPUT (policy ACCEPT 17 packets, 968 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">1        0     0 DROP       all  --  *      *       0.0.0.0/0            0.0.0.0/0            source IP range 192.168.33.1-192.168.33.10</span><br></pre></td></tr></table></figure>

<h3 id="string扩展模块"><a href="#string扩展模块" class="headerlink" title="string扩展模块"></a>string扩展模块</h3><p>匹配报文中包含的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 匹配报文中包含XXOO的报文</span><br><span class="line">[root@localhost vagrant]# iptables -t filter -I INPUT -m string --algo bm --string &quot;XXOO&quot; -j REJECT</span><br><span class="line">[root@localhost vagrant]# iptables -t filter -nvL INPUT --line</span><br><span class="line">Chain INPUT (policy ACCEPT 15 packets, 852 bytes)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">1        0     0 REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            STRING match  &quot;XXOO&quot; ALGO name bm TO 65535 reject-with icmp-port-unreachable</span><br></pre></td></tr></table></figure>

<h3 id="其他扩展"><a href="#其他扩展" class="headerlink" title="其他扩展"></a>其他扩展</h3><p>time扩展用来根据时间段进行匹配</p>
<p>connlimit用来对ip的并发连接数进行限制</p>
<p>limit模块限制单位时间内进出包的数量</p>
<p>tcp扩展中可以使用<code>--tcp-flags</code>可根据tcp flag进行匹配</p>
<p>state扩展可根据tcp的连接状态进行匹配</p>
<h2 id="实验四-自定义链"><a href="#实验四-自定义链" class="headerlink" title="实验四 自定义链"></a>实验四 自定义链</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建自定义链 IN_WEB</span><br><span class="line">[root@localhost vagrant]# iptables -t filter -N IN_WEB</span><br><span class="line">[root@localhost vagrant]# iptables -nvL</span><br><span class="line">Chain INPUT (policy ACCEPT 31 packets, 1780 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 16 packets, 1216 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"></span><br><span class="line">Chain IN_WEB (0 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"> </span><br><span class="line">[root@localhost vagrant]# iptables -t filter -I IN_WEB -s 192.168.33.1 -j REJECT</span><br><span class="line">[root@localhost vagrant]# iptables -t filter -I IN_WEB -s 192.168.33.2 -j REJECT</span><br><span class="line"></span><br><span class="line">[root@localhost vagrant]# iptables -t filter -nvL IN_WEB --line</span><br><span class="line">Chain IN_WEB (0 references)</span><br><span class="line">num   pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">1        0     0 REJECT     all  --  *      *       192.168.33.2         0.0.0.0/0            reject-with icmp-port-unreachable</span><br><span class="line">2        0     0 REJECT     all  --  *      *       192.168.33.1         0.0.0.0/0            reject-with icmp-port-unreachable</span><br><span class="line"></span><br><span class="line"># 将IN_WEB自定义链添加到INPUT链上</span><br><span class="line">[root@localhost vagrant]# iptables -t filter -I INPUT -p tcp --dport 80 -j IN_WEB</span><br><span class="line"># 可以看到INPUT链中多出了IN_WEB链</span><br><span class="line">[root@localhost vagrant]# iptables -nvL</span><br><span class="line">Chain INPUT (policy ACCEPT 35 packets, 2012 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">    0     0 IN_WEB     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 18 packets, 1408 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"></span><br><span class="line">Chain IN_WEB (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">    0     0 REJECT     all  --  *      *       192.168.33.2         0.0.0.0/0            reject-with icmp-port-unreachable</span><br><span class="line">    0     0 REJECT     all  --  *      *       192.168.33.1         0.0.0.0/0            reject-with icmp-port-unreachable</span><br><span class="line"></span><br><span class="line"># 重新定义自定链名字    </span><br><span class="line">[root@localhost vagrant]# iptables -E IN_WEB WEB</span><br><span class="line">[root@localhost vagrant]# iptables -nvL</span><br><span class="line">Chain INPUT (policy ACCEPT 39 packets, 2244 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">    0     0 WEB        tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 20 packets, 1520 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line"></span><br><span class="line">Chain WEB (1 references)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br><span class="line">    0     0 REJECT     all  --  *      *       192.168.33.2         0.0.0.0/0            reject-with icmp-port-unreachable</span><br><span class="line">    0     0 REJECT     all  --  *      *       192.168.33.1         0.0.0.0/0            reject-with icmp-port-unreachable</span><br><span class="line">    </span><br><span class="line"># 由于iptables有自定义链，不能删除</span><br><span class="line">[root@localhost vagrant]# iptables -X WEB</span><br><span class="line">iptables: Too many links.</span><br><span class="line"># 将INPUT链引用的WEB链删除</span><br><span class="line">[root@localhost vagrant]# iptables -D INPUT 1</span><br><span class="line"># 此时仍不能删除自定义链，因为自定义链删除，需要上面没有任何规则</span><br><span class="line">[root@localhost vagrant]# iptables -X WEB</span><br><span class="line">iptables: Directory not empty.</span><br><span class="line"></span><br><span class="line"># 先清空自定义链的规则后可以删除</span><br><span class="line">[root@localhost vagrant]# iptables -F WEB</span><br><span class="line">[root@localhost vagrant]# iptables -X WEB</span><br></pre></td></tr></table></figure>


<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul>
<li><a href="http://www.zsythink.net/archives/tag/iptables/page/2/">iptables详解系列</a></li>
<li><a href="https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#ACCEPTTARGET">Iptables Tutorial 1.2.2</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>ipv6</title>
    <url>/post/ipv6/</url>
    <content><![CDATA[<h2 id="ipv6的优势"><a href="#ipv6的优势" class="headerlink" title="ipv6的优势"></a>ipv6的优势</h2><ol>
<li>拥有更大的地址空间。</li>
<li>点对点通讯更方便。由于ipv6地址足够多，可以不再使用NAT功能，避免NAT场景下的各种坑。</li>
<li>ip配置方便。每台机器都有一个唯一48位的mac地址，如果再增加一个80位的网段前缀即可组成ipv6地址。因此，在分配ip地址的时候，只需要获取到网段前缀即可获取到完整的ipv6地址了。</li>
<li>局域网内更安全。去掉了arp协议，而是采用Neighbor Discovery协议。</li>
</ol>
<h2 id="ipv6的数据包格式"><a href="#ipv6的数据包格式" class="headerlink" title="ipv6的数据包格式"></a>ipv6的数据包格式</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/ipv6-header.png"></p>
<p>分为报头、扩展报头和上层协议数据单元（PDU）三部分组成。</p>
<h3 id="报头"><a href="#报头" class="headerlink" title="报头"></a>报头</h3><p>固定为40个字节，相比于 ipv4 的可变长度报文更简洁。</p>
<ul>
<li><p>版本：固定为4bit，固定值6。</p>
</li>
<li><p>业务流类别：8bit，用来表明数据流的通讯类别或者优先级。</p>
</li>
<li><p>流标签：20bit，标记ipv6路由器需要特殊处理的数据流，目的是为了让路由器对于同一批数据报文能够按照同样的逻辑来处理。目前该字段的应用场景较少。</p>
</li>
<li><p>净荷长度：16bit，扩展头和上次协议数据单元的字节数，不包含报头的固定 40 字节。</p>
</li>
<li><p>下一个头：8bit，每个字段值有固定含义，用来表示上层协议。如果上层协议为 tcp，那么该字段的值为 4。</p>
</li>
<li><p>跳限制：8bit，即跳数限制，等同于ipv4中的ttl值。</p>
</li>
<li><p>源ip地址：128bit</p>
</li>
<li><p>目的ip地址：128bit</p>
</li>
</ul>
<h3 id="扩展报头"><a href="#扩展报头" class="headerlink" title="扩展报头"></a>扩展报头</h3><p>扩展报头的长度任意</p>
<h2 id="ipv6地址"><a href="#ipv6地址" class="headerlink" title="ipv6地址"></a>ipv6地址</h2><h3 id="地址表示方法"><a href="#地址表示方法" class="headerlink" title="地址表示方法"></a>地址表示方法</h3><ol>
<li>采用16进制表示法，共128位，分为8组，每组16位，每组用4个16进制表示。各组之间使用<code>:</code>分割。例如：1080:0:0:0:8:800:200C:417A。</li>
<li>地址中出现连续的0，可以使用<code>::</code>来代替连续的0，一个地址中只能出现一次连续的0。例如上述地址可以表示为：1080::8:800:200C:417A。本地的回环地址可使用 <code>::1</code> 表示。</li>
<li>如果ipv6的前面地址全部为0，可能存在包含ipv4地址的场景，可以使用ipv4的十进制表示方法。例如：0:0:0:0:0:0:61.1.133.1或者::61.1.133.1。</li>
</ol>
<p>ip地址结构包含了64位的网络地址和64位的主机地址，其中64位的网络地址又分为了48位的全球网络标识符和16位的本地子网标识符。</p>
<h3 id="网段表示方法"><a href="#网段表示方法" class="headerlink" title="网段表示方法"></a>网段表示方法</h3><p>在ipv6中同样有网段的概念，如 2001:0:0:CD30::&#x2F;60 ，其中前60位为前缀长度，后面的所有位表示接口 ID，使用 <code>::</code> 表示，但前面的两个0不能使用 <code>::</code> 表示。</p>
<h3 id="地址分类"><a href="#地址分类" class="headerlink" title="地址分类"></a>地址分类</h3><p>包括了如下地址类型，但跟 ipv4 不同的地方在于没有广播地址。</p>
<h4 id="单播地址"><a href="#单播地址" class="headerlink" title="单播地址"></a>单播地址</h4><p>单播地址又可以分为如下类型：</p>
<h5 id="链路本地地址（LLA）"><a href="#链路本地地址（LLA）" class="headerlink" title="链路本地地址（LLA）"></a>链路本地地址（LLA）</h5><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/ipv6-lla.jpg"></p>
<p>类似于 ipv4 的私网地址段，但比 ipv4 的私网地址段范围更小，仅可以用于本地子网内通讯，不可被路由。以<code>fe80::/10</code>开头的地址段。设备要想支持 ipv6，必须要有链路本地地址，且只能设置一个。</p>
<p>在设备启动时，通常该地址会自动设置，也可以手动设置。自动生成的地址通常会根据 mac 地址有关，因为每个设备的 mac 地址都是唯一的。</p>
<h5 id="公网单播地址（GUA）"><a href="#公网单播地址（GUA）" class="headerlink" title="公网单播地址（GUA）"></a>公网单播地址（GUA）</h5><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/ipv6-uga.jpg"></p>
<p>类似于 ipv4 的公网地址。</p>
<p>地址范围：<code>2000::3</code> - <code>3fff::/16</code>，即以 2 或者 3 开头，用总 ipv6 地址空间的1&#x2F;8。</p>
<p>通常情况下，公网路由前缀为 48 位，子网 id 为 16 位，接口 id 为 64 位。</p>
<h5 id="本地唯一单播地址（ULA）"><a href="#本地唯一单播地址（ULA）" class="headerlink" title="本地唯一单播地址（ULA）"></a>本地唯一单播地址（ULA）</h5><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/ipv6-ula.jpg"></p>
<p>范围：<code>fc00::/7</code>，当前唯一有效的前缀为<code>fd00::/8</code>。只能在私网内部使用，不能在公网上路由。</p>
<p>其全网 id 的部分采用伪随机算法，可以尽最大可可能确保全局的唯一性，从而在两个网络进行并网的时候减少地址冲突的概率。</p>
<h5 id="loopback地址"><a href="#loopback地址" class="headerlink" title="loopback地址"></a>loopback地址</h5><p>即 <code>::1</code>，等同于 ipv4 的 <code>127.0.0.1/8</code></p>
<h5 id="未指定单播地址"><a href="#未指定单播地址" class="headerlink" title="未指定单播地址"></a>未指定单播地址</h5><p>即 <code>::</code>。</p>
<h4 id="多播地址（Multicast）"><a href="#多播地址（Multicast）" class="headerlink" title="多播地址（Multicast）"></a>多播地址（Multicast）</h4><p>又叫组播地址，标识一组节点，目的为组播地址的流量会转发到组内的所有节点，类似于 ipv4 的广播地址。地址范围：<code>FF00::/8</code>。</p>
<h4 id="任意播地址（Anycast）"><a href="#任意播地址（Anycast）" class="headerlink" title="任意播地址（Anycast）"></a>任意播地址（Anycast）</h4><p>标识一组节点，所有节点的接口分配相同的 ip 地址，目的为组播地址的流量会转发到组内的就近节点。任意播地址没有固定的前缀。</p>
<h2 id="DNS服务和ipv6"><a href="#DNS服务和ipv6" class="headerlink" title="DNS服务和ipv6"></a>DNS服务和ipv6</h2><h3 id="双栈请求域名请求顺序"><a href="#双栈请求域名请求顺序" class="headerlink" title="双栈请求域名请求顺序"></a>双栈请求域名请求顺序</h3><p>在开启ipv4&#x2F;ipv6双栈的情况下，域名解析会同时发出A&#x2F;AAAA请求，发出请求的先后顺序由&#x2F;etc&#x2F;resolv.conf的option中的inet6选项决定。</p>
<h3 id="ipv6与-x2F-etc-x2F-hosts文件"><a href="#ipv6与-x2F-etc-x2F-hosts文件" class="headerlink" title="ipv6与  &#x2F;etc&#x2F;hosts文件"></a>ipv6与  &#x2F;etc&#x2F;hosts文件</h3><p>通常在&#x2F;etc&#x2F;hosts文件中包含了如下的回环地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">::1             localhost6.localdomain6 localhost6</span><br></pre></td></tr></table></figure>



<h3 id="检测域名是否支持ipv6"><a href="#检测域名是否支持ipv6" class="headerlink" title="检测域名是否支持ipv6"></a>检测域名是否支持ipv6</h3><h4 id="dig-aaaa方法"><a href="#dig-aaaa方法" class="headerlink" title="dig aaaa方法"></a>dig aaaa方法</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">dig</span> <span class="string">aaaa</span>  <span class="string">ipv6.google.com.hk</span></span><br><span class="line"></span><br><span class="line"><span class="string">;</span> <span class="string">&lt;&lt;&gt;&gt;</span> <span class="string">DiG</span> <span class="number">9.10</span><span class="number">.6</span> <span class="string">&lt;&lt;&gt;&gt;</span> <span class="string">aaaa</span> <span class="string">ipv6.google.com.hk</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">global options:</span> <span class="string">+cmd</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">Got answer:</span></span><br><span class="line"><span class="string">;;</span> <span class="string">-&gt;&gt;HEADER&lt;&lt;-</span> <span class="attr">opcode:</span> <span class="string">QUERY,</span> <span class="attr">status:</span> <span class="string">NOERROR,</span> <span class="attr">id:</span> <span class="number">50248</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">flags:</span> <span class="string">qr</span> <span class="string">rd</span> <span class="string">ra;</span> <span class="attr">QUERY:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">ANSWER:</span> <span class="number">6</span><span class="string">,</span> <span class="attr">AUTHORITY:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">ADDITIONAL:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">;;</span> <span class="attr">OPT PSEUDOSECTION:</span></span><br><span class="line"><span class="string">;</span> <span class="attr">EDNS: version:</span> <span class="number">0</span><span class="string">,</span> <span class="string">flags:;</span> <span class="attr">udp:</span> <span class="number">4000</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">QUESTION SECTION:</span></span><br><span class="line"><span class="string">;ipv6.google.com.hk.</span>		<span class="string">IN</span>	<span class="string">AAAA</span></span><br><span class="line"></span><br><span class="line"><span class="string">;;</span> <span class="attr">ANSWER SECTION:</span></span><br><span class="line"><span class="string">ipv6.google.com.hk.</span>	<span class="number">21600</span>	<span class="string">IN</span>	<span class="string">CNAME</span>	<span class="string">ipv6.google.com.</span></span><br><span class="line"><span class="string">ipv6.google.com.</span>	<span class="number">21600</span>	<span class="string">IN</span>	<span class="string">CNAME</span>	<span class="string">ipv6.l.google.com.</span></span><br><span class="line"><span class="string">ipv6.l.google.com.</span>	<span class="number">300</span>	<span class="string">IN</span>	<span class="string">AAAA</span>	<span class="number">2607</span><span class="string">:f8b0:4003:c0b::71</span></span><br><span class="line"><span class="string">ipv6.l.google.com.</span>	<span class="number">300</span>	<span class="string">IN</span>	<span class="string">AAAA</span>	<span class="number">2607</span><span class="string">:f8b0:4003:c0b::64</span></span><br><span class="line"><span class="string">ipv6.l.google.com.</span>	<span class="number">300</span>	<span class="string">IN</span>	<span class="string">AAAA</span>	<span class="number">2607</span><span class="string">:f8b0:4003:c0b::65</span></span><br><span class="line"><span class="string">ipv6.l.google.com.</span>	<span class="number">300</span>	<span class="string">IN</span>	<span class="string">AAAA</span>	<span class="number">2607</span><span class="string">:f8b0:4003:c0b::8b</span></span><br><span class="line"></span><br><span class="line"><span class="string">;;</span> <span class="attr">Query time:</span> <span class="number">83</span> <span class="string">msec</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">SERVER:</span> <span class="number">30.30</span><span class="number">.30</span><span class="number">.30</span><span class="comment">#53(30.30.30.30)</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">WHEN:</span> <span class="string">Mon</span> <span class="string">Jun</span> <span class="number">20</span> <span class="number">10</span><span class="string">:45:37</span> <span class="string">CST</span> <span class="number">2022</span></span><br><span class="line"><span class="string">;;</span> <span class="attr">MSG SIZE  rcvd:</span> <span class="number">209</span></span><br></pre></td></tr></table></figure>

<h4 id="使用网站测试"><a href="#使用网站测试" class="headerlink" title="使用网站测试"></a>使用网站测试</h4><p>使用该网址，将域名更换为对应的域名：<a href="http://ipv6-test.com/validate.php?url=http://www.microsoft.com">http://ipv6-test.com/validate.php?url=http://www.microsoft.com</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/ipv6-check.png"></p>
<h2 id="启用ipv6"><a href="#启用ipv6" class="headerlink" title="启用ipv6"></a>启用ipv6</h2><p>ipv6特性可以设置在整个系统级别或者单个网卡上，默认启用。</p>
<h3 id="系统级别"><a href="#系统级别" class="headerlink" title="系统级别"></a>系统级别</h3><p>系统级别可以通过内核参数 net.ipv6.conf.all.disable_ipv6 来查看是否启用，如果输出结果为0，说明启用。可以修改该内核参数的值来开启或者关闭系统级别的ipv6特性。</p>
<p>也可以通过修改grub的内核参数来选择开启或者关闭，在  &#x2F;etc&#x2F;default&#x2F;grub 中GRUB_CMDLINE_LINUX追加如下内容，其中xxxxx代表当前已经有的参数：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">GRUB_CMDLINE_LINUX=&quot;xxxxx</span> <span class="string">ipv6.disable=1&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="网卡级别"><a href="#网卡级别" class="headerlink" title="网卡级别"></a>网卡级别</h3><p>可以通过 <code>ifconfig ethx</code> 命令来查看网卡信息，如果其中包含了inet6，则说明该网卡启用了ipv6特性。</p>
<p>也可以通过 <code>sysctl net.ipv6.conf.ethx.disable_ipv6</code> 来查看网卡是否启用。其中ethx为对应的网卡名称。</p>
<h3 id="nginx支持ipv6"><a href="#nginx支持ipv6" class="headerlink" title="nginx支持ipv6"></a>nginx支持ipv6</h3><p>默认情况下，nginx不支持ipv6，要支持ipv6，需要在编译的时候指定 –with-ipv6 选项。</p>
<p>在编译完成后，通过nginx -V 查看需要包含 –with-ipv6 选项。</p>
<h2 id="配置-ipv6"><a href="#配置-ipv6" class="headerlink" title="配置 ipv6"></a>配置 ipv6</h2><p>ifconfig  eth0  inet6 add 2607:f8b0:4003:c0b::71</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.aliyun.com/article/87556?spm=a2c6h.13813017.content3.1.7de919b7VnWCcD">Linux有问必答：如何在Linux下禁用IPv6</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java读取C语言写的二进制文件</title>
    <url>/post/java_call_c_bit_file/</url>
    <content><![CDATA[<p>本程序将讲解java调用C语言写的二进制文件，并将二进制文件中的内容利用Java读出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">union data  </span><br><span class="line">&#123;  </span><br><span class="line">    int inter;  </span><br><span class="line">    char ch;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Test</span><br><span class="line">&#123;</span><br><span class="line">    int length;</span><br><span class="line">    char arr[20];</span><br><span class="line"></span><br><span class="line">    void toBigEndian()</span><br><span class="line">    &#123;   </span><br><span class="line">        union data c;</span><br><span class="line">        c.inter = 1;</span><br><span class="line">        if(c.ch == 1)</span><br><span class="line">        &#123;   </span><br><span class="line">            // 小端</span><br><span class="line">            unsigned char temp;</span><br><span class="line">            unsigned char *tempData = (unsigned char *)&amp;length;</span><br><span class="line">            for (int i=0; i &lt; sizeof(int) / 2; i++)</span><br><span class="line">            &#123;   </span><br><span class="line">                temp = tempData[i];</span><br><span class="line">                tempData[i] = tempData[sizeof(int) - i - 1]; </span><br><span class="line">                tempData[sizeof(int) - i - 1] = temp;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Test test;</span><br><span class="line">    memset(&amp;test, 0, sizeof(Test));</span><br><span class="line">    test.length = 0x12345678;</span><br><span class="line">    strcpy(test.arr, &quot;hello world&quot;);</span><br><span class="line">    test.toBigEndian();</span><br><span class="line">    FILE *file = fopen(&quot;test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">    fwrite(&amp;test, sizeof(Test), 1, file);</span><br><span class="line">    fclose(file);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例子中的C程序将一个包含int变量和char数组的结构体写入文件中。</p>
<p>其中需要考虑到机器的大小端问题，java程序采用的大端字节序，因此这里将C的结构体在写入文件时转换成大端字节序。在将结构体写入到文件时，将其中的int类型变量转换成大端字节序，如果机器本身即为大端字节序则不需要转换字节序。</p>
<p>java端读取的文件代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">byte2int</span><span class="params">(<span class="type">byte</span>[] res)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">targets</span> <span class="operator">=</span> (res[<span class="number">3</span>] &amp; <span class="number">0xff</span>) | (res[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | (res[<span class="number">1</span>] &lt;&lt; <span class="number">16</span>) | (res[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">		<span class="keyword">return</span> targets; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">50</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">			<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> fis.read(data);</span><br><span class="line">			System.out.println(<span class="string">&quot;读取到&quot;</span> + size + <span class="string">&quot;个字节的数据&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 转换完成的int值</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> byte2int(data);</span><br><span class="line">		System.out.printf(<span class="string">&quot;%x\n&quot;</span>, value);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">4</span>; i&lt;<span class="number">24</span>; i++) &#123;</span><br><span class="line">			System.out.print((<span class="type">char</span>)data[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>json patch</title>
    <url>/post/json-patch/</url>
    <content><![CDATA[<h1 id="json-patch"><a href="#json-patch" class="headerlink" title="json patch"></a>json patch</h1><p>该规范定义在 <a href="https://datatracker.ietf.org/doc/html/rfc6902/">RFC 6902</a>，定义了修改 json 格式的规范，同时还可以配合 http patch 请求一起使用，实例如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PATCH /my/data HTTP/<span class="number">1.1</span></span><br><span class="line">Host<span class="punctuation">:</span> example.org</span><br><span class="line">Content-Length<span class="punctuation">:</span> <span class="number">326</span></span><br><span class="line">Content-Type<span class="punctuation">:</span> application/json-patch+json</span><br><span class="line">If-Match<span class="punctuation">:</span> <span class="string">&quot;abc123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;op&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/a/b/c&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;foo&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;op&quot;</span><span class="punctuation">:</span> <span class="string">&quot;remove&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/a/b/c&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;op&quot;</span><span class="punctuation">:</span> <span class="string">&quot;add&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/a/b/c&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;foo&quot;</span><span class="punctuation">,</span> <span class="string">&quot;bar&quot;</span> <span class="punctuation">]</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;op&quot;</span><span class="punctuation">:</span> <span class="string">&quot;replace&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/a/b/c&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">42</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;op&quot;</span><span class="punctuation">:</span> <span class="string">&quot;move&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/a/b/c&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/a/b/d&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;op&quot;</span><span class="punctuation">:</span> <span class="string">&quot;copy&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/a/b/d&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/a/b/e&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>支持add、remove、replace、move、copy和 test 六个patch动作。</p>
<h2 id="协议规范"><a href="#协议规范" class="headerlink" title="协议规范"></a>协议规范</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;op&quot;</span><span class="punctuation">:</span> <span class="string">&quot;add&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/hello&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;foo&quot;</span> <span class="punctuation">]</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>规范：</p>
<ol>
<li>如果原始 json 中不存在 key “&#x2F;hello”，则会全新创建 key。</li>
<li>如果原始 json 存在 key “&#x2F;hello”，则会直接覆盖；即使”&#x2F;hello”为数组，也不会在原先的基础上追加，而是直接强制覆盖；</li>
</ol>
<p>原始 json 如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;hello&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;123&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>执行后结果如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hello&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;world&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>用来删除某个 key，格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;op&quot;</span><span class="punctuation">:</span> <span class="string">&quot;remove&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/hello&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>用来替换某个 key，跟 add 动作的差异是，如果 key 不存在，则不会创建 key。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;op&quot;</span><span class="punctuation">:</span> <span class="string">&quot;replace&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/hello&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">42</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果原始 json 格式为: <code>&#123;&#125;</code>，执行完成后，输出 json 格式仍然为：<code>&#123;&#125;</code>。</p>
<h3 id="move"><a href="#move" class="headerlink" title="move"></a>move</h3><p>用来修改 key 的名称，格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;op&quot;</span><span class="punctuation">:</span> <span class="string">&quot;move&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/hello&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/hello2&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果 key 不存在，则不做任何修改。</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>用来复制某个 key，格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;op&quot;</span><span class="punctuation">:</span> <span class="string">&quot;copy&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/hello&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/hello2&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果原始 key 不存在，则不复制；如果目标 key 已经存在，则仍然会复制。</p>
<p>原始 json 如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;hello&quot;</span><span class="punctuation">:</span> <span class="string">&quot;world&quot;</span><span class="punctuation">,</span></span><br><span class="line"> <span class="attr">&quot;hello2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;world2&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>执行完成后的 json 如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hello&quot;</span><span class="punctuation">:</span> <span class="string">&quot;world&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hello2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>用来测试 key 对应的 value 是否相等，该操作并不常用</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;op&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/a/b/c&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;foo&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><a href="https://json-patch-builder-online.github.io/">JSON Patch Builder Online</a> 在线工具，可根据原始 json 和 patch 完成后的 json，产生 json patch</li>
<li><a href="https://jsonpatch.me/">jsonpatch.me</a> 在线工具，可根据原始 json 和 json patch，产生 patch 完成后的 json</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述协议可以发现如下缺点：</p>
<ol>
<li>对于数组的处理不是太理想，如果要删除数组中的某个元素，或者在数组中追加某个元素，则无法表达。</li>
<li>该协议对于人类并不友好。</li>
</ol>
<h1 id="json-merge-patch"><a href="#json-merge-patch" class="headerlink" title="json merge patch"></a>json merge patch</h1><p>定义在 <a href="https://www.rfc-editor.org/rfc/rfc7386">RFC 7386</a>，由于patch 能力比较有限，使用场景较少。</p>
<p>同样可以配合 http patch 方法一起使用，http 请求如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PATCH /target HTTP/<span class="number">1.1</span></span><br><span class="line">Host<span class="punctuation">:</span> example.org</span><br><span class="line">Content-Type<span class="punctuation">:</span> application/merge-patch+json</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;a&quot;</span><span class="punctuation">:</span><span class="string">&quot;z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;c&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;f&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>下面结合具体的实例来说明 json merge patch 的功能。<br>原始 json 格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Goodbye!&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;givenName&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;John&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;familyName&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Doe&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span> <span class="string">&quot;example&quot;</span><span class="punctuation">,</span> <span class="string">&quot;sample&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This will be unchanged&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>patch json 格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello!&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;phoneNumber&quot;</span><span class="punctuation">:</span> <span class="string">&quot;+01-123-456-7890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;familyName&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;example&quot;</span> <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中 null 用来表示该 key 需要删除。对于数组类型，则直接覆盖数组中的值。<br>patch 完成后的 json 如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello!&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;givenName&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;John&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;example&quot;</span> <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This will be unchanged&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;phoneNumber&quot;</span><span class="punctuation">:</span> <span class="string">&quot;+01-123-456-7890&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过上述实例可以发现如下的功能缺陷：</p>
<ol>
<li>如果某个 json 的 key 对应的值为 null，则无法表达，即不可以将某个 key 对应的value 设置为 null。</li>
<li>对于数组的处理非常弱，是直接对数组中所有元素的替换。</li>
</ol>
<h1 id="k8s-strategic-merge-patch"><a href="#k8s-strategic-merge-patch" class="headerlink" title="k8s strategic merge patch"></a>k8s strategic merge patch</h1><p>该协议的资料较少，官方参考资料只有两篇文章，最好结合着 k8s 的代码才能完全理解：</p>
<ul>
<li><a href="https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/">Update API Objects in Place Using kubectl patch</a></li>
<li><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machinery/strategic-merge-patch.md">Strategic Merge Patch</a></li>
<li><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#podspec-v1-core">Pod Spec 定义</a></li>
</ul>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>无论是 json patch，还是 json merge patch 协议，对于数组元素的支持都不够友好。<br>比如对于如下的 json：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">spec<span class="punctuation">:</span></span><br><span class="line">  containers<span class="punctuation">:</span></span><br><span class="line">    - name<span class="punctuation">:</span> nginx</span><br><span class="line">      image<span class="punctuation">:</span> nginx<span class="number">-1.0</span></span><br></pre></td></tr></table></figure>
<p>期望能够 patch 如下的内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">spec<span class="punctuation">:</span></span><br><span class="line">  containers<span class="punctuation">:</span></span><br><span class="line">    - name<span class="punctuation">:</span> log-tailer</span><br><span class="line">      image<span class="punctuation">:</span> log-tailer<span class="number">-1.0</span></span><br></pre></td></tr></table></figure>
<p>从而可以实现 containers中包含两个元素的情况，无论是 json patch 还是 json merge patch，其行为是对数组元素的直接替换，不能实现追加的功能。</p>
<h2 id="协议规范-1"><a href="#协议规范-1" class="headerlink" title="协议规范"></a>协议规范</h2><p>为了解决 json merge patch 的功能缺陷，strategic merge patch 通过如下两种方式来扩展功能：</p>
<ol>
<li>json merge patch 的 json 语法增强，增加一些额外的指令</li>
<li>通过增强原始 json 的 struct 结构实现，跟 golang 语言强绑定，通过 golang 中的 struct tag 机制实现。这样的好处是不用再扩充 json merge patch 的 json 格式了。支持如下 struct tag：<ol>
<li>patchStrategy： 指定策略指令，支持：replace、merge 和 delete。默认的行为为 replace，保持跟 json merge patch 的兼容性。</li>
<li>patchMergeKey: 数组一个子 map 元素的主键，类似于关系型数据库中一行记录的主键。</li>
</ol>
</li>
</ol>
<p>支持如下指令：</p>
<ol>
<li>replace</li>
<li>merge</li>
<li>delete</li>
</ol>
<h3 id="replace-1"><a href="#replace-1" class="headerlink" title="replace"></a>replace</h3><p>支持 go struct tag 和 在 json patch 中增加指令两种方式。<br>replace 是默认的指令模式，对于数组而言会直接全部替换数组内容。</p>
<p>如下指令用来表示，</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">$patch<span class="punctuation">:</span> replace  # recursive and applies to all fields of the map it&#x27;s in</span><br><span class="line">containers<span class="punctuation">:</span></span><br><span class="line">- name<span class="punctuation">:</span> nginx</span><br><span class="line">  image<span class="punctuation">:</span> nginx<span class="number">-1.0</span></span><br></pre></td></tr></table></figure>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>删除数组中的特定元素，下面例子可以删除数组中包含 name: log-tailer 的元素。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">containers<span class="punctuation">:</span></span><br><span class="line">  - name<span class="punctuation">:</span> nginx</span><br><span class="line">    image<span class="punctuation">:</span> nginx<span class="number">-1.0</span></span><br><span class="line">  - $patch<span class="punctuation">:</span> delete</span><br><span class="line">    name<span class="punctuation">:</span> log-tailer  # merge key and value goes here</span><br></pre></td></tr></table></figure>
<p>删除 map 的特定 key，如下实例可以删除 map 中的 key rollingUpdate。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">rollingUpdate<span class="punctuation">:</span></span><br><span class="line">  $patch<span class="punctuation">:</span> delete</span><br></pre></td></tr></table></figure>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>该指令仅支持 go struct tag 模式，格式为：<code>$deleteFromPrimitiveList/&lt;keyOfPrimitiveList&gt;: [a primitive list]</code>。</p>
<h4 id="deleteFromPrimitiveList"><a href="#deleteFromPrimitiveList" class="headerlink" title="deleteFromPrimitiveList"></a>deleteFromPrimitiveList</h4><p>删除数组中的某个元素<br>go struct 定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Finalizers []<span class="type">string</span> <span class="string">`json:&quot;finalizers,omitempty&quot; patchStrategy:&quot;merge&quot; protobuf:&quot;bytes,14,rep,name=finalizers&quot;`</span></span><br></pre></td></tr></table></figure>
<p>原始 yaml 如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">finalizers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">a</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">b</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">c</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">b</span></span><br></pre></td></tr></table></figure>
<p>patch yaml 如下，用来表示删除finalizers中的所有元素 b 和 c</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The directive includes the prefix $deleteFromPrimitiveList and</span></span><br><span class="line"><span class="comment"># followed by a &#x27;/&#x27; and the name of the list.</span></span><br><span class="line"><span class="comment"># The values in this list will be deleted after applying the patch.</span></span><br><span class="line"><span class="string">$deleteFromPrimitiveList/finalizers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">b</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">c</span></span><br></pre></td></tr></table></figure>
<p>最终得到结果：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">finalizers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">a</span></span><br></pre></td></tr></table></figure>
<h4 id="setElementOrder"><a href="#setElementOrder" class="headerlink" title="setElementOrder"></a>setElementOrder</h4><p>用于数组中的元素排序</p>
<h5 id="简单数组排序例子"><a href="#简单数组排序例子" class="headerlink" title="简单数组排序例子"></a>简单数组排序例子</h5><p>原始内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">finalizers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">a</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">b</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">c</span></span><br></pre></td></tr></table></figure>
<p>设置排序顺序：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The directive includes the prefix $setElementOrder and</span></span><br><span class="line"><span class="comment"># followed by a &#x27;/&#x27; and the name of the list.</span></span><br><span class="line"><span class="string">$setElementOrder/finalizers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">b</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">c</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">a</span></span><br></pre></td></tr></table></figure>
<p>最终得到排序顺序：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">finalizers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">b</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">c</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">a</span></span><br></pre></td></tr></table></figure>
<h5 id="map-类型数组排序例子"><a href="#map-类型数组排序例子" class="headerlink" title="map 类型数组排序例子"></a>map 类型数组排序例子</h5><p>其中 patchMergeKey 为 name 字段</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">a</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">b</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">c</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure>
<p>patch 指令的格式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># each map in the list should only include the mergeKey</span></span><br><span class="line"><span class="string">$setElementOrder/containers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">b</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">c</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">a</span></span><br></pre></td></tr></table></figure>
<p>最终获得结果：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">b</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">c</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">a</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure>
<h4 id="retainKeys"><a href="#retainKeys" class="headerlink" title="retainKeys"></a>retainKeys</h4><p>用来清理 map 结构中的 key，并指定保留的 key<br>原始内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">union:</span></span><br><span class="line">  <span class="attr">foo:</span> <span class="string">a</span></span><br><span class="line">  <span class="attr">other:</span> <span class="string">b</span></span><br></pre></td></tr></table></figure>
<p>patch 内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">union:</span></span><br><span class="line">  <span class="attr">retainKeys:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">another</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bar</span></span><br><span class="line">  <span class="attr">another:</span> <span class="string">d</span></span><br><span class="line">  <span class="attr">bar:</span> <span class="string">c</span></span><br></pre></td></tr></table></figure>
<p>最终结果，可以看到 foo 和 other 因为不在保留列表中已经被清楚了。同时新增加了字段 another 和 bar，新增加的是字段是直接 patch 的结果，同时这两个字段也在保留的列表内。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">union:</span></span><br><span class="line">  <span class="comment"># Field foo and other have been cleared w/o explicitly set them to null.</span></span><br><span class="line">  <span class="attr">another:</span> <span class="string">d</span></span><br><span class="line">  <span class="attr">bar:</span> <span class="string">c</span></span><br></pre></td></tr></table></figure>

<h1 id="strategic-merge-patch-在-k8s-中应用"><a href="#strategic-merge-patch-在-k8s-中应用" class="headerlink" title="strategic merge patch 在 k8s 中应用"></a>strategic merge patch 在 k8s 中应用</h1><p>kubectl patch 命令通过–type 参数提供了几种 patch 方法。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">--type=&#x27;strategic&#x27;<span class="punctuation">:</span> The type of patch being provided; one of <span class="punctuation">[</span>json merge strategic<span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<ol>
<li>json：即支持 json patch 协议，例子：<code>kubectl patch pod valid-pod --type=&#39;json&#39; -p=&#39;[&#123;&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/spec/containers/0/image&quot;, &quot;value&quot;:&quot;newimage&quot;&#125;]</code></li>
<li>merge：对应的为 json merge patch 协议。</li>
<li>stategic：k8s 特有的 patch 协议，在 json merge patch 协议基础上的扩展，可以解决 json merge patch 的缺点。</li>
</ol>
<p>对于 k8s 的 CRD 对象，由于不存在 go struct tag，因此无法使用 stategic merge patch。</p>
<p>TODO：待补充具体例子</p>
<h1 id="kubectl-patch、replace、apply之间的区别"><a href="#kubectl-patch、replace、apply之间的区别" class="headerlink" title="kubectl patch、replace、apply之间的区别"></a>kubectl patch、replace、apply之间的区别</h1><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>kubectl patch 命令的实现比较简单，直接调用 kube-apiserver 的接口在 server 端实现 patch 操作。</p>
<h2 id="replace-2"><a href="#replace-2" class="headerlink" title="replace"></a>replace</h2><p>如果该命令使用 –force&#x3D;true 参数，则会先删除对象，然后再提交，相当于是全新创建。</p>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>apply 的实现相对比较复杂，逻辑也比较绕，可以实现 map 结构中的字段增删改操作，数组中数据的增删改操作。实现上会将多份数据进行merge 后提交，数据包含：</p>
<ol>
<li>要重新 apply 的 yaml</li>
<li>对象的annotation kubectl.kubernetes.io&#x2F;last-applied-configuration 包含的内容</li>
<li>运行时的 k8s 对象</li>
</ol>
<p>具体的操作步骤：</p>
<ol>
<li>要重新 apply 的 yaml 跟annotation kubectl.kubernetes.io&#x2F;last-applied-configuration 包含的内容比较，获取到要删除的字段。</li>
<li>要重新 apply 的 yaml 跟运行时的 k8s 对象进行比较，获取到要增加的字段。</li>
<li>上述两个结果再进行一次 merge 操作，最终调用 kube-apiserver 的接口实现 patch 操作。</li>
</ol>
<p>为什么一定需要用到kubectl.kubernetes.io&#x2F;last-applied-configuration的数据呢？<br>在 yaml 对象提交到 k8s 后，k8s 会自动增加一些字段，也可以通过额外的方式修改对象增加一些字段。如果 patch 内容仅跟运行时结果比较，会导致一些运行时的k8s 自动增加的字段或者手工更新的字段被删除掉。</p>
<table>
<thead>
<tr>
<th>试验</th>
<th>上次提交 last-applied-configuration</th>
<th>运行时</th>
<th>patch 内容</th>
<th>结果</th>
<th>结果分析</th>
</tr>
</thead>
<tbody><tr>
<td>试验一</td>
<td>label1: first</td>
<td>label1: first</td>
<td>label2: second</td>
<td>label2: second</td>
<td>1. patch 内容跟上次内容比较，发现要删除字段 label1<br>2. patch 内容跟运行时比较，发现新增加了字段 label2  <br>3. 最终 label1 被删除，仅保留 label2</td>
</tr>
<tr>
<td>试验二</td>
<td>label1: first</td>
<td>label1: first <br>label2: second</td>
<td>label1: first</td>
<td>label1: first <br>label2: second</td>
<td>1. patch 内容跟上次内容比较，发现结果无变化<br>2. patch 内容跟运行时比较，发现要新增加字段 label2<br>3. 最终新增加字段 label2</td>
</tr>
</tbody></table>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://datatracker.ietf.org/doc/html/rfc6902/">json patch RFC 规范</a></li>
<li><a href="https://jsonpatch.com/">https://jsonpatch.com/</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>k8s CSI</title>
    <url>/post/k8s-CSI/</url>
    <content><![CDATA[<p><a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">CSI</a>：Container Storage Interface (CSI)</p>
<p>Volume 的三个阶段：</p>
<ol>
<li>Provision and Delete：负责卷的创建以及销毁。</li>
<li>Attaching and Detaching：将卷设备挂载到本地或者从本地卸载。</li>
<li>Mount and Umount：将 Attaching 的块设备以目录形式挂载到 pod中，或者从 pod 中卸载块设备。</li>
</ol>
<h1 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h1><p>CSI 插件分为三个部分：</p>
<ol>
<li>CSI Identity：用来获取 CSI 的身份信息</li>
<li>CSI Controller</li>
<li>CSI Node</li>
</ol>
<p>参考 k8s 官方的 hostpath 项目：<a href="https://github.com/kubernetes-csi/csi-driver-host-path">https://github.com/kubernetes-csi/csi-driver-host-path</a></p>
<p>为了方便开发，在每个阶段 k8s 官方均实现了对应的 SideCarSet 容器。要想研发，仅需要实现 grpc server，又 SideCarSet 容器调用自研的容器。</p>
<p>自研的容器需要实现如下的接口即可。</p>
<h2 id="CSI-Identity"><a href="#CSI-Identity" class="headerlink" title="CSI Identity"></a>CSI Identity</h2><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">Identity</span> &#123;</span><br><span class="line">  <span class="comment">// 返回插件名字以及版本号</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetPluginInfo(GetPluginInfoRequest) <span class="keyword">returns</span> (GetPluginInfoResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回插件的包含的功能</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetPluginCapabilities(GetPluginCapabilitiesRequest) <span class="keyword">returns</span> (GetPluginCapabilitiesResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Probe (ProbeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ProbeResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>External provisioner 会调用该接口。</p>
<h2 id="CSI-Controller"><a href="#CSI-Controller" class="headerlink" title="CSI Controller"></a>CSI Controller</h2><p>实现 Volume 中的 Provisioning and Deleting 和 Attaching and Detaching 两个阶段的功能。只有块存储 CSI 插件才需要 Attach 功能。<br>该部分以中心化组件的方式部署，比如 Deployment。Provision 功能对应的 SidecarSet 为 <a href="https://github.com/kubernetes-csi/external-provisioner">external-provisioner</a>，Attach 对应的 SidecarSet 为 <a href="https://github.com/kubernetes-csi/external-attacher">external-attacher</a>。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">Controller</span> &#123;</span><br><span class="line">  <span class="comment">// Provisioning， External provisioner调用</span></span><br><span class="line">  <span class="comment">// hostPath 实现中会调用 fallocate 实现</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> CreateVolume (CreateVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (CreateVolumeResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Deleting， External provisioner调用</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> DeleteVolume (DeleteVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (DeleteVolumeResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Attaching, 只有块设备才需要实现，比如云盘，由External attach 调用</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ControllerPublishVolume (ControllerPublishVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ControllerPublishVolumeResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Detaching，External attach 调用</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ControllerUnpublishVolumeResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ValidateVolumeCapabilitiesResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ListVolumes (ListVolumesRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ListVolumesResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetCapacity (GetCapacityRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (GetCapacityResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ControllerGetCapabilities (ControllerGetCapabilitiesRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ControllerGetCapabilitiesResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建快照功能</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> CreateSnapshot (CreateSnapshotRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (CreateSnapshotResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除快照功能</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> DeleteSnapshot (DeleteSnapshotRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (DeleteSnapshotResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ListSnapshots (ListSnapshotsRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ListSnapshotsResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ControllerExpandVolume (ControllerExpandVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ControllerExpandVolumeResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ControllerGetVolume (ControllerGetVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ControllerGetVolumeResponse) </span>&#123;</span><br><span class="line">        <span class="keyword">option</span> (alpha_method) = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ControllerModifyVolume (ControllerModifyVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (ControllerModifyVolumeResponse) </span>&#123;</span><br><span class="line">        <span class="keyword">option</span> (alpha_method) = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CSI-Node"><a href="#CSI-Node" class="headerlink" title="CSI Node"></a>CSI Node</h2><p>实现 Volume 中的Mount 和 Umount 阶段，由 kubelet 负责调用。<br>该部分以 DaemonSet 的形式部署在每个 k8s node 上，对应的 SidecarSet 容器为 <a href="https://github.com/kubernetes-csi/node-driver-registrar">node-driver-registrer</a>。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="comment">// 针对块存储类型，将块设备格式化后先挂载到一个临时全局目录</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> NodeStageVolume (NodeStageVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeStageVolumeResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> NodeUnstageVolume (NodeUnstageVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeUnstageVolumeResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是块存储设备，在执行完 NodeStageVolume 后，使用 linux 的 bind mount 技术将全局目录挂载到pod 中的对应目录</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> NodePublishVolume (NodePublishVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodePublishVolumeResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> NodeUnpublishVolume (NodeUnpublishVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeUnpublishVolumeResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> NodeGetVolumeStats (NodeGetVolumeStatsRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeGetVolumeStatsResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> NodeExpandVolume(NodeExpandVolumeRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeExpandVolumeResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> NodeGetCapabilities (NodeGetCapabilitiesRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeGetCapabilitiesResponse) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> NodeGetInfo (NodeGetInfoRequest)</span></span><br><span class="line"><span class="function">    <span class="keyword">returns</span> (NodeGetInfoResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p>协议：<a href="https://github.com/container-storage-interface/spec/blob/master/spec.md">https://github.com/container-storage-interface/spec/blob/master/spec.md</a></p>
]]></content>
  </entry>
  <entry>
    <title>k8s ipv4/ipv6双栈</title>
    <url>/post/k8s-dual-stack/</url>
    <content><![CDATA[<h1 id="ipv6在k8s中的支持情况"><a href="#ipv6在k8s中的支持情况" class="headerlink" title="ipv6在k8s中的支持情况"></a>ipv6在k8s中的支持情况</h1><p>ipv6特性在k8s中作为一个特定的feature IPv6DualStack来管理。在1.15版本到1.20版本该feature为alpha版本，默认不开启。从1.21版本开始，该feature为beta版本，默认开启，支持pod和service网络的双栈。1.23版本变为稳定版本。</p>
<h2 id="配置双栈"><a href="#配置双栈" class="headerlink" title="配置双栈"></a>配置双栈</h2><p>alpha版本需要通过kube-apiserver、kube-controller-manager、kubelet和kube-proxy的–feature-gates&#x3D;”IPv6DualStack&#x3D;true”命令来开启该特性，beta版本该特性默认开启。<br />​</p>
<p>kube-apiserver：</p>
<ul>
<li><code>--service-cluster-ip-range=&lt;IPv4 CIDR&gt;,&lt;IPv6 CIDR&gt;</code></li>
</ul>
<p>kube-controller-manager:</p>
<ul>
<li><code>--cluster-cidr=&lt;IPv4 CIDR&gt;,&lt;IPv6 CIDR&gt;</code></li>
<li><code>--service-cluster-ip-range=&lt;IPv4 CIDR&gt;,&lt;IPv6 CIDR&gt;</code></li>
<li><code>--node-cidr-mask-size-ipv4|--node-cidr-mask-size-ipv6</code> 对于 IPv4 默认为 &#x2F;24，对于 IPv6 默认为 &#x2F;64</li>
</ul>
<p>kube-proxy:</p>
<ul>
<li><code>--cluster-cidr=&lt;IPv4 CIDR&gt;,&lt;IPv6 CIDR&gt;</code></li>
</ul>
<h1 id="使用kind创建k8s集群"><a href="#使用kind创建k8s集群" class="headerlink" title="使用kind创建k8s集群"></a>使用kind创建k8s集群</h1><p>由于ipv6的环境并不容易找到，可以使用kind快速在本地拉起一个k8s的单集群环境，同时kind支持ipv6的配置。</p>
<p>检查当前系统是否支持ipv6，如果输出结果为0，说明当前系统支持ipv6.</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> sysctl <span class="literal">-a</span> | grep net.ipv6.conf.all.disable_ipv6</span><br><span class="line">net.ipv6.conf.all.disable_ipv6 = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>创建ipv6单栈k8s集群执行如下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; kind<span class="literal">-ipv6</span>.conf &lt;&lt;EOF</span><br><span class="line">kind: Cluster</span><br><span class="line">apiVersion: kind.x<span class="literal">-k8s</span>.io/v1alpha4</span><br><span class="line">name: ipv6<span class="literal">-only</span></span><br><span class="line">networking:</span><br><span class="line">  ipFamily: ipv6</span><br><span class="line"><span class="comment"># networking:</span></span><br><span class="line">  <span class="comment"># apiServerAddress: &quot;127.0.0.1&quot;</span></span><br><span class="line">  <span class="comment"># apiServerPort: 6443</span></span><br><span class="line">EOF</span><br><span class="line">kind create cluster <span class="literal">--config</span> kind<span class="literal">-ipv6</span>.conf</span><br></pre></td></tr></table></figure>
<p>创建ipv4&#x2F;ipv6双栈集群执行如下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; kind<span class="literal">-dual-stack</span>.conf &lt;&lt;EOF</span><br><span class="line">kind: Cluster</span><br><span class="line">apiVersion: kind.x<span class="literal">-k8s</span>.io/v1alpha4</span><br><span class="line">name: dual<span class="literal">-stack</span></span><br><span class="line">networking:</span><br><span class="line">  ipFamily: dual</span><br><span class="line"><span class="comment"># networking:</span></span><br><span class="line">  <span class="comment"># apiServerAddress: &quot;127.0.0.1&quot;</span></span><br><span class="line">  <span class="comment"># apiServerPort: 6443</span></span><br><span class="line">EOF</span><br><span class="line">kind create cluster <span class="literal">--config</span> kind<span class="literal">-dual-stack</span>.conf</span><br></pre></td></tr></table></figure>
<h1 id="service网络"><a href="#service网络" class="headerlink" title="service网络"></a>service网络</h1><h2 id="spec定义"><a href="#spec定义" class="headerlink" title="spec定义"></a>spec定义</h2><p>k8s的service网络为了支持双栈，新增加了几个字段。</p>
<p>.spec.ipFamilies用来设置地址族，service一旦场景后该值不可认为修改，但可以通过修改.spec.ipFamilyPolicy来简介修改该字段的值。为数组格式，支持如下值：</p>
<ul>
<li>[“IPv4”]</li>
<li>[“IPv6”]</li>
<li>[“IPv4”,”IPv6”] （双栈）</li>
<li>[“IPv6”,”IPv4”] （双栈）</li>
</ul>
<p>上述数组中的第一个元素会决定.spec.ClusterIP中的字段。<br />​</p>
<p>.spec.ClusterIPs：由于.spec.ClusterIP的value为字符串，不支持同时设置ipv4和ipv6两个ip地址。因此又扩展出来了一个.spec.ClusterIPs字段，该字段的value为宿主元祖。在Headless类型的Service情况下，该字段的值为None。<br />​</p>
<p>.spec.ClusterIP：该字段的值跟.spec.ClusterIPs中的第一个元素的值保持一致。<br />​</p>
<p>.spec.ipFamilyPolicy支持如下值：</p>
<ul>
<li>SingleStack：默认值。会使用.spec.ipFamilies数组中配置的第一个协议来分配cluster ip。如果没有指定.spec.ipFamilies，会使用service-cluster-ip-range配置中第一个cidr中来配置地址。</li>
<li>PreferDualStack：如果 .spec.ipFamilies 没有设置，使用 k8s 集群默认的 ipFamily。</li>
<li>RequireDualStack：同时分配ipv4和ipv6地址。.spec.ClusterIP的值会从.spec.ClusterIPs选择第一个元素。</li>
</ul>
<h2 id="service配置场景"><a href="#service配置场景" class="headerlink" title="service配置场景"></a>service配置场景</h2><p>先创建如下的deployment，以便于后面试验的service可以关联到pod。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h3 id="未指定任何协议栈信息"><a href="#未指定任何协议栈信息" class="headerlink" title="未指定任何协议栈信息"></a>未指定任何协议栈信息</h3><p>在没有指定协议栈信息的Service，创建出来的service .spec.ipFamilyPolicy为SingleStack。同时会使用service-cluster-ip-range配置中第一个cidr中来配置地址。如果第一个cidr为ipv6，则service分配的clusterip为ipv6地址。创建如下的service</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>会生成如下的service</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.96</span><span class="number">.80</span><span class="number">.114</span></span><br><span class="line">  <span class="attr">clusterIPs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.96</span><span class="number">.80</span><span class="number">.114</span></span><br><span class="line">  <span class="attr">ipFamilies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IPv4</span></span><br><span class="line">  <span class="attr">ipFamilyPolicy:</span> <span class="string">SingleStack</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指定-spec-ipFamilyPolicy为PreferDualStack"><a href="#指定-spec-ipFamilyPolicy为PreferDualStack" class="headerlink" title="指定.spec.ipFamilyPolicy为PreferDualStack"></a>指定.spec.ipFamilyPolicy为PreferDualStack</h3><p>创建如下的service</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service-2</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ipFamilyPolicy:</span> <span class="string">PreferDualStack</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>提交到环境后会生成如下的service，可以看到.spec.clusterIPs中的ip地址跟ipFamilies中的顺序一致。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service-2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.96</span><span class="number">.221</span><span class="number">.70</span></span><br><span class="line">  <span class="attr">clusterIPs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.96</span><span class="number">.221</span><span class="number">.70</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">fd00:10:96::7d1</span></span><br><span class="line">  <span class="attr">ipFamilies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IPv4</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IPv6</span></span><br><span class="line">  <span class="attr">ipFamilyPolicy:</span> <span class="string">PreferDualStack</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>查看Endpoints，可以看到subsets中的地址为pod的ipv4协议地址。Endpoints中的地址跟service的.spec.ipFamilies数组中的第一个协议的值保持一致。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service-2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">10.244</span><span class="number">.0</span><span class="number">.5</span></span><br><span class="line">    <span class="attr">nodeName:</span> <span class="string">dual-stack-control-plane</span></span><br><span class="line">    <span class="attr">targetRef:</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nginx-deployment-65b5dd4c68-vrfps</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">resourceVersion:</span> <span class="string">&quot;16875&quot;</span></span><br><span class="line">      <span class="attr">uid:</span> <span class="string">30a1d787-f799-4250-8c56-c96564ca9239</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">10.244</span><span class="number">.0</span><span class="number">.6</span></span><br><span class="line">    <span class="attr">nodeName:</span> <span class="string">dual-stack-control-plane</span></span><br><span class="line">    <span class="attr">targetRef:</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nginx-deployment-65b5dd4c68-wgz72</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">resourceVersion:</span> <span class="string">&quot;16917&quot;</span></span><br><span class="line">      <span class="attr">uid:</span> <span class="string">8166d43e-2702-45c6-839e-b3005f44f647</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">10.244</span><span class="number">.0</span><span class="number">.7</span></span><br><span class="line">    <span class="attr">nodeName:</span> <span class="string">dual-stack-control-plane</span></span><br><span class="line">    <span class="attr">targetRef:</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nginx-deployment-65b5dd4c68-x4lt5</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">resourceVersion:</span> <span class="string">&quot;16896&quot;</span></span><br><span class="line">      <span class="attr">uid:</span> <span class="string">f9c2968f-ca59-4ba9-a69f-358c202a964b</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<p>接下来指定.spec.ipFamilies的顺序再看一下执行的结果，创建如下的service</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service-3</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ipFamilyPolicy:</span> <span class="string">PreferDualStack</span></span><br><span class="line">  <span class="attr">ipFamilies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IPv6</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IPv4</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>在环境中生成的service如下，可以看到.spec.clusterIPs中的顺序第一个为ipv6地址，.spec.clusterIP同样为ipv6地址。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service-3</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">fd00:10:96::c306</span></span><br><span class="line">  <span class="attr">clusterIPs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">fd00:10:96::c306</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.96</span><span class="number">.147</span><span class="number">.82</span></span><br><span class="line">  <span class="attr">ipFamilies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IPv6</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IPv4</span></span><br><span class="line">  <span class="attr">ipFamilyPolicy:</span> <span class="string">PreferDualStack</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>查看Endpoints，可以看到subsets中的地址为pod的ipv6协议地址。Endpoints中的地址跟service的.spec.ipFamilies数组中的第一个协议的值保持一致。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service-3</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">fd00:10:244::5</span></span><br><span class="line">    <span class="attr">nodeName:</span> <span class="string">dual-stack-control-plane</span></span><br><span class="line">    <span class="attr">targetRef:</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nginx-deployment-65b5dd4c68-vrfps</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">resourceVersion:</span> <span class="string">&quot;16875&quot;</span></span><br><span class="line">      <span class="attr">uid:</span> <span class="string">30a1d787-f799-4250-8c56-c96564ca9239</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">fd00:10:244::6</span></span><br><span class="line">    <span class="attr">nodeName:</span> <span class="string">dual-stack-control-plane</span></span><br><span class="line">    <span class="attr">targetRef:</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nginx-deployment-65b5dd4c68-wgz72</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">resourceVersion:</span> <span class="string">&quot;16917&quot;</span></span><br><span class="line">      <span class="attr">uid:</span> <span class="string">8166d43e-2702-45c6-839e-b3005f44f647</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">fd00:10:244::7</span></span><br><span class="line">    <span class="attr">nodeName:</span> <span class="string">dual-stack-control-plane</span></span><br><span class="line">    <span class="attr">targetRef:</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nginx-deployment-65b5dd4c68-x4lt5</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">resourceVersion:</span> <span class="string">&quot;16896&quot;</span></span><br><span class="line">      <span class="attr">uid:</span> <span class="string">f9c2968f-ca59-4ba9-a69f-358c202a964b</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<h2 id="单栈和双栈之间的切换"><a href="#单栈和双栈之间的切换" class="headerlink" title="单栈和双栈之间的切换"></a>单栈和双栈之间的切换</h2><p>虽然.spec.ipFamilies字段不允许直接修改，但.spec.ipFamilyPolicy字段允许修改，但并不影响单栈和双栈之间的切换。<br />单栈变双栈只需要修改.spec.ipFamilyPolicy从SingleStack变为PreferDualStack或者RequireDualStack即可。<br />双栈同样可以变为单栈，只需要修改.spec.ipFamilyPolicy从PreferDualStack或者RequireDualStack变为SingleStack即可。此时.spec.ipFamilies会自动变更为一个元素，.spec.clusterIPs同样会变更为一个元素。</p>
<h2 id="LoadBalancer类型的Service"><a href="#LoadBalancer类型的Service" class="headerlink" title="LoadBalancer类型的Service"></a>LoadBalancer类型的Service</h2><p>对于LoadBalancer类型的Service，单栈的情况下，会在.status.loadBalancer.ingress设置vip地址。如果是ingress中的ip地址为双栈，此时应该是将双栈的vip地址同时写到.status.loadBalancer.ingress中，并且要保证其顺序跟serivce的.spec.ipFamilies中的顺序一致。</p>
<h1 id="pod网络"><a href="#pod网络" class="headerlink" title="pod网络"></a>pod网络</h1><p>pod网络要支持ipv6，需要容器网络插件的支持。为了支持ipv6特性，新增加了.status.podIPs字段，用来展示pod上分配的ipv4和ipv6的信息。.status.podIP字段的值跟.status.podIPs数组的第一个元素的值保持一致。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kube-dns</span></span><br><span class="line">    <span class="attr">pod-template-hash:</span> <span class="string">558bd4d5db</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">coredns-558bd4d5db-b2zbj</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-conf</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/etc/coredns/Corefile</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s.gcr.io/coredns/coredns:v1.8.0</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">failureThreshold:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/health</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">53</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dns</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">UDP</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">53</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dns-tcp</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9153</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">metrics</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">readinessProbe:</span></span><br><span class="line">      <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/ready</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8181</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">170Mi</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">70Mi</span></span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">capabilities:</span></span><br><span class="line">        <span class="attr">add:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">NET_BIND_SERVICE</span></span><br><span class="line">        <span class="attr">drop:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">all</span></span><br><span class="line">      <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">terminationMessagePath:</span> <span class="string">/dev/termination-log</span></span><br><span class="line">    <span class="attr">terminationMessagePolicy:</span> <span class="string">File</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/coredns</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/var/run/secrets/kubernetes.io/serviceaccount</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">kube-api-access-hgxnc</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">Default</span></span><br><span class="line">  <span class="attr">enableServiceLinks:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">dual-stack-control-plane</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line">  <span class="attr">preemptionPolicy:</span> <span class="string">PreemptLowerPriority</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">2000000000</span></span><br><span class="line">  <span class="attr">priorityClassName:</span> <span class="string">system-cluster-critical</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line">  <span class="attr">securityContext:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">serviceAccount:</span> <span class="string">coredns</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">coredns</span></span><br><span class="line">  <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">CriticalAddonsOnly</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">defaultMode:</span> <span class="number">420</span></span><br><span class="line">      <span class="attr">items:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">Corefile</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">Corefile</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kube-api-access-hgxnc</span></span><br><span class="line">    <span class="attr">projected:</span></span><br><span class="line">      <span class="attr">defaultMode:</span> <span class="number">420</span></span><br><span class="line">      <span class="attr">sources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">serviceAccountToken:</span></span><br><span class="line">          <span class="attr">expirationSeconds:</span> <span class="number">3607</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">token</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">ca.crt</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">ca.crt</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">kube-root-ca.crt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">downwardAPI:</span></span><br><span class="line">          <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">namespace</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastProbeTime:</span> <span class="literal">null</span></span><br><span class="line">    <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2022-01-16T12:51:24Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Initialized</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="attr">containerStatuses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">containerID:</span> <span class="string">containerd://6da36ab908291ca1b4141a86d70f8c2bb150a933336d852bcabe2118aa1a3439</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">k8s.gcr.io/coredns/coredns:v1.8.0</span></span><br><span class="line">    <span class="attr">imageID:</span> <span class="string">sha256:296a6d5035e2d6919249e02709a488d680ddca91357602bd65e605eac967b899</span></span><br><span class="line">    <span class="attr">lastState:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">name:</span> <span class="string">coredns</span></span><br><span class="line">    <span class="attr">ready:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restartCount:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">started:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">state:</span></span><br><span class="line">      <span class="attr">running:</span></span><br><span class="line">        <span class="attr">startedAt:</span> <span class="string">&quot;2022-01-16T12:51:27Z&quot;</span></span><br><span class="line">  <span class="attr">hostIP:</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line">  <span class="attr">phase:</span> <span class="string">Running</span></span><br><span class="line">  <span class="attr">podIP:</span> <span class="number">10.244</span><span class="number">.0</span><span class="number">.3</span></span><br><span class="line">  <span class="attr">podIPs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">10.244</span><span class="number">.0</span><span class="number">.3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">fd00:10:244::3</span></span><br><span class="line">  <span class="attr">qosClass:</span> <span class="string">Burstable</span></span><br><span class="line">  <span class="attr">startTime:</span> <span class="string">&quot;2022-01-16T12:51:24Z&quot;</span></span><br></pre></td></tr></table></figure>
<p>pod中要想获取到ipv4、ipv6地址，可以通过downward api的形式将.status.podIPs以环境变量的形式传递到容器中，在pod中通过环境变量获取到的格式为: <code>10.244.1.4,a00:100::4</code>。</p>
<h1 id="k8s-node"><a href="#k8s-node" class="headerlink" title="k8s node"></a>k8s node</h1><p>在宿主机上可以通过ip addr show eth0的方式来查看网卡上的ip地址。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip addr show eth0</span></span><br><span class="line"><span class="attr">23:</span> <span class="string">eth0@if24:</span> <span class="string">&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> <span class="string">mtu</span> <span class="number">1500 </span><span class="string">qdisc</span> <span class="string">noqueue</span> <span class="string">state</span> <span class="string">UP</span> <span class="string">group</span> <span class="string">default</span></span><br><span class="line">    <span class="string">link/ether</span> <span class="number">02</span><span class="string">:42:ac:12:00:02</span> <span class="string">brd</span> <span class="string">ff:ff:ff:ff:ff:ff</span> <span class="string">link-netnsid</span> <span class="number">0</span></span><br><span class="line">    <span class="string">inet</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.2</span><span class="string">/16</span> <span class="string">brd</span> <span class="number">172.18</span><span class="number">.255</span><span class="number">.255</span> <span class="string">scope</span> <span class="string">global</span> <span class="string">eth0</span></span><br><span class="line">       <span class="string">valid_lft</span> <span class="string">forever</span> <span class="string">preferred_lft</span> <span class="string">forever</span></span><br><span class="line">    <span class="string">inet6</span> <span class="string">fc00:f853:ccd:e793::2/64</span> <span class="string">scope</span> <span class="string">global</span> <span class="string">nodad</span></span><br><span class="line">       <span class="string">valid_lft</span> <span class="string">forever</span> <span class="string">preferred_lft</span> <span class="string">forever</span></span><br><span class="line">    <span class="string">inet6</span> <span class="string">fe80::42:acff:fe12:2/64</span> <span class="string">scope</span> <span class="string">link</span></span><br><span class="line">       <span class="string">valid_lft</span> <span class="string">forever</span> <span class="string">preferred_lft</span> <span class="string">forever</span></span><br></pre></td></tr></table></figure>
<p>宿主机的网卡上有ipv6地址，k8s node上的.status.addresses中有所体现，type为InternalIP即包含了ipv4地址，又包含了ipv6地址，但此处并没有字段标识当前地址为ipv4，还是ipv6。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Node</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubeadm.alpha.kubernetes.io/cri-socket:</span> <span class="string">unix:///run/containerd/containerd.sock</span></span><br><span class="line">    <span class="attr">node.alpha.kubernetes.io/ttl:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="attr">volumes.kubernetes.io/controller-managed-attach-detach:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">beta.kubernetes.io/arch:</span> <span class="string">amd64</span></span><br><span class="line">    <span class="attr">beta.kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line">    <span class="attr">kubernetes.io/arch:</span> <span class="string">amd64</span></span><br><span class="line">    <span class="attr">kubernetes.io/hostname:</span> <span class="string">dual-stack-control-plane</span></span><br><span class="line">    <span class="attr">kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line">    <span class="attr">node-role.kubernetes.io/control-plane:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">node-role.kubernetes.io/master:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">node.kubernetes.io/exclude-from-external-load-balancers:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dual-stack-control-plane</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podCIDR:</span> <span class="number">10.244</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">  <span class="attr">podCIDRs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.244</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">fd00:10:244::/64</span></span><br><span class="line">  <span class="attr">providerID:</span> <span class="string">kind://docker/dual-stack/dual-stack-control-plane</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">addresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span> <span class="number">172.18</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">InternalIP</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span> <span class="string">fc00:f853:ccd:e793::2</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">InternalIP</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">address:</span> <span class="string">dual-stack-control-plane</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Hostname</span></span><br><span class="line">  <span class="attr">allocatable:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">&quot;4&quot;</span></span><br><span class="line">    <span class="attr">ephemeral-storage:</span> <span class="string">41152812Ki</span></span><br><span class="line">    <span class="attr">hugepages-1Gi:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="attr">hugepages-2Mi:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">15936568Ki</span></span><br><span class="line">    <span class="attr">pods:</span> <span class="string">&quot;110&quot;</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="string">&quot;4&quot;</span></span><br><span class="line">    <span class="attr">ephemeral-storage:</span> <span class="string">41152812Ki</span></span><br><span class="line">    <span class="attr">hugepages-1Gi:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="attr">hugepages-2Mi:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">15936568Ki</span></span><br><span class="line">    <span class="attr">pods:</span> <span class="string">&quot;110&quot;</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastHeartbeatTime:</span> <span class="string">&quot;2022-01-16T15:01:48Z&quot;</span></span><br><span class="line">    <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2022-01-16T12:50:54Z&quot;</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">kubelet</span> <span class="string">has</span> <span class="string">sufficient</span> <span class="string">memory</span> <span class="string">available</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">KubeletHasSufficientMemory</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;False&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">MemoryPressure</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="attr">daemonEndpoints:</span></span><br><span class="line">    <span class="attr">kubeletEndpoint:</span></span><br><span class="line">      <span class="attr">Port:</span> <span class="number">10250</span></span><br><span class="line">  <span class="attr">images:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">names:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">k8s.gcr.io/kube-proxy:v1.21.1</span></span><br><span class="line">    <span class="attr">sizeBytes:</span> <span class="number">132714699</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="attr">nodeInfo:</span></span><br><span class="line">    <span class="attr">architecture:</span> <span class="string">amd64</span></span><br><span class="line">    <span class="attr">bootID:</span> <span class="string">7f95abb9-7731-4a8c-9258-4a91cdcfb2ca</span></span><br><span class="line">    <span class="attr">containerRuntimeVersion:</span> <span class="string">containerd://1.5.2</span></span><br><span class="line">    <span class="attr">kernelVersion:</span> <span class="number">4.18</span><span class="number">.0</span><span class="number">-305.</span><span class="string">an8.x86_64</span></span><br><span class="line">    <span class="attr">kubeProxyVersion:</span> <span class="string">v1.21.1</span></span><br><span class="line">    <span class="attr">kubeletVersion:</span> <span class="string">v1.21.1</span></span><br><span class="line">    <span class="attr">machineID:</span> <span class="string">8f6a98bffc184893ab6bc260e705421b</span></span><br><span class="line">    <span class="attr">operatingSystem:</span> <span class="string">linux</span></span><br><span class="line">    <span class="attr">osImage:</span> <span class="string">Ubuntu</span> <span class="number">21.04</span></span><br><span class="line">    <span class="attr">systemUUID:</span> <span class="string">f7928fdb-32be-4b6e-8dfd-260b6820f067</span></span><br></pre></td></tr></table></figure>
<h1 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h1><p>Ingress 可以通过开关 <code>disable-ipv6</code> 来控制是否开启 ipv6，默认 ipv6 开启。</p>
<p>在开启 ipv6 的情况下，如果 nginx ingress 的 pod 本身没有ipv6 的 ip地址，则在 nginx 的配置文件中并不会监听 ipv6 的端口号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen 80  ;</span><br><span class="line">listen 443  ssl http2 ;</span><br></pre></td></tr></table></figure>

<p>如果 nginx ingress 的 pod 本身包含 ipv6 地址，则 nginx 的配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">listen 80  ;</span><br><span class="line">listen [::]:80  ;</span><br><span class="line">listen 443  ssl http2 ;</span><br><span class="line">listen [::]:443  ssl http2 ;</span><br></pre></td></tr></table></figure>





<p>参考资料：</p>
<ul>
<li>阿里云ACK的Nginx Ingress支持ipv6特性：<a href="https://help.aliyun.com/document_detail/378167.html">https://help.aliyun.com/document_detail/378167.html</a></li>
<li>[Nginx Ingress 支持 ipv6](<a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#disable-ipv6">ConfigMap - NGINX Ingress Controller (kubernetes.github.io)</a>)</li>
</ul>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://kubernetes.io/docs/concepts/services-networking/dual-stack/">https://kubernetes.io/docs/concepts/services-networking/dual-stack/</a></li>
<li><a href="https://kubernetes.io/docs/tasks/network/validate-dual-stack/">https://kubernetes.io/docs/tasks/network/validate-dual-stack/</a></li>
<li><a href="https://kind.sigs.k8s.io/docs/user/configuration/">https://kind.sigs.k8s.io/docs/user/configuration/</a></li>
</ul>
<br />
]]></content>
  </entry>
  <entry>
    <title>k8s pod异常状态分析</title>
    <url>/post/k8s-pod-errors/</url>
    <content><![CDATA[<h1 id="pod状态"><a href="#pod状态" class="headerlink" title="pod状态"></a>pod状态</h1><h2 id="1-前置检查"><a href="#1-前置检查" class="headerlink" title="1. 前置检查"></a>1. 前置检查</h2><p>在排查异常状态的pod错误之前，可以先检查一下node状态，执行<code>kubectl get node</code>查看是否所有的node状态都正常。</p>
<h2 id="2-pod状态为CrashLoopBackOff"><a href="#2-pod状态为CrashLoopBackOff" class="headerlink" title="2. pod状态为CrashLoopBackOff"></a>2. pod状态为CrashLoopBackOff</h2><p>如果pod状态为CrashLoopBackOff状态，查看pod日志来定位原因，或者describe pod看一下。</p>
<h2 id="3-pod状态为Pending"><a href="#3-pod状态为Pending" class="headerlink" title="3. pod状态为Pending"></a>3. pod状态为Pending</h2><p>pod状态为Pending状态，说明调度失败，通常跟污点、标签、cpu、内存、磁盘等资源相关。</p>
<p>可以通过<code>kubectl describe pod -n &#123;NAMESPACE&#125; &#123;POD_NAME&#125;</code>，可以在最后的Event部分找到原因。</p>
<h2 id="4-pod状态为Init-0-x2F-1"><a href="#4-pod状态为Init-0-x2F-1" class="headerlink" title="4. pod状态为Init:0&#x2F;1"></a>4. pod状态为Init:0&#x2F;1</h2><p>有些pod会有Init Containers，这些container是在pod的containers执行之前先执行。如果Init Container出现未执行完成的情况，此时pod处于Init状态。</p>
<p>通过<code>kubectl get pod -n &#123;NAMESPACE&#125; &#123;POD_NAME&#125; -o yaml</code> 找到pod的Init Containers，并找到其中的name字段。执行<code>kubectl logs -n &#123;NAMESPACE&#125; &#123;POD_NAME&#125; -c &#123;INIT_CONTAINER_NAME&#125;</code>可以查看Init Container的日志来分析原因。</p>
<h2 id="5-pod状态为Terminating"><a href="#5-pod状态为Terminating" class="headerlink" title="5. pod状态为Terminating"></a>5. pod状态为Terminating</h2><p>pod处于此种状态的原因大致可分为：<br>1、pod或其控制器被删除。<br>解决方法：查看pod控制器类型和控制器名称，查看其控制器是否正常。如果正常pod将会被重建，如果pod没有被重建，查看controller-manager是否正常。<br>2、pod所在节点状态NotReady导致。<br>解决方法：检查该节点的网络，cpu，内存，磁盘空间等资源是否正常。检查该节点的kubelet、docker服务是否正常。检查该节点的网络插件pod是否正常。</p>
<p>最常见的pod处于Terminating状态的解决办法为强制删除 <code>kubectl delete pods -n $&#123;namespace&#125; $&#123;name&#125; --grace-period=0 --force</code></p>
<h2 id="6-pod状态为Evicted"><a href="#6-pod状态为Evicted" class="headerlink" title="6. pod状态为Evicted"></a>6. pod状态为Evicted</h2><p>pod处于Evicted的原因大致可分为：<br>1、kubelet服务启动时存在驱逐限制当节点资源可用量达到指定阈值（magefs.available&lt;15%,memory.available&lt;300Mi,nodefs.available&lt;10%,nodefs.inodesFree&lt;5%）<br>会优先驱逐Qos级别低的pod以保障Qos级别高的pod可用。<br>解决方法：增加节点资源或将被驱逐的pod迁移到其他空闲资源充足的节点上。<br>2、pod所在节点上被打上了NoExecute的污点，此种污点会将该节点上无法容忍此污点的pod进行驱逐。<br>解决方法：查看该节点上的NoExecute污点是否必要。或者pod是否可以迁移到其他节点。<br>3、pod所在的节点为NotReady状态</p>
<p>通常可以通过<code>kubectl describe pods $&#123;pod&#125; -n $&#123;namespace&#125;</code>的底部的Events信息来找到一些问题的原因。例如下面例子中可以看到DiskPressure信息，说明跟磁盘相关。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Events:</span></span><br><span class="line">  <span class="string">Type</span>     <span class="string">Reason</span>     <span class="string">Age</span>        <span class="string">From</span>                 <span class="string">Message</span></span><br><span class="line">  <span class="string">----</span>     <span class="string">------</span>     <span class="string">----</span>       <span class="string">----</span>                 <span class="string">-------</span></span><br><span class="line">  <span class="string">Warning</span>  <span class="string">Evicted</span>    <span class="string">61s</span>        <span class="string">kubelet,</span> <span class="attr">acs.deploy  The node had condition:</span> [<span class="string">DiskPressure</span>]<span class="string">.</span></span><br><span class="line">  <span class="string">Normal</span>   <span class="string">Scheduled</span>  <span class="string">&lt;invalid&gt;</span>  <span class="string">default-scheduler</span>    <span class="string">Successfully</span> <span class="string">assigned</span> <span class="string">ark-system/bridge-console-bridge-console-554d57bb87-nh2vd</span> <span class="string">to</span> <span class="string">acs.deploy</span></span><br></pre></td></tr></table></figure>
<p>或者根据pod的Message字段来找到原因</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name:           tiller-deploy-7f6456894f-22vgr</span><br><span class="line">Namespace:      kube-system</span><br><span class="line">Priority:       0</span><br><span class="line">Node:           a36e04001.cloud.e04.amtest17/</span><br><span class="line">Start Time:     Mon, 08 Jun 2020 12:17:26 +0800</span><br><span class="line">Labels:         app=helm</span><br><span class="line">                name=tiller</span><br><span class="line">                pod-template-hash=7f6456894f</span><br><span class="line">Annotations:    &lt;none&gt;</span><br><span class="line">Status:         Failed</span><br><span class="line">Reason:         Evicted</span><br><span class="line">Message:        Pod The node had condition: [DiskPressure].</span><br></pre></td></tr></table></figure>
<p>由于pod驱逐的原因排查跟时间点相关，需要根据pod被驱逐的时间来分析当时的状态。<br>4、批量删除状态Evicted的pod，此操作会删除集群里面所有状态为Evicted的pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ns=`kubectl get ns | awk &#x27;NR&gt;1 &#123;print $1&#125;&#x27;`</span><br><span class="line">for i in $ns;do  kubectl get pods -n $i  | grep Evicted| awk &#x27;&#123;print $1&#125;&#x27; | xargs  kubectl delete pods -n $i ;done</span><br></pre></td></tr></table></figure>
<h2 id="7-pod状态为Unknown"><a href="#7-pod状态为Unknown" class="headerlink" title="7. pod状态为Unknown"></a>7. pod状态为Unknown</h2><p>通常该状态为pod对应节点的为NotReady，通过查看 kubectl get node 来查看node是否为NotReady。</p>
<h2 id="8-pod为running，但是Not-Ready状态"><a href="#8-pod为running，但是Not-Ready状态" class="headerlink" title="8. pod为running，但是Not Ready状态"></a>8. pod为running，但是Not Ready状态</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">argo-ui-56f4d67b69-8gshr</span>   <span class="number">0</span><span class="string">/1</span>     <span class="string">Running</span>     <span class="number">0</span>          <span class="string">10h</span></span><br></pre></td></tr></table></figure>
<p>类似上面这种状态，此时说明pod的readiness健康检查没过导致的，需要先从pod的健康检查本身来排查问题。可以通过 <code>kubectl get pods -n $&#123;namespace&#125; $&#123;name&#125; -o yaml</code> 找到pod的健康检查部分，关键字为readiness，然后进入pod中执行对应的健康检查命令来测试健康检查的准确性。</p>
<p>例如readiness的配置如下，需要进入pod中执行<code>curl http://127.0.0.1/api/status</code>，也可以在pod对应的node节点上执行<code>curl [http://$&#123;pod_ip&#125;/api/status](http://127.0.0.1/api/status)</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/api/status</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">120</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="9-pod为ContainerCreating状态"><a href="#9-pod为ContainerCreating状态" class="headerlink" title="9. pod为ContainerCreating状态"></a>9. pod为ContainerCreating状态</h2><p>通过<code>kubectl describe pods -n $&#123;namespace&#125; $&#123;name&#125;</code>的Events部分来分析原因，可能的原因如下：</p>
<ul>
<li>网络分配ip地址失败</li>
</ul>
<h2 id="10-Init-CrashLoopBackOff"><a href="#10-Init-CrashLoopBackOff" class="headerlink" title="10. Init:CrashLoopBackOff"></a>10. Init:CrashLoopBackOff</h2><ol>
<li>通过<code>kubectl get pod -n &#123;NAMESPACE&#125; &#123;POD_NAME&#125; -o yaml</code> 找到pod的Init Containers，并找到其中的name字段。</li>
<li>执行<code>kubectl logs -n &#123;NAMESPACE&#125; &#123;POD_NAME&#125; -c &#123;INIT_CONTAINER_NAME&#125;</code>可以查看Init Container的日志来分析原因。</li>
</ol>
<h2 id="11-PodInitializing"><a href="#11-PodInitializing" class="headerlink" title="11. PodInitializing"></a>11. PodInitializing</h2><p>需要查看initContainer的日志</p>
<h2 id="12-MatchNodeSelector"><a href="#12-MatchNodeSelector" class="headerlink" title="12. MatchNodeSelector"></a>12. MatchNodeSelector</h2><p>查看pod的status信息可以看到如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">status:</span><br><span class="line">  message: Pod Predicate MatchNodeSelector failed</span><br><span class="line">  phase: Failed</span><br><span class="line">  reason: MatchNodeSelector</span><br><span class="line">  startTime: &quot;2022-03-15T05:07:57Z&quot;</span><br></pre></td></tr></table></figure>

<p>说明该pod没有调度成功，在predicate的MatchNodeSelector阶段失败了，没有匹配上node节点。</p>
<p>在k8s 1.21之前的版本，存在bug，节点重启后可能遇到过问题，将pod delete后重新调度可以解决。<a href="https://github.com/kubernetes/kubernetes/issues/92067">https://github.com/kubernetes/kubernetes/issues/92067</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://help.aliyun.com/document_detail/412618.html#section-7gv-3tf-paf">常见的Pod异常状态及处理方式</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>k8s 集群内 dns 规范</title>
    <url>/post/k8s-service/</url>
    <content><![CDATA[<h1 id="zone-设置"><a href="#zone-设置" class="headerlink" title="zone 设置"></a>zone 设置</h1><p>DNS 记录的 zone 信息为全局配置，配置地方包括 kubelet 和 coredns 两部分。</p>
<h2 id="kubelet-的启动参数"><a href="#kubelet-的启动参数" class="headerlink" title="kubelet 的启动参数"></a>kubelet 的启动参数</h2><ol>
<li>通过 kubelet 的 yaml 配置文件的 clusterDomain 字段。</li>
<li>通过 kubelet 的参数 <code>--cluster-domain</code>。</li>
</ol>
<p>设置了 kubelet 的启动参数后，会设置容器的 &#x2F;etc&#x2F;resolv.conf 中的 search 域为如下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search default.svc.cluster.local svc.cluster.local cluster.local tbsite.net</span><br><span class="line">nameserver 10.181.48.10</span><br><span class="line">options ndots:5 single-request-reopen</span><br></pre></td></tr></table></figure>

<p>其中 search 域中的 cluster.local 为 kubelet 的配置。</p>
<h2 id="coredns-的配置文件"><a href="#coredns-的配置文件" class="headerlink" title="coredns 的配置文件"></a>coredns 的配置文件</h2><p>coredns controller 需要 watch k8s 集群中的 pod 和 service，将其进行注册，因此 coredns 需要知道集群的 zone 配置。该配置信息位于 coredns 的配置文件 ConfigMap kube-system&#x2F;coredns 中，默认的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Corefile: |</span><br><span class="line">  .:53 &#123;</span><br><span class="line">      errors</span><br><span class="line">      health &#123;</span><br><span class="line">         lameduck 5s</span><br><span class="line">      &#125;</span><br><span class="line">      ready</span><br><span class="line">      kubernetes cluster.local in-addr.arpa ip6.arpa &#123;</span><br><span class="line">         pods insecure</span><br><span class="line">         fallthrough in-addr.arpa ip6.arpa</span><br><span class="line">         ttl 30</span><br><span class="line">      &#125;</span><br><span class="line">      prometheus :9153</span><br><span class="line">      forward . /etc/resolv.conf &#123;</span><br><span class="line">         max_concurrent 1000</span><br><span class="line">      &#125;</span><br><span class="line">      cache 30</span><br><span class="line">      loop</span><br><span class="line">      reload</span><br><span class="line">      loadbalance</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中 cluster.local 为对应的 k8s zone。</p>
<h1 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h1><p>在 k8s 中，Service 和 Pod 对象会创建 DNS 记录，用于 k8s 集群内部的域名解析。</p>
<h2 id="Pod-域名注册"><a href="#Pod-域名注册" class="headerlink" title="Pod 域名注册"></a>Pod 域名注册</h2><p>规则一：</p>
<p>每个 k8s pod 都会创建 DNS 记录： <code>&lt;pod_ip&gt;.&lt;namespace&gt;.pod.&lt;cluster-domain&gt;</code>。其中 <pod_ip> 为 pod ip 地址，但需要将 ip 地址中的 <code>.</code> 转换为 <code>-</code>。</p>
<p>比如 pod nginx-deployment-57d84f57dc-cpgkc 会创建 A 记录 <code>10-244-3-8.default.pod.cluster.local</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl get pod -o wide nginx-deployment-57d84f57dc-cpgkc -o wide</span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE     IP           NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-deployment-57d84f57dc-cpgkc   1/1     Running   0          2m59s   10.244.3.8   vc-worker2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>规则二：</p>
<p>pod 如何同时指定了 <code>spec.hostname</code> 和 <code>spec.subdomain</code>，则会创建 A 记录：<code>&lt;hostname&gt;.&lt;subdomain&gt;.&lt;namespace&gt;.svc.cluster.local</code>，而不是 <code>&lt;pod_ip&gt;.&lt;namespace&gt;.pod.&lt;cluster-domain&gt;</code>。对于 Statefulset 类型的 pod 会自动设置 <code>spec.hostname</code> 为 pod 的名字，<code>spec.subdomain</code> 为 StatefulSet 的 <code>spec.serviceName</code>。</p>
<p>比如 pod nginx-statefulset-0 会创建 A 记录 <code>nginx-statefulset-0.nginx.default.svc.cluster.local</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl get pod nginx-statefulset-0 -o wide</span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE   IP           NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-statefulset-0   1/1     Running   0          62m   10.244.3.7   vc-worker2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Deployment-x2F-DaemonSet-管理的-pod"><a href="#Deployment-x2F-DaemonSet-管理的-pod" class="headerlink" title="Deployment&#x2F;DaemonSet 管理的 pod"></a>Deployment&#x2F;DaemonSet 管理的 pod</h3><p>使用 Deployment&#x2F;DaemonSet 拉起的 pod，k8s 会创建额外的 DNS 记录：<code>&lt;pod_ip&gt;.&lt;deployment-name/daemonset-name&gt;.&lt;namespace&gt;.svc.&lt;cluster-domain&gt;</code>。</p>
<h2 id="Service-域名注册"><a href="#Service-域名注册" class="headerlink" title="Service 域名注册"></a>Service 域名注册</h2><h3 id="普通-Service"><a href="#普通-Service" class="headerlink" title="普通 Service"></a>普通 Service</h3><p>除了 headless service 之外的其他 service 会在 DNS 中生成 <code>my-svc.my-namespace.svc.cluster-domain.example</code> 的 A 或者 AAAA 记录，A 记录指向 ClusterIP。</p>
<p>headless service 会在 DNS 中生成 <code>my-svc.my-namespace.svc.cluster-domain.example</code> 的 A 或者 AAAA 记录，但指向的为 pod ip 地址集合。</p>
<p>k8s 在 pod 的 &#x2F;etc&#x2F;resolv.conf 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nameserver 10.32.0.10</span><br><span class="line">search &lt;namespace&gt;.svc.cluster.local svc.cluster.local cluster.local</span><br><span class="line">options ndots:5</span><br></pre></td></tr></table></figure>

<p>对于跟 pod 同一个 namespace 下的 service，要访问可以直接使用 service 名字接口。跟 pod 不在同一个 namespace 下的 service，访问 service 必须为 <code>service name.service namespace</code>。</p>
<h3 id="ExternalName-Service"><a href="#ExternalName-Service" class="headerlink" title="ExternalName Service"></a>ExternalName Service</h3><p>service 的 <code>spec.type</code> 为 <code>ExternalName</code>，该种类型的服务会向 dns 中注册 CNAME 记录，CNAME 记录指向 externalName 字段。例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">  namespace: prod</span><br><span class="line">spec:</span><br><span class="line">  type: ExternalName</span><br><span class="line">  externalName: my.database.example.com</span><br></pre></td></tr></table></figure>

<p>当访问 <code>my-service.prod.svc.cluster.local</code> 时，DNS 服务会返回 CNAME 记录，指向地址为 <code>my.database.example.com</code>。</p>
<h3 id="externalIPs-字段"><a href="#externalIPs-字段" class="headerlink" title="externalIPs 字段"></a>externalIPs 字段</h3><p>可以针对所有类型的 Service 生效，用来配置多个外部的 ip 地址（该 ip 地址不是 k8s 分配），kube-proxy 会设置该 ip 地址的规则，确保在 k8s 集群内部访问该 ip 地址时，可以路由到后端的 pod。效果就跟访问普通的 ClusterIP 类型 Service 没有区别。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: my-service</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app.kubernetes.io/name: MyApp</span><br><span class="line">  ports:</span><br><span class="line">    - name: http</span><br><span class="line">      protocol: TCP</span><br><span class="line">      port: 80</span><br><span class="line">      targetPort: 49152</span><br><span class="line">  externalIPs:</span><br><span class="line">    - 198.51.100.32</span><br></pre></td></tr></table></figure>

<p>当在集群内部访问 <code>198.51.100.32:80</code> 时，流量会被 kube-proxy 路由到当前 Service 的 Endpoint。</p>
<p>该字段存在中间人攻击的风险，不推荐使用。<a href="https://sysdig.com/blog/detect-cve-2020-8554-using-falco/">Detect CVE-2020-8554 – Unpatched Man-In-The-Middle (MITM) Attack in Kubernetes</a></p>
<h3 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h3><p>翻译成中文又叫无头 Service，显式的将 Service <code>spec.clusterIP</code> 设置为 <code>&quot;None&quot;</code>，表示该 Service 为 Headless Service。此时，该 Service 不会分配 clusterIP。因为没有 clusterIP，因此 kube-proxy 并不会处理该 service。</p>
<p>Headless Service 按照是否配置了 <code>spec.selector</code> 在实现上又有不同的区分。</p>
<p>未配置 <code>spec.selector</code> 的 Service，不会创建 EndpointSlice 对象，但是会注册如下的记录：</p>
<ul>
<li>对于 ExternalName Service，配置 CNAME 记录。</li>
<li>对于非 ExternalName Service，配置 A&#x2F;AAAA 记录，指向 EndPoint 的所有 ip 地址。如果未配置 Endpoint，但配置了 externalIPs 字段，则指向 externalIPs。</li>
</ul>
<p>配置 <code>spec.selector</code> 的 Service，会创建 EndpointSlice 对象，并修改 DNS 配置返回 A 或者 AAAA 记录，指向 pod 的集合。</p>
<h1 id="域名查询"><a href="#域名查询" class="headerlink" title="域名查询"></a>域名查询</h1><p>待补充</p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul>
<li><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">k8s 官方 Service 文档</a></li>
<li><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/">k8s 官方 Service 与 Pod 的 DNS</a></li>
<li><a href="https://github.com/kubernetes/dns/blob/master/docs/specification.md">Kubernetes DNS-Based Service Discovery</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>k8s在region和zone方面的支持情况</title>
    <url>/post/k8s-support-zone-region/</url>
    <content><![CDATA[<p>k8s虽然已经发展了多个版本，但在多region和多zone的场景下支持还是相对比较弱的，且很多的特性在alpha版本就已经废弃，说明k8s官方对于region和zone方面的支持情况有很大的不确定性。业界支持多reigon和容灾的特性更多是从上层的应用层来解决。本文主要是介绍k8s自身以及社区在region和zone方面的支持情况。</p>
<h1 id="k8s标签"><a href="#k8s标签" class="headerlink" title="k8s标签"></a>k8s标签</h1><p><a href="https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesiozone">https://kubernetes.io/docs/reference/labels-annotations-taints/#topologykubernetesiozone</a><br>官方推荐的跟region和zone有关的标签：</p>
<ul>
<li>failure-domain.beta.kubernetes.io&#x2F;region：1.17版本已经废弃，被topology.kubernetes.io&#x2F;region取代</li>
<li>failure-domain.beta.kubernetes.io&#x2F;zone：1.17版本已经废弃，被topology.kubernetes.io&#x2F;zone取代</li>
<li>topology.kubernetes.io&#x2F;region：1.17版本开始支持</li>
<li>topology.kubernetes.io&#x2F;zone：1.17版本开始支持</li>
</ul>
<h1 id="服务拓扑ServiceTopology"><a href="#服务拓扑ServiceTopology" class="headerlink" title="服务拓扑ServiceTopology"></a>服务拓扑ServiceTopology</h1><p>支持版本：在1.17版本引入，在1.21版本废弃</p>
<p>该特性在Service对象上增加了spec.topologyKeys字段，表示访问该Service的流量优先选用的拓扑域列表。访问Service流量的具体过程如下：</p>
<ol>
<li>当访问该Service时，一定是从某个k8s的node节点上发起，会查看当前node的label topology.kubernetes.io&#x2F;zone对应的value，如果发现有endpoint所在的node的lable topology.kubernetes.io&#x2F;zone对应的value相同，那么会将流量转发到该拓扑域的endpoint上。</li>
<li>如果没有找到topology.kubernetes.io&#x2F;zone相同拓扑域的endpoint，则尝试找topology.kubernetes.io&#x2F;region相同拓扑域的endpoint。</li>
<li>如果没有找到任何拓扑域的endpoint，那么该service会转发失败。<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">Name:</span> <span class="string">my-app-web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">topologyKeys:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;topology.kubernetes.io/zone&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;topology.kubernetes.io/region&quot;</span></span><br></pre></td></tr></table></figure>
在底层实现上，使用了1.16版本新引入的alpha版本特性 EndpointSlice，该特性主要是用来解决Endpoints对象过多时带来的性能问题，从而将Endpoints拆分为多个组，Service Topology特性恰好可以借助该特性来实现，本质上也是为了将Endpoints进行拆分。k8s会根据Service的topologyKeys来将Service拆分为多个EndpointSlice对象，kube-proxy根据EndpointSlice会将Service流量进行拆分。</li>
</ol>
<h1 id="拓扑感知提示Topology-Aware-Hints"><a href="#拓扑感知提示Topology-Aware-Hints" class="headerlink" title="拓扑感知提示Topology Aware Hints"></a>拓扑感知提示Topology Aware Hints</h1><p>该特性在1.21版本引入，在1.23版本变为beta版本，用来取代Topology Key功能。<br>该特性会启用两个组件：EndpointSlice控制器和kube-proxy。</p>
<p>在Service Topology功能中，需要给Service来指定topologyKeys字段。该特性会更自动化一些，只需要在Service上增加annotation service.kubernetes.io&#x2F;topology-aware-hints:auto，EndpointSlice控制器会watch到Service，发现开启了拓扑感知功能，会自动向endpoints的hints中增加forZones字段，该字段的value会根据endpoint所在node的topology.kubernetes.io&#x2F;zone来决定。</p>
<p>值得一提的是，当前的hints中并没有包含forRegions的字段。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">discovery.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">EndpointSlice</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-hints</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">kubernetes.io/service-name:</span> <span class="string">example-svc</span></span><br><span class="line"><span class="attr">addressType:</span> <span class="string">IPv4</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">endpoints:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;10.1.2.3&quot;</span></span><br><span class="line">    <span class="attr">conditions:</span></span><br><span class="line">      <span class="attr">ready:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">pod-1</span></span><br><span class="line">    <span class="attr">zone:</span> <span class="string">zone-a</span></span><br><span class="line">    <span class="attr">hints:</span></span><br><span class="line">      <span class="attr">forZones:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;zone-a&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="">Well-Known Labels, Annotations and Taints</a></li>
<li>Google Ingress for Anthos：<a href="https://cloud.google.com/kubernetes-engine/docs/concepts/ingress-for-anthos#architecture">https://cloud.google.com/kubernetes-engine/docs/concepts/ingress-for-anthos#architecture</a></li>
<li>阿里云ccm支持多个k8s集群的场景（手工指定lb id和server group方案）：<a href="https://help.aliyun.com/document_detail/335878.html#title-4wt-hc5-p2p">https://help.aliyun.com/document_detail&#x2F;335878.html#title-4wt-hc5-p2p</a></li>
<li><a href="https://tencentcloudcontainerteam.github.io/2019/11/26/service-topology/">https://tencentcloudcontainerteam.github.io/2019/11/26/service-topology/</a></li>
<li><a href="https://kubernetes.io/zh/docs/concepts/services-networking/endpoint-slices/">https://kubernetes.io/zh/docs/concepts/services-networking/endpoint-slices/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/245165617">使用 EndpointSlice 扩展 Kubernetes 网络</a></li>
<li><a href="https://kubernetes.io/docs/setup/best-practices/multiple-zones/">Running in multiple zones</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>k8s多集群管理方案 - karmada</title>
    <url>/post/karmada/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>华为云开源的多云容器编排项目，目前为CNCF沙箱项目。Karmada是基于<a href="https://links.jianshu.com/go?to=https://github.com/kubernetes-sigs/kubefed">kubefed v2</a>进行修改的一个项目，因此里面很多概念都是取自kubefed v2。</p>
<p>Karmada相对于kubefed v2的最大优点：<strong>完全兼容k8s的API</strong>。karmada提供了一个一套独立的karmada-apiserver，跟kube-apiserver是兼容的，使用方在调用的时候只需要访问karmada-apiserver就可以了。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/karmada-arch.png"><br>有三个组件构建：</p>
<ul>
<li>karmada api server，用来给其他的组件提供rest api</li>
<li>karmada controller manager</li>
<li>karmada scheduler</li>
</ul>
<p>karmada会新建一个ETCD，用来存储karmada的API对象。</p>
<p>karmada controller manager内部包含了多个controller的功能，会通过karmada apiserver来watch karmada对象，并通过调用各个子集群的apiserver来创建标准的k8s对象，包含了如下的controller对象：</p>
<ol>
<li>Cluster Controller：用来管理子集群的声明周期</li>
<li>Policy Controller：监听PropagationPolicy对象，通过resourceSelector找到匹配中的资源，并创建ResourceBinding对象。</li>
<li>Binding Controller：监听ResourceBinding对象，并创建每个集群的Work对象。</li>
<li>Execution Controller：监听Work对象，一旦Work对象场景后，会在子集群中创建Work关联的k8s对象。</li>
</ol>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="karmada-aggregated-apiserver"><a href="#karmada-aggregated-apiserver" class="headerlink" title="karmada-aggregated-apiserver"></a>karmada-aggregated-apiserver</h2><p>在karmada-apiserver上注册的api信息</p>
<h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><p>用来存放karmada的元数据信息</p>
<h1 id="CRD"><a href="#CRD" class="headerlink" title="CRD"></a>CRD</h1><h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><p>需要使用kamada-apiserver来查询</p>
<details>
<summary>unfold me to see the yaml</summary>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">cluster.karmada.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Cluster</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">finalizers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">karmada.io/cluster-controller</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">member1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">apiEndpoint:</span> <span class="string">https://172.18.0.3:6443</span></span><br><span class="line">  <span class="attr">impersonatorSecretRef:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member1-impersonator</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">karmada-cluster</span></span><br><span class="line">  <span class="attr">secretRef:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">member1</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">karmada-cluster</span></span><br><span class="line">  <span class="attr">syncMode:</span> <span class="string">Push</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">	<span class="comment"># 支持的api列表</span></span><br><span class="line">  <span class="attr">apiEnablements:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">admissionregistration.k8s.io/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">MutatingWebhookConfiguration</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">mutatingwebhookconfigurations</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ValidatingWebhookConfiguration</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">validatingwebhookconfigurations</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">apiextensions.k8s.io/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">CustomResourceDefinition</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">customresourcedefinitions</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">apiregistration.k8s.io/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">APIService</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">apiservices</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ControllerRevision</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">controllerrevisions</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">daemonsets</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">deployments</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">replicasets</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">statefulsets</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">authentication.k8s.io/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">TokenReview</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">tokenreviews</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">authorization.k8s.io/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">LocalSubjectAccessReview</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">localsubjectaccessreviews</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">SelfSubjectAccessReview</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">selfsubjectaccessreviews</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">SelfSubjectRulesReview</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">selfsubjectrulesreviews</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">SubjectAccessReview</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">subjectaccessreviews</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">autoscaling/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">horizontalpodautoscalers</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">autoscaling/v2beta1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">horizontalpodautoscalers</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">autoscaling/v2beta2</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">horizontalpodautoscalers</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">batch/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cronjobs</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">jobs</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cronjobs</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">certificates.k8s.io/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">CertificateSigningRequest</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">certificatesigningrequests</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">coordination.k8s.io/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Lease</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">leases</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">discovery.k8s.io/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">EndpointSlice</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">endpointslices</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">discovery.k8s.io/v1beta1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">EndpointSlice</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">endpointslices</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">events.k8s.io/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Event</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">events</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">events.k8s.io/v1beta1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Event</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">events</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">flowcontrol.apiserver.k8s.io/v1beta1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">FlowSchema</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">flowschemas</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">PriorityLevelConfiguration</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">prioritylevelconfigurations</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">IngressClass</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">ingressclasses</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">ingresses</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">networkpolicies</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">node.k8s.io/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">RuntimeClass</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">runtimeclasses</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">node.k8s.io/v1beta1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">RuntimeClass</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">runtimeclasses</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">policy/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">PodDisruptionBudget</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">poddisruptionbudgets</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">policy/v1beta1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">PodDisruptionBudget</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">poddisruptionbudgets</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">PodSecurityPolicy</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">podsecuritypolicies</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">clusterrolebindings</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">clusterroles</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">rolebindings</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">roles</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">scheduling.k8s.io/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">PriorityClass</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">priorityclasses</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">CSIDriver</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">csidrivers</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">CSINode</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">csinodes</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">storageclasses</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">VolumeAttachment</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">volumeattachments</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">storage.k8s.io/v1beta1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">CSIStorageCapacity</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">csistoragecapacities</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">groupVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Binding</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">bindings</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ComponentStatus</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">componentstatuses</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">configmaps</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">endpoints</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Event</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">events</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">LimitRange</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">limitranges</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">namespaces</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Node</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nodes</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">persistentvolumeclaims</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">persistentvolumes</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">pods</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">PodTemplate</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">podtemplates</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">replicationcontrollers</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ResourceQuota</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">resourcequotas</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">secrets</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">serviceaccounts</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">services</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2022-02-21T08:27:56Z&quot;</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">cluster</span> <span class="string">is</span> <span class="string">healthy</span> <span class="string">and</span> <span class="string">ready</span> <span class="string">to</span> <span class="string">accept</span> <span class="string">workloads</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">ClusterReady</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Ready</span></span><br><span class="line">  <span class="attr">kubernetesVersion:</span> <span class="string">v1.22.0</span></span><br><span class="line">  <span class="attr">nodeSummary:</span></span><br><span class="line">    <span class="attr">readyNum:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">totalNum:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">resourceSummary:</span></span><br><span class="line">    <span class="attr">allocatable:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;8&quot;</span></span><br><span class="line">      <span class="attr">ephemeral-storage:</span> <span class="string">41152812Ki</span></span><br><span class="line">      <span class="attr">hugepages-1Gi:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">      <span class="attr">hugepages-2Mi:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">32192720Ki</span></span><br><span class="line">      <span class="attr">pods:</span> <span class="string">&quot;110&quot;</span></span><br><span class="line">    <span class="attr">allocated:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">950m</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">290Mi</span></span><br><span class="line">      <span class="attr">pods:</span> <span class="string">&quot;9&quot;</span></span><br></pre></td></tr></table></figure>
</details>

<h2 id="PropagationPolicy"><a href="#PropagationPolicy" class="headerlink" title="PropagationPolicy"></a>PropagationPolicy</h2><p>应用发布策略</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: policy.karmada.io/v1alpha1</span><br><span class="line">kind: PropagationPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx<span class="literal">-propagation</span></span><br><span class="line">  namespace: default</span><br><span class="line">spec:</span><br><span class="line">  placement:</span><br><span class="line">    clusterAffinity:</span><br><span class="line">      clusterNames:</span><br><span class="line">      - member1</span><br><span class="line">      - member2</span><br><span class="line">    replicaScheduling:</span><br><span class="line">      replicaDivisionPreference: Weighted·</span><br><span class="line">      replicaSchedulingType: Divided</span><br><span class="line">      weightPreference:</span><br><span class="line">        staticWeightList:</span><br><span class="line">        - targetCluster:</span><br><span class="line">            clusterNames:</span><br><span class="line">            - member1</span><br><span class="line">          weight: <span class="number">1</span></span><br><span class="line">        - targetCluster:</span><br><span class="line">            clusterNames:</span><br><span class="line">            - member2</span><br><span class="line">          weight: <span class="number">1</span></span><br><span class="line">  resourceSelectors:</span><br><span class="line">  - apiVersion: apps/v1</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: nginx</span><br><span class="line">    namespace: default</span><br></pre></td></tr></table></figure>
<h2 id="ClusterPropagationPolicy"><a href="#ClusterPropagationPolicy" class="headerlink" title="ClusterPropagationPolicy"></a>ClusterPropagationPolicy</h2><p>用来定义Cluster级别资源的发布策略</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy.karmada.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterPropagationPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">serviceexport-policy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">resourceSelectors:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">apiextensions.k8s.io/v1</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">CustomResourceDefinition</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">serviceexports.multicluster.x-k8s.io</span></span><br><span class="line">  <span class="attr">placement:</span></span><br><span class="line">    <span class="attr">clusterAffinity:</span></span><br><span class="line">      <span class="attr">clusterNames:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">member1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">member2</span></span><br></pre></td></tr></table></figure>
<h2 id="OverridePolicy"><a href="#OverridePolicy" class="headerlink" title="OverridePolicy"></a>OverridePolicy</h2><p>用于修改不同集群内的对象</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy.karmada.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">OverridePolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">overriders:</span></span><br><span class="line">    <span class="attr">commandOverrider:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerName:</span> <span class="string">myapp</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">remove</span></span><br><span class="line">        <span class="attr">value:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--parameter1=foo</span></span><br></pre></td></tr></table></figure>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>karmada提供了三种安装方式：</p>
<ul>
<li>kubectl karmada插件的方式安装，较新的特性，v1.0版本才会提供，当前最新版本为v0.10.1</li>
<li>helm chart方式安装</li>
<li>使用源码安装</li>
</ul>
<h2 id="安装kubectl插件"><a href="#安装kubectl插件" class="headerlink" title="安装kubectl插件"></a>安装kubectl插件</h2><p>karmada提供了一个cli的工具，可以是单独的二进制工具kubectl-karmada，也可以是kubectl的插件karmada，本文以kubectl插件的方式进行安装。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl krew install karmada</span><br></pre></td></tr></table></figure>
<p>接下来就可以执行 kubectl karmada命令了。</p>
<h2 id="helm-chart的方式安装"><a href="#helm-chart的方式安装" class="headerlink" title="helm chart的方式安装"></a>helm chart的方式安装</h2><p>使用kind插件一个k8s集群 host，此处步骤略<br>​</p>
<p>在源码目录下执行如下的命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">helm install karmada <span class="literal">-n</span> karmada<span class="literal">-system</span> <span class="literal">--create-namespace</span> ./charts</span><br></pre></td></tr></table></figure>
<p>会在karmada-system下部署如下管控的组件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> kubectl get deployments <span class="literal">-n</span> karmada<span class="literal">-system</span></span><br><span class="line">NAME                              READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">karmada<span class="literal">-apiserver</span>                 <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">83</span>s</span><br><span class="line">karmada<span class="literal">-controller-manager</span>        <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">83</span>s</span><br><span class="line">karmada<span class="literal">-kube-controller-manager</span>   <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">83</span>s</span><br><span class="line">karmada<span class="literal">-scheduler</span>                 <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">83</span>s</span><br><span class="line">karmada<span class="literal">-webhook</span>                   <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">83</span>s</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> kubectl get statefulsets <span class="literal">-n</span> karmada<span class="literal">-system</span></span><br><span class="line">NAME   READY   AGE</span><br><span class="line">etcd   <span class="number">1</span>/<span class="number">1</span>     <span class="number">2</span>m1s</span><br></pre></td></tr></table></figure>

<h2 id="从源码安装一个本地测试集群"><a href="#从源码安装一个本地测试集群" class="headerlink" title="从源码安装一个本地测试集群"></a>从源码安装一个本地测试集群</h2><p>本方式仅用于本地测试，会自动使用kind拉起测试的k8s集群，包括了一个host集群和3个member集群。</p>
<p>执行如下命令，会执行如下的任务：</p>
<ol>
<li>使用kind启动一个新的k8s集群host</li>
<li>构建karmada的控制平面，并部署控制平面到host集群</li>
<li>创建3个member集群并加入到karmada中<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/karmada<span class="literal">-io</span>/karmada</span><br><span class="line"><span class="built_in">cd</span> karmada</span><br><span class="line">hack/local<span class="literal">-up-karmada</span>.sh</span><br></pre></td></tr></table></figure>
local-up-karmada.sh有两个细节问题值得关注。<br>kind创建出来的集群名一定带有“kind-”的前缀，该脚本中为了去掉“kind-”前缀，使用了kubectl config rename-context 命令来rename context。<a href="https://github.com/karmada-io/karmada/blob/master/hack/util.sh#L375">https://github.com/karmada-io/karmada/blob/master/hack/util.sh#L375</a><br>另外，使用kind创建出来的集群，context中的apiserver地址为类似<a href="https://127.0.0.1:45195/">https://127.0.0.1:45195</a>这样的本地随机端口，只能在宿主机网络中访问。如果要想在两个k8s集群之间访问是不可行的。脚本中使用kubectl config set-cluster 命令将集群apiserver的地址替换为了docker网段的ip地址，以便于多个k8s集群之间的互访。<a href="https://github.com/karmada-io/karmada/blob/master/hack/util.sh#L389">https://github.com/karmada-io/karmada/blob/master/hack/util.sh#L389</a><br>​</li>
</ol>
<p>可以看到创建了如下的4个k8s cluster</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> kind get clusters</span><br><span class="line">karmada<span class="literal">-host</span></span><br><span class="line">member1</span><br><span class="line">member2</span><br><span class="line">member3</span><br></pre></td></tr></table></figure>

<p>但这四个集群会分为两个kubeconfig文件 ~&#x2F;.kube&#x2F;karmada.config 和 ~&#x2F;.kube&#x2F;members.config。karmada又分为了两个context karmada-apiserver和karmada-host，两者连接同一个k8s集群。karmada-apiserver为跟karmada控制平台交互使用的context，为容器中的karmada-apiserver。karmada-host连接容器的kube-apiserver。<br>​</p>
<p>如果要连接host集群设置环境变量：export KUBECONFIG&#x3D;”$HOME&#x2F;.kube&#x2F;karmada.config”<br>如果要连接member集群设置环境变量：export KUBECONFIG&#x3D;”$HOME&#x2F;.kube&#x2F;members.config”</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">export</span> <span class="string">KUBECONFIG=&quot;$HOME/.kube/karmada.config&quot;</span></span><br><span class="line"><span class="comment"># 切换到karmada-host</span></span><br><span class="line"><span class="string">$</span> <span class="string">kctx</span> <span class="string">karmada-host</span></span><br><span class="line"><span class="comment"># 可以看到karmada部署的组件</span></span><br><span class="line"><span class="string">$</span> <span class="string">k</span> <span class="string">get</span> <span class="string">deploy</span> <span class="string">-n</span> <span class="string">karmada-system</span>   </span><br><span class="line"><span class="string">NAME</span>                                  <span class="string">READY</span>   <span class="string">UP-TO-DATE</span>   <span class="string">AVAILABLE</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">karmada-aggregated-apiserver</span>          <span class="number">2</span><span class="string">/2</span>     <span class="number">2</span>            <span class="number">2</span>           <span class="string">17m</span></span><br><span class="line"><span class="string">karmada-apiserver</span>                     <span class="number">1</span><span class="string">/1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="string">18m</span></span><br><span class="line"><span class="string">karmada-controller-manager</span>            <span class="number">2</span><span class="string">/2</span>     <span class="number">2</span>            <span class="number">2</span>           <span class="string">17m</span></span><br><span class="line"><span class="string">karmada-kube-controller-manager</span>       <span class="number">1</span><span class="string">/1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="string">17m</span></span><br><span class="line"><span class="string">karmada-scheduler</span>                     <span class="number">2</span><span class="string">/2</span>     <span class="number">2</span>            <span class="number">2</span>           <span class="string">17m</span></span><br><span class="line"><span class="string">karmada-scheduler-estimator-member1</span>   <span class="number">2</span><span class="string">/2</span>     <span class="number">2</span>            <span class="number">2</span>           <span class="string">17m</span></span><br><span class="line"><span class="string">karmada-scheduler-estimator-member2</span>   <span class="number">2</span><span class="string">/2</span>     <span class="number">2</span>            <span class="number">2</span>           <span class="string">17m</span></span><br><span class="line"><span class="string">karmada-scheduler-estimator-member3</span>   <span class="number">2</span><span class="string">/2</span>     <span class="number">2</span>            <span class="number">2</span>           <span class="string">17m</span></span><br><span class="line"><span class="string">karmada-webhook</span>                       <span class="number">2</span><span class="string">/2</span>     <span class="number">2</span>            <span class="number">2</span>           <span class="string">17m</span></span><br></pre></td></tr></table></figure>
<p>在host集群中可以看到会创建出如下的pod</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># k get pod -n karmada-system </span></span><br><span class="line">NAME                                                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">etcd<span class="literal">-0</span>                                                 <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">18</span><span class="built_in">h</span></span><br><span class="line">karmada<span class="literal">-aggregated-apiserver-7b88b8df99-95twq</span>          <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">18</span><span class="built_in">h</span></span><br><span class="line">karmada<span class="literal">-apiserver-5746cf97bb-pspfg</span>                     <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">18</span><span class="built_in">h</span></span><br><span class="line">karmada<span class="literal">-controller-manager-7d66968445-h4xsc</span>            <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">18</span><span class="built_in">h</span></span><br><span class="line">karmada<span class="literal">-kube-controller-manager-869d9df85-f4bqj</span>        <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">18</span><span class="built_in">h</span></span><br><span class="line">karmada<span class="literal">-scheduler-8677cdf96d-psnlw</span>                     <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">18</span><span class="built_in">h</span></span><br><span class="line">karmada<span class="literal">-scheduler-estimator-member1-696b54fd56-jjg6b</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">18</span><span class="built_in">h</span></span><br><span class="line">karmada<span class="literal">-scheduler-estimator-member2-774fb84c5d-fldhd</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">18</span><span class="built_in">h</span></span><br><span class="line">karmada<span class="literal">-scheduler-estimator-member3-5c7d87f4b4-fk4lj</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">18</span><span class="built_in">h</span></span><br><span class="line">karmada<span class="literal">-webhook-79b87f7c5f-lt8ps</span>                       <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">18</span><span class="built_in">h</span></span><br></pre></td></tr></table></figure>
<p>在karmada-apiserver集群会创建出如下的Cluster，同时可以看到有两个Push模式一个Pull模式的集群。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kctx</span> <span class="string">karmada-apiserver</span></span><br><span class="line"><span class="string">Switched</span> <span class="string">to</span> <span class="string">context</span> <span class="string">&quot;karmada-apiserver&quot;</span><span class="string">.</span></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">clusters</span></span><br><span class="line"><span class="string">NAME</span>      <span class="string">VERSION</span>   <span class="string">MODE</span>   <span class="string">READY</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">member1</span>   <span class="string">v1.22.0</span>   <span class="string">Push</span>   <span class="literal">True</span>    <span class="string">61m</span></span><br><span class="line"><span class="string">member2</span>   <span class="string">v1.22.0</span>   <span class="string">Push</span>   <span class="literal">True</span>    <span class="string">61m</span></span><br><span class="line"><span class="string">member3</span>   <span class="string">v1.22.0</span>   <span class="string">Pull</span>   <span class="literal">True</span>    <span class="string">61m</span></span><br></pre></td></tr></table></figure>
<h1 id="应用发布"><a href="#应用发布" class="headerlink" title="应用发布"></a>应用发布</h1><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/karama-concepts.png"></p>
<p>将context切换到karmada-host，在host集群部署应用nginx</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> export KUBECONFIG=<span class="string">&quot;<span class="variable">$HOME</span>/.kube/karmada.config&quot;</span></span><br><span class="line"><span class="variable">$</span> kctx karmada<span class="literal">-apiserver</span></span><br><span class="line"><span class="variable">$</span> kubectl create <span class="operator">-f</span> samples/nginx/propagationpolicy.yaml</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> samples/nginx/propagationpolicy.yaml</span><br><span class="line">apiVersion: policy.karmada.io/v1alpha1</span><br><span class="line">kind: PropagationPolicy</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx<span class="literal">-propagation</span></span><br><span class="line">spec:</span><br><span class="line">  resourceSelectors:</span><br><span class="line">    - apiVersion: apps/v1</span><br><span class="line">      kind: Deployment</span><br><span class="line">      name: nginx</span><br><span class="line">  placement:</span><br><span class="line">    <span class="comment"># 要提交到子集群1和2</span></span><br><span class="line">    clusterAffinity:</span><br><span class="line">      clusterNames:</span><br><span class="line">        - member1</span><br><span class="line">        - member2</span><br><span class="line">    replicaScheduling:</span><br><span class="line">      replicaDivisionPreference: Weighted</span><br><span class="line">      replicaSchedulingType: Divided</span><br><span class="line">      weightPreference:</span><br><span class="line">        staticWeightList:</span><br><span class="line">          - targetCluster:</span><br><span class="line">              clusterNames:</span><br><span class="line">                - member1</span><br><span class="line">            weight: <span class="number">1</span></span><br><span class="line">          - targetCluster:</span><br><span class="line">              clusterNames:</span><br><span class="line">                - member2</span><br><span class="line">            weight: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在karmada-apiserver中提交deployment。deployment提交后实际上仅为一个模板，只有PropagationPolicy跟deployment关联后，才会真正部署。deployment中指定的副本数为所有子集群的副本数综合。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">samples/nginx/deployment.yaml</span></span><br><span class="line"><span class="string">$</span> <span class="string">k</span> <span class="string">get</span> <span class="string">deploy</span> </span><br><span class="line"><span class="string">NAME</span>    <span class="string">READY</span>   <span class="string">UP-TO-DATE</span>   <span class="string">AVAILABLE</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">nginx</span>   <span class="number">2</span><span class="string">/2</span>     <span class="number">2</span>            <span class="number">2</span>           <span class="string">7m37s</span></span><br><span class="line"><span class="comment"># 可以看到虽然deployment的副本数为2，但在karmada-apiserver集群中实际上并没有pod创建出来</span></span><br><span class="line"><span class="string">$</span> <span class="string">k</span> <span class="string">get</span> <span class="string">pod</span></span><br><span class="line"><span class="literal">No</span> <span class="string">resources</span> <span class="string">found</span> <span class="string">in</span> <span class="string">default</span> <span class="string">namespace.</span></span><br></pre></td></tr></table></figure>
<p>通过karmadactl命令可以查询环境中的所有子集群的pod状态</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">karmadactl</span> <span class="string">get</span> <span class="string">pod</span></span><br><span class="line"><span class="string">The</span> <span class="string">karmadactl</span> <span class="string">get</span> <span class="string">command</span> <span class="string">now</span> <span class="string">only</span> <span class="string">supports</span> <span class="string">Push</span> <span class="string">mode,</span> [ <span class="string">member3</span> ] <span class="string">are</span> <span class="string">not</span> <span class="string">push</span> <span class="string">mode</span></span><br><span class="line"></span><br><span class="line"><span class="string">NAME</span>                     <span class="string">CLUSTER</span>   <span class="string">READY</span>   <span class="string">STATUS</span>    <span class="string">RESTARTS</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">nginx-6799fc88d8-4w2gc</span>   <span class="string">member1</span>   <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>          <span class="string">4m16s</span></span><br><span class="line"><span class="string">nginx-6799fc88d8-j77f5</span>   <span class="string">member2</span>   <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>          <span class="string">4m16s</span></span><br></pre></td></tr></table></figure>
<h1 id="元集群访问子集群"><a href="#元集群访问子集群" class="headerlink" title="元集群访问子集群"></a>元集群访问子集群</h1><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/karmada-aa.png"></p>
<p>可以看到在karmada-apiserver上注册了AA服务，group为cluster.karmada.io</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl --kubeconfig /root/.kube/karmada.config --context karmada-apiserver get  apiservice v1alpha1.cluster.karmada.io -o yaml </span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiregistration.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">APIService</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">apiserver:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">karmada-aggregated-apiserver</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">v1alpha1.cluster.karmada.io</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">cluster.karmada.io</span></span><br><span class="line">  <span class="attr">groupPriorityMinimum:</span> <span class="number">2000</span></span><br><span class="line">  <span class="attr">insecureSkipTLSVerify:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">karmada-aggregated-apiserver</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">karmada-system</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">v1alpha1</span></span><br><span class="line">  <span class="attr">versionPriority:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2022-02-21T08:27:47Z&quot;</span></span><br><span class="line">    <span class="attr">message:</span> <span class="string">all</span> <span class="string">checks</span> <span class="string">passed</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">Passed</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Available</span></span><br></pre></td></tr></table></figure>
<p>如果直接使用kubectl访问karmada-apiserver服务，会提示存在权限问题</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">￥</span> <span class="string">kubectl</span> <span class="string">--kubeconfig</span> <span class="string">~/.kube/karmada-apiserver.config</span> <span class="string">--context</span> <span class="string">karmada-apiserver</span>   <span class="string">get</span> <span class="string">--raw</span> <span class="string">/apis/cluster.karmada.io/v1alpha1/clusters/member1/proxy/api/v1/nodes</span></span><br><span class="line"><span class="string">Error</span> <span class="string">from</span> <span class="string">server</span> <span class="string">(Forbidden):</span> <span class="string">users</span> <span class="string">&quot;system:admin&quot;</span> <span class="attr">is forbidden:</span> <span class="string">User</span> <span class="string">&quot;system:serviceaccount:karmada-cluster:karmada-impersonator&quot;</span> <span class="string">cannot</span> <span class="string">impersonate</span> <span class="string">resource</span> <span class="string">&quot;users&quot;</span> <span class="string">in</span> <span class="string">API</span> <span class="string">group</span> <span class="string">&quot;&quot;</span> <span class="string">at</span> <span class="string">the</span> <span class="string">cluster</span> <span class="string">scope</span></span><br></pre></td></tr></table></figure>
<p>给karmada-apiserver的Account system:admin授权，创建文件cluster-proxy-rbac.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-proxy-clusterrole</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;cluster.karmada.io&#x27;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">clusters/proxy</span></span><br><span class="line">  <span class="attr">resourceNames:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">member1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">member2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">member3</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-proxy-clusterrolebinding</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-proxy-clusterrole</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;system:admin&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行如下命令即可给karmada-apiserver的Account system:admin 授权可访问AA服务的member1-3</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">--kubeconfig</span> <span class="string">/root/.kube/karmada.config</span> <span class="string">--context</span> <span class="string">karmada-apiserver</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">cluster-proxy-rbac.yaml</span>   </span><br></pre></td></tr></table></figure>
<p>通过url的形式访问AA服务，返回数据格式为json</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">--kubeconfig</span> <span class="string">~/.kube/karmada-apiserver.config</span> <span class="string">--context</span> <span class="string">karmada-apiserver</span> <span class="string">get</span> <span class="string">--raw</span> <span class="string">/apis/cluster.karmada.io/v1alpha1/clusters/member1/proxy/api/v1/nodes</span></span><br></pre></td></tr></table></figure>
<p>如果要想使用 kubectl get node 的形式来访问，则需要在kubeconfig文件中server字段的url地址后追加url <code>/apis/cluster.karmada.io/v1alpha1/clusters/&#123;clustername&#125;/proxy</code> </p>
<h2 id="给特定的账号授权"><a href="#给特定的账号授权" class="headerlink" title="给特定的账号授权"></a>给特定的账号授权</h2><p>在karmada-apiserver中创建账号 tom</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">--kubeconfig</span> <span class="string">/root/.kube/karmada.config</span> <span class="string">--context</span> <span class="string">karmada-apiserver</span> <span class="string">create</span> <span class="string">serviceaccount</span> <span class="string">tom</span></span><br></pre></td></tr></table></figure>
<p>在karmada-apiserver中提交如下的yaml文件，用来给tom账号增加访问member1集群的权限</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-proxy-clusterrole</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;cluster.karmada.io&#x27;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">clusters/proxy</span></span><br><span class="line">  <span class="attr">resourceNames:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">member1</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-proxy-clusterrolebinding</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-proxy-clusterrole</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tom</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="comment"># The token generated by the serviceaccount can parse the group information. Therefore, you need to specify the group information below.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;system:serviceaccounts&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&quot;system:serviceaccounts:default&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行如下命令提交</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">--kubeconfig</span> <span class="string">/root/.kube/karmada.config</span> <span class="string">--context</span> <span class="string">karmada-apiserver</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">cluster-proxy-rbac.yaml</span></span><br></pre></td></tr></table></figure>
<p>获取karmada-apiserver集群的tom账号的token信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">--kubeconfig</span> <span class="string">/root/.kube/karmada.config</span> <span class="string">--context</span> <span class="string">karmada-apiserver</span>  <span class="string">get</span> <span class="string">secret</span> <span class="string">`kubectl</span> <span class="string">--kubeconfig</span> <span class="string">/root/.kube/karmada.config</span> <span class="string">--context</span> <span class="string">karmada-apiserver</span>  <span class="string">get</span> <span class="string">sa</span> <span class="string">tom</span> <span class="string">-oyaml</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">token</span> <span class="string">|</span> <span class="string">awk</span> <span class="string">&#x27;&#123;print $3&#125;&#x27;</span><span class="string">`</span> <span class="string">-oyaml</span> <span class="string">|</span> <span class="attr">grep token:</span> <span class="string">|</span> <span class="string">awk</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> <span class="string">|</span> <span class="string">base64</span> <span class="string">-d</span></span><br></pre></td></tr></table></figure>
<p> 创建~&#x2F;.kube&#x2F;tom.config文件，其中token信息为上一步获取的token，server的地址可以查看 ~&#x2F;.kube&#x2F;karmada-apiserver.config文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">insecure-skip-tls-verify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">server:</span> &#123;<span class="string">karmada-apiserver-address</span>&#125; <span class="comment"># Replace &#123;karmada-apiserver-address&#125; with karmada-apiserver-address. You can find it in /root/.kube/karmada.config file.</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tom</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">tom</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">tom</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tom</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">tom</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tom</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">token:</span> &#123;<span class="string">token</span>&#125; <span class="comment"># Replace &#123;token&#125; with the token obtain above.</span></span><br></pre></td></tr></table></figure>
<p>通过karmada-apiserver的tom用户访问member1集群</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预期可以正常访问</span></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">--kubeconfig</span> <span class="string">~/.kube/tom.config</span> <span class="string">get</span> <span class="string">--raw</span> <span class="string">/apis/cluster.karmada.io/v1alpha1/clusters/member1/proxy/apis</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预期不可以访问，因为tom在member1集群没有权限</span></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">--kubeconfig</span> <span class="string">~/.kube/tom.config</span> <span class="string">get</span> <span class="string">--raw</span> <span class="string">/apis/cluster.karmada.io/v1alpha1/clusters/member1/proxy/api/v1/nodes</span></span><br><span class="line"><span class="string">Error</span> <span class="string">from</span> <span class="string">server</span> <span class="string">(Forbidden):</span> <span class="attr">nodes is forbidden:</span> <span class="string">User</span> <span class="string">&quot;system:serviceaccount:default:tom&quot;</span> <span class="string">cannot</span> <span class="string">list</span> <span class="string">resource</span> <span class="string">&quot;nodes&quot;</span> <span class="string">in</span> <span class="string">API</span> <span class="string">group</span> <span class="string">&quot;&quot;</span> <span class="string">at</span> <span class="string">the</span> <span class="string">cluster</span> <span class="string">scope</span></span><br></pre></td></tr></table></figure>
<p>在member1集群将tom账号绑定权限，创建member1-rbac.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tom</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tom</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tom</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tom</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>
<p>权限在member1集群生效</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">--kubeconfig</span> <span class="string">/root/.kube/members.config</span> <span class="string">--context</span> <span class="string">member1</span> <span class="string">apply</span> <span class="string">-f</span> <span class="string">member1-rbac.yaml</span> </span><br></pre></td></tr></table></figure>
<p>重新执行命令即可以访问子集群中的数据</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">--kubeconfig</span> <span class="string">~/.kube/tom.config</span> <span class="string">get</span> <span class="string">--raw</span> <span class="string">/apis/cluster.karmada.io/v1alpha1/clusters/member1/proxy/api/v1/nodes</span></span><br></pre></td></tr></table></figure>
<h1 id="集群注册"><a href="#集群注册" class="headerlink" title="集群注册"></a>集群注册</h1><p>支持Push和Pull两种模式。<br>​</p>
<p>push模式karmada会直接访问成员集群的kuba-apiserver。</p>
<p>pull模式针对的场景是中心集群无法直接子集群的场景。每个子集群运行karmada-agent组件，一旦karmada-agent部署完成后就会自动向host集群注册，karmada-agent会watch host集群的karmada-es-<cluster name>下的cr，并在本集群部署。<br>​</p>
]]></content>
      <tags>
        <tag>多集群</tag>
      </tags>
  </entry>
  <entry>
    <title>keepalived简易教程</title>
    <url>/post/keepalived_easy/</url>
    <content><![CDATA[<p>keepalived的作用为保持存活服务，服务启动后会在两台物理机器之间维护一个vip，但是仅有一台物理机器拥有该vip，这样就保证了两台机器之间是主备。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在ubuntu下直接执行：<code>sudo apt-get install keepalived</code>.</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>本例子两台机器的物理ip地址分别为10.101.185和10.101.1.186，要增加的虚拟ip地址为10.101.0.101、10.101.0.102、10.101.0.107和10.101.0.108，其中10.101.0.101和10.101.0.102在10.101.185上为主，10.101.0.107和10.101.0.108在10.101.1.186上为主。</p>
<p>keepalived的默认配置文件位于&#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf目录下，由于两台物理机器之间的主辅关系不同，配置文件也不相同。</p>
<p>10.101.185机器上的配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   # 报警邮箱配置</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     ops@yidian-inc.com</span><br><span class="line">   &#125;</span><br><span class="line">   smtp_server 10.101.1.139</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id 101-1-185-lg-201-l10.yidian.com  // 运行机器的唯一标识，每个机器应该都不一样，可以直接使用hostname代替，具体用在什么地方暂时不是很清楚</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance ha-internal-1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 1	// VRID标记，可以设置为0-255，对应VRRD协议中的Virtual Rtr Id</span><br><span class="line">    priority 100  // 对应VRRD协议中的priority选项</span><br><span class="line">    advert_int 1	// 检测间隔，默认为1s，对应VRRD协议中的adver int</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS // 认证方式，支持PASS和AH</span><br><span class="line">        auth_pass 1-internal-ha  // 认证的密码，从抓取的包中看到</span><br><span class="line">    &#125;</span><br><span class="line">    // 声明的虚拟ip地址，这些ip会在VRRP一些的一个包发送</span><br><span class="line">    // 另外VRRP协议中还有一个Count IP Addrs用来指明需要声明多少个VIP</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.101.0.101/22 dev eth0</span><br><span class="line">        10.101.0.102/22 dev eth0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance ha-internal-2 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 2</span><br><span class="line">    priority 99</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 2-internal-ha</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.101.0.107/22 dev eth0</span><br><span class="line">        10.101.0.108/22 dev eth0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10.101.1.186上的配置文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     ops@yidian-inc.com</span><br><span class="line">   &#125;</span><br><span class="line">   smtp_server 10.101.1.139</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id 101-1-186-lg-201-l10.yidian.com</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance ha-internal-1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 1</span><br><span class="line">    priority 99</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1-internal-ha</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.101.0.101/22 dev eth0</span><br><span class="line">        10.101.0.102/22 dev eth0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance ha-internal-2 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface eth0</span><br><span class="line">    virtual_router_id 2</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 2-internal-ha</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.101.0.107/22 dev eth0</span><br><span class="line">        10.101.0.108/22 dev eth0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件搭建完毕后，通过<code>sudo service keepalived start</code>即可启动服务，执行<code>ip addr</code>命令即可看到vip。需要注意的是，通过<code>ifconfig</code>命令是看不到vip的。</p>
<p>有了vip，其他服务就可以利用该vip做一些绑定vip的端口来作为主辅热备模式了。</p>
<h1 id="about-vrrp"><a href="#about-vrrp" class="headerlink" title="about vrrp"></a>about vrrp</h1><p>关于VRRP的详细说明可以查看<a href="https://tools.ietf.org/html/rfc3768">RFC3768</a>，我这里记录几点说明。</p>
<p>协议中的以太网Destination Address的值必须为多播地址224.0.0.18。</p>
<p>当前正在使用的VRRP版本为version 2，认证功能已经取消，但为了向下兼容，仍然可用。在抓取的包中，仍在使用认证信息</p>
<h1 id="download"><a href="#download" class="headerlink" title="download"></a>download</h1><p><a href="http://pan.baidu.com/s/1jHreDyI">这里提供两个vrrp协议的pcap包</a></p>
]]></content>
      <tags>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title>knative（个人笔记）</title>
    <url>/post/knative/</url>
    <content><![CDATA[<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><p>待补充</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下载kind命令，但不需要创建一个k8s集群。</p>
<p>执行如下命令下载kn 二进制文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">wget</span> <span class="string">https://github.com/knative/client/releases/download/knative-v1.2.0/kn-linux-amd64</span></span><br><span class="line"><span class="string">mv</span> <span class="string">kn-linux-amd64</span> <span class="string">/usr/local/bin/kn</span></span><br><span class="line"><span class="string">chmod</span> <span class="string">+x</span> <span class="string">/usr/local/bin/kn</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动补全</span></span><br><span class="line"><span class="string">echo</span> <span class="string">-e</span> <span class="string">&quot;\n# kn&quot;</span> <span class="string">&gt;&gt;</span> <span class="string">~/.bash_profile</span></span><br><span class="line"><span class="string">echo</span> <span class="string">&#x27;source &lt;(kn completion bash)&#x27;</span> <span class="string">&gt;&gt;~/.bash_profile</span></span><br></pre></td></tr></table></figure>
<p>下载quickstart二进制文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">wget</span> <span class="string">https://github.com/knative-sandbox/kn-plugin-quickstart/releases/download/knative-v1.2.0/kn-quickstart-linux-amd64</span></span><br><span class="line"><span class="string">mv</span> <span class="string">kn-quickstart-linux-amd64</span> <span class="string">/usr/local/bin/kn-quickstart</span></span><br><span class="line"><span class="string">chmod</span> <span class="string">+x</span> <span class="string">/usr/local/bin/kn-quickstart</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如下两条命令可以得到相同的输出结果</span></span><br><span class="line"><span class="string">kn</span> <span class="string">quickstart</span> <span class="string">--help</span></span><br><span class="line"><span class="string">kn-quickstart</span> <span class="string">--help</span></span><br></pre></td></tr></table></figure>
<p>执行 kn quickstart kind 命令即可创建出一个knative的k8s集群。</p>
<h1 id="knative-serving"><a href="#knative-serving" class="headerlink" title="knative serving"></a>knative serving</h1><p>serving的核心功能为提供弹性扩缩容能力。</p>
<h2 id="CRD"><a href="#CRD" class="headerlink" title="CRD"></a>CRD</h2><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2022/png/220839/1647100343983-06e5baa7-13fb-4c21-a2d3-ce5dc7a1a50c.png#clientId=uf314a495-0864-4&from=paste&height=424&id=ud95a644c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=424&originWidth=540&originalType=binary&ratio=1&size=23832&status=done&style=none&taskId=u80bb136a-1106-43dc-8c93-f62a6fbbe2a&width=540" alt="image.png"><br>Service：用来管理整个应用的生命周期。<br>Route：用来将流量分发到不同的Revision<br>Configuration：<br>Revision：</p>
<p>kpa功能</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="最简单service"><a href="#最简单service" class="headerlink" title="最简单service"></a>最简单service</h3><p>创建hello.yaml文件，内容如下，并执行 kubectl apply -f hello.yaml。其中service的名字为hello，revision的名字为world。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">serving.knative.dev/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="comment"># This is the name of our new &quot;Revision,&quot; it must follow the convention &#123;service-name&#125;-&#123;revision-name&#125;</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">hello-world</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/knative-samples/helloworld-go</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TARGET</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;World&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过kn命令可以看到创建了一个service hello，并且有一个可以访问的url地址。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kn service list</span></span><br><span class="line"><span class="string">NAME</span>    <span class="string">URL</span>                                       <span class="string">LATEST</span>        <span class="string">AGE</span>    <span class="string">CONDITIONS</span>   <span class="string">READY</span>   <span class="string">REASON</span></span><br><span class="line"><span class="string">hello</span>   <span class="string">http://hello.default.127.0.0.1.sslip.io</span>   <span class="string">hello-world</span>   <span class="string">154m</span>   <span class="number">3</span> <span class="string">OK</span> <span class="string">/</span> <span class="number">3</span>     <span class="literal">True</span>  </span><br></pre></td></tr></table></figure>
<p>knative抽象了Revision来标识该service对应的版本信息，可以使用kubectl命令，也可以使用kn命令来查看revision信息。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">k</span> <span class="string">get</span> <span class="string">revisions.serving.knative.dev</span> </span><br><span class="line"><span class="string">NAME</span>          <span class="string">CONFIG</span> <span class="string">NAME</span>   <span class="string">K8S</span> <span class="string">SERVICE</span> <span class="string">NAME</span>   <span class="string">GENERATION</span>   <span class="string">READY</span>   <span class="string">REASON</span>   <span class="string">ACTUAL</span> <span class="string">REPLICAS</span>   <span class="string">DESIRED</span> <span class="string">REPLICAS</span></span><br><span class="line"><span class="string">hello-world</span>   <span class="string">hello</span>                            <span class="number">1</span>            <span class="literal">True</span>             <span class="number">0</span>                 <span class="number">0</span></span><br><span class="line"><span class="string">$</span> <span class="string">kn</span> <span class="string">revision</span> <span class="string">list</span></span><br><span class="line"><span class="string">NAME</span>          <span class="string">SERVICE</span>   <span class="string">TRAFFIC</span>   <span class="string">TAGS</span>   <span class="string">GENERATION</span>   <span class="string">AGE</span>     <span class="string">CONDITIONS</span>   <span class="string">READY</span>   <span class="string">REASON</span></span><br><span class="line"><span class="string">hello-world</span>   <span class="string">hello</span>     <span class="number">100</span><span class="string">%</span>             <span class="number">1</span>            <span class="string">6m33s</span>   <span class="number">3</span> <span class="string">OK</span> <span class="string">/</span> <span class="number">4</span>     <span class="literal">True</span>  </span><br></pre></td></tr></table></figure>

<p>在宿主机上执行 curl <a href="http://hello.default.127.0.0.1.sslip.io/">http://hello.default.127.0.0.1.sslip.io</a> 接口访问刚才创建的service。这里比较有意思的是为什么域名可以在宿主机上解析，该域名实际上是通过公网来解析的，域名服务器sslip.io负责该域名的解析。<br>本机的127.0.0.1的80端口实际是指向的是kind容器的31080端口，而31080为kourier-ingress对外暴露的服务。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl  get svc -A | grep 31080</span></span><br><span class="line"><span class="string">kourier-system</span>     <span class="string">kourier-ingress</span>   <span class="string">NodePort</span>       <span class="number">10.96</span><span class="number">.252</span><span class="number">.144</span>   <span class="string">&lt;none&gt;</span>    <span class="number">80</span><span class="string">:31080/TCP</span>     <span class="string">3h16m</span></span><br></pre></td></tr></table></figure>
<p>kourier-ingress为knative使用的ingress服务，该ingress并非k8s原生的ingress对象，而是自定义的ingress networking.internal.knative.dev&#x2F;v1alpha1。service hello在创建的时候会同步创建一个ingress对象。在该ingress对象中可以看到刚才访问的域名hello.default.127.0.0.1.sslip.io，同时可以看到该ingress将域名指向到了k8s的service hello-world.default。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span>  <span class="string">get</span>  <span class="string">ingresses.networking.internal.knative.dev</span> <span class="string">hello</span> <span class="string">-o</span> <span class="string">yaml</span> </span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.internal.knative.dev/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">networking.internal.knative.dev/rollout:</span> <span class="string">&#x27;&#123;&quot;configurations&quot;:[&#123;&quot;configurationName&quot;:&quot;hello&quot;,&quot;percent&quot;:100,&quot;revisions&quot;:[&#123;&quot;revisionName&quot;:&quot;hello-world&quot;,&quot;percent&quot;:100&#125;],&quot;stepParams&quot;:&#123;&#125;&#125;]&#125;&#x27;</span></span><br><span class="line">    <span class="attr">networking.knative.dev/ingress.class:</span> <span class="string">kourier.ingress.networking.knative.dev</span></span><br><span class="line">    <span class="attr">serving.knative.dev/creator:</span> <span class="string">kubernetes-admin</span></span><br><span class="line">    <span class="attr">serving.knative.dev/lastModifier:</span> <span class="string">kubernetes-admin</span></span><br><span class="line">  <span class="attr">finalizers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ingresses.networking.internal.knative.dev</span></span><br><span class="line">  <span class="attr">generation:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">serving.knative.dev/route:</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">serving.knative.dev/routeNamespace:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">serving.knative.dev/service:</span> <span class="string">hello</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">serving.knative.dev/v1</span></span><br><span class="line">    <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Route</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">4c58e77b-4871-42cc-bfa0-aa9fda9646ed</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">httpOption:</span> <span class="string">Enabled</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hello.default</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hello.default.svc</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hello.default.svc.cluster.local</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">splits:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">appendHeaders:</span></span><br><span class="line">            <span class="attr">Knative-Serving-Namespace:</span> <span class="string">default</span></span><br><span class="line">            <span class="attr">Knative-Serving-Revision:</span> <span class="string">hello-world</span></span><br><span class="line">          <span class="attr">percent:</span> <span class="number">100</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">hello-world</span></span><br><span class="line">          <span class="attr">serviceNamespace:</span> <span class="string">default</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">visibility:</span> <span class="string">ClusterLocal</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hello.default.127.0.0.1.sslip.io</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">splits:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">appendHeaders:</span></span><br><span class="line">            <span class="attr">Knative-Serving-Namespace:</span> <span class="string">default</span></span><br><span class="line">            <span class="attr">Knative-Serving-Revision:</span> <span class="string">hello-world</span></span><br><span class="line">          <span class="attr">percent:</span> <span class="number">100</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">hello-world</span></span><br><span class="line">          <span class="attr">serviceNamespace:</span> <span class="string">default</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">visibility:</span> <span class="string">ExternalIP</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2022-03-11T12:47:26Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">LoadBalancerReady</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2022-03-11T12:47:26Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">NetworkConfigured</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2022-03-11T12:47:26Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Ready</span></span><br><span class="line">  <span class="attr">observedGeneration:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">privateLoadBalancer:</span></span><br><span class="line">    <span class="attr">ingress:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">domainInternal:</span> <span class="string">kourier-internal.kourier-system.svc.cluster.local</span></span><br><span class="line">  <span class="attr">publicLoadBalancer:</span></span><br><span class="line">    <span class="attr">ingress:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">domainInternal:</span> <span class="string">kourier.kourier-system.svc.cluster.local</span></span><br></pre></td></tr></table></figure>
<p>在default namespace下可以看到有三个service，其中hello-world的ingress转发的service。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># k get svc | grep hello</span></span><br><span class="line"><span class="string">hello</span>                                   <span class="string">ExternalName</span>   <span class="string">&lt;none&gt;</span>         <span class="string">kourier-internal.kourier-system.svc.cluster.local</span>   <span class="number">80</span><span class="string">/TCP</span>                                       <span class="string">155m</span></span><br><span class="line"><span class="string">hello-world</span>                             <span class="string">ClusterIP</span>      <span class="number">10.96</span><span class="number">.58</span><span class="number">.149</span>   <span class="string">&lt;none&gt;</span>                                              <span class="number">80</span><span class="string">/TCP</span>                                       <span class="string">155m</span></span><br><span class="line"><span class="string">hello-world-private</span>                     <span class="string">ClusterIP</span>      <span class="number">10.96</span><span class="number">.54</span><span class="number">.163</span>   <span class="string">&lt;none&gt;</span>                                              <span class="number">80</span><span class="string">/TCP,9090/TCP,9091/TCP,8022/TCP,8012/TCP</span>   <span class="string">155m</span></span><br></pre></td></tr></table></figure>
<p>通过查看该serivce的yaml，并未定义serivce的selector。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">autoscaling.knative.dev/class:</span> <span class="string">kpa.autoscaling.knative.dev</span></span><br><span class="line">    <span class="attr">serving.knative.dev/creator:</span> <span class="string">kubernetes-admin</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hello-world</span></span><br><span class="line">    <span class="attr">networking.internal.knative.dev/serverlessservice:</span> <span class="string">hello-world</span></span><br><span class="line">    <span class="attr">networking.internal.knative.dev/serviceType:</span> <span class="string">Public</span></span><br><span class="line">    <span class="attr">serving.knative.dev/configuration:</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">serving.knative.dev/configurationGeneration:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">    <span class="attr">serving.knative.dev/configurationUID:</span> <span class="string">13138d0f-ee5f-4631-94a5-6928546e504c</span></span><br><span class="line">    <span class="attr">serving.knative.dev/revision:</span> <span class="string">hello-world</span></span><br><span class="line">    <span class="attr">serving.knative.dev/revisionUID:</span> <span class="string">f3aaae74-6b79-4785-b60d-5607c0ab3bcf</span></span><br><span class="line">    <span class="attr">serving.knative.dev/service:</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">serving.knative.dev/serviceUID:</span> <span class="number">79907029</span><span class="string">-32df-4f21-b14b-ed7d24e1a10e</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-world</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">networking.internal.knative.dev/v1alpha1</span></span><br><span class="line">    <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ServerlessService</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hello-world</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">3a6326c5-32b0-4074-bec2-4d3eed293b71</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.96</span><span class="number">.58</span><span class="number">.149</span></span><br><span class="line">  <span class="attr">clusterIPs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.96</span><span class="number">.58</span><span class="number">.149</span></span><br><span class="line">  <span class="attr">internalTrafficPolicy:</span> <span class="string">Cluster</span></span><br><span class="line">  <span class="attr">ipFamilies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IPv4</span></span><br><span class="line">  <span class="attr">ipFamilyPolicy:</span> <span class="string">SingleStack</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8012</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>查看Service对应的Endpoint对象，可以看到Endpoint对象实际上指向到了knative-serving下的pod activator-85bd4ddcbb-6ms7n。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">autoscaling.knative.dev/class:</span> <span class="string">kpa.autoscaling.knative.dev</span></span><br><span class="line">    <span class="attr">serving.knative.dev/creator:</span> <span class="string">kubernetes-admin</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">hello-world</span></span><br><span class="line">    <span class="attr">networking.internal.knative.dev/serverlessservice:</span> <span class="string">hello-world</span></span><br><span class="line">    <span class="attr">networking.internal.knative.dev/serviceType:</span> <span class="string">Public</span></span><br><span class="line">    <span class="attr">serving.knative.dev/configuration:</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">serving.knative.dev/configurationGeneration:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">    <span class="attr">serving.knative.dev/configurationUID:</span> <span class="string">13138d0f-ee5f-4631-94a5-6928546e504c</span></span><br><span class="line">    <span class="attr">serving.knative.dev/revision:</span> <span class="string">hello-world</span></span><br><span class="line">    <span class="attr">serving.knative.dev/revisionUID:</span> <span class="string">f3aaae74-6b79-4785-b60d-5607c0ab3bcf</span></span><br><span class="line">    <span class="attr">serving.knative.dev/service:</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">serving.knative.dev/serviceUID:</span> <span class="number">79907029</span><span class="string">-32df-4f21-b14b-ed7d24e1a10e</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-world</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">networking.internal.knative.dev/v1alpha1</span></span><br><span class="line">    <span class="attr">blockOwnerDeletion:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ServerlessService</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hello-world</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">3a6326c5-32b0-4074-bec2-4d3eed293b71</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">10.244</span><span class="number">.0</span><span class="number">.5</span></span><br><span class="line">    <span class="attr">nodeName:</span> <span class="string">knative-control-plane</span></span><br><span class="line">    <span class="attr">targetRef:</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">activator-85bd4ddcbb-6ms7n</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">knative-serving</span></span><br><span class="line">      <span class="attr">resourceVersion:</span> <span class="string">&quot;809&quot;</span></span><br><span class="line">      <span class="attr">uid:</span> <span class="string">df916ac6-3161-4bc6-bf8c-47bb7c83cc4a</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8012</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>
<p>进一步查看knative-serving下有一个knative的组件activator。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">k</span> <span class="string">get</span> <span class="string">deploy</span> <span class="string">-n</span> <span class="string">knative-serving</span> <span class="string">activator</span> </span><br><span class="line"><span class="string">NAME</span>        <span class="string">READY</span>   <span class="string">UP-TO-DATE</span>   <span class="string">AVAILABLE</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">activator</span>   <span class="number">1</span><span class="string">/1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="string">3h35m</span></span><br></pre></td></tr></table></figure>
<p>打开终端，执行一下 kubectl get pod -l serving.knative.dev&#x2F;service&#x3D;hello -w，重新执行 curl <a href="http://hello.default.127.0.0.1.sslip.io/">http://hello.default.127.0.0.1.sslip.io</a> 发起新的请求，可以看到会有pod产生，且pod为通过deployment拉起。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">pod</span> <span class="string">-l</span> <span class="string">serving.knative.dev/service=hello</span> <span class="string">-w</span></span><br><span class="line"><span class="string">hello-world-deployment-7ff4bdb7fd-rqg96</span>   <span class="number">0</span><span class="string">/2</span>     <span class="string">Pending</span>       <span class="number">0</span>          <span class="string">0s</span></span><br><span class="line"><span class="string">hello-world-deployment-7ff4bdb7fd-rqg96</span>   <span class="number">0</span><span class="string">/2</span>     <span class="string">ContainerCreating</span>   <span class="number">0</span>          <span class="string">0s</span></span><br><span class="line"><span class="string">hello-world-deployment-7ff4bdb7fd-rqg96</span>   <span class="number">1</span><span class="string">/2</span>     <span class="string">Running</span>             <span class="number">0</span>          <span class="string">1s</span></span><br><span class="line"><span class="string">hello-world-deployment-7ff4bdb7fd-rqg96</span>   <span class="number">2</span><span class="string">/2</span>     <span class="string">Running</span>             <span class="number">0</span>          <span class="string">1s</span></span><br></pre></td></tr></table></figure>
<p>过一段时间没有新的请求后，pod会自动被删除，同时可以看到deployment的副本数缩成0。该namespace下并没有对应的hpa产生，说明deployment副本数的调整并非使用k8s原生的hpa机制。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">hello-world-deployment-7ff4bdb7fd-rqg96</span>   <span class="number">2</span><span class="string">/2</span>     <span class="string">Terminating</span>         <span class="number">0</span>          <span class="string">63s</span></span><br><span class="line"><span class="string">hello-world-deployment-7ff4bdb7fd-rqg96</span>   <span class="number">0</span><span class="string">/2</span>     <span class="string">Terminating</span>         <span class="number">0</span>          <span class="string">93s</span></span><br><span class="line"><span class="string">$</span> <span class="string">k</span> <span class="string">get</span> <span class="string">deployments.apps</span> </span><br><span class="line"><span class="string">NAME</span>                     <span class="string">READY</span>   <span class="string">UP-TO-DATE</span>   <span class="string">AVAILABLE</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">hello-world-deployment</span>   <span class="number">0</span><span class="string">/0</span>     <span class="number">0</span>            <span class="number">0</span>           <span class="string">21h</span></span><br></pre></td></tr></table></figure>
<h3 id="service的流量切分"><a href="#service的流量切分" class="headerlink" title="service的流量切分"></a>service的流量切分</h3><p>重新提交如下的yaml文件，将service对应的revision更新为knative。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">serving.knative.dev/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">hello-knative</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/knative-samples/helloworld-go</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TARGET</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;Knative&quot;</span></span><br></pre></td></tr></table></figure>
<p>重新查看revision，可以看到revision已经变更为了knative，同时可以看到老的revision world并没有被删除，只是没有了流量转发。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kn</span> <span class="string">revision</span> <span class="string">list</span></span><br><span class="line"><span class="string">NAME</span>            <span class="string">SERVICE</span>   <span class="string">TRAFFIC</span>   <span class="string">TAGS</span>   <span class="string">GENERATION</span>   <span class="string">AGE</span>   <span class="string">CONDITIONS</span>   <span class="string">READY</span>   <span class="string">REASON</span></span><br><span class="line"><span class="string">hello-knative</span>   <span class="string">hello</span>     <span class="number">100</span><span class="string">%</span>             <span class="number">2</span>            <span class="string">49s</span>   <span class="number">4</span> <span class="string">OK</span> <span class="string">/</span> <span class="number">4</span>     <span class="literal">True</span>    </span><br><span class="line"><span class="string">hello-world</span>     <span class="string">hello</span>                      <span class="number">1</span>            <span class="string">10m</span>   <span class="number">3</span> <span class="string">OK</span> <span class="string">/</span> <span class="number">4</span>     <span class="literal">True</span>    </span><br></pre></td></tr></table></figure>
<p>重新apply新的Service，将流量切分为hello-world和hello-knative两份，重新执行curl请求，可以看到结果会随机返回。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">serving.knative.dev/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">hello-knative</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">gcr.io/knative-samples/helloworld-go</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TARGET</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;Knative&quot;</span></span><br><span class="line">  <span class="attr">traffic:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">latestRevision:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">percent:</span> <span class="number">50</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">revisionName:</span> <span class="string">hello-world</span></span><br><span class="line">    <span class="attr">percent:</span> <span class="number">50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看revision的信息，可以看到流量已经是50%的切分了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kn revision list              </span></span><br><span class="line"><span class="string">NAME</span>            <span class="string">SERVICE</span>   <span class="string">TRAFFIC</span>   <span class="string">TAGS</span>   <span class="string">GENERATION</span>   <span class="string">AGE</span>   <span class="string">CONDITIONS</span>   <span class="string">READY</span>   <span class="string">REASON</span></span><br><span class="line"><span class="string">hello-knative</span>   <span class="string">hello</span>     <span class="number">50</span><span class="string">%</span>              <span class="number">2</span>            <span class="string">11m</span>   <span class="number">3</span> <span class="string">OK</span> <span class="string">/</span> <span class="number">4</span>     <span class="literal">True</span>    </span><br><span class="line"><span class="string">hello-world</span>     <span class="string">hello</span>     <span class="number">50</span><span class="string">%</span>              <span class="number">1</span>            <span class="string">21m</span>   <span class="number">3</span> <span class="string">OK</span> <span class="string">/</span> <span class="number">4</span>     <span class="literal">True</span>    </span><br></pre></td></tr></table></figure>
<h1 id="knative-eventing"><a href="#knative-eventing" class="headerlink" title="knative eventing"></a>knative eventing</h1><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2022/png/220839/1647084177641-8d961050-347c-4f45-8a9c-dfa3b0d05dce.png#clientId=uf314a495-0864-4&from=paste&height=471&id=ud6d39aae&margin=%5Bobject%20Object%5D&name=image.png&originHeight=471&originWidth=1288&originalType=binary&ratio=1&size=46263&status=done&style=none&taskId=ub29b3700-7520-4a9a-bc3f-6118fd56695&width=1288" alt="image.png"><br>Source：k8s的CR对象，产生Event<br>Broker：用来分发Event<br>Trigger：Event触发器<br>Sink：Event输出结果</p>
<p>其中包含业务逻辑的可编程的部分在于Trigger部分，由于trigger实际上是无状态的服务，对于一些有状态的消息knative很难满足。比如同一类型的特定字段的event转发到特定的trigger上，broker实际上不具备可编程性，因此无法完成。</p>
<p>kn quickstart 命令会安装一个broker到环境中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">k</span> <span class="string">get</span> <span class="string">brokers.eventing.knative.dev</span> <span class="string">example-broker</span> <span class="string">-o</span> <span class="string">yaml</span> </span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">eventing.knative.dev/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Broker</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">eventing.knative.dev/broker.class:</span> <span class="string">MTChannelBasedBroker</span></span><br><span class="line">    <span class="attr">eventing.knative.dev/creator:</span> <span class="string">kubernetes-admin</span></span><br><span class="line">    <span class="attr">eventing.knative.dev/lastModifier:</span> <span class="string">kubernetes-admin</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-broker</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-br-default-channel</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">knative-eventing</span></span><br><span class="line">  <span class="attr">delivery:</span></span><br><span class="line">    <span class="attr">backoffDelay:</span> <span class="string">PT0.2S</span></span><br><span class="line">    <span class="attr">backoffPolicy:</span> <span class="string">exponential</span></span><br><span class="line">    <span class="attr">retry:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://broker-ingress.knative-eventing.svc.cluster.local/default/example-broker</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">knative.dev/channelAPIVersion:</span> <span class="string">messaging.knative.dev/v1</span></span><br><span class="line">    <span class="attr">knative.dev/channelAddress:</span> <span class="string">http://example-broker-kne-trigger-kn-channel.default.svc.cluster.local</span></span><br><span class="line">    <span class="attr">knative.dev/channelKind:</span> <span class="string">InMemoryChannel</span></span><br><span class="line">    <span class="attr">knative.dev/channelName:</span> <span class="string">example-broker-kne-trigger</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2022-03-11T12:32:43Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Addressable</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2022-03-11T12:32:43Z&quot;</span></span><br><span class="line">    <span class="attr">message:</span> <span class="literal">No</span> <span class="string">dead</span> <span class="string">letter</span> <span class="string">sink</span> <span class="string">is</span> <span class="string">configured.</span></span><br><span class="line">    <span class="attr">reason:</span> <span class="string">DeadLetterSinkNotConfigured</span></span><br><span class="line">    <span class="attr">severity:</span> <span class="string">Info</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">DeadLetterSinkResolved</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2022-03-11T12:32:43Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">FilterReady</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2022-03-11T12:32:43Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">IngressReady</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2022-03-11T12:32:43Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Ready</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">lastTransitionTime:</span> <span class="string">&quot;2022-03-11T12:32:43Z&quot;</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">TriggerChannelReady</span></span><br><span class="line">  <span class="attr">observedGeneration:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>创建如下的Service，该service通过环境变量 BROKER_URL 作为broker地址，可以看到其地址为 quickstart工具默认安装的example-broker。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">serving.knative.dev/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cloudevents-player</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">autoscaling.knative.dev/min-scale:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">ruromero/cloudevents-player:latest</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">BROKER_URL</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">http://broker-ingress.knative-eventing.svc.cluster.local/default/example-broker</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问service页面 <a href="http://cloudevents-player.default.127.0.0.1.sslip.io/">http://cloudevents-player.default.127.0.0.1.sslip.io/</a> 可以在界面上创建Event后，产生如下的Event内容，格式完全遵循社区的CloudEvent规范。点击发送，即可以将消息发送给broker，但由于borker没有配置任何的Trigger，消息在发送到broker后会被直接丢弃。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;root&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;datacontenttype&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/json&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;mediaType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;application/json&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;manual&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;specversion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test-type&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello CloudEvents!&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;extensions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们继续来给broker增加触发器，创建如下的yaml。该触发器定义了broker为example-broker，</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">apiVersion<span class="punctuation">:</span> eventing.knative.dev/v1</span><br><span class="line">kind<span class="punctuation">:</span> Trigger</span><br><span class="line">metadata<span class="punctuation">:</span></span><br><span class="line">  name<span class="punctuation">:</span> cloudevents-trigger</span><br><span class="line">  annotations<span class="punctuation">:</span></span><br><span class="line">    knative-eventing-injection<span class="punctuation">:</span> enabled</span><br><span class="line">spec<span class="punctuation">:</span></span><br><span class="line">  broker<span class="punctuation">:</span> example-broker</span><br><span class="line">  subscriber<span class="punctuation">:</span></span><br><span class="line">    ref<span class="punctuation">:</span></span><br><span class="line">      apiVersion<span class="punctuation">:</span> serving.knative.dev/v1</span><br><span class="line">      kind<span class="punctuation">:</span> Service</span><br><span class="line">      name<span class="punctuation">:</span> cloudevents-player</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重新在页面上发送event，可以看到消息的状态为接收。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/4HijmNvhQAXyEHSBlMHyVw">即学即会Serverless</a></li>
</ul>
]]></content>
      <tags>
        <tag>个人笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>知识分享第一期</title>
    <url>/post/knowledge-share-1/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/qinglongxia.jpeg" alt="北京青龙峡"></p>
<p>自从<a href="http://www.ruanyifeng.com/blog/">阮一峰的博客</a>中增加了每周分享栏目，自己每周五都是主动的浏览一下阮老师的每周分享，一来阮老师的涉猎非常广泛，可以提高自己的视野；二来，阮老师的文章都特别容易懂，给人一种一直想看下去的冲动。</p>
<p>我个人平常也会看很多的技术类文章，也会遇到各种工具或者特别不错的文章，也有分享的冲动，也想搞一些分享的文章，当然我没有阮老师勤奋和涉猎广泛，但也期望能够对他人有所帮助，哪怕文中的一条分享能够让读者觉得有价值，那么也是值的做的一件事情。</p>
<p>具体的分享版块可能不会特别固定，分享的间隔也不会特别勤快，很难做到阮老师的一周一次的频次。</p>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h4 id="1-The-Go-Memory-Model"><a href="#1-The-Go-Memory-Model" class="headerlink" title="1. The Go Memory Model"></a>1. <a href="https://golang.org/ref/mem">The Go Memory Model</a></h4><p>Golang的内存模型，建议Golang开发者读一遍。</p>
<h4 id="2-《极客时间》-左耳听风"><a href="#2-《极客时间》-左耳听风" class="headerlink" title="2. 《极客时间》-左耳听风"></a>2. 《极客时间》-左耳听风</h4><p>知名博客<a href="coolshell.cn">酷壳</a>的作者陈皓的技术专栏，花钱购买一下专栏还是非常值得的，尤其是最近写的程序员练级攻略系列，能提供大量有价值的学习资料及方向指导，非常赞。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/WechatIMG47.jpeg"><br>http:&#x2F;&#x2F;</p>
<h4 id="3-深入解析-kubernetes-资源管理，容器云牛人有话说"><a href="#3-深入解析-kubernetes-资源管理，容器云牛人有话说" class="headerlink" title="3. 深入解析 kubernetes 资源管理，容器云牛人有话说"></a>3. <a href="https://mp.weixin.qq.com/s?__biz=MjM5NzAwNDI4Mg==&mid=2652194459&idx=1&sn=b1191a35a1a87495f21a7e5296afd3ab&chksm=bd01700e8a76f918c0ab3c2efa6578db88b66f5ac7e14d9aa051ebabb9d5aba1079e58938539&mpshare=1&scene=1&srcid=0821WoBhwsd31yM8lGsEDEiF%23rd">深入解析 kubernetes 资源管理，容器云牛人有话说</a></h4><p>对kubernetes的资源管理讲解的非常到位和深入，文章略长，需要花点时间才能读完，值的一看。</p>
<h4 id="4-《TCP-x2F-IP详解-卷1-协议》"><a href="#4-《TCP-x2F-IP详解-卷1-协议》" class="headerlink" title="4. 《TCP&#x2F;IP详解 卷1: 协议》"></a>4. 《TCP&#x2F;IP详解 卷1: 协议》</h4><p>网络方面的经典著作，每个工程师必读，虽然是写给工程师看的，但很多的学术著作中引用到了该书中内容。</p>
<h4 id="5-《深入解析GO》"><a href="#5-《深入解析GO》" class="headerlink" title="5. 《深入解析GO》"></a>5. <a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/01.0.html">《深入解析GO》</a></h4><p>对于go的内部实现原理讲解的挺到位，对于理解go的原理挺有帮助。涉及少量汇编，我不太懂汇编，涉及汇编的地方直接跳过了。</p>
<h4 id="6-Red-Hat-Enterprise-Linux-Document"><a href="#6-Red-Hat-Enterprise-Linux-Document" class="headerlink" title="6. Red Hat Enterprise Linux Document"></a>6. <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/">Red Hat Enterprise Linux Document</a></h4><p>RedHat官方的Linux文档，我个人还没怎么读过。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><h4 id="1-腾讯大学-CEO来了"><a href="#1-腾讯大学-CEO来了" class="headerlink" title="1. 腾讯大学-CEO来了"></a>1. <a href="http://daxue.qq.com/content/special/id/119">腾讯大学-CEO来了</a></h4><p>货真价实的互联网CEO的视频分享，谈创业、谈感悟，目前已经有蔚来汽车、VIPKID、每日优鲜、快手、Keep、知乎的CEO的分享。</p>
<h4 id="2-nginx-upsync-module"><a href="#2-nginx-upsync-module" class="headerlink" title="2. nginx-upsync-module"></a>2. <a href="https://github.com/weibocom/nginx-upsync-module">nginx-upsync-module</a></h4><p>新浪微博开源的nginx module，用于动态更改upstream server。</p>
<h4 id="3-语义化版本规范SemVer"><a href="#3-语义化版本规范SemVer" class="headerlink" title="3. 语义化版本规范SemVer"></a>3. <a href="https://semver.org/lang/zh-CN/">语义化版本规范SemVer</a></h4><p>软件版本在取名上会比较混乱，有的使用1.0.1，有的使用1.0等，SemVer用于规范软件版本的命名。</p>
<h4 id="4-《见识》"><a href="#4-《见识》" class="headerlink" title="4. 《见识》"></a>4. 《见识》</h4><p>吴军老师的最新图书，内容整理自吴军的专栏《硅谷来信》，每篇文章一个主题，值的一读。</p>
<h4 id="5-嗨！济南"><a href="#5-嗨！济南" class="headerlink" title="5. 嗨！济南"></a>5. <a href="https://music.163.com/#/song?id=1304482323&userid=39774156&from=timeline&isappinstalled=0">嗨！济南</a></h4><p>又听到了一首关于济南的歌曲，曾在济南生活多年，必须要分享一下。</p>
<h4 id="6-termtosvg"><a href="#6-termtosvg" class="headerlink" title="6. termtosvg"></a>6. <a href="https://github.com/nbedos/termtosvg">termtosvg</a></h4><p>Github上的开源项目，将命令行工具单独保存为SVG动画。</p>
<h4 id="7-teleport"><a href="#7-teleport" class="headerlink" title="7. teleport"></a>7. <a href="https://github.com/gravitational/teleport">teleport</a></h4><p>提供了ssh的审计和回放，基于SSH的RBAC管理，同时还有一个带管理功能的ui界面，目的是用于取代系统自带的sshd。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h4 id="1-cloc"><a href="#1-cloc" class="headerlink" title="1. cloc"></a>1. <a href="https://github.com/AlDanial/cloc">cloc</a></h4><p>统计代码行数的工具，下面是kubernetes项目的v1.11.2版本的代码行数统计，go的代码行数已经超过了100万行。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/cloc.png"></p>
<h4 id="2-SpaceVim"><a href="#2-SpaceVim" class="headerlink" title="2. SpaceVim"></a>2. <a href="https://spacevim.org/">SpaceVim</a></h4><p>我个人不是vim工具党，刚毕业那会曾经一度热衷于将vim打造成为一个开发C++的IDE，但经过复杂的配置后仍然难以达到CLion这种IDE的水平。最近偶然看到SpaceVim，心中为之一振，这就是我想要的vim，虽达不到IDEA的高度，但已经可以跟vscode的易用度差不多了。</p>
<p>SpaceVim的强大之处在于Space键的使用，默认情况下按下空格键会给出快捷键的提示，类似于桌面系统中的菜单功能。</p>
<p><img src="https://user-images.githubusercontent.com/13142418/36210381-e6dffde6-1163-11e8-9b35-0bf262e6f22b.gif"></p>
]]></content>
      <tags>
        <tag>知识分享</tag>
      </tags>
  </entry>
  <entry>
    <title>知识分享第10期</title>
    <url>/post/knowledge-share-10/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/beixiaohe.jpeg"></p>
<p>春回大地，题图为即将融化的河面以及还在冰面上行走的路人。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>1.<a href="https://fastthread.io/">fastThread</a></p>
<p>在线的JVM线程栈分析工具，通过上传JVM Dump文件，在线查看线程分析结果。</p>
<p>2.<a href="https://www.purpleair.com/map">全球空气质量地图</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/purpleair.png"></p>
<p>可以在线查看全球的PM2.5情况，很多国家的PM2.5都超过了200，但并不包含中国的数据，不知道是不是怕数据把其他国家吓死的缘故。</p>
<p>3.<a href="https://github.com/meolu/walle-web">Walle</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/walle-deploy-console.png" alt="http://www.walle-web.io/docs/2/zh-cn/static/deploy-console.png"></p>
<p>使用Python3开发的CI&#x2F;CD平台，有相对友好的界面，目前Github Star数在6000+。</p>
<p>4.<a href="https://traefik.io/">Træfɪk</a></p>
<p>为微服务而生的HTTP协议反向代理，自带API接口、dashboard，并支持Kubernetes Ingress、Mesos等，可动态加载配置文件等诸多nginx不具备的特性。</p>
<p>5.<a href="https://github.com/xtaci/kcptun">kcptun</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/kcptun.png" alt="https://github.com/xtaci/kcptun/blob/master/kcptun.png"></p>
<p>基于KCP协议的UDP隧道，<a href="https://github.com/skywind3000/kcp">KCP</a>协议能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%。</p>
<p>6.<a href="https://github.com/ibuildthecloud/k3s">k3s - 5 less than k8s</a></p>
<p>有人搞了个k3s项目，作为轻量级的k8s，整个二进制包只有40M大小。项目定位为边缘计算、IoT、CI等，支持多种硬件平台，裁剪了k8s的很多功能，比如云依赖，存储插件等，甚至连k8s依赖的etcd存储都默认更换为了sqlite3。</p>
<p>7.<a href="https://drone.io/">Drone</a></p>
<p>基于Golang的Container Native的CD平台，Github上star 17000+，插件的安装也是基于容器的。</p>
<p>8.<a href="https://github.com/GoogleContainerTools/kaniko#how-does-kaniko-work">kaniko</a></p>
<p>通过Dockerfile来构建docker镜像，需要dockerd进程的支持，这在物理机上操作没有任何问题。而如果要想在容器中通过Dockerfile构建docker镜像却变得困难起来，因为dockerd的运行需要root权限，而容器为了安全是不建议开启root权限的。</p>
<p>该工具可以在容器中不运行dockerd的情况下通过Dockerfile构建出docker镜像。</p>
<p>9.<a href="https://nacos.io/en-us/">Nacos</a></p>
<p>阿里巴巴开源的微服务框架，支持配置中心、动态服务发现、动态DNS。</p>
<p>10.<a href="https://www.powerdns.com/">PowerDNS</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/powerdns-admin.png" alt="https://user-images.githubusercontent.com/6447444/44068603-0d2d81f6-9fa5-11e8-83af-14e2ad79e370.png"></p>
<p>Linux下除了bind外的另一个可选择的DNS服务器，数据存储在mysql中，还有一个可选择的漂亮UI。</p>
<h2 id="精彩书籍"><a href="#精彩书籍" class="headerlink" title="精彩书籍"></a>精彩书籍</h2><ul>
<li><a href="http://product.dangdang.com/25180345.html#ddclick_reco_reco_relate">《激荡十年，水大鱼大》</a></li>
</ul>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/jidang10.jpeg"></p>
<p>要想回顾一下过去的十年中都发生了哪些大事，中国发生了哪些变化，经济领域里有哪些大起大落，本书可以拿来一读。</p>
]]></content>
  </entry>
  <entry>
    <title>知识分享第11期</title>
    <url>/post/knowledge-share-11/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/flower.jpeg"></p>
<p>古语有云，一年之计在于春，这句话对于很多植物而言再合适不过。在经历了寒冬之后，很多植物选择将最美好的一面在春天里绽放。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>1.<a href="https://www.pagerduty.com/">PagerDuty</a></p>
<p>PagerDuty是一家Sass平台厂商，其产品为一款告警处理平台，提供了On-Call管理、告警收敛分组、告警时间报表，并集成了多种告警方式。</p>
<p>2.<a href="https://github.com/usefathom/fathom">Fathom</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/fathom.jpg" alt="https://github.com/usefathom/fathom/raw/master/assets/src/img/fathom.jpg?v=7"></p>
<p>一款开源的简易网站数据分析工具，类似于Google Analytics或者百度分析。</p>
<p>3.<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a></p>
<p>该网站将常见的计算机数据结构以可视化的形式展示在了界面上，可以在界面上点击按钮完成插入元素、删除元素等操作，对应的数据结构展现会实时发生变化，非常直观。</p>
<p>4.<a href="https://developer.twitter.com/en/docs/basics/twitter-ids.html">snowflake</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/snowflake.png" alt="https://user-gold-cdn.xitu.io/2018/2/11/16182507bcefae54?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>Twitter开源的分布式算法，常用于分布式id的生成，使用毫秒时间戳、机器id、毫秒内的流水号来生成随机id。采用此种方法生成的id可以保证单机递增，但不能保证是全局递增的。</p>
<p>5.<a href="https://www.netlify.com/">Netlify</a></p>
<p>很多人喜欢将自己的博客系统利用Github的Pages功能托管到Github上，但Github Pages并不支持对静态页面的构建，只能将构建完成后的页面推动到Github上。Netlify支持对静态网站的持续集成和持续部署，代码可以托管于Github上，Netlify会自动构建和发布，支持免费的https协议和CDN。</p>
<p>但可惜的是，实际测试下来，网站的访问速度在国内不是很理想。</p>
<p>6.<a href="https://github.com/996icu/996.ICU">996.ICU</a></p>
<p>全世界最大的同性交友社区Github上异常火爆的声讨996工作制度的项目，两天的时间内已经突破6万多Star，issue的数量也已经破万（截止到2019-03-28 19:55），要知道Github上Star数最多的项目<a href="https://github.com/freeCodeCamp/freeCodeCamp">freeCodeCamp</a>也才接近30万Star，全世界运行设备最多的操作系统<a href="https://github.com/torvalds/linux">linux</a>也才7万多Star，这简直创造了Github上Star数增长的奇迹。</p>
<p>很多人在issue中提到了加群交友吐槽、倾诉加班不满，甚至还有过来找男盆友的，活脱脱把issue玩成了贴吧，留言中清一色的汉字，说明基本是中国人在玩。</p>
<p>我个人对于强制996加班的事情不是很赞成，虽然过去三年中我的工作强度应该大于996，但更多的是出于个人自愿和对健康的无视，公司层面并没有强制要求。人生确实有非常多美好的事情可以参与和享受，对于程序员这个群体而言，电脑屏幕之外的世界还很大，还有太多的领域值得去探索和挖掘。但如果确实是因为个人的爱好，在工作中能够获得很好的成就感和满足感，996或者更高强度的加班，我个人觉得都是值得的。</p>
<p>说起ICU，程序员这个群的职业病是颈椎、腰椎、视力等，失眠多梦也是大有人在。我个人也确实身体出过一些问题而住过院，人往往都是在身体好的时候不懂得去重视自己的身体，当身体一旦出毛病的时候才懂得去珍惜。我曾经生病的时候也是鼓励自己要多锻炼和注意身体，但当身体好了之后，当时的愿望又抛到了脑后。</p>
<p>身体出现问题往往不是一朝一夕造成的，而是长期积累的结果，尤其是刚工作的前几年，趁着年轻确实能多加班熬夜，但30岁之后往往体力就跟不上了。还是奉劝各位，在工作的时候多注意休息和加强锻炼，无论是996，还是朝九晚五，都要多注意。</p>
<h2 id="精彩文章"><a href="#精彩文章" class="headerlink" title="精彩文章"></a>精彩文章</h2><p>1.<a href="https://www.jianshu.com/p/07374ed16a73">互联网运维工作</a></p>
<p>滴滴运维总监来伟在2017年对运维工作范围的思考，公司处在不同的阶段，运维所能干的事情也有所不同。</p>
<p>2.<a href="https://mp.weixin.qq.com/s?__biz=MzI5OTM3MjMyNA==&mid=2247486405&idx=1&sn=2a9feae9bcfa5ce9c481dd6b3f9c933d&chksm=ec96d18edbe158980a4083e9ed20b8c77216ba6e40b8512bde04b14189aa6353673a146f273e&mpshare=1&scene=1&srcid=%23rd">早点懂这几个道理，就不害怕被裁员了</a></p>
<p>IT行业中的一些职场规则，程序员在中年时期如果不做好职场转型，会逐步被更有活力更有体力的年轻人给取代。</p>
]]></content>
  </entry>
  <entry>
    <title>技术分享第12期</title>
    <url>/post/knowledge-share-12/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/12.JPG"></p>
<p>距离上次的知识分享系列已经过去了半年之久，难以想象。在该系列的开始我就说过该系列是不定期的，果不食言，只是这次的不定期有些久😓。该系列会继续下去，但节奏仍然是不定期的，但应该不会间隔半年之巨了。</p>
<p>题图来自首钢工业遗址公园，首钢于2010年完成了搬迁到唐山市的工作，位于石景山的工厂被废弃。2019年国庆节前夕以公园的形式部分对外开放，跟普通公园不同的地方在于保留了很多之前的工厂建筑及大型生产机械，足够硬核，非常原汁原味。</p>
<p>2022年要举办的冬奥会也非常明智的将场地选择在了该公园，预计将来会有很多的场馆位于该公园内且对外开放。</p>
<p>国内很多的地市都有一些类似的建筑，比如90年代下岗潮之前的一些国企工厂，我知道的济南的机床厂就有很多个，但很多这些倒闭关门的工厂后来的建筑及地皮都给卖掉了，建筑物也直接给拆掉了，殊不知其衍生价值也是有不少的。位于北京酒仙桥的798就是个非常好的改造案例，798园区的建筑稍加改造，给很多艺术工作室提供了非常好的办公场地，也是城市中的一个亮眼的名片。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>1.<a href="https://msgpack.org/">MessagePack</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/messagepack.png"></p>
<p>json作为一种常见的数据序列化方案，存在占用空间过多、反序列化过于消耗cpu的问题。MessagePack是一种基于二进制的高效轻量的数据序列化方案，支持数据的压缩，支持丰富的编程语言。在上图中，可以看出原27字节的json数据转换为MessagePack后仅占用了18字节。</p>
<p>另外，据今日头条的压测，要比Thrift的二进制序列化方案更高效一些。</p>
<p>2.<a href="https://github.com/yuroyoro/goast-viewer">GoAst Viewer</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/goast-viewer.png" alt="https://raw.githubusercontent.com/yuroyoro/goast-viewer/master/goast-viewer.png"></p>
<p>Golang中的ast、parser、token包可用来对golang的源码进行语法分析，并构建出AST树。GoAst Viewer支持在线输入Golang源码来构建AST树。</p>
<p>3.<a href="https://kubeedge.io/">KubeEdge</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/kubeedge_arch.png" alt="https://github.com/kubeedge/kubeedge/blob/master/docs/images/kubeedge_arch.png"></p>
<p>IoT目前正在大力发展，边缘设备的计算能力在逐渐增强，同时处理的数据量的需求正在快速增加，而数据中心的数据处理能力、网络带宽、扩展能力并没有太多的增强，未来势必会将部分计算能力下放到边缘设备，以降低数据中心的成本。</p>
<p>华为开源的KubeEdge为基于Kubernetes的边缘计算平台，支持边缘集群的编排和管理。</p>
<p>4.<a href="http://mycat.io/">Mycat</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/mycat.png" alt="http://mycat.io/index_files/mycat2.jpg"></p>
<p>国内开源的关系型数据库中间件，支持MySQL、Oracle等常见的关系型数据库。关系型数据库单表过大导致性能下降后的解决思路往往是分库分表，分库分表后需要增加中间件层来解决多个数据库多张表的数据增删改查问题，而Mycat是一个不错的解决方案。</p>
<p>当然Mycat的功能不仅限于此，比如支持跨库的两张表join、Mycat-eye可以来监控Mycat等，更多功能请参照官方网站。</p>
<p>5.<a href="https://lab.lyric.im/wxformat/">WeChat Format</a></p>
<p>一款转换markdown格式的文档为微信公众号排版的工具，排版比较精美，推荐一试。</p>
<p>6.<a href="https://gitnoteapp.com/zh/">GitNote</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/gitnote.png" alt="https://gitnoteapp.com/imgs/gitnote.png"></p>
<p> 一款基于git的笔记管理软件，可以将笔记存放到Github中，支持多种图床插件，支持多个平台（还没有移动端），支持富文本编辑和Markdown编辑。由于笔记是可以同步Github上的，可以做到永久保存和版本控制，而且笔记的存放目录和格式不受该工具的影响，可以说是完全没有侵入性，脱离了该工具仍然可以通过直接编辑git项目的方式来发布笔记。</p>
<p>7.<a href="http://www.vlang.org/">Vlang开源啦</a></p>
<p>V语言宣布开源，从V语言的特性上看到了很多Golang的影子，并未看到耳目一新的特性。</p>
<p>8.<a href="https://github.com/kubernetes-sigs/krew">krew</a></p>
<p>一款kubectl的plunin管理工具，mac平台下有brew包管理工具，随着kubectl的plugin机制的成熟，plugin管理工具应运而生。</p>
<p>9.<a href="https://github.com/jetstack/cert-manager">cert-manager</a></p>
<p>运行在k8s上的证书管理工具，可以签发证书，基于CRD实现。</p>
<p>Let’s Encrypt提供了免费的tls证书，但证书有有效期限制，过期后需要手工重新申请证书，cert-manager可以做到从Let’s Encrypt自动申请证书，并过期后重新申请证书。</p>
<p>10.<a href="https://github.com/abishekvashok/cmatrix">cmatrix</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/capture_orig.gif" alt="https://github.com/abishekvashok/cmatrix/raw/master/data/img/capture_orig.gif?raw=true"></p>
<p>一款黑客帝国效果的命令行工具，除了炫酷也没啥其他用途了。</p>
<p>11.<a href="https://boxes.thomasjensen.com/">boxes</a></p>
<p>boxes为一款有趣的命令行工具，可以显示很多神奇效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          __   _,--=&quot;=--,_   __</span><br><span class="line">         /  \.&quot;    .-.    &quot;./  \</span><br><span class="line">        /  ,/  _   : :   _  \/` \</span><br><span class="line">        \  `| /o\  :_:  /o\ |\__/</span><br><span class="line">         `-&#x27;| :=&quot;~` _ `~&quot;=: |</span><br><span class="line">            \`     (_)     `/</span><br><span class="line">     .-&quot;-.   \      |      /   .-&quot;-.</span><br><span class="line">.---&#123;     &#125;--|  /,.-&#x27;-.,\  |--&#123;     &#125;---.</span><br><span class="line"> )  (_)_)_)  \_/`~-===-~`\_/  (_(_(_)  (</span><br><span class="line">(        Different all twisty a         )</span><br><span class="line"> )         of in maze are you,         (</span><br><span class="line">(           passages little.            )</span><br><span class="line"> )                                     (</span><br><span class="line">&#x27;---------------------------------------&#x27;</span><br></pre></td></tr></table></figure>

<p>12.<a href="https://github.com/elastic/rally">rally</a></p>
<p>一款elasticsearch的压测工具。</p>
<p>13.<a href="https://tekton.dev/">tekton</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/tekton-horizontal-color.png" alt="https://tekton.dev/img/logos/tekton-horizontal-color.png"></p>
<p>Google开源的一款基于Kubernetes的应用发布框架，Google在云原生生态中出品一般质量都比较高，主要用来做CI&#x2F;CD。</p>
<p>14.<a href="https://github.com/aylei/kubectl-debug">kubectl-debug</a></p>
<p>一款基于kubectl插件的debug工具，基础镜像使用nicolaka&#x2F;netshoot(内置了大量的网络排查工具)，可用于kubernetes集群中快速定位问题。值得一提的是，该工具的初版是作者在参加pingcap面试时的小作业。</p>
<p>15.<a href="https://github.com/helm/monocular">Monocular</a></p>
<p>Rancher出品的一款基于管理helm chart的ui工具。</p>
<p>16.<a href="https://gitmoji.carloscuesta.me/">gitmoji</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/gitmoji.jpg"></p>
<p>github上的开源项目中经常会看到一些git commit message中包含了moji表情，而且有越来越多的趋势，这些moji表情不紧紧是好玩，而且还非常生动形象的表达了commit message的含义，并且非常醒目，但这些moji表情可不应该是滥用的。该网站记录了一些常用的moji表情在git commit中的含义。</p>
<h2 id="精彩文章"><a href="#精彩文章" class="headerlink" title="精彩文章"></a>精彩文章</h2><p>1.<a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/">Monitoring and Tuning the Linux Networking Stack: Receiving Data</a></p>
<p>本文讲解了一个数据包到达网卡后是怎么一步步从网卡 -&gt; 操作系统 -&gt; 应用程序，并讲解了Linux中的实现方式。</p>
<p>绝大多数的工程师对于这一块的知识是较为模糊的，建议一读。</p>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU3OTc1Njk4MQ==&mid=2247486851&idx=1&sn=d0322f6d1a59c21e977488d9701d0476&chksm=fd607b59ca17f24fb07f60b8f488e602ac7e75302c999c206938682387e1d3cac44feb67b208&mpshare=1&scene=1&srcid=%23rd">https://mp.weixin.qq.com/s?__biz=MzU3OTc1Njk4MQ==&amp;mid=2247486851&amp;idx=1&amp;sn=d0322f6d1a59c21e977488d9701d0476&amp;chksm=fd607b59ca17f24fb07f60b8f488e602ac7e75302c999c206938682387e1d3cac44feb67b208&amp;mpshare=1&amp;scene=1&amp;srcid=%23rd</a></p>
<p>半年多前比较火的视频，但我还是经常会想起来，给大家重温一下。</p>
<p>视频中为杭州一小伙深夜骑车逆行被交警拦下后情绪崩溃，失声痛哭。小伙每晚加班到十一二点，一方面女朋友在催着给送药匙，另一方面公司还在催着赶回公司，再加上被交警拦下，最终来自三方面的催促导致积压在小伙内心长久以来的压力爆发而情绪失控。隔着屏幕都能感受到小伙长期以来的压力，我猜想如果给他一些自由的时间，他一定会选择独自一人到一个安静的地方过上一段时间与世隔绝的生活。</p>
<p>生活本不易，在觉大多数的成年人生活中没有简单二字，祝愿各位生活如意！</p>
]]></content>
  </entry>
  <entry>
    <title>技术分享第13期</title>
    <url>/post/knowledge-share-13/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/wangjing-soho.jpg" alt="望京SOHO"></p>
<p>又是很长的一段时间没有更新，果然又是不定期更新，文章的有些内容也是很久以前积累的，并不是因为太懒，而是确实没有太多的精力。</p>
<p>题图为雨中的望京SOHO，今年全国的雨水特别多，北京亦是如此。南方的鱼米之乡地区出现了严重的洪灾，不知道今年的粮食产量会受多大影响。我们的地球在人类翻天覆地的变更后实在经受不了太多的hack，愿雨季早日过去。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>1.<a href="https://github.com/p8952/bocker">bocker</a></p>
<p>bocker&#x3D;bash + docker，其利用100多行bash代码实现的简易版的docker，使用到的底层技术跟docker是一致的，包括chroot、namespace、cgroup。</p>
<p>2.<a href="https://github.com/ahmetb/kubectx">kubectx</a></p>
<p>天天操作k8s的工程师一定少不了使用kubectl命令，而用kubectl命令的工程师一定会特别烦天天输入<code>-n $&#123;namespace&#125;</code>这样的操作，该工具可以省去输入namespace的操作。刚开始的时候不是太习惯该工具，直到近期才感知到该工具的价值。🤦‍♂️</p>
<p>3.<a href="https://kubeoperator.io/">KubeOperator</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/kubeoperator-ui.jpg" alt="https://raw.githubusercontent.com/KubeOperator/website/master/images/kubeoperator-ui.jpg"></p>
<p>k8s集群的安装操作基本上都是黑屏来完成的，同时集群规模较大时，还需要一些自动化的手段来解决安装和运维物理机的问题。KubeOperator提供了界面化的操作来完成k8s集群的配置、安装、升级等的操作，底层也是调用了ansible来作为自动化的工具。该项目已经加入CNCF，期望后面可以做的功能更加强大，给k8s集群的运维带来便利。</p>
<p>4.<a href="https://github.com/operator-framework/awesome-operators">awesome-operators</a></p>
<p>k8s生态的operator非常火爆，作为k8s扩展能力的一个重要组成部分，该项目汇总了常见的operator项目。</p>
<p>5.<a href="https://github.com/pingcap/chaos-mesh">chaos-mesh</a></p>
<p>pingcap开源的Kubernetes的混沌工程项目，可以使用CRD的方式来注入故障到Kubernetes集群中。</p>
<p>6.<a href="https://github.com/bregman-arie/devops-exercises">devops-exercises</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/devops-exercises.jpg"></p>
<p>DevOps相关的一些面试题，涉及到的方面还是比较全的。</p>
<p>7.<a href="https://github.com/msoap/shell2http">shell2http</a></p>
<p>可以将shell脚本放到业务页面上执行的工具，在web页面上点击按钮后，会执行shell脚本，shell脚本的输出会在web页面上显示。</p>
<p>8.<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-shell-styleguide/contents/">Google Shell 风格指南</a></p>
<p>Google编程规范还是比较有权威性的，此为Shell的编码规范。</p>
<p>9.<a href="https://github.com/koalaman/shellcheck">shellcheck</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/shellcheck.png"></p>
<p>Shell作为弱类型的编程语言，稍有不慎还是非常容易写错语法的，至少很多的语法我是记不住的，每次都是边查语法边写🤦‍。该项目为Shell的静态检查工具，用来检查可能的语法错误，在Github上的start数量还是非常高的。</p>
<p>不仅支持命令行工具检查，而且还可以跟常用的编辑器集成（比如vim、vscode），用来实现边写边检查的效果。还提供了web界面，可以将shell脚本输入到web界面上来在线检查。</p>
<p>10.<a href="https://www.teambition.com/">teambition</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/teambition.png"></p>
<p>阿里的一款的远程协作工具，类似于国外slack+trello的结合版，在产品设计上能看到太多地方借鉴了trello，非常像是trello的本土化版本，更贴近国人的使用习惯，可用于管理团队和个人的任务。</p>
<p>11.<a href="https://icepanel.io/">IcePanel</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/icepanel.png"></p>
<p>IcePanel为vscode的一款插件，提供了k8s一些基础对象的编辑生成器，通过ui的界面即可生成k8s的ConfigMap、Deployment、Service等对象。</p>
<ol start="12">
<li><a href="https://labs.play-with-k8s.com/">Play with Kubernetes</a></li>
</ol>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/play-with-kubernetes.jpg"></p>
<p>一个提供在线的kubernetes集群的工具，在界面上点一下按钮就可以创建一个k8s集群，不需要注册，非常方便，但创建的集群只有四个小时的使用时间。可以用来熟悉k8s的基本操作，或者试验一些功能。</p>
<h2 id="精彩文章"><a href="#精彩文章" class="headerlink" title="精彩文章"></a>精彩文章</h2><p>1.<a href="https://mp.weixin.qq.com/s/FK9cYbGvzCLUsO7q63TrCA">腾讯自研业务上云：优化Kubernetes集群负载的技术方案探讨</a></p>
<p>k8s虽然在服务器的资源利用率上比起传统的物理机或虚拟机部署服务方式有了非常大的提升，本文结合实践经验，从pod、node、hpa等多个维护来优化以便进一步的压榨服务器的资源。</p>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p>1.[Linux开源网络全栈详解：从DPDK到OpenFlow])(<a href="http://product.china-pub.com/8061094">http://product.china-pub.com/8061094</a>)</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/linux_opensource_network_stack.jpg"></p>
<p>该书可以作为全面了解开源软件网络的相关技术，涉及到Linux虚拟网络、DPDK、OpenStack、容器相关网络等知识。</p>
<p>2.<a href="http://product.china-pub.com/8064178">Kubernetes 网络权威指南：基础、原理与实践</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/k8s-network.jpg"></p>
<p>该书可以作为全面了解k8s相关的容器网络的相关技术，如果对k8s周边的虚拟网络知识有所全面了解，该书籍还是比较适合的。</p>
]]></content>
  </entry>
  <entry>
    <title>技术分享第14期</title>
    <url>/post/knowledge-share-14/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/zheli.jpg"></p>
<p>题图为一点资讯近期推出的一款定位线上社交的App啫喱，每个人可以给自己订制一个卡通形象，是国内厂商对于线上社交的一次新的尝试。</p>
<p>距离上期技术分享已经约有一年半的时间，这次不定期更新的时间有些久。2022年期望在博客方面增加时间投入，多关注开源技术，预计会大幅度提升更新的频率。</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><h2 id="1-Katacoda"><a href="#1-Katacoda" class="headerlink" title="1. Katacoda"></a>1. <a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/katacoda.jpg"></p>
<p>可以一键创建一个k8s集群的工具，甚至无需登录，比上期推荐的工具<a href="http://kuring.me/post/knowledage-share-13/">Play with Kubernetes</a>更为方便。</p>
<h2 id="2-OperatorHub"><a href="#2-OperatorHub" class="headerlink" title="2. OperatorHub"></a>2. <a href="operatorhub.io">OperatorHub</a></h2><p>k8s推出了CRD的机制后，大大增强了k8s的扩展能力，可以好不夸张的说，k8s之所以如此成功，跟CRD的扩展机制有很大关系。OperatorHub类似于DockerHub，收集了各种各样的operator实现。</p>
<h2 id="3-lazykube"><a href="#3-lazykube" class="headerlink" title="3. lazykube"></a>3. <a href="https://github.com/TNK-Studio/lazykube">lazykube</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/lazykube.gif"></p>
<p>一款可以通过命令行终端来展示和管理k8s资源的工具。</p>
<h2 id="4-LazyDocker"><a href="#4-LazyDocker" class="headerlink" title="4. LazyDocker"></a>4. <a href="https://github.com/jesseduffield/lazydocker">LazyDocker</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/lazydocker.jpg"></p>
<p>同上面的lazykube工具，LazyDocker是一个可以在命令行上查看本机docker的工具，可以查看docker上容器以及运行状态、本地的镜像以及分层信息、volume信息。</p>
<h2 id="5-httpbin"><a href="#5-httpbin" class="headerlink" title="5. httpbin"></a>5. <a href="http://httpbin.org/">httpbin</a></h2><p>一个非常简单的http服务，可以用来在测试服务的连通性，尤其是可以用curl测试api层面的连通性，再也不用访问curl <a href="http://www.baidu.com了.比如执行`curl/">http://www.baidu.com了。比如执行`curl</a> <a href="http://httpbin.org/headers%60%E5%8F%AF%E4%BB%A5%E4%BB%A5json%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%BF%94%E5%9B%9Erequest%E7%9A%84http">http://httpbin.org/headers`可以以json的形式返回request的http</a> header信息，执行<code>curl http://httpbin.org/status/200</code>可以返回状态码为200。</p>
<p>不过，在国内访问该网站连通性并不是太好。还提供了镜像版本，可以直接在本地以docker的方式运行该服务。</p>
<h2 id="6-Flux"><a href="#6-Flux" class="headerlink" title="6. Flux"></a>6. <a href="https://github.com/fluxcd/flux">Flux</a></h2><p>一款基于k8s的GitOps工具，采用k8s的声明式api基于operator实现。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/flux-cd-diagram.png" alt="https://github.com/fluxcd/flux/blob/master/docs/_files/flux-cd-diagram.png"></p>
<h2 id="7-OpenTelemetry"><a href="#7-OpenTelemetry" class="headerlink" title="7. OpenTelemetry"></a>7. <a href="https://opentelemetry.io/">OpenTelemetry</a></h2><p>云原生领域的可观测性工具，用来制定规范、提供sdk和采集agent实现，实现了可观察性中的tracing和metric，并没有实现logging部分。不负责底层的后端存储，可以跟负责metric的prometheus集成，负责tracing的jager集成。</p>
<h2 id="8-kspan"><a href="#8-kspan" class="headerlink" title="8. kspan"></a>8. <a href="https://github.com/weaveworks-experiments/kspan">kspan</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/kspan.png" alt="https://github.com/weaveworks-experiments/kspan/blob/main/example-2pod.png"></p>
<p>该工具可以将k8s的event使用OpenTelemetry转换成tracing的形式，并将其存储在支持tracing的后端，比如jaeger中。</p>
<h2 id="9-skopeo"><a href="#9-skopeo" class="headerlink" title="9. skopeo"></a>9. <a href="https://github.com/containers/skopeo">skopeo</a></h2><p>skopeo是一款镜像操作工具，用来解决常用的镜像操作，但这些功能docker命令却不太具备，或者需要调用docker registry的api才可以完成操作。比如镜像从一个镜像仓库迁移到另外一个镜像仓库，从镜像仓库中删除镜像等。</p>
<h2 id="10-KubeOperator"><a href="#10-KubeOperator" class="headerlink" title="10. KubeOperator"></a>10. <a href="https://fit2cloud.com/kubeoperator/index.html">KubeOperator</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/kube-operator.jpeg" alt="https://camo.githubusercontent.com/1045b27ad1186b915281a6fd77b35979d2038d97e152c34f0431e74ac43d4145/68747470733a2f2f6b7562656f70657261746f722e696f2f696d616765732f73637265656e73686f742f30322e6a7067"></p>
<p>KubeOperator一个开源的轻量级 Kubernetes 发行版，提供可视化的 Web UI，可以用来在IaaS 平台上自动创建主机，通过 Ansible 完成自动化部署和变更操作。</p>
<p>另外，还提供了商业版本，支持更多的企业级特性，这种模式也是类似Redhat的最为常见的开源软件的商业变现方式。</p>
<h2 id="11-Lens"><a href="#11-Lens" class="headerlink" title="11. Lens"></a>11. <a href="https://k8slens.dev/">Lens</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/lens.png" alt="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/kube-operator.jpeg"></p>
<p>Kubernetes的客户端工具，非web端工具，可以通过本地访问远程的k8s集群，并且可以获取k8s集群的node、pod等信息，提供了mac、linux、windows三种客户端版本。</p>
<h2 id="12-Caddy"><a href="#12-Caddy" class="headerlink" title="12. Caddy"></a>12. <a href="https://caddyserver.com/">Caddy</a></h2><p>一款使用Golang编写的七层负载均衡软件，Github上有3万+的star数量，相比与nginx有两个明显的优势：提供了默认的https服务，支持证书的自签发；使用Golang开发，只需要一个二进制配合caddyfile配置文件即可运行，更轻量。</p>
<h2 id="13-LVScare"><a href="#13-LVScare" class="headerlink" title="13. LVScare"></a>13. <a href="https://github.com/sealyun/lvscare">LVScare</a></h2><p>sealyun开源的一个轻量级的lvs管理工具，可以作为轻量级的负载均衡，基于Golang实现。输入这样一条指令 <code>lvscare care --run-once --vs 10.103.97.12:6443 --rs 192.168.0.2:6443 --rs 192.168.0.3:6443 --rs 192.168.0.4:6443</code> 即可在宿主机上创建对应的ipvs规则。自带了健康检查功能，支持四层和七层的健康检查，是该工具的最大优势。一般lvs会配合着keepalived来进行检查检查，一旦健康检查失败后会将rs的权重调整为0，但keepalived的配置相对复杂，该工具更轻量。</p>
<h2 id="14-HUGO"><a href="#14-HUGO" class="headerlink" title="14. HUGO"></a>14. <a href="https://gohugo.io/">HUGO</a></h2><p>非常火爆的使用Golang开发的开源博客系统，目前Github上的Star数量已经超过5万+，更老牌的开源博客系统Hexo的Star数量才3万+，基于Vue开发的VuePress Star数量还不到2万。</p>
<h2 id="15-sealer"><a href="#15-sealer" class="headerlink" title="15. sealer"></a>15. <a href="https://github.com/alibaba/sealer">sealer</a></h2><p>阿里巴巴开源的一款云原生的应用发布工具。该工具的设计思路非常先进，提出了集群镜像的概念，可以将k8s集群和应用build成为一个集群镜像，类似于docker镜像，一旦集群镜像构建完成后即可像容器一样运行在不同的硬件上。</p>
]]></content>
  </entry>
  <entry>
    <title>技术分享第15期</title>
    <url>/post/knowledge-share-15/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/knowledage-15.jpg"></p>
<p>题图为周末的公园露营区。一周前曾经下过一场雪，地上覆盖着厚厚的一层雪，而一星期过后，上面却扎满了帐篷。城市里的人们，在捂了一个冬季后，终于迎来了阳光明媚的春天。虽内心充满着诗和远方，疫情之下，能约上三五好友，在草地上吃上一顿野餐，亦或在帐篷里美美的睡上一觉已是一件很奢侈的事情。</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><h2 id="1-Submariner"><a href="#1-Submariner" class="headerlink" title="1. Submariner"></a>1. <a href="https://www.rancher.cn/submariner/">Submariner</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/how-it-works-submariner.svg"></p>
<p>Rancher开源的一款k8s集群之间的容器网络打通的工具。k8s社区的网络插件中以overlay的网络插件居多，因为overlay的网络对底层物理网络几乎很少有依赖，通常会采用vxlan、IPIP等协议来实现。虽然overlay的网络插件用起来比较方便，但是两个k8s集群的容器网络通常是无法直接通讯，在多k8s集群的应用场景下比较受限。Submariner提供了容器网络的互通方案。 </p>
<h2 id="2-k8e"><a href="#2-k8e" class="headerlink" title="2. k8e"></a>2. <a href="https://github.com/xiaods/k8e">k8e</a></h2><p>k8e为Kubernetes Easy的简写。社区里有k3s和k0s项目来提供了k8s精简版，本项目在k3s的基础之上又进一步进行了裁剪，移除了一些边缘场景的特性。</p>
<h2 id="3-Rancher-Desktop"><a href="#3-Rancher-Desktop" class="headerlink" title="3. Rancher Desktop"></a>3. <a href="https://rancherdesktop.io/">Rancher Desktop</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/rancher-desktop.png"></p>
<p>k8s的发行版SUSE Rancher提供的k8s的桌面客户端，目前已经发布了1.0.0版本。</p>
<h2 id="4-nginx-config"><a href="#4-nginx-config" class="headerlink" title="4. nginx config"></a>4. <a href="https://nginxconfig.io/">nginx config</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/nginx-config.jpg"></p>
<p>Nginx作为最流行的负载均衡配置软件之一，有自己的一套配置语法。DigitalOcean提供的nginx config工具可以通过UI直接进行配置，并最终可以一键生成nginx的配置文件。</p>
<h2 id="5-mizu"><a href="#5-mizu" class="headerlink" title="5. mizu"></a>5. <a href="https://github.com/up9inc/mizu">mizu</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/mizu-ui.png"></p>
<p>一款部署在k8s上的流量分析工具，可以认为是k8s版的tcpdump + wireshark。底层的实现也是基于libpcap抓包的方式，可以支持解析HTTP、Redis、Kafka等协议。</p>
<h2 id="6-kube-bench"><a href="#6-kube-bench" class="headerlink" title="6. kube-bench"></a>6. <a href="https://github.com/aquasecurity/kube-bench">kube-bench</a></h2><p>互联网安全中心（Center for Internet Security）针对k8s版本提供了一套安全检查的规范，<a href="https://learn.cisecurity.org/benchmarks">约有200多页的pdf文档</a>，本项目为针对该规范的实现。仅需要向k8s环境中提交一个job，即可得到最终的安全结果。很多公有云厂商也有自己的实现，比如<a href="https://help.aliyun.com/document_detail/207760.html">阿里云ACK的实现</a>。</p>
<h2 id="7-virtual-kubelet"><a href="#7-virtual-kubelet" class="headerlink" title="7. virtual-kubelet"></a>7. <a href="https://github.com/virtual-kubelet/virtual-kubelet">virtual-kubelet</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/virtual-kubelet.svg"></p>
<p>virtual kubelet服务通过在k8s集群上创建虚拟node，当一个pod调度到虚拟node时，virtual kubelet组件以插件的形式提供了不同的实现，可以将pod创建在k8s集群之外。比如，在阿里云的场景下，可以将pod创建到弹性容器实例ECI上面，从而达到弹性的目的。该项目除了用于公有云一些弹性的场景外，还常用于边缘计算的场景。</p>
<h2 id="8-cloudevents"><a href="#8-cloudevents" class="headerlink" title="8. cloudevents"></a>8. <a href="https://cloudevents.io/">cloudevents</a></h2><p>CloudEvents定义了一种通用的方式描述事件数据的规范，由CNCF的Serverless工作组提出。阿里云的事件总线EventBridge基于此规范提供了比较好商业化产品。</p>
<p>相关链接：<a href="https://mp.weixin.qq.com/s/SdpMLCaRSGsFnm08PjBxEA">EventBridge 事件总线及 EDA 架构解析</a></p>
<h2 id="9-kubectl-who-can"><a href="#9-kubectl-who-can" class="headerlink" title="9. kubectl-who-can"></a>9. <a href="https://github.com/aquasecurity/kubectl-who-can">kubectl-who-can</a></h2><p>在k8s系统中，通常会通过RBAC的机制来配置某个账号拥有某种权限，但如果反过来要查询某个权限被哪些账号所拥有，就会麻烦很多。</p>
<p>该工具是一个k8s的命令行小工具，可以用来解决上述需求。比如查询拥有创建namespace权限的ServiceAccount有哪些，可以直接执行 <code>kubectl-who-can create namespace</code>。</p>
<h2 id="10-kyverno"><a href="#10-kyverno" class="headerlink" title="10. kyverno"></a>10. <a href="https://kyverno.io/">kyverno</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/kyverno-architecture.png"></p>
<p>Kyverno是一款基于k8s的策略引擎工具，通过抽象CRD ClusterPolicy的方式来声明策略，在运行时通过webhook的技术来执行策略。相比于opa &amp; gatekeeper，更加k8s化，但却没有编程语言的灵活性。目前该项目为CNCF的孵化项目。</p>
<h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><h2 id="1-进击的Kubernetes调度系统"><a href="#1-进击的Kubernetes调度系统" class="headerlink" title="1. 进击的Kubernetes调度系统"></a>1. <a href="https://developer.aliyun.com/article/766273">进击的Kubernetes调度系统</a></h2><p>该系列一共三篇文档，分别讲解了如下内容：</p>
<ul>
<li><a href="https://developer.aliyun.com/article/766273">第一篇</a>：k8s 1.16版本引入的Scheduling Framework</li>
<li><a href="https://developer.aliyun.com/article/766275">第二篇</a>：阿里云ACK服务基于Scheduling Framework实现的Gang scheduling</li>
<li><a href="https://developer.aliyun.com/article/770336">第三篇</a>：阿里云ACK服务基于Scheduling Framework实现的支持批任务的Binpack Scheduling</li>
</ul>
<h2 id="2-中国的云计算革命尚未开始"><a href="#2-中国的云计算革命尚未开始" class="headerlink" title="2. 中国的云计算革命尚未开始"></a>2. <a href="https://mp.weixin.qq.com/s/TXB5lkRCW6MTUbEkby5R-w">中国的云计算革命尚未开始</a></h2><p>作者通过工业革命时代的电气化道路做类似，认为当前云计算的阶段仍然比较初级，并且首先要解决的是人的问题，而不是技术本身。</p>
]]></content>
  </entry>
  <entry>
    <title>技术分享第16期</title>
    <url>/post/knowledge-share-16/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/header-16.jpg"></p>
<p>题图为望京傍晚的天气，夕阳尽情散发着落山前的最后余光，层次分明的云朵映射在建筑物的上熠熠生辉。上班族结束了一天紧张的工作，朝着地铁站的方向奔向自己的家，这才是城市生活该有的模样。不过可惜的是，对于很多打工族而言，一天的工作还远未结束，晚饭后仍要坐在灯火通明的写字楼内或为生活或为梦想挥霍着自己的时光。</p>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><h2 id="kaniko"><a href="#kaniko" class="headerlink" title="kaniko"></a><a href="https://github.com/GoogleContainerTools/kaniko">kaniko</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/kaniko.png"></p>
<p>Google开源的一款可以在容器内部通过Dockerfile构建docker镜像的工具。</p>
<p>我们知道<code>docker build</code>命令可以根据Dockerfile构建出docker镜像，但该操作实际上是由docker daemon进程完成。如果<code>docker build</code>命令在docker容器中执行，由于容器中并没有docker daemon进程，因此直接执行<code>docker build</code>肯定会失败。</p>
<p>kaniko则重新实现了Dockerfile构建镜像的功能，使得构建镜像不再依赖docker daemon。随着gitops的技术普及，CI工具也正逐渐on k8s部署，kaniko正好可以在k8s的环境中根据Dockerfile完成镜像的打包过程，并将镜像推送到镜像仓库中。</p>
<h2 id="arc42"><a href="#arc42" class="headerlink" title="arc42"></a><a href="https://arc42.org/overview">arc42</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/arc42-overview-V8.png"></p>
<p>技术人员在写架构文档的时候，遇到最多的问题是该如何组织技术文档的结构，arc42 提供了架构文档的模板，将架构文档分为了 12 个章节，每个章节又包含了多个子章节，用来帮助技术人员更好的编写架构文档。</p>
<p>相关链接：<a href="https://topic.atatech.org/articles/205083?spm=ata.21736010.0.0.18c23b50NAifwr#tF1lZkHm">https://topic.atatech.org/articles/205083?spm=ata.21736010.0.0.18c23b50NAifwr#tF1lZkHm</a></p>
<h2 id="Carina"><a href="#Carina" class="headerlink" title="Carina"></a><a href="https://github.com/carina-io/carina/blob/main/README_zh.md">Carina</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/carina.png"></p>
<p>国内云厂商博云发起的一款基于 Kubernetes CSI 标准实现的存储插件，用来管理本地的存储资源，支持本地磁盘的整盘或者LVM方案来管理存储。同时，还包含了Raid管理、磁盘限速、容灾转移等高级特性。</p>
<p>相关链接：<a href="https://mp.weixin.qq.com/s/-435K5O780NS2gkuLvSr5g">一篇看懂 Carina 全貌</a></p>
<h2 id="kube-capacity"><a href="#kube-capacity" class="headerlink" title="kube-capacity"></a><a href="https://github.com/robscott/kube-capacity">kube-capacity</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/kube-capacity.png"></p>
<p>k8s的命令行工具kubectl用来查看集群的整体资源情况往往操作会比较复杂，可能需要多条命令配合在一起才能拿得到想要的结果。kube-capacity命令行工具用来快速查看集群中的资源使用情况，包括node、pod维度。</p>
<p>相关链接：<a href="https://able8.medium.com/check-kubernetes-resource-reqeusts-limits-and-utilization-with-kube-capacity-cli-b00bf2f4acc9">Check Kubernetes Resource Requests, Limits, and Utilization with Kube-capacity CLI</a></p>
<h2 id="Kubeprober"><a href="#Kubeprober" class="headerlink" title="Kubeprober"></a><a href="https://k.erda.cloud/">Kubeprober</a></h2><p>在k8s集群运维的过程中，诊断能力非常重要，可用来快速的定位发现问题。Kubeprober为一款定位为k8s多集群的诊断框架，提供了非常好的扩展性来接入诊断项，诊断结果可以通过grafana来统一展示。</p>
<p>社区里类似的解决方案还有Kubehealthy和Kubeeye。</p>
<p>相关链接：<a href="https://mp.weixin.qq.com/s/Wte75OfQ7Ihzlm4th-pNYA">用更云原生的方式做诊断｜大规模 K8s 集群诊断利器深度解析</a></p>
<h2 id="Open-Policy-Agent"><a href="#Open-Policy-Agent" class="headerlink" title="Open Policy Agent"></a><a href="https://www.openpolicyagent.org/">Open Policy Agent</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/opa.png"></p>
<p>OPA为一款开源的基于Rego语言的通用策略引擎，CNCF的毕业项目，可以用来实现一些基于策略的安全防护。比如在k8s中，要求pod的镜像必须为某个特定的registry，用户可以编写策略，一旦pod创建，OPA的gatekeeper组件通过webhook的方式来执行策略校验，一旦校验失败从而会导致pod创建失败。</p>
<p>比如 <a href="https://help.aliyun.com/document_detail/180803.html?spm=ata.21736010.0.0.3d7e50fddLMBB9">阿里云的ACK的gatekeeper</a> 就是基于OPA的实现。</p>
<h2 id="docker-squash"><a href="#docker-squash" class="headerlink" title="docker-squash"></a><a href="https://github.com/goldmann/docker-squash">docker-squash</a></h2><p>docker-squash为一款docker镜像压缩工具。在使用Dockerfile来构建镜像时，会产生很多的docker镜像层，当Dockerfile中的命令过多时，会产生大量的docker镜像层，从而导致docker镜像过大。该工具可以将镜像进行按照层合并压缩，从而减小镜像的体积。</p>
<h2 id="FlowUs"><a href="#FlowUs" class="headerlink" title="FlowUs"></a><a href="https://flowus.cn/">FlowUs</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/flowus.jpg"></p>
<p>FlowUs为国内研发的一款在线编辑器，支持文档、表格和网盘功能，该软件可以实现笔记、项目管理、共享文件等功能，跟蚂蚁集团的产品《<a href="https://www.yuque.com/">语雀</a>》功能比较类似。但相比语雀做的好的地方在于，FlowUs通过”块编辑器“的方式，在FlowUs看来所有的文档形式都是”块“，作者可以在文档中随意放置各种类型的”块“，在同一个文档中即可以有功能完善的表格，也可以有网盘。而语雀要实现一个相对完整的表格，需要新建一种表格类型的文档，类似于Word和Excel。</p>
<h2 id="k8tz"><a href="#k8tz" class="headerlink" title="k8tz"></a><a href="https://github.com/k8tz/k8tz">k8tz</a></h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/k8tz.png"></p>
<p>k8s中的pod默认的时区跟pod的镜像有关，跟pod宿主机所在的时区没有关系。很多情况下，用户都期望pod里看到的时区能够跟宿主机的保持一致。用户的一种实现方式是将宿主机的时区文件挂载到pod中，但需要修改pod的yaml文件。本工具可以通过webhook的方式自动化将宿主机的时区文件挂载到pod中。</p>
<h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><ol>
<li><a href="https://mp.weixin.qq.com/s/4ufpUSq2Qn_QV5vIJcPgqg">中美云巨头歧路，中国云未来增长点在哪？</a></li>
</ol>
<p>文章结合全球的云计算行业，对国内的云计算行业做了非常透彻的分析。”全球云，看中美；中美云，看六大云“，推荐阅读。</p>
<ol start="2">
<li><a href="https://mp.weixin.qq.com/s/F0KoDD9er7MNKYo-5POfsA">程序员必备的思维能力：结构化思维</a></li>
</ol>
<p>结构化思维不仅对于程序员，对于职场中的很多职业都非常重要，无论是沟通、汇报、晋升，还是写代码结构化思维都非常重要。本文深度剖析了金字塔原理以及如何应用，非常值得一读。文章的作者将公众号的文章整理为了《程序员底层思维》一书，推荐大家阅读。</p>
<ol start="3">
<li><a href="https://github.com/ruanyf/document-style-guide">中文技术文档的写作规范</a></li>
</ol>
<p>阮一峰老师的中文技术文档写作规范，写技术文档的同学可以参考。</p>
<h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><ol>
<li><a href="https://book.douban.com/subject/35794819/">《程序员的底层思维》</a></li>
</ol>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/knowledge/dicengsiwei.jpg"></p>
<p>通过书名中的“程序员”来看有点初级，但实际上书中的内容适合所有软件行业的从业者，甚至同样适合于其他行业的从业者，因为底层思维本来就是共性的东西，万变不离其宗。作者曾在阿里巴巴有过很长一段工作经历，书中结合着工作中的实践经验介绍了16种思维能力，讲解浅显易懂，部分内容上升到了哲学的角度来讲解。</p>
<p>作为软件行业从业者的我，实际上书中的大部分思维能力在工作中都有应用，但却没有形成理论来总结。阅读本书，有助于对工作的内容进行总结，找到工作的理论基础。另一方面，有了书中的理论总结，也可以更好的指导工作。</p>
]]></content>
  </entry>
  <entry>
    <title>知识分享第2期</title>
    <url>/post/knowledge-share-2/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/lingshan.jpeg" alt="北京灵山"></p>
<p>题图为北京灵山主峰，海拔2303米，北京最高峰。登上主峰的时候，恰巧一头牛就在山顶悠闲，拍照的时候，牛哥把我带上去的枣、葡萄、花生米全部吃光了，甚至连橘子皮都没剩下，吃完后牛哥又悠闲的去吃草了，让我见识了啥叫吃葡萄不吐葡萄皮。</p>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><ol>
<li>《Kubernetes权威指南 企业级容器云实战》</li>
</ol>
<p>kubernetes的书籍并不多，该书八月份刚初版，内容较新，并不是一本kubernetes的入门书籍，而是讲解kubernetes在企业落地为PASS平台时需要做的工作，建议对kubernetes有一定了解后再看。</p>
<p>书的内容为HPE的多名工程师拼凑而成，有些部分的内容明显是没有经过实践验证的理论派想法，但总体来看值得一读。</p>
<p>书中提到了很多kubernetes较新版本才有的特性、微服务、service mesh、lstio，对于补充自己已经掌握的知识点有一定帮助。</p>
<p>书的后半部分反而显的干货少了非常多，我仅草草的过了一遍。</p>
<ol start="2">
<li><a href="https://chai2010.gitbooks.io/advanced-go-programming-book/content/">《Go语言高级编程》</a></li>
</ol>
<p>Golang中相对进阶的中文教程，我还没来得及看。</p>
<ol start="3">
<li><a href="https://www.vldb.org/pvldb/vol8/p1816-teller.pdf">Gorilla</a></li>
</ol>
<p>facebook发表的分布式的时序数据库论文，如果英文看起来吃力，可以看一下小米运维公众号中的<a href="https://mp.weixin.qq.com/s/-1jpuCm20LSTrVU7nTw5_Q">翻译版本</a>。facebook并未提供开源的实现，但在github上能找到一些开源的实现。</p>
<ol start="4">
<li>《深入剖析Kubernetes》</li>
</ol>
<p>极客时间app的专栏，本来购买之前没有报特别大的预期，但读完头几篇文章后被作者的文字功底折服，将PASS、容器的来龙去脉、docker的发展讲解的很到位，超出了我的预期。期待后面更新的专栏能够保持搞水准。</p>
<ol start="5">
<li><a href="https://tonydeng.github.io/sdn-handbook">SDN手册</a></li>
</ol>
<p>一本介绍SDN相关知识的开源电子书。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ol>
<li><a href="https://github.com/m3db">M3DB</a></li>
</ol>
<p>监控领域还是比较缺少特别好用的分布式时间序列存储数据库，性能特别优异的数据库往往都是单机版的，缺少高可用的方案，比如rrdtool、influxdb、graphite等。OpenTSDB、KairosDB、Druid等虽为分布式的时序数据库，但使用或者运维起来总有各种不方便的地方。uber开源的m3在分布式时序数据库领域又多了一个方案，并可作为prometheus的远程存储。</p>
<ol start="2">
<li><a href="https://cilium.io/">cilium</a></li>
</ol>
<p>使用BPF(Berkeley Packet Filter)和XDP(eXpress Data Path)内核技术来提供网络安全控制的高性能开源网络方案。</p>
<ol start="3">
<li><a href="https://github.com/kubeless/kubeless">kubeless</a></li>
</ol>
<p>kubernetes平台上的Serverless项目，Faas（功能即服务）一定是云计算发展的一个趋势。目前CNCF中还没有Serverless项目，期待CNCF下能够孵化一个Serverless项目。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol>
<li>vagrant</li>
</ol>
<p>还在使用virturalbox的你，是时候使用vagrant了。vagrant作为对虚拟机的管理，虽然引入了一些概念带来了更大的复杂性。但同时功能上也更强大，比如对box的管理，可以将box理解为docker image，便于将虚拟机的环境在不同的主机上分发。</p>
<h2 id="公众账号推荐"><a href="#公众账号推荐" class="headerlink" title="公众账号推荐"></a>公众账号推荐</h2><ol>
<li>小米运维</li>
</ol>
<p>开通时间不算特别长，但文章的质量不错，都是比较接地气的干货，看得出确实是在工作中遇到的问题或者是总结经验，值的一读。</p>
<p><img src="https://open.weixin.qq.com/qr/code?username=MI-SRE"></p>
<ol start="2">
<li>开柒</li>
</ol>
<p>曾经公众号的名字为开八，江湖人称八姐，忘记为何更改为开柒了，曾经的搜狐记者。总能非常及时的爆料很多互联网的内幕，消息来源往往非常准确，可见八姐在圈内的人脉非同一般。</p>
<p><img src="https://open.weixin.qq.com/qr/code?username=hlkaiba"></p>
<ol start="3">
<li>毕导</li>
</ol>
<p>打发时间非常好的公众号，用理科男的思维方式进行恶搞，是不是拿出冗长的数学公式来证明日常生活中的小尝试，语言诙谐幽默，绝对是公众号中的一股清流。可惜每篇文章都很长，我没有太多时间把每一篇文章都看一遍。</p>
<p><img src="https://open.weixin.qq.com/qr/code?username=bxt_thu"></p>
]]></content>
      <tags>
        <tag>知识分享</tag>
      </tags>
  </entry>
  <entry>
    <title>知识分享第3期</title>
    <url>/post/knowledge-share-3/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/yudushan.jpeg" alt="玉渡山"></p>
<p>题图为北京玉渡山风景区中的盘山公路，旁边有个观景台，在观景台上可以鸟瞰官厅水库。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>1.<a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/resource-director-technology.html">Intel RDT</a></p>
<p>Intel RDT(Resource Director Technology)资源调配技术框架，包括高速缓存监控技术（CMT）、高速缓存分配技术（CAT）、内存带宽监控（MBM）和代码和数据优先级（CDP），容器技术的runc项目中使用到了CAT技术来解决cgroup下的CPU的三级缓存隔离性问题。</p>
<p>在linux 4.10以上内核中通过资源控制文件系统的方式来提供给用户接口，类似cgroup的管理方式。</p>
<p>感兴趣的可以了解下<a href="https://github.com/opencontainers/runc/blob/master/libcontainer/intelrdt/intelrdt.go">runc项目源码</a>。</p>
<p>2.<a href="https://github.com/improbable-eng/thanos">Thanos</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/Thanos-logo_fullmedium.png" alt="Thanos"></p>
<p>Prometheus作为Google内部监控系统Borgmon的开源实现版本，存在高可用和历史数据存储两个致命的缺点，Thanos利用Sidecar等技术来解决Prometheus的缺点。</p>
<p>3.<a href="https://github.com/nicolaka/netshoot">netshoot</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                    dP            dP                           dP</span><br><span class="line">                    88            88                           88</span><br><span class="line">88d888b. .d8888b. d8888P .d8888b. 88d888b. .d8888b. .d8888b. d8888P</span><br><span class="line">88&#x27;  `88 88ooood8   88   Y8ooooo. 88&#x27;  `88 88&#x27;  `88 88&#x27;  `88   88</span><br><span class="line">88    88 88.  ...   88         88 88    88 88.  .88 88.  .88   88</span><br><span class="line">dP    dP `88888P&#x27;   dP   `88888P&#x27; dP    dP `88888P&#x27; `88888P&#x27;   dP</span><br></pre></td></tr></table></figure>

<p>用于排查docker网络问题的工具，以容器的方式运行在跟要排查问题的容器同一个网络命名空间中，该容器中已经具备了较为丰富的网络命令行工具，用于排查容器中的网络问题。</p>
<p>4.<a href="https://github.com/sharkdp/bat">bat</a></p>
<p>用来替代cat的命令行工具，支持语法高亮、自动分页。mac下可直接使用<code>brew install bat</code>来安装。</p>
<p><img src="https://camo.githubusercontent.com/9d3d89364f2cc83ace8f29646a6236bc15ea1da0/68747470733a2f2f696d6775722e636f6d2f724773646e44652e706e67" alt="image"></p>
<p>5.<a href="http://asciiflow.com/">asciiflow</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/asciiflow.png" alt="asciiflow"></p>
<p>写博客的往往都比较痛恨图片的存储问题，尤其是使用markdown语法写作的，图片往往需要图床来存储，常常跟文章不在一起存储。asciiflow是较为小众的一款ascii图形工具，可以应付较为简单的图形绘制，直接以文字的形式呈现简单图形，省去了存储图片的繁琐。</p>
<p>6.<a href="https://www.processon.com/">processon</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/processon.gif" alt="processon"></p>
<p>免费的在线图行绘制协作工具，支持流程图、思维导图等多种图形，有类似visio的使用体验，同时是web版的，支持多人协作。我目前在使用，不过免费版有使用限制。</p>
<h2 id="精彩文章"><a href="#精彩文章" class="headerlink" title="精彩文章"></a>精彩文章</h2><p>1.<a href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&mid=2247486254&idx=1&sn=c78b509e84a64cb921280a5e1e111bb7&chksm=eac52a07ddb2a311c2a21a3decf26c8ab5d9b0d6c9ff8701a8db3e369d76fe9c6045e34808f1&mpshare=1&scene=1&srcid=0915GAFGR2dEjnoRI1ngfo8f%23rd">手把手教你打造高效的 Kubernetes 命令行终端
</a></p>
<p>文中汇总了各种可以取代kubernetes的命令行kubectl的工具，以便提供更方便的操作，比如更完善的自动补全。</p>
<p>2.<a href="http://pierrchen.blogspot.com/2018/08/understand-container-index.html">Understand Container - Index Page</a></p>
<p>学习容器的cgroup和namespace的系列文章。</p>
<p>3.<a href="https://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&mid=2649698847&idx=1&sn=b1ffce56c1397b3f60f8c776aff0ae85&chksm=88930d7cbfe4846a14fe50e9824e8a81abce19097717b1fbd3834101b21872f5ccdb6aab9366&mpshare=1&scene=1&srcid=0919nVdgzYLK9dtdRUsf2ifa%23rd">gVisor是什么？可以解决什么问题？</a></p>
<p>docker容器技术基于cgroup和namespace来实现，但系统调用仍是调用宿主机的系统调用，比如在其中一个容器中通过系统调用修改了当前系统时间，在其他容器中看到的时间也已经修改过了，这显然不是符合期望的，通常可以通过Seccomp来限制容器中的系统调用。</p>
<p>gVisor为Google开源的容器Runtime，通过pstrace技术来截获系统调用，从而保证系统的安全。目前还不成熟，单就凭Google的开源项目，该项目还是非常值得关注的。</p>
<p>4.<a href="https://docs.docker.com/develop/develop-images/multistage-build/">Use multi-stage builds</a></p>
<p>Dockerfile的多阶段构建技术，对于解决编译型语言的发布非常有帮助，可以在其中一个image中编译源码，另外一个image用于将编译完成后的二进制文件复制过来后打包成单独的线上运行镜像。而这两部操作可以合并到一个Dockerfile中来完成。</p>
<p>5.<a href="https://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&mid=2649698903&idx=1&sn=6392175b0cf62825e4981b08acc85fda&chksm=88930d34bfe48422ee85d50037489868e2432b6aa4c7bef6dc46b8eaa3852f91bd5da14c5da1&mpshare=1&scene=1&srcid=09255FcTm8fVdN6r5OqWkTvK%23rd">唯品会Noah云平台实现内幕披露</a></p>
<p>唯品会内部云平台的实践，涉及到大量的干货，值的花时间一读。</p>
<h2 id="App推荐"><a href="#App推荐" class="headerlink" title="App推荐"></a>App推荐</h2><p>1.Nike Training</p>
<p>健身类app我用过keep、火辣健身、FitTime（以收费课程居多），偶然间在AppStore上看到了Nike Training，如果厌倦了国内的健身类app，不防尝试一下。</p>
<h2 id="新奇"><a href="#新奇" class="headerlink" title="新奇"></a>新奇</h2><p>1.手机QQ扫一扫</p>
<p>用手机QQ扫一扫100元人民币正面，可以出现浮动的凤凰图案，并会跳转到人民币鉴别真伪的视频页面，视频效果确实不错，忍不住会多扫描几遍。</p>
<p>2.kubeadm</p>
<p>kubernetes的组件非常多，部署起来非常复杂，因此社区就推出了kubeadm工具来简化集群的部署，将除了kubelet外的其他组件都部署在容器中。令人惊奇的是，kubeadm几乎完全是一个芬兰高中生Lucas KaIdstrom的作品，是他在17岁时利用业余时间完成的一个社区项目。</p>
]]></content>
  </entry>
  <entry>
    <title>知识分享第4期</title>
    <url>/post/knowledge-share-4/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/laiwushi.jpeg"></p>
<p>今年以来，网络上一直在传言济南市要吞并莱芜市的消息，最近几天尤甚。市民们纷纷去市政府门前拍照留念，纪念莱芜市的最后一天，虽然到今天为止传言还未变成现实，但应该是迟早要到来的。</p>
<p>有趣的是，莱芜市是1993才从泰安市中独立出来，很多人都感慨道：出生是泰安人，长大是莱芜人，明天变成济南人。地理位置上而言，莱芜跟济南搭界，而且莱芜市是山东省17地市中面积最小的一个。</p>
<p>山东的发展策略一直是各地市全面发展，济南市作为省会，在中国城市中的存在感确实不够强，吞并莱芜后也一样不会变强太多，一个地市要想变强，要从多方面找原因。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>1.<a href="https://github.com/ContainerSolutions/k8s-deployment-strategies">k8s-deployment-strategies</a></p>
<p>kubernetes内置的deployment和statefulset对象往往很难满足企业的部署需求，比如蓝绿发布、金丝雀发布等，Github上的项目介绍了其他部署方式在kubernetes上的具体实现方式。</p>
<p>2.<a href="https://letsencrypt.org/">Let’s Encrypt</a></p>
<p>https越来越普及，通常CA颁发的证书都是收费的，Let’s Encrypt是一家非盈利的CA机构，为广大的小型站点和博客博主提供了非常大的帮助。Github pages中也是采用了Let’s Encrypt来提供自定义域名的https服务支持。</p>
<p>3.<a href="https://openmetrics.io/">openmetrics</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/openmetrics.png"></p>
<p>监控领域存在多款开源软件，比如premetheus、influxdb、opentsdb等，每种软件的写入数据格式都不一致，该开源项目旨在定义监控数据的标准格式，目前支持premetheus的文本格式和protobuf两种格式。该项目目前还在起步阶段，已经加入CNCF，期待后续一统行业标准。</p>
<p>4.<a href="https://github.com/nats-io">NATS</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/nats.png"></p>
<p>Go语言实现的消息队列，目前已经加入CNCF。</p>
<p>5.<a href="https://sqlfum.pt/">sequel fumpt</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/sqlfum.png"></p>
<p>sql的在线格式化工具。</p>
<p>6.<a href="https://github.com/linux-audit">The Linux Audit Project</a></p>
<p>Linux下的日志审计工具，CentOS系统下默认安装，可以通过<code>man auditd</code>看到该工具的说明。</p>
<p>7.<a href="https://github.com/Qihoo360/kafkabridge">kafkabridge</a></p>
<p>360开源的kafka客户端库的封装，只需调用极少量的接口，就可完成消息的生产和消费。支持多种语言：c++&#x2F;c、php、python、golang。</p>
<h2 id="精彩文章"><a href="#精彩文章" class="headerlink" title="精彩文章"></a>精彩文章</h2><p>1.Keyhole,Google Maps发展史</p>
<p>文章为微信公众号<em>余晟以为</em>的系列文章，大部分素材来源于<a href="https://book.douban.com/subject/30243035/">《Never Lost Again》</a>一书，该书作者为Bill Kilday，Keyhole和Google Maps团队的核心成员。文章介绍了Google Maps的前身Keyhole的创业史，后被Google收购后，又推出了基于web的Google Maps产品，继而开发出了Google Earth产品。即使在Google内部，也存在团队之间的孤立及不信任问题。</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/P6IVAAux9N3tNb0QNp4XeQ">Keyhole，Google Maps前传</a></li>
<li><a href="https://mp.weixin.qq.com/s/-F4XO-NyOqn2wSXlM4CSyA">Google Maps，Keyhole后传</a></li>
<li><a href="https://mp.weixin.qq.com/s/X-XZcSTsKd6Pzv5RzjrFyA">从Google Maps到Google Earth</a></li>
</ul>
<p>2.<a href="https://mp.weixin.qq.com/s?__biz=MzU4MjQ0MTU4Ng==&mid=2247483917&idx=1&sn=e272bd1d91f148f879b602d6640efb5d&chksm=fdb90d10cace840608fa21e090e5dfbc5c95894151998c4998b13e13b31b423088b61bb4873d&mpshare=1&scene=1&srcid=1011azypmKUvqeurakroNuxT%23rd">Kubernetes 调度器介绍</a></p>
<p>文章对kubernetes的kube-scheduler的整体流程介绍的比较清晰。</p>
<p>3.<a href="https://iprice.sg/trends/insights/history-jack-ma-alibaba-18-founders/">A Brief History of Alibaba Founders</a></p>
<p>阿里巴巴的18罗汉介绍。</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>1.电传打字机设备(Teletype)</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/tty.png" alt="tty"></p>
<p>早期的计算机设备比较笨重，计算机放在单独的一个房间中，操作计算机的人坐在另外一个房间中，通过终端机设备来操作计算机。</p>
<p>早期的终端设备为电传打字机(Teletype)，该设备价格比较低廉，通过键盘输入，并将输出内容打印出来。图中的设备为ASR-33，在YouTube上可以可以看到<a href="https://www.youtube.com/watch?v=MikoF6KZjm0">视频</a>。</p>
<p>有意思的是，实际上Teletype的出现要早于计算机，原本用于在电报线路上发送电报，但是后来计算机出现后直接拿来作为计算机的终端设备。</p>
<p>在linux操作系统中设计了tty子系统用于支持tty设备，并将具体的硬件设备放到&#x2F;dev&#x2F;tty*目录下，这里的tty设备即Teletype。不过后来随着其他终端设备的引入，tty这个名字仍旧保留了下来，tty目前已基本代表终端的总称。</p>
]]></content>
  </entry>
  <entry>
    <title>知识分享第5期</title>
    <url>/post/knowledge-share-5/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/tanzhesi.jpeg"></p>
<p>题图为北京城西部的潭柘寺，始建于西晋年间，有“先有潭柘寺，后有幽州城”的说法。</p>
<p>明朝燕王朱棣听取了重臣姚广孝的建议后，起兵“靖难”，并成功夺取皇位。朱棣继皇帝位后，姚广孝辞官到京西的潭柘寺隐居修行。据说当年修建北京城时，设计师就是姚广孝，他从潭柘寺的建筑和布局中获得了不少灵感。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>1.<a href="https://github.com/virtual-kubelet/virtual-kubelet">virtual-kubelet</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/virtual-kubelet.svg"></p>
<p>很多公有云厂商都提供了弹性容器服务实例，比如阿里云的ECI（Elastic Container Instance）、AWS Fargate、Azure Container Instances等，但这些平台都提供了私有的API，与kubernetes的API不兼容。该项目将公有云厂商的的容器组虚拟为kubernetes集群中的一个超级node，以便支持kubernetes的API，与此同时失去了很多kubernetes的特性。</p>
<p>2.<a href="https://katacontainers.io/">Kata Containers</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/katacontainers.jpg"></p>
<p>容器在部署服务方面有得天独厚的优势，但受限于内核特性，在隔离性和安全性方面仍然较弱。虚拟机（VM）在隔离性和安全性方面都比较好，但启动速度和占用资源方面却不如容器。Kata Containers项目作为轻量级的虚拟机，但提供了快速的启动速度。同时支持Docker容器的OCI标准和kubernetes的CRI。目前华为公有云已经将此技术用于生产环境中。</p>
<p>3.<a href="https://github.com/knative/">Knative</a></p>
<p>在今年的Google Cloud Next大会上，Google发布了Knative, 这是由Google、Pivotal、Redhat和IBM等云厂商共同推出的Serverless开源工具组件，它与Istio，Kubernetes一起，形成了开源Serverless服务的三驾马车。</p>
<p>4.<a href="https://github.com/XiaoMi/naftis">naftis</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/naftis.png"></p>
<p>小米信息部武汉研发中心开源的istio的dashboard。</p>
<p>5.<a href="https://github.com/pulumi/kubespy">kubespy</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/kubespy.gif"></p>
<p>用来查看kubernetes中资源实时变化的命令行工具。</p>
<p>6.<a href="http://md.aclickall.com/">Md2All</a></p>
<p>如果你已经习惯了markdown写作，在微信公账号发文时，可以使用该工具渲染后，将文章复制到微信公众号后台。</p>
<h2 id="精彩文章"><a href="#精彩文章" class="headerlink" title="精彩文章"></a>精彩文章</h2><p>1.<a href="https://mp.weixin.qq.com/s?__biz=MzU0NDEwMTc1MA==&mid=2247490379&idx=1&sn=17857e09e980b41bc188e592422c3459&chksm=fb001f52cc7796444cb18e5a483d3ad26e44fc70d543fa03fb2f56ae74d4db7d65e8d5df7b4e&mpshare=1&scene=1&srcid=1016QBaRRz9JrroPgKJ8xXBp%23rd">阿里云的这群疯子</a></p>
<p>从记者的视角来了解阿里云的历史。</p>
<p>2.<a href="http://www.yinwang.org/blog-cn/2018/10/14/update">王垠最近博客-更新一下</a></p>
<p>曾经以天才自居桀骜不驯傲视一切的垠神，突然变得温顺了许多，开始意识到自己的缺点，开始享受生活。</p>
<p>3.<a href="https://mp.weixin.qq.com/s/9vYnko3l8asVr2Mly5NjbQ">为何“秀恩爱，死得快”？我是认真的</a></p>
<p>用量子物理学的知识来解释为啥“秀恩爱，死得快”。</p>
<p>4.<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665515178&idx=1&sn=52cb7a6363a93a50fb5a6608fe0006a5&chksm=80d670e9b7a1f9ff3c99e444ad383905ea26793673ed6d220e889cfce66c833e4f48000e4525&mpshare=1&scene=1&srcid=1019RCPQVkN8CT6NF0xNe8Y5%23rd">CTO、技术总监、首席架构师的区别</a></p>
<p>5.<a href="https://mp.weixin.qq.com/s?__biz=MzI5OTM3MjMyNA==&mid=2247485701&idx=1&sn=ff6e2e6d3090555339bd93b111ae3d20&chksm=ec96d34edbe15a58a0aa8252defd77c378565e88bcf2d5f9a522043ecfc8302f6133f185f79b&mpshare=1&scene=1&srcid=1019jffSXvtK3BUofnCzPx9n%23rd">面对云厂商插管吸血，MongoDB使出绝杀</a></p>
<p>半年后看下MongoDB的修改开源协议的做法在国内奏效否。</p>
<p>6.<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ0MTU4Ng==&mid=2247483928&idx=1&sn=157497314c4c2a2f5ad93f4a0d4b20b7&chksm=fdb90d05cace8413f9e2470f6f8eacec4479031e7acc8acb63ae99c9b57a5e4d9a15c3d37db8&mpshare=1&scene=1&srcid=1024ksuGmq7gQIMXBcJPNFcF%23rd">终于明白了 K8S 亲和性调度</a></p>
<p>通过该文章，已经差不多可以了解kubernetes调度的亲和性、反亲和性、taint和toleration机制了。</p>
<p>7.<a href="http://mp.weixin.qq.com/s?__biz=MzU1OTAzNzc5MQ==&mid=2247486496&idx=1&sn=0214f3d62b7d65350cd58ea6b4173184&chksm=fc1c2010cb6ba906a94f851184a15f462d16836c3ab5ab362ca5faeb40726f056a40261ccba6&mpshare=1&scene=1&srcid=1022SujMyNtcwnqLaT3fI3aM%23rd">微软资深工程师详解 K8S 容器运行时</a></p>
<h2 id="图书"><a href="#图书" class="headerlink" title="图书"></a>图书</h2><p>1.<a href="http://product.china-pub.com/8053114#ml">鸟哥的Linux私房菜：基础学习篇（第四版）</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/niaoge_linux.png"></p>
<p>鸟哥的linux私房菜终于出新版了，最新版本是基于CentOS7的。</p>
<h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><p>1.嗝嗝老师</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/hichki.jpg"></p>
<p>电影讲述了印度贫民窟中的孩子在学校上学总是遭受歧视不爱学习各种调皮捣蛋，在一位新老师来了后，将学生们带向正轨的故事。印度电影总能将平凡的电影演绎的很魔性，单就这些故事就已经足够了。偏偏这位老师还是抽动秽语综合征患者，在受到老师和学生们的双重歧视下，给故事情节增加了许多感人和励志色彩。</p>
<p>强迫症患者谨慎观看，看完电影后，总感觉得抽搐两下才舒服。</p>
<h2 id="精彩句子"><a href="#精彩句子" class="headerlink" title="精彩句子"></a>精彩句子</h2><blockquote>
<p>货币的贬值，是永恒的趋势。明天的物价，一定比今天的贵。<br>你想要赚钱，就一定要把今天的钱，换成明天的物。<br>而且时间越紧凑越好。</p>
</blockquote>
<p>– <a href="https://mp.weixin.qq.com/s?__biz=MzUxMDAwOTE4OQ==&mid=2247483881&idx=2&sn=1226590dd47dd171e833fee97e43d30d&chksm=f908cbe3ce7f42f57d07e6c060a7f607b2c11d7f0542a3215800e1610b65c5f1ad0ddfded56d&mpshare=1&scene=1&srcid=10197m4srqox3aXZOybWcQgm%23rd">八年之后 房价多少？</a></p>
]]></content>
  </entry>
  <entry>
    <title>知识分享第6期</title>
    <url>/post/knowledge-share-6/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/leaves.jpeg"></p>
<p>题图为公司楼下公园的杨树林。时光易逝弹指间，又到一年叶落时。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>1.<a href="https://github.com/hyperhq/runv">runV</a></p>
<p>基于 hypervisor 的 OCI runtime</p>
<p>2.<a href="https://github.com/operator-framework/operator-sdk">operator-sdk</a></p>
<p>operator机制利用CRD机制增强了kubernetes的灵活性，但operator的编写代码很多模式都是固定的，该项目提供了更高层次的抽象。</p>
<p>3.<a href="https://github.com/github/orchestrator">orchestrator</a></p>
<p>用来管理mysql的集群拓扑和故障自动转移的工具。</p>
<p>4.<a href="https://github.com/TarsCloud/Tars">Tars</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/tars.png" alt="https://github.com/TarsCloud/Tars/blob/master/docs/images/tars_jiaohu.png"></p>
<p>腾讯开源的RPC框架，在腾讯内部已经有多年的使用历史，目前支持多种语言。</p>
<p>5.<a href="https://github.com/yzprofile/ngx_http_dyups_module">ngx_http_dyups_module</a></p>
<p>nginx module，可以提供Restful API的形式来动态修改upstream，而不用重新reload nginx。</p>
<p>6.<a href="https://github.com/alibaba/Dragonfly">Dragonfly</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/dragonfly.png" alt="https://github.com/alibaba/Dragonfly/raw/master/docs/images/logo/dragonfly-linear.png"></p>
<p>阿里巴巴开源的基于P2P的容器镜像分发系统。</p>
<p>7.<a href="https://www.sonarqube.org/">SonarQube</a></p>
<p>开源的代码检查和扫描工具，支持多种语言，并提供了友好的web界面用来查看分析结果。</p>
<p>8.<a href="https://www.chromium.org/quic">QUIC</a></p>
<p>QUIC是Google开发的基于UDP的传输层协议，提供了像TCP一样的数据可靠性，但降低了数据的传输延时，并具有灵活的拥塞控制和流量控制。</p>
<p>9.<a href="http://openmessaging.cloud/">OpenMessaging</a></p>
<p>阿里巴巴发起的分布式消息的应用开发标准，目前github上的star数还较少。</p>
<p>10.<a href="https://github.com/jpetazzo/nsenter">nsenter</a></p>
<p>nsenter是一个命令行工具，用来进入到进程的linux namespace中。</p>
<p>docker提供了exec命令可以进入到容器中，nsenter具有跟docker exec差不多的执行效果，但是更底层，特别是docker daemon进程异常的时候，nsenter的作用就显示出来了，因此可以用于排查线上的docker问题。</p>
<h2 id="精彩文章"><a href="#精彩文章" class="headerlink" title="精彩文章"></a>精彩文章</h2><p>1.<a href="http://mp.weixin.qq.com/s?__biz=MzIxNzYxMTU0OQ==&mid=2247486289&idx=1&sn=36950b6c33abbd0fd34dc04c231a1444&chksm=97f66723a081ee35c294fb332f5a530a29d5d69b39b6b77b128efd1260b2222bba622ec3c013&mpshare=1&scene=1&srcid=1026F66EebJRZ6bqonnBKBVi%23rd">为何程序员永远是高薪行业</a></p>
<p>从记者的视角来了解阿里云的历史。</p>
<p>2.<a href="https://mp.weixin.qq.com/s?__biz=MzIwODAzNTA2NQ==&mid=2651219445&idx=1&sn=2cf373851086355ae4ad26cd741480cf&chksm=8cfb8863bb8c01759b536ce04af5d04d8f149701626caa97e73a4012ba059584d63737cf8a3e&mpshare=1&scene=1&srcid=1029OVgZCxr32GyIFbfqKuEs%23rd">Harbor传奇（1）- Harbor前世</a></p>
<p>3.<a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2651010202&idx=1&sn=742179879a25d526402a5b561b769ed1&chksm=bdbeccc98ac945df391f1b54f06495868a683002ac9fb71a80fc001e10344a991d36019ad1f4&mpshare=1&scene=1&srcid=1031sNSkczy7L8lzRXMgWXlv%23rd">蚂蚁金服 Service Mesh 实践探索</a></p>
<p>4.<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=1&sn=92dcd59d05984eaa036e7fa804fccf20&chksm=bd12a5778a652c61f4a181c1967dbcf120dd16a47f63a5779fbf931b476e6e712e02d7c7e3a3&mpshare=1&scene=1&srcid=1115JtuwzXeezCv5UkmOcrFw%23rd">美团容器平台架构及容器技术实践</a></p>
<p>美团内部的容器平台HULK已经从第一代的自研升级为第二代的基于kubernetes的容器管理平台。由此可以反映出kubernetes在容器管理领域的地位。</p>
<p>5.<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTAzMDEwMA==&mid=2652507564&idx=1&sn=cfedc29419e54987803197d8b975df62&chksm=8023e497b7546d81d4b68778c78cd3cc8fb7d0e746e385119c7b9e332ec599495da3017d0cda&mpshare=1&scene=1&srcid=1111C1S9Vcyb1bDDgLiCVIfS%23rd">Serverless：后端小程序的未来</a></p>
<p>Serverless是未来软件架构的一个演进方向，包括BasS（Backend as a Service，后端即服务）和FaaS（Functions as a Service，函数即服务）两个组成部分。</p>
<p>BaaS包括对象存储、数据库、消息队列等服务，并以API的形式提供应用依赖的后端服务。</p>
<p>FaaS中的运行是通过事件触发的方式，代码执行完成后即运行结束，因此代码必须是无状态的。FaaS平台负责服务的自动扩容，并可做到按照服务的使用资源付费，以节省大量开支。</p>
<p>Serverless给开发人员带来了非常大的便利性，但同时也软件跟云平台绑定特别紧密。</p>
<h2 id="图书"><a href="#图书" class="headerlink" title="图书"></a>图书</h2><p>1.《<a href="https://www.amazon.cn/dp/B07J34BKTL">奈飞文化手册:“硅谷重要文件”的深度解读</a>》</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/netflix_powerful.jpg" alt="https://images-na.ssl-images-amazon.com/images/I/51UmLKXW9%2BL._SX366_BO1,204,203,200_.jpg"></p>
<p>Netflix公司的技术文化一直非常被业界推崇，可以从<a href="https://netflix.github.io/">Netflix OSS</a>已经开源的软件项目，很多的开源项目在社区也有不错的影响力，本书值得每一位技术从业者一读。</p>
<h2 id="精彩句子"><a href="#精彩句子" class="headerlink" title="精彩句子"></a>精彩句子</h2><blockquote>
<p>我们要求大家做出的任何举动，出发点都是以对客户和公司最有利为出发点，而不是试图证明自己正确。</p>
</blockquote>
<p>- 奈飞文化手册:“硅谷重要文件”的深度解读</p>
]]></content>
  </entry>
  <entry>
    <title>知识分享第7期</title>
    <url>/post/knowledge-share-7/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/jinshanling.jpeg"></p>
<p>题图为金山岭长城，明代著名抗倭名将戚继光从南方调任至此修筑，为明长城之精华，</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>1.<a href="https://goaccess.io/">GoAccess</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/goaccess-bright.png" alt="http://rt.goaccess.io/?20180926071813&amp;ref=hpimg"></p>
<p>一款开源的实时分析nginx日志的工具，并拥有一个比较强大的dashboard。</p>
<p>2.<a href="https://github.com/Qihoo360/wayne">Wayne</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/wayne-dashboard-ui.png" alt="https://raw.githubusercontent.com/wiki/Qihoo360/wayne/image/dashboard-ui.png"></p>
<p>360开源的kubernetes的多集群管理平台。</p>
<p>3.<a href="http://www.mackeynote.com/">MacKey</a></p>
<p>一个分享KeyNote模版的网站，每个KeyNote模版都带有动画和图片截图。</p>
<p>4.<a href="https://github.com/hashicorp/nomad">Nomad</a></p>
<p>Hashicorp公司开源的集群调度工具，该公司另一款较为出名的产品为Vagrant。</p>
<p>5.<a href="https://github.com/gliderlabs/registrator">registrator</a></p>
<p>该服务部署在宿主机上，自动将docker的容器注册到服务注册中心中，如consul、etcd等。</p>
<p>6.<a href="https://github.com/Huawei-PaaS/CNI-Genie">CNI-Genie</a></p>
<p>华为开源的容器网络解决方案，CNI（Container Network Interface）仅支持加载一个插件，该插件可以同时一次加载多个网络插件，在容器中可以同时存在多个网络解决方案的ip。</p>
<p>7.<a href="http://manpages.ubuntu.com/manpages/bionic/man1/stress-ng.1.html">stress-ng</a></p>
<p>Linux下有一个命令行的压测测试工具stress，可以用来测试cpu、内存、io等，stress-ng提供了更丰富的选项。</p>
<p>8.<a href="https://github.com/resilience4j/resilience4j">Resilience4j</a></p>
<p>java版的开源熔断工具Hystrix宣布停止开发，并推荐了Resilience4j工具，该工具灵感来自于Hystrix，主要为java 8和函数式编程设计的自动熔断工具。</p>
<p>9.<a href="https://github.com/golang-standards/project-layout">Standard Go Project Layout</a></p>
<p>我刚开始写go的时候，一度被golang的源码目录结构所困惑，这个项目提供了一个标准的goalng目录结构的用法，很多开源项目都是按照这个标准组织的。</p>
<p>10.<a href="https://github.com/wagoodman/dive">dive</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/dive.gif" alt="https://github.com/wagoodman/dive/blob/master/.data/demo.gif"></p>
<p>docker images不是一个单独的文件存储在宿主机上，而是采用分层设计，以便于多个镜像之间复用相同的层数据。dive可以用来分析docker image的每一层的具体组成。</p>
<p>11.<a href="https://www.swoole.com/">Swoole</a></p>
<p>php号称是世界上最好的编程语言之一，但最为人诟病的是其网络模型是同步模型，导致其性能一直上不去。Swoole可以实现类似于Golang中的goroutine同步编程模型来实现异步的功能。</p>
<h2 id="精彩文章"><a href="#精彩文章" class="headerlink" title="精彩文章"></a>精彩文章</h2><p>1.<a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653550448&idx=1&sn=e2ab178782f3fc1a6423f44c5b71afe3&chksm=813a66e8b64deffeec07664c15a315eb570ece4a3415f6ab06b4e9a15e4608dbd9838d5af071&mpshare=1&scene=1&srcid=1204G7pzjRvrQz0iFiDeYUfx%23rd">知乎社区核心业务 Golang 化实践</a></p>
<p>本文记录了知乎内部使用golang来重构python的实践经验，用来解决python编程语言的运行效率低和维护成本高的问题。</p>
<p>2.<a href="https://mp.weixin.qq.com/s?__biz=MzI0NjI4MDg5MQ==&mid=2715292188&idx=1&sn=2b7f26203aa594027550e324460bc901&chksm=cd6d15c8fa1a9cde757868fd34c8336433c4877d3e7689ed0a2bd90eb1ef6271bda97aa3bb03&mpshare=1&scene=1&srcid=12045vIwpmKLu97HvFOssitt%23rd">如何在Docker内部使用gdb调试器</a></p>
<p>本文记录了一些docker关于权限相关的技术实现。</p>
<p>3.<a href="https://mp.weixin.qq.com/s?__biz=MzA3NDI0ODMzMw==&mid=2651302666&idx=1&sn=1ada632809e5c2a3895214a3590e5a0c&chksm=84f1b2e8b3863bfea2dfa0868e930ed3cf2b3f0860aeec5b8bbc2f6e0e73a20c7670b3bfc93f&mpshare=1&scene=1&srcid=1206BiRCjxkExnHMuFyQX0JM%23rd">ofo剧中人：我不愿谢幕</a></p>
<p>以记者的角度记录了OFO的发家、辉煌、衰败，曾有过彷徨与迷茫，曾有过野性与嚣张，但最终还是要倒在资本面前。</p>
<p>大家都在吐槽OFO押金退不了的事情，看到一个评论中的不错的点子，可以在OFO的退押金页面增加广告位，毕竟流量就是金钱，退押金页面的流量也是流量，反正押金也退不了，不如借此来一波，至少比在公众号中卖蜂蜜要好的多。</p>
<blockquote>
<p>一个生动的细节是，有黑摩的司机不爽共享单车影响他们生意，砸ofo的车。ofo后期转化了一批相当数量的司机当修车师傅，化干戈为玉帛。</p>
</blockquote>
<p>上述操作还是非常犀利的，说白了还是利益在作怪。</p>
]]></content>
  </entry>
  <entry>
    <title>知识分享第8期</title>
    <url>/post/knowledge-share-8/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/railway-museum.jpeg"></p>
<p>题图为中国铁道博物馆东郊馆中的毛泽东号列车</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>1.<a href="https://www.hawkular.org/">Hawkular</a></p>
<p>Hawkular为RedHat开源的监控解决方案，实现语言为java，监控数据的底层存储引擎使用Cassandra，包含了告警功能。目前Github上的Star还较少。RedHat的OpenShift就使用了该监控方案。</p>
<p>2.<a href="https://konghq.com/">Kong</a></p>
<p>基于Nginx OpenResty的API网关，支持自定义插件，支持比原生nginx更多的功能。</p>
<p>3.<a href="https://www.nuodb.com/">NuoDB</a></p>
<div align=center><img src="https://www.nuodb.com/sites/all/themes/nuodb/logo.svg" width="250" align=center /></div>

<p>弹性可伸缩的关系型数据库，兼容SQL标准。将数据库中的事务和存储进行了分离，存储层支持多种存储系统，比如文件系统、Amazon S3和HDFS。因为存储层可以是外部的存储，意味着NuoDB的扩展性会大大增强，使其部署到Kubernetes成为了比较容易的事情。</p>
<p>4.Linux命令hping3</p>
<p>hping3是一个用于生成和解析tcp&#x2F;ip协议的工具，能够对数据包进行定制，可用于端口扫描、DDOS攻击等，是一个比较常见的黑客工具。</p>
<p>5.<a href="https://firecracker-microvm.github.io/">Firecracker</a></p>
<div align=center><img src="https://firecracker-microvm.github.io/img/logo-icon@3x.png" width="100" align=center /></div>

<p>Amazon开源的轻量级的虚拟机软件，使用KVM来创建和管理虚拟机，整体架构类似Kata Container。容器采用cgroup和namespace来做资源隔离，但是在安全性方面却比较差，轻量级的虚拟机在做到隔离性的同时，又提供了不错的启动速度，是容器领域的一个发展方向。</p>
<p>6.<a href="https://nginxconfig.io/">NginxConfig.io</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/nginxconfig.png"></p>
<p>NginxConfig.io是一款在线生成nginx配置文件的工具，可以通过点点鼠标，在文本框中内容的方式轻松生成nginx的配置文件。</p>
<p>7.<a href="https://github.com/mholt/caddy">Caddy</a></p>
<p>一款实用Go语言编写的负载均衡工具，默认启用HTTPS服务，可以使用Let’s Encrypt来自动签发证书。配置文件的写法也比nginx要简洁。</p>
<p>8.<a href="https://github.com/grafana/loki">loki</a></p>
<p>Grafana团队最新发布的基于Go语言开发的日志聚合系统，loki不会对日志进行全文索引，而是以压缩聚合的方式进行存储，可以对日志流通过打标签的方式进行分组，页面的展示直接使用grafana。对Kubernetes Pod中的log做了特别的支持，比较适合抓取和存储Kubernetes Pod中的log。</p>
<p>个人感觉该工具未来会很火爆，尤其是跟Grafana有着无缝的整合。很多公司会使用ES来作为日志中心的底层存储，但不见得所有的服务都有按照关键字进行匹配搜索的需求，ES作为日志中心就显得不够高效和经济。</p>
<p>9.<a href="https://www.jsonrpc.org/specification">JSON-RPC</a></p>
<p>json-rpc是rpc通讯中的一种json格式标准，该协议要求request和response的内容必须为json格式，且json有固定的格式。</p>
<p>10.<a href="https://github.com/confluentinc/ksql">KSQL</a></p>
<p>Apache Kafka的开源SQL引擎，可以使用SQL的形式查询kafka中的消息，该产品跟Kafka一样，同样为Confluent出品。</p>
<h2 id="精彩文章"><a href="#精彩文章" class="headerlink" title="精彩文章"></a>精彩文章</h2><p>1.<a href="https://mp.weixin.qq.com/s/9XyayHJ_m_9Q-igED6jRRg">北京五环外的真实中国</a></p>
<p>朋友圈刷屏文章，文章以gif动画的形式描述了社会底层人士的艰辛生活，他们背上扛起的不仅是压得直不起腰来的砖头，而是面对困难努力生活的勇气，有些时候为了生计确实没得选择。</p>
<p>当我们在抱怨生活的同时，可以想想比我们更苦更累却默默承受生活之重的人们，或许心里会好受些。</p>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p>1.<a href="https://tiancaiamao.gitbooks.io/go-internals/zh/">《深入解析Go》</a></p>
<p>从底层角度分析go语言实现，推荐所有golang开发者一看。</p>
<p>2.<a href="http://product.china-pub.com/8054378">深入浅出Serverless：技术原理与应用实践</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/serverless-zcover.jpg" alt="http://images.china-pub.com/ebook8050001-8055000/8054378/zcover.jpg"></p>
<p>要想能够对Serverless技术的概念和现状有所了解，该书还是挺合适的。</p>
<p>该书介绍了公有云上的Serverless产品AWS Lambda、Azure Functions，开源项目OpenWhisk、Kubeless、Fission和OpenFasS，提供对这些技术的一站式了解。</p>
]]></content>
  </entry>
  <entry>
    <title>知识分享第9期</title>
    <url>/post/knowledge-share-9/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/fujishan.jpeg"></p>
<p>富士山&amp;富士吉田市，富士山的海拔高达3776米，远在80公里外的东京都能够看到。令人称奇的是，富士山海拔3360米以上的土地并不是归日本政府所有，而是归富士山上的浅间寺所有，日本政府每年都要支付大量的租金给浅间寺。在富士山周边游览后，突然萌生了登顶富士山的想法，不知是否有志同道合的驴友，可以相约在某年的夏季去一起实现梦想。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>1.<a href="https://criu.org/Main_Page">CRIU</a></p>
<p>Linux下的一款实现checkpoint&#x2F;restore功能的软件，该软件可以冻结某个正在运行的应用程序，并将应用程序的当前状态作为checkpoint存放在磁盘上的文件中，此后正在运行的应用程序会被kill。</p>
<p>此后，可以通过读取磁盘上的文件，恢复之前冻结的应用程序继续执行，而不是从main函数开始执行。</p>
<p>2.<a href="https://bindfs.org/">bindfs</a></p>
<p>将一个目录mount到另外一个目录的工具，利用该命令可以将docker中的路径挂载到宿主机上。具体操作命令类似如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PID=$(docker inspect b991b7ad105f --format &#123;&#123;.State.Pid&#125;&#125;)</span><br><span class="line">bindfs /proc/$PID/root /tmp/root</span><br><span class="line"># 别忘了卸载目录</span><br><span class="line">umount /tmp/root</span><br></pre></td></tr></table></figure>

<p>3.<a href="https://www.msra.cn/">微软亚洲研究院-对联电脑</a></p>
<p>微软亚洲研究院的自动对对联系统，给出上联后，可以自动给出多个下联，最终生成横批。</p>
<p>4.<a href="https://github.com/iovisor/bcc">bcc</a></p>
<p>基于Linux eBPF的一系列的性能分析工具，包括IO、网络等多个方面。</p>
<p>5.<a href="https://github.com/tobert/pcstat">pcstat</a></p>
<p>基于golang开发的linux下的文件缓存统计工具。</p>
<p>6.<a href="https://electronjs.org/">Electron</a></p>
<p>利用前端技术（JavaScript、HTML、CSS）来构建桌面程序的框架，当前很多流行的桌面应用都是使用该技术来开发的，比如VSCode、Slack、Atom等技术。</p>
<p>得益于ES6、V8引擎和Node.js，JavaScript技术已经横跨前端、后端、桌面端的技术栈。</p>
<p>7.<a href="https://github.com/y123456yz/Reading-and-comprehense-linux-Kernel-network-protocol-stack">Reading-and-comprehense-linux-Kernel-network-protocol-stack</a></p>
<p>该项目包含了对Linux网络协议栈的源码中文注释，对阅读Linux网络协议栈的代码有一些帮助。</p>
<h2 id="精彩文章"><a href="#精彩文章" class="headerlink" title="精彩文章"></a>精彩文章</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&mid=2649699945&idx=1&sn=c5b32baf1ea063d908b547381d4c13da&chksm=8893090abfe4801caa8ae854b2eb2ef6f37d79a83f7147db74a5656616baac00d60c80053fdd&scene=21#wechat_redirect">Kubernetes API 与 Operator：不为人知的开发者战争（一）</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&mid=2649700020&idx=1&sn=4e8b2ae1c1d9d0457eb4134b3624da96&chksm=889309d7bfe480c11030dc181a5e6c7b8998ae2850deed5637b4e4cd4a9c33339e87abab73ea&mpshare=1&scene=1&srcid=0108IZNbW8zHwqP9OH0anKe6%23rd">Kubernetes API 与 Operator：不为人知的开发者战争（二）</a></li>
</ol>
<h2 id="精彩语句"><a href="#精彩语句" class="headerlink" title="精彩语句"></a>精彩语句</h2><ol>
<li><blockquote>
<p>“不能用”“不好用”“需要定制开发”，这才是落地开源基础设施项目的三大常态。</p>
</blockquote>
</li>
</ol>
<p>– 张磊《深入剖析Kubernetes》</p>
<p>开源项目在落地到公司内部实际使用时，会发现有这样或者那样的问题。开源项目往往是个通用项目，公司在落地时，总有其特殊需求之处，开源软件无法面面俱到，往往只能覆盖一些通用的需求。再加上靠社区来驱动，在bug方面、功能方面跟商业软件也还有较大差距。</p>
<h2 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h2><p>1.《塞尔达传说-旷野之息》</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/BreathoftheWildFinalCover.jpg"></p>
<p>任天堂Switch上的游戏神作，历时四年时间，300人的团队开发，最近一直在玩，已经深深被游戏设计的海拉鲁大陆所折服，完全开放的世界，不同于传统的闯关类游戏，该游戏的自由度非常高，有时候就单纯的在地图中瞎逛都是一种享受，随时都会有惊喜发生。</p>
<p>曾天真的以为，一个单机游戏能好玩到哪里去，但在玩游戏的每一刻都能体会到制作团队的用心，心里总是念到这才是我想要玩的游戏。自从玩了该游戏后，手机上的游戏再也没有打开过。我甚至一度感叹，在国内快糙猛的环境下是产生不了如此细腻良心作品的。如果大家有机会，可以尝试下这款游戏，或许会发现单机游戏还可以做得如此出彩。</p>
<p>2.<a href="https://zeldamaps.com/">ZELDA MAPS</a></p>
<p>同样是跟《塞尔达传说-旷野之息》相关的，由于塞尔达传说的地图实在过于庞大，包含了神庙、驿站、村庄、回忆（没错主人公Link失忆了）、各种支线任务、装备、呀哈哈、各类大小boss、迷宫等等，有玩家制作了一款在线的地图，可以在线查询地图中的各类元素，使用体验类似Google Map。还包含了账号体系，可以在地图上标记自己已经完成的任务。</p>
]]></content>
  </entry>
  <entry>
    <title>kube-proxy iptables规则分析</title>
    <url>/post/kube-proxy-iptables/</url>
    <content><![CDATA[<p>kube-proxy默认使用iptables规则来做k8s集群内部的负载均衡，本文通过例子来分析创建的iptabels规则。</p>
<p>主要的自定义链涉及到：</p>
<ul>
<li>KUBE-SERVICES： 访问集群内服务的CLusterIP数据包入口，根据匹配到的目标ip+port将数据包分发到相应的KUBE-SVC-xxx链上。一个Service对应一条规则。由OUTPUT链调用。</li>
<li>KUBE-NODEPORTS: 用来匹配nodeport端口号，并将规则转发到KUBE-SVC-xxx。一个NodePort类型的Service一条。在KUBE-SERVICES链的最后被调用</li>
<li>KUBE-SVC-xxx：相当于是负载均衡，将流量利用random模块均分到KUBE-SEP-xxx链上。</li>
<li>KUBE-SEP-xxx：通过dnat规则将连接的目的地址和端口号做dnat，从Service的ClusterIP或者NodePort转换为后端的pod ip</li>
<li>KUBE-MARK-MASQ: 使用mark命令，对数据包设置标记0x4000&#x2F;0x4000。在KUBE-POSTROUTING链上有MARK标记的数据包进行一次MASQUERADE，即SNAT，会用节点ip替换源ip地址。</li>
</ul>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>创建nginx deployment</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-svc</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-svc</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-svc</span></span><br><span class="line">        <span class="attr">version:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">&#x27;nginx:1.9.0&#x27;</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">443</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>创建service对象</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-svc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&#x27;80&#x27;</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30080</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-svc</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>

<p>环境信息如下：</p>
<ul>
<li>容器网段：172.20.0.0&#x2F;16</li>
<li>Service ClusterIP cidr: 192.168.0.0&#x2F;20</li>
<li>k8s版本：</li>
</ul>
<p>提交后创建出来的信息如下：</p>
<ul>
<li>Service ClusterIP：192.168.103.148</li>
<li>nginx pod的两个ip地址：172.16.3.3 172.16.4.4</li>
</ul>
<h2 id="从宿主机上访问ClusterIP"><a href="#从宿主机上访问ClusterIP" class="headerlink" title="从宿主机上访问ClusterIP"></a>从宿主机上访问ClusterIP</h2><p>从本机请求ClusterIP的数据包会经过iptables的链：OUTPUT -&gt; POSTROUTING</p>
<p>要想详细知道iptabels的执行情况，可以通过iptables的trace功能。如何开启trace功能可以参考：<a href="http://kuring.me/post/iptables/%E3%80%82">http://kuring.me/post/iptables/。</a></p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/kube-proxy-clusterip.png" alt="image"></p>
<p>执行 <code>iptables -nvL OUTPUT -t nat</code> 可以看到如下的iptables规则命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkts bytes target         prot opt in     out     source               destination         </span><br><span class="line">17M  1150M KUBE-SERVICES  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */</span><br></pre></td></tr></table></figure>

<p>执行 <code>iptables -nvL KUBE-SERVICES -t nat</code> 可以查看自定义链的具体内容，里面包含了多条规则，其中跟当前Service相关的规则如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkts bytes target                     prot opt in     out     source               destination</span><br><span class="line">1    60    KUBE-SVC-Y5VDFIEGM3DY2PZE  tcp  --  *      *       0.0.0.0/0            192.168.103.148      /* default/nginx-svc:80 cluster IP */ tcp dpt:8000</span><br></pre></td></tr></table></figure>

<p>执行 <code>iptables -nvL KUBE-SVC-Y5VDFIEGM3DY2PZE -t nat</code> 查看自定义链的具体规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkts  bytes target                     prot opt in     out     source               destination</span><br><span class="line">0     0     KUBE-SEP-IFV44I3EMZAL3LH3  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-svc:80 */ statistic mode random probability 0.50000000000</span><br><span class="line">1    60     KUBE-SEP-6PNQETFAD2JPG53P  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-svc:80 */</span><br></pre></td></tr></table></figure>

<p>上述规则会按照特定的概率将流量均等的执行自定义链的规则，两个自定义的链的规则跟endpoint相关，执行 <code>iptables -nvL  KUBE-SEP-IFV44I3EMZAL3LH3 -t nat</code>可查看endpoint级别的iptabels规则。dnat操作会修改数据包的目的地址和端口，从clusterip+service port修改为访问pod ip+pod端口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkts bytes target          prot opt in     out     source               destination</span><br><span class="line">0     0    KUBE-MARK-MASQ  all  --  *      *       172.16.3.3           0.0.0.0/0            /* default/nginx-svc:80 */</span><br><span class="line">0     0    DNAT            tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-svc:80 */ tcp to:172.16.3.3:80</span><br></pre></td></tr></table></figure>

<p>会在dnat操作之前为对数据包执行打标签操作。KUBE-MARK-MASQ 自定义链为对数据包打标记的自定义规则，执行 <code>iptables -nvL  KUBE-MARK-MASQ -t nat</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"> 1    60   MARK       all  --  *      *       0.0.0.0/0            0.0.0.0/0            MARK or 0x4000</span><br></pre></td></tr></table></figure>

<p>接下来看一下POSTROUTING链上的规则，<code>iptables -nvL  POSTROUTING -t nat</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkts bytes target            prot opt in     out     source               destination         </span><br><span class="line">205K   13M KUBE-POSTROUTING  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes postrouting rules */</span><br></pre></td></tr></table></figure>

<p>继续看一下KUBE-POSTROUTING链的内容，<code>iptables -nvL  KUBE-POSTROUTING -t nat</code>，其中最后一条的MASQUERADE指令的操作实际上为SNAT操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Chain KUBE-POSTROUTING (1 references)</span><br><span class="line">pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">6499  398K RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0            mark match ! 0x4000/0x4000</span><br><span class="line">   1    60 MARK       all  --  *      *       0.0.0.0/0            0.0.0.0/0            MARK xor 0x4000</span><br><span class="line">   1    60 MASQUERADE  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service traffic requiring SNAT */</span><br></pre></td></tr></table></figure>

<p>即从本机访问service clusterip的数据包，在output链上经过了dnat操作，在postrouting链上经过了snat操作后，最终会发往目标pod。pod在处理完请求后，回的数据包最终会经过nat的逆过程返回到本机。</p>
<h2 id="外部访问nodeport"><a href="#外部访问nodeport" class="headerlink" title="外部访问nodeport"></a>外部访问nodeport</h2><p>从外部访问本机的nodeport数据包会经过iptables的链：PREROUTING -&gt; FORWARD -&gt; POSTROUTING</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/kube-proxy-clusterip.png" alt="image"></p>
<p>nodeport都是被外部访问的情况，入口位于PREROUTING链上。执行 <code>iptables -nvL PREROUTING  -t nat</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkts bytes target         prot opt in     out     source               destination         </span><br><span class="line">349K   21M KUBE-SERVICES  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service portals */</span><br></pre></td></tr></table></figure>

<p>在KUBE-SERVICES链的最后一条规则为跳转到KUBE-NODEPORTS链</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4079  246K KUBE-NODEPORTS  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes service nodeports; NOTE: this must be the last rule in this chain */ ADDRTYPE match dst-type LOCAL</span><br></pre></td></tr></table></figure>

<p>执行<code>iptables -nvL KUBE-NODEPORTS -t nat</code>， 查看KUBE-NODEPORTS链 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkts bytes target                     prot opt in     out     source               destination         </span><br><span class="line">0     0    KUBE-MARK-MASQ             tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-svc:80 */ tcp dpt:30080</span><br><span class="line">0     0    KUBE-SVC-Y5VDFIEGM3DY2PZE  tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-svc:80 */ tcp dpt:30080</span><br></pre></td></tr></table></figure>

<p>其中KUBE-MARK-MASQ链只有一条规则，即打上0x4000的标签。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">0     0    MARK       all  --  *      *       0.0.0.0/0            0.0.0.0/0            MARK or 0x4000</span><br></pre></td></tr></table></figure>

<p>自定义链KUBE-SVC-Y5VDFIEGM3DY2PZE的内容如下，跟clusterip的规则是重叠的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">0    0     KUBE-SEP-IFV44I3EMZAL3LH3  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-svc:80 */ statistic mode random probability 0.50000000000</span><br><span class="line">0    0     KUBE-SEP-6PNQETFAD2JPG53P  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-svc:80 */</span><br></pre></td></tr></table></figure>

<p>KUBE-SEP-IFV44I3EMZAL3LH3的内容为，会经过一次DNAT操作:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkts bytes target          prot opt in     out     source               destination         </span><br><span class="line">0    0     KUBE-MARK-MASQ  all  --  *      *       172.16.3.3           0.0.0.0/0            /* default/nginx-svc:80 */</span><br><span class="line">0    0     DNAT            tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            /* default/nginx-svc:80 */ tcp to:172.16.3.3:80</span><br></pre></td></tr></table></figure>

<p>在经过了PREROUTING链后，接下来会判断目的ip地址不是本机的ip地址，接下来会经过FORWARD链。在FORWARD链上，仅做了一件事情，就是将前面大了0x4000的数据包允许转发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkts bytes target              prot opt in     out     source               destination         </span><br><span class="line">0    0 KUBE-FORWARD            all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes forwarding rules */</span><br><span class="line">0    0 KUBE-SERVICES           all  --  *      *       0.0.0.0/0            0.0.0.0/0            ctstate NEW /* kubernetes service portals */</span><br><span class="line">0    0 KUBE-EXTERNAL-SERVICES  all  --  *      *       0.0.0.0/0            0.0.0.0/0            ctstate NEW /* kubernetes externally-visible service portals */</span><br></pre></td></tr></table></figure>

<p>KUBE-FORWARD的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">0     0    DROP       all  --  *      *       0.0.0.0/0            0.0.0.0/0            ctstate INVALID</span><br><span class="line">0     0    ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes forwarding rules */ mark match 0x4000/0x4000</span><br><span class="line">0     0    ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes forwarding conntrack pod source rule */ ctstate RELATED,ESTABLISHED</span><br><span class="line">0     0    ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* kubernetes forwarding conntrack pod destination rule */ ctstate RELATED,ESTABLISHED</span><br></pre></td></tr></table></figure>

<p>跟clusterip一样，会在POSTROUTING阶段匹配mark为0x4000&#x2F;0x4000的数据包，并进行一次MASQUERADE转换，将ip包替换为宿主上的ip地址。</p>
<p>加入这里不做MASQUERADE，流量发到目的的pod后，pod回包时目的地址为发起端的源地址，而发起端的源地址很可能是在k8s集群外部的，此时pod发回的包是不能回到发起端的。NodePort跟ClusterIP的最大不同就是NodePort的发起端很可能是在集群外部的，从而这里必须做一层SNAT转换。</p>
<p>在上述分析中，访问NodePort类型的Service会经过snat，从而服务端的pod不能获取到正确的客户端ip。可以设置Service的spec.externalTrafficPolicy为Local，此时iptables规则只会将ip包转发给运行在这台宿主机上的pod，而不需要经过snat。pod回包时，直接回复源ip地址即可，此时源ip地址是可达的，因为源ip地址跟宿主机是可达的。如果所在的宿主机上没有pod，那么此时流量就不可以转发，此为限制。</p>
<h2 id="使用LoadBalancer类型访问的情况"><a href="#使用LoadBalancer类型访问的情况" class="headerlink" title="使用LoadBalancer类型访问的情况"></a>使用LoadBalancer类型访问的情况</h2><h3 id="externalTrafficPolicy为local"><a href="#externalTrafficPolicy为local" class="headerlink" title="externalTrafficPolicy为local"></a>externalTrafficPolicy为local</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-A KUBE-SERVICES -d 10.149.30.186/32 -p tcp -m comment --comment &quot;acs-system/nginx-ingress-lb-cloudbiz:http loadbalancer IP&quot; -m tcp --dport 80 -j KUBE-FW-76HLDRT5IPNSMPF5</span><br><span class="line">-A KUBE-FW-76HLDRT5IPNSMPF5 -m comment --comment &quot;acs-system/nginx-ingress-lb-cloudbiz:http loadbalancer IP&quot; -j KUBE-XLB-76HLDRT5IPNSMPF5</span><br><span class="line">-A KUBE-FW-76HLDRT5IPNSMPF5 -m comment --comment &quot;acs-system/nginx-ingress-lb-cloudbiz:http loadbalancer IP&quot; -j KUBE-MARK-DROP</span><br><span class="line"></span><br><span class="line"># 10.149.112.0/23为pod网段</span><br><span class="line">-A KUBE-XLB-76HLDRT5IPNSMPF5 -s 10.149.112.0/23 -m comment --comment &quot;Redirect pods trying to reach external loadbalancer VIP to clusterIP&quot; -j KUBE-SVC-76HLDRT5IPNSMPF5</span><br><span class="line">-A KUBE-XLB-76HLDRT5IPNSMPF5 -m comment --comment &quot;Balancing rule 0 for acs-system/nginx-ingress-lb-cloudbiz:http&quot; -j KUBE-SEP-XZXLBWOKJBSJBGVU</span><br><span class="line"></span><br><span class="line">-A KUBE-SVC-76HLDRT5IPNSMPF5 -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-XZXLBWOKJBSJBGVU</span><br><span class="line">-A KUBE-SVC-76HLDRT5IPNSMPF5 -j KUBE-SEP-GP4UCOZEF3X7PGLR</span><br><span class="line"></span><br><span class="line">-A KUBE-SEP-XZXLBWOKJBSJBGVU -s 10.149.112.45/32 -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SEP-XZXLBWOKJBSJBGVU -p tcp -m tcp -j DNAT --to-destination 10.149.112.45:80</span><br><span class="line">-A KUBE-SEP-GP4UCOZEF3X7PGLR -s 10.149.112.46/32 -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SEP-GP4UCOZEF3X7PGLR -p tcp -m tcp -j DNAT --to-destination 10.149.112.46:80</span><br></pre></td></tr></table></figure>

<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>iptables规则特别乱，一旦出现问题非常难以排查</li>
<li>由于iptables规则是串行执行，算法复杂度为O(n)，一旦iptables规则多了后，性能将非常差。</li>
<li>iptables规则提供的负载均衡功能非常有限，不支持较为复杂的负载均衡算法。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>使用 kubeadm 安装 k8s 集群</title>
    <url>/post/kubeadm/</url>
    <content><![CDATA[<p>本文将通过 kubeadm 实现单 master 节点模式和集群模式两种部署方式。</p>
<h2 id="所有节点均需初始化操作"><a href="#所有节点均需初始化操作" class="headerlink" title="所有节点均需初始化操作"></a>所有节点均需初始化操作</h2><p>所有节点均需做的操作。</p>
<h3 id="主机准备"><a href="#主机准备" class="headerlink" title="主机准备"></a>主机准备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysctl.d/kubernets.conf &lt;&lt;EOF</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">vm.swappiness=0</span><br><span class="line">EOF</span><br><span class="line">sysctl --system</span><br><span class="line">modprobe br_netfilter</span><br></pre></td></tr></table></figure>


<h3 id="安装containerd"><a href="#安装containerd" class="headerlink" title="安装containerd"></a>安装containerd</h3><p>由于 dockerd 从 k8s 1.24 版本开始不再支持，这里选择 containerd。</p>
<h4 id="手工安装"><a href="#手工安装" class="headerlink" title="手工安装"></a>手工安装</h4><p>安装 containerd，containerd 的版本可以从这里获取 <a href="https://github.com/containerd/containerd/releases">https://github.com/containerd/containerd/releases</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/containerd/containerd/releases/download/v1.6.11/containerd-1.6.11-linux-amd64.tar.gz</span><br><span class="line">tar Cxzvf /usr/local containerd-1.6.11-linux-amd64.tar.gz</span><br><span class="line">wget https://raw.githubusercontent.com/containerd/containerd/main/containerd.service -P /usr/local/lib/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable --now containerd</span><br></pre></td></tr></table></figure>

<p>安装 runc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/opencontainers/runc/releases/download/v1.1.4/runc.amd64</span><br><span class="line">install -m 755 runc.amd64 /usr/local/sbin/runc</span><br></pre></td></tr></table></figure>

<h4 id="yum-源安装"><a href="#yum-源安装" class="headerlink" title="yum 源安装"></a>yum 源安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils</span><br><span class="line">yum-config-manager --add-repo     https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">yum install containerd.io -y</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable --now containerd</span><br></pre></td></tr></table></figure>

<p>通过 yum 安装的containerd 没有启用 cri，在其配置文件 &#x2F;etc&#x2F;containerd&#x2F;config.toml 中包含了 <code>disabled_plugins = [&quot;cri&quot;]</code> 配置，需要将配置信息注释后并重启 containerd。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/disabled_plugins/#disabled_plugins/&#x27;  /etc/containerd/config.toml</span><br><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure>

<h3 id="安装-kubeadm-x2F-kubelet-x2F-kubectl"><a href="#安装-kubeadm-x2F-kubelet-x2F-kubectl" class="headerlink" title="安装 kubeadm&#x2F;kubelet&#x2F;kubectl"></a>安装 kubeadm&#x2F;kubelet&#x2F;kubectl</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">exclude=kubelet kubeadm kubectl</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># Set SELinux in permissive mode (effectively disabling it)</span><br><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config</span><br><span class="line"></span><br><span class="line">sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure>

<h2 id="单-master-节点模式"><a href="#单-master-节点模式" class="headerlink" title="单 master 节点模式"></a>单 master 节点模式</h2><table>
<thead>
<tr>
<th>节点</th>
<th>角色</th>
</tr>
</thead>
<tbody><tr>
<td>172.21.115.190<br/></td>
<td>master 节点</td>
</tr>
</tbody></table>
<h3 id="kubeadm-初始化"><a href="#kubeadm-初始化" class="headerlink" title="kubeadm 初始化"></a>kubeadm 初始化</h3><p>创建文件 kubeadm-config.yaml，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.25.4</span><br><span class="line">---</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">cgroupDriver: systemd</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm init --config kubeadm-config.yaml</span><br><span class="line">kubeadm config print init-defaults --component-configs KubeletConfiguration &gt; cluster.yaml</span><br><span class="line">kubeadm init --config cluster.yaml</span><br></pre></td></tr></table></figure>

<p>接下来初始化 kubeconfig 文件，这样即可通过 kubectl 命令来访问 k8s 了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>


<h3 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h3><p>刚部署完成的节点处于NotReady 的状态，原因是因为还没有安装网络插件。</p>
<h4 id="cilim-网络插件"><a href="#cilim-网络插件" class="headerlink" title="cilim 网络插件"></a>cilim 网络插件</h4><p>cilim 网络插件比较火爆，下面介绍其安装步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装 cilium 客户端</span><br><span class="line">CILIUM_CLI_VERSION=$(curl -s https://raw.githubusercontent.com/cilium/cilium-cli/master/stable.txt)</span><br><span class="line">CLI_ARCH=amd64</span><br><span class="line">if [ &quot;$(uname -m)&quot; = &quot;aarch64&quot; ]; then CLI_ARCH=arm64; fi</span><br><span class="line">curl -L --fail --remote-name-all https://github.com/cilium/cilium-cli/releases/download/$&#123;CILIUM_CLI_VERSION&#125;/cilium-linux-$&#123;CLI_ARCH&#125;.tar.gz&#123;,.sha256sum&#125;</span><br><span class="line">sha256sum --check cilium-linux-$&#123;CLI_ARCH&#125;.tar.gz.sha256sum</span><br><span class="line">sudo tar xzvfC cilium-linux-$&#123;CLI_ARCH&#125;.tar.gz /usr/local/bin</span><br><span class="line">rm cilium-linux-$&#123;CLI_ARCH&#125;.tar.gz&#123;,.sha256sum&#125;</span><br><span class="line"></span><br><span class="line"># 网络插件初始化</span><br><span class="line">cilium install</span><br></pre></td></tr></table></figure>

<p>在安装完网络插件后，node 节点即可变为 ready 状态。</p>
<p>查看环境中包含如下的 pod:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl  get pod  -A</span><br><span class="line">NAMESPACE     NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   cilium-7zj7t                     1/1     Running   0          82s</span><br><span class="line">kube-system   cilium-operator-bc4d5b54-kvqqx   1/1     Running   0          82s</span><br><span class="line">kube-system   coredns-565d847f94-hrm9b         1/1     Running   0          14m</span><br><span class="line">kube-system   coredns-565d847f94-z5kwr         1/1     Running   0          14m</span><br><span class="line">kube-system   etcd-k8s002                      1/1     Running   0          14m</span><br><span class="line">kube-system   kube-apiserver-k8s002            1/1     Running   0          14m</span><br><span class="line">kube-system   kube-controller-manager-k8s002   1/1     Running   0          14m</span><br><span class="line">kube-system   kube-proxy-bhpqr                 1/1     Running   0          14m</span><br><span class="line">kube-system   kube-scheduler-k8s002            1/1     Running   0          14m</span><br></pre></td></tr></table></figure>

<h4 id="k8s-自带的-bridge-插件"><a href="#k8s-自带的-bridge-插件" class="headerlink" title="k8s 自带的 bridge 插件"></a>k8s 自带的 bridge 插件</h4><p>在单节点的场景下，pod 不需要跨节点通讯，k8s 自带的 bridge 插件也可以满足单节点内的 pod 相互通讯，类似于 docker 的 bridge 网络模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/cni/net.d</span><br><span class="line">cat &gt; /etc/cni/net.d/10-mynet.conf &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;cniVersion&quot;: &quot;0.2.0&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;mynet&quot;,</span><br><span class="line">  &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="line">  &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class="line">  &quot;isGateway&quot;: true,</span><br><span class="line">  &quot;ipMasq&quot;: true,</span><br><span class="line">  &quot;ipam&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="line">    &quot;subnet&quot;: &quot;172.19.0.0/24&quot;,</span><br><span class="line">    &quot;routes&quot;: [</span><br><span class="line">      &#123; &quot;dst&quot;: &quot;0.0.0.0/0&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>如果 k8s 节点已经部署完成，需要重启下 kubelet 进程该配置即可生效。</p>
<h3 id="添加其他节点"><a href="#添加其他节点" class="headerlink" title="添加其他节点"></a>添加其他节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join 172.21.115.189:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:457fba2c4181a5b02d2a4f202dfe20f9ce5b9f2274bf40b6d25a8a8d4a7ce440 </span><br></pre></td></tr></table></figure>

<p>此时即可以将节点添加到 k8s 集群中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl  get node </span><br><span class="line">NAME     STATUS   ROLES           AGE   VERSION</span><br><span class="line">k8s002   Ready    control-plane   79m   v1.25.4</span><br><span class="line">k8s003   Ready    &lt;none&gt;          35s   v1.25.4</span><br></pre></td></tr></table></figure>

<h3 id="节点清理"><a href="#节点清理" class="headerlink" title="节点清理"></a>节点清理</h3><h4 id="清理普通节点"><a href="#清理普通节点" class="headerlink" title="清理普通节点"></a>清理普通节点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl drain &lt;node name&gt; --delete-emptydir-data --force --ignore-daemonsets</span><br><span class="line">kubeadm reset </span><br><span class="line"># 清理 iptabels 规则</span><br><span class="line">iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X</span><br><span class="line">kubectl delete node &lt;node name&gt;</span><br></pre></td></tr></table></figure>

<h4 id="清理-control-plan-节点"><a href="#清理-control-plan-节点" class="headerlink" title="清理 control plan 节点"></a>清理 control plan 节点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure>

<h2 id="集群模式部署"><a href="#集群模式部署" class="headerlink" title="集群模式部署"></a>集群模式部署</h2><p>待补充，参考文档：<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/">Creating Highly Available Clusters with kubeadm | Kubernetes</a></p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/">Bootstrapping clusters with kubeadm</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>kubectl常用命令</title>
    <url>/post/kubectl-command/</url>
    <content><![CDATA[<p>本文记录常用的kubectl命令，不定期更新。</p>
<h2 id="1-统计k8s-node上的污点信息"><a href="#1-统计k8s-node上的污点信息" class="headerlink" title="1. 统计k8s node上的污点信息"></a>1. 统计k8s node上的污点信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get nodes -o=custom-columns=NodeName:.metadata.name,TaintKey:.spec.taints[*].key,TaintValue:.spec.taints[*].value,TaintEffect:.spec.taints[*].effect</span><br></pre></td></tr></table></figure>

<h2 id="2-查看不ready的pod"><a href="#2-查看不ready的pod" class="headerlink" title="2. 查看不ready的pod"></a>2. 查看不ready的pod</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pod --all-namespaces -o wide -w | grep -vE &quot;Com|NAME|Running|1/1|2/2|3/3|4/4&quot;</span><br></pre></td></tr></table></figure>

<h2 id="3-pod按照重启次数排序"><a href="#3-pod按照重启次数排序" class="headerlink" title="3. pod按照重启次数排序"></a>3. pod按照重启次数排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pods -A  --sort-by=&#x27;.status.containerStatuses[0].restartCount&#x27; | tail</span><br></pre></td></tr></table></figure>

<h2 id="4-kubectl-proxy命令代理k8s-apiserver"><a href="#4-kubectl-proxy命令代理k8s-apiserver" class="headerlink" title="4. kubectl proxy命令代理k8s apiserver"></a>4. kubectl proxy命令代理k8s apiserver</h2><p>该命令经常用在开发的场景下，用来测试k8s api的结果。执行如下命令即可在本地127.0.0.1开启10999端口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl proxy --port=10999</span><br></pre></td></tr></table></figure>

<p>在本地即可通过curl的方式来访问k8s的apiserver，而无需考虑鉴权问题。例如，<code>curl http://127.0.0.1:10999/apis/batch/v1</code>，即可直接返回结果。</p>
<h2 id="5-raw命令"><a href="#5-raw命令" class="headerlink" title="5. --raw命令"></a>5. <code>--raw</code>命令</h2><p>该命令经常用在开发的场景下，用来测试k8s api的结果。执行如下的命令，即可返回json格式的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get --raw /apis/batch/v1</span><br></pre></td></tr></table></figure>

<h2 id="6-查看集群中的pod的request和limit情况"><a href="#6-查看集群中的pod的request和limit情况" class="headerlink" title="6. 查看集群中的pod的request和limit情况"></a>6. 查看集群中的pod的request和limit情况</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pod -n kube-system  -o=custom-columns=NAME:.metadata.name,NAMESPACE:.metadata.namespace,PHASE:.status.phase,Request-cpu:.spec.containers\[0\].resources.requests.cpu,Request-memory:.spec.containers\[0\].resources.requests.memory,Limit-cpu:.spec.containers\[0\].resources.limits.cpu,Limit-memory:.spec.containers\[0\].resources.limits.memory</span><br></pre></td></tr></table></figure>

<p>得到的效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME                                              NAMESPACE     PHASE       Request-cpu   Request-memory   Limit-cpu   Limit-memory</span><br><span class="line">cleanup-for-np-processor-9pjkm                    kube-system   Succeeded   &lt;none&gt;        &lt;none&gt;           &lt;none&gt;      &lt;none&gt;</span><br><span class="line">coredns-6c6664b94-7rnm8                           kube-system   Running     100m          70Mi             &lt;none&gt;      170Mi</span><br><span class="line">coredns-6c6664b94-djxch                           kube-system   Failed      100m          70Mi             &lt;none&gt;      170Mi</span><br><span class="line">coredns-6c6664b94-khvrb                           kube-system   Running     100m          70Mi             &lt;none&gt;      170Mi</span><br></pre></td></tr></table></figure>

<h2 id="7-修改对象的status"><a href="#7-修改对象的status" class="headerlink" title="7. 修改对象的status"></a>7. 修改对象的status</h2><p>因为status资源实际上为对象的subResource资源，实际上无法通过kubectl来完成，但该操作还是放到了该文档中。</p>
<p>下述命令的需求为修改service的status</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APISERVER=https://kube-cn-nb-nbsjzxpoc-d01-a.intra.nbsjzx.ali.com:6443</span><br><span class="line">TOKEN=eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi10b2tlbi1jazdkciIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJhZG1pbiIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjhkZWE4MWQ4LTU2YTgtMTFlYy05MDMyLTgwNjE1ZjA4NDI0YSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlLXN5c3RlbTphZG1pbiJ9.O25G_MSmKRU_pIPO_9tFqDvbZm9SOM_Mix7jCJeFiZHzLiSc7n5RanP3QoEldR1IcFN4AZXzlzI1Rb0GyFQH7XmS1eLESMbKnrTR3N5s3wlRp-D5QT0c_RAVAiLKrP7KsSKNcLjQkIO8-Csf_kmizIh6fP0-b7Mp90cw0J8oSlM-ScEeUEksQyXvyisVN9qvvTIkmbsgh7pX5IFcB4mGbvV9loOUC3-LdiiaCkMJzMisEeSJRaajmLlwpWXtb2BSi9HmBMktUE9IVB8ryZ06wbPRianbjoBwtAhcXuRyj1LaEog3aJHsyMA_DOZJtvjYis60AIRZ1iBnc-gZtEFCxw</span><br><span class="line">obj=nginx-ingress-lb</span><br><span class="line">curl -XPATCH -H &quot;Accept: application/json&quot; -H  &quot;Content-Type: application/merge-patch+json&quot; --header &quot;Authorization: Bearer $TOKEN&quot; --insecure -d &#x27;&#123;&quot;status&quot;: &#123;&quot;loadBalancer&quot;: &#123;&quot;ingress&quot;: [&#123;&quot;ip&quot;: &quot;10.209.97.170&quot;&#125;]&#125;&#125;&#125;&#x27; $APISERVER/api/v1/namespaces/acs-system/services/nginx-ingress-lb/status</span><br></pre></td></tr></table></figure>

<p>APISERVER变量可以通过kubeconfig文件获取到。</p>
<p>TOKEN变量可以直接使用kube-system下的admin账号。</p>
<ol>
<li>执行 <code>kubectl get secrets -n kube-system  | grep admin</code> 获取到sa对应的secret</li>
<li>执行 <code>kubectl get secrets -n kube-system xxxx -o yaml</code> 获取到base64之后的token</li>
<li>执行 <code>echo &quot;xxxx&quot; | base64 -d</code> 即可获取到对应的token</li>
</ol>
<p>obj变量为要修改的service对象名称。</p>
<h2 id="8-查看-secret-内容"><a href="#8-查看-secret-内容" class="headerlink" title="8. 查看 secret 内容"></a>8. 查看 secret 内容</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get secret -n ark-system ark.cmdb.https.origin.tls -o jsonpath=&#x27;&#123;.data.ca\.pem&#125;&#x27; | base64 -d</span><br></pre></td></tr></table></figure>

<h2 id="9-修改-secret-或-cm-的内容"><a href="#9-修改-secret-或-cm-的内容" class="headerlink" title="9. 修改 secret 或 cm 的内容"></a>9. 修改 secret 或 cm 的内容</h2><p>很多场景下使用 <code>kubectl edit</code> 修改不能完全满足需求，比如某个 key 对应的 value 非常长且包含空格，很难直接编辑。可以通过导出 key 对应的 value 到文件，然后再重新 apply 的方式合入。</p>
<p>导出 configmap 中特定的 key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get cm -n kube-system  networkpolicy-config -o jsonpath=&#x27;&#123;.data.config\.yaml&#125;&#x27; -o yaml</span><br></pre></td></tr></table></figure>

<p>修改完成后，将文件重新 apply cm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create --save-config cm  networkpolicy-config -n kube-system --from-file /tmp/config.yaml -o yaml --dry-run | kubectl apply -f -</span><br></pre></td></tr></table></figure>

<h2 id="9-删除所有-pod（或特定状态-pod）"><a href="#9-删除所有-pod（或特定状态-pod）" class="headerlink" title="9. 删除所有 pod（或特定状态 pod）"></a>9. 删除所有 pod（或特定状态 pod）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pods --all-namespaces -o wide --no-headers | grep -v Running | awk &#x27;&#123;print $1 &quot; &quot; $2&#125;&#x27; | while read AA BB; do kubectl get pod -n $AA $BB --no-headers; done</span><br></pre></td></tr></table></figure>

<h2 id="10-kubectl-debug"><a href="#10-kubectl-debug" class="headerlink" title="10. kubectl debug"></a>10. kubectl debug</h2><p>常用于网络问题排查，其中镜像 netshoot 中包含了丰富的网络命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl exec -it nginx-statefulset-0 bash</span><br></pre></td></tr></table></figure>

<p>进入到 k8s node 网络，其中 <code>$&#123;node&#125;</code> 为 k8s 的 node 名字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl debug node/$&#123;node&#125; -it --image=nicolaka/netshoot</span><br></pre></td></tr></table></figure>

<h2 id="11-kubectl-patch"><a href="#11-kubectl-patch" class="headerlink" title="11. kubectl patch"></a>11. kubectl patch</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl patch -p &#x27;&#123;&quot;spec&quot;:&#123;&quot;filed1&quot;: &quot;value1&quot;&#125;&#125;&#x27; --type=merge xxx -n yyy</span><br></pre></td></tr></table></figure>

<h2 id="12-查询对象的-labels"><a href="#12-查询对象的-labels" class="headerlink" title="12. 查询对象的 labels"></a>12. 查询对象的 labels</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看所有 k8s 节点及其 label</span><br><span class="line">kubectl get nodes -o=jsonpath=&#x27;&#123;range .items[*]&#125;&#123;.metadata.name&#125;&#123;&quot;\t&quot;&#125;&#123;.metadata.labels.topology\.kubernetes\.io/zone&#125;&#123;&quot;\n&quot;&#125;&#123;end&#125;&#x27;</span><br><span class="line"># 查看单个 k8s 节点的 label</span><br><span class="line">kubectl  get node c25e04016.cloud.e04.amtest130  -o jsonpath=&quot;&#123;.metadata.labels[&#x27;topology\.kubernetes\.io/zone&#x27;]&#125;&quot;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>k8s多集群管理方案 - KubeFed V2</title>
    <url>/post/kubefedv2/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="Federation-V1"><a href="#Federation-V1" class="headerlink" title="Federation V1"></a>Federation V1</h2><p>Federation v1 在 K8s v1.3 左右就已经着手设计（Design Proposal），并在后面几个版本中发布了相关的组件与命令行工具（kubefed），用于帮助使用者快速建立联邦集群，并在 v1.6 时，进入了 Beta 阶段；但 Federation v1 在进入 Beta 后，就没有更进一步的发展，由于灵活性和 API 成熟度的问题，在 K8s v1.11 左右正式被弃用。</p>
<h2 id="Federation-V2架构"><a href="#Federation-V2架构" class="headerlink" title="Federation V2架构"></a>Federation V2架构</h2><p>v2 版本利用 CRD 实现了整体功能，通过定义多种自定义资源（CR），从而省掉了 v1 中的 API Server；v2 版本由两个组件构成：</p>
<ul>
<li>admission-webhook 提供了准入控制</li>
<li>controller-manager 处理自定义资源以及协调不同集群间的状态</li>
</ul>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/kubefedv2-1.png" alt="image"><br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/kubefedv2-2.png" alt="image"></p>
<p>代码行数在2万行左右。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>Host Cluster：主集群&#x2F;父集群</li>
<li>Member Cluster：子集群&#x2F;成员集群</li>
</ul>
<h1 id="CRD扩展"><a href="#CRD扩展" class="headerlink" title="CRD扩展"></a>CRD扩展</h1><h2 id="KubeFedCluster"><a href="#KubeFedCluster" class="headerlink" title="KubeFedCluster"></a>KubeFedCluster</h2><p>子集群抽象，通过kubefedctl join命令创建。后续controller会使用该信息来访问子k8s集群。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kind: KubeFedCluster</span><br><span class="line">metadata:</span><br><span class="line">  name: kind<span class="literal">-cluster1</span></span><br><span class="line">  namespace: kube<span class="literal">-federation-system</span></span><br><span class="line">spec:</span><br><span class="line">  apiEndpoint: https://<span class="number">172.21</span>.<span class="number">115.165</span>:<span class="number">6443</span></span><br><span class="line">  caBundle: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKY201bGRHVnpNQjRYRFRJeE1USXlOREUyTlRNME9Wb1hEVE14TVRJeU1qRTJOVE0wT1Zvd0ZURVRNQkVHQTFVRQpBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTmxjCnF3UHd5cHNFc2M0aXB3QnFuRndDN044RXo2Slhqajh3ZzRybnlXTDNSdlZ0cmVua1Nha1VyYlRjZWVIck9lQTUKWGlNUVo2T1FBY25tUGU0Q2NWSkFoL2ZLQzBkeU9uL0ZZeXgyQXppRjBCK1ZNaUFhK2dvME1VMmhMZ1R5eVFGdQpDbWFmUGtsNmJxZUFJNCtCajZJUWRqY3dVMHBjY3lrNGhSTUxnQmhnTUh4NWkzVkpQckQ2Y284dHcwVnllWncyCkdDUlh2ZzlSd0QweUs5eitOVS9LVS83QjBiMTBvekpNRlVJMktPZmI4N1RkQ0h2NmlBdlVRYVdKc1BqQ0M3MzQKcnBma1ZGZXB2S2liKy9lUVBFaDE4VE5qaitveEVGMnl0Vmo2ZWVKeFc3VVZrbit0T3BxdGpEeUtKVDllNnlwdAp6U1VDTnRZWTAzckdhNTlLczBVQ0F3RUFBYU5DTUVBd0RnWURWUjBQQVFIL0JBUURBZ0trTUE4R0ExVWRFd0VCCi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZOTnRQU3hsMlMxUldOb1BCeXNIcHFoRXJONlVNQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFDME0vaktCL2dqcWRSNlRLNXJQVktSSFU2cy8xTTh2eTY2WFBiVEx4M0srazdicUFWdAoxVUFzcUZDZmNrVk91WHY3eFQ0ZHIzVzdtMHE1bDYzRGg3ZDJRZDNiQ00zY2FuclpNd01OM0lSMlpmYzR0VlBGCnRTMFFONElTa0hsYnBudXQxb0F3cy9CaXNwaXNRQ0VtbHF3Zy9xbmdPMStlWWRoWm5vRW40SEFDamF4Slc5MS8KNXlOR1pKRXdia2dYQTVCbSs3VEZRL2FiYnp5a1JvOWtTMnl5c29pMnVzcUg0ZnlVS0ZWK2RETnp3Ujh0ck16cgpjWkRBNHpaVFB1WGlYRkVsWlNRa2NJSGIyV0VsYmZNRGpKNjlyVG5wakJCOWNPQ25jaHVmK0xiOXQwN1lJQ01wCmNlK0prNVp2RElRUFlKK3hTeGdRaVJxMTFraWlKcFE4Wm1FWgotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==</span><br><span class="line">  proxyURL: <span class="string">&quot;&quot;</span></span><br><span class="line">  secretRef:</span><br><span class="line">    name: kind<span class="literal">-cluster1-dbxns</span></span><br><span class="line">status:</span><br><span class="line">  conditions:</span><br><span class="line">  - lastProbeTime: <span class="string">&quot;2021-12-24T17:00:47Z&quot;</span></span><br><span class="line">    lastTransitionTime: <span class="string">&quot;2021-12-24T17:00:07Z&quot;</span></span><br><span class="line">    message: /healthz responded with ok</span><br><span class="line">    reason: ClusterReady</span><br><span class="line">    status: <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="built_in">type</span>: Ready</span><br></pre></td></tr></table></figure>
<h2 id="Fedrated"><a href="#Fedrated" class="headerlink" title="Fedrated"></a>Fedrated<Kind></h2><p>发布应用到子集群时手工创建。每一个要被联邦管理的资源都会对应一个Fedrated<Kind>类型的资源，比如ConfigMap对应的是FederatedConfigMap。FederatedConfigMap包含了三部分的信息：</p>
<ul>
<li>template：联邦的资源详细spec信息，需要特别注意的是并没有包含metadata部分的信息。</li>
<li>placement：template中的spec信息要部署的k8s子集群信息</li>
<li>overrides：允许对部分k8s的部分资源进行自定义修改<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: types.kubefed.io/v1beta1</span><br><span class="line">kind: FederatedConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test-configmap</span></span><br><span class="line">  namespace: <span class="built_in">test-namespace</span></span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    <span class="keyword">data</span>:</span><br><span class="line">      A: ala ma kota</span><br><span class="line">  placement:</span><br><span class="line">    clusters:</span><br><span class="line">    - name: cluster2</span><br><span class="line">    - name: cluster1</span><br><span class="line">  overrides:</span><br><span class="line">  - clusterName: cluster2</span><br><span class="line">    clusterOverrides:</span><br><span class="line">    - path: /<span class="keyword">data</span></span><br><span class="line">      value:</span><br><span class="line">        foo: bar</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="FederatedTypeConfig"><a href="#FederatedTypeConfig" class="headerlink" title="FederatedTypeConfig"></a>FederatedTypeConfig</h2><p>通过kubefedctl enable <target API type>创建。定义了哪些k8s api资源需要联邦，下面的例子描述了k8s ConfigMap要被联邦资源FederatedConfigMap所管理。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: core.kubefed.io/v1beta1</span><br><span class="line">kind: FederatedTypeConfig</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    meta.helm.sh/release<span class="literal">-name</span>: kubefed</span><br><span class="line">    meta.helm.sh/release<span class="literal">-namespace</span>: kube<span class="literal">-federation-system</span></span><br><span class="line">  finalizers:</span><br><span class="line">  - core.kubefed.io/federated<span class="literal">-type-config</span></span><br><span class="line">  labels:</span><br><span class="line">    app.kubernetes.io/managed<span class="literal">-by</span>: Helm</span><br><span class="line">  name: configmaps</span><br><span class="line">  namespace: kube<span class="literal">-federation-system</span></span><br><span class="line">spec:</span><br><span class="line">  federatedType:</span><br><span class="line">    <span class="built_in">group</span>: types.kubefed.io</span><br><span class="line">    kind: FederatedConfigMap</span><br><span class="line">    pluralName: federatedconfigmaps</span><br><span class="line">    scope: Namespaced</span><br><span class="line">    version: v1beta1</span><br><span class="line">  propagation: Enabled <span class="comment"># 是否启用该联邦对象</span></span><br><span class="line">  targetType:</span><br><span class="line">    kind: ConfigMap</span><br><span class="line">    pluralName: configmaps</span><br><span class="line">    scope: Namespaced</span><br><span class="line">    version: v1</span><br><span class="line">status:</span><br><span class="line">  observedGeneration: <span class="number">1</span></span><br><span class="line">  propagationController: Running</span><br><span class="line">  statusController: NotRunning</span><br></pre></td></tr></table></figure>
<h2 id="ReplicaSchedulingPreference"><a href="#ReplicaSchedulingPreference" class="headerlink" title="ReplicaSchedulingPreference"></a>ReplicaSchedulingPreference</h2><p>用来管理相同名字的FederatedDeployment或FederatedReplicaset资源，保证所有子集群的副本数为spec.totalReplicas。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: scheduling.kubefed.io/v1alpha1</span><br><span class="line">kind: ReplicaSchedulingPreference</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test-deployment</span></span><br><span class="line">  namespace: <span class="built_in">test-ns</span></span><br><span class="line">spec:</span><br><span class="line">  targetKind: FederatedDeployment</span><br><span class="line">  totalReplicas: <span class="number">9</span></span><br><span class="line">  clusters:</span><br><span class="line">    A:</span><br><span class="line">      minReplicas: <span class="number">4</span></span><br><span class="line">      maxReplicas: <span class="number">6</span></span><br><span class="line">      weight: <span class="number">1</span></span><br><span class="line">    B:</span><br><span class="line">      minReplicas: <span class="number">4</span></span><br><span class="line">      maxReplicas: <span class="number">8</span></span><br><span class="line">      weight: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用kind来在本机创建多个k8s集群的方式测试。通过kind创建两个k8s集群 kind-cluster1和kind-cluster2。<br>​</p>
<p>安装kubefedctl</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wget</span> https://github.com/kubernetes<span class="literal">-sigs</span>/kubefed/releases/download/v0.<span class="number">9.0</span>/kubefedctl<span class="literal">-0</span>.<span class="number">9.0</span><span class="literal">-linux-amd64</span>.tgz</span><br><span class="line">tar zvxf kubefedctl<span class="literal">-0</span>.<span class="number">9.0</span><span class="literal">-linux-amd64</span>.tgz</span><br><span class="line">chmod u+x kubefedctl</span><br><span class="line"><span class="built_in">mv</span> kubefedctl /usr/local/bin/</span><br></pre></td></tr></table></figure>
<p>在第一个集群安装KubeFed，在第一个集群执行如下的命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> helm repo add kubefed<span class="literal">-charts</span> https://raw.githubusercontent.com/kubernetes<span class="literal">-sigs</span>/kubefed/master/charts</span><br><span class="line"><span class="variable">$</span> helm repo list</span><br><span class="line"><span class="variable">$</span> helm <span class="literal">--namespace</span> kube<span class="literal">-federation-system</span> upgrade <span class="literal">-i</span> kubefed kubefed<span class="literal">-charts</span>/kubefed <span class="literal">--version</span>=<span class="number">0.9</span>.<span class="number">0</span> <span class="literal">--create-namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 会安装如下两个deployment，其中一个是controller，另外一个是webhook</span></span><br><span class="line"><span class="variable">$</span> kubectl  get deploy <span class="literal">-n</span> kube<span class="literal">-federation-system</span></span><br><span class="line">NAME                         READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">kubefed<span class="literal">-admission-webhook</span>    <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">7</span>m40s</span><br><span class="line">kubefed<span class="literal">-controller-manager</span>   <span class="number">2</span>/<span class="number">2</span>     <span class="number">2</span>            <span class="number">2</span>           <span class="number">7</span>m40s</span><br></pre></td></tr></table></figure>
<h1 id="子集群注册"><a href="#子集群注册" class="headerlink" title="子集群注册"></a>子集群注册</h1><p>将cluster1和cluster2集群加入到cluster1中</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubefedctl join kind<span class="literal">-cluster1</span> <span class="literal">--cluster-context</span> kind<span class="literal">-cluster1</span> <span class="literal">--host-cluster-context</span> kind<span class="literal">-cluster1</span> <span class="literal">--v</span>=<span class="number">2</span></span><br><span class="line">kubefedctl join kind<span class="literal">-cluster2</span> <span class="literal">--cluster-context</span> kind<span class="literal">-cluster2</span> <span class="literal">--host-cluster-context</span> kind<span class="literal">-cluster1</span> <span class="literal">--v</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>在第一个集群可以看到在kube-federation-system中创建出了两个新的kubefedcluster对象</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> kubectl <span class="literal">-n</span> kube<span class="literal">-federation-system</span> get kubefedcluster</span><br><span class="line">NAME            AGE   READY</span><br><span class="line">kind<span class="literal">-cluster1</span>   <span class="number">17</span>s   True</span><br><span class="line">kind<span class="literal">-cluster2</span>   <span class="number">16</span>s   True</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> apiVersion: core.kubefed.io/v1beta1</span><br><span class="line">kind: KubeFedCluster</span><br><span class="line">metadata:</span><br><span class="line">  name: kind<span class="literal">-cluster1</span></span><br><span class="line">  namespace: kube<span class="literal">-federation-system</span></span><br><span class="line">spec:</span><br><span class="line">  apiEndpoint: https://<span class="number">172.21</span>.<span class="number">115.165</span>:<span class="number">6443</span></span><br><span class="line">  caBundle: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKY201bGRHVnpNQjRYRFRJeE1USXlOREUyTlRNME9Wb1hEVE14TVRJeU1qRTJOVE0wT1Zvd0ZURVRNQkVHQTFVRQpBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTmxjCnF3UHd5cHNFc2M0aXB3QnFuRndDN044RXo2Slhqajh3ZzRybnlXTDNSdlZ0cmVua1Nha1VyYlRjZWVIck9lQTUKWGlNUVo2T1FBY25tUGU0Q2NWSkFoL2ZLQzBkeU9uL0ZZeXgyQXppRjBCK1ZNaUFhK2dvME1VMmhMZ1R5eVFGdQpDbWFmUGtsNmJxZUFJNCtCajZJUWRqY3dVMHBjY3lrNGhSTUxnQmhnTUh4NWkzVkpQckQ2Y284dHcwVnllWncyCkdDUlh2ZzlSd0QweUs5eitOVS9LVS83QjBiMTBvekpNRlVJMktPZmI4N1RkQ0h2NmlBdlVRYVdKc1BqQ0M3MzQKcnBma1ZGZXB2S2liKy9lUVBFaDE4VE5qaitveEVGMnl0Vmo2ZWVKeFc3VVZrbit0T3BxdGpEeUtKVDllNnlwdAp6U1VDTnRZWTAzckdhNTlLczBVQ0F3RUFBYU5DTUVBd0RnWURWUjBQQVFIL0JBUURBZ0trTUE4R0ExVWRFd0VCCi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZOTnRQU3hsMlMxUldOb1BCeXNIcHFoRXJONlVNQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFDME0vaktCL2dqcWRSNlRLNXJQVktSSFU2cy8xTTh2eTY2WFBiVEx4M0srazdicUFWdAoxVUFzcUZDZmNrVk91WHY3eFQ0ZHIzVzdtMHE1bDYzRGg3ZDJRZDNiQ00zY2FuclpNd01OM0lSMlpmYzR0VlBGCnRTMFFONElTa0hsYnBudXQxb0F3cy9CaXNwaXNRQ0VtbHF3Zy9xbmdPMStlWWRoWm5vRW40SEFDamF4Slc5MS8KNXlOR1pKRXdia2dYQTVCbSs3VEZRL2FiYnp5a1JvOWtTMnl5c29pMnVzcUg0ZnlVS0ZWK2RETnp3Ujh0ck16cgpjWkRBNHpaVFB1WGlYRkVsWlNRa2NJSGIyV0VsYmZNRGpKNjlyVG5wakJCOWNPQ25jaHVmK0xiOXQwN1lJQ01wCmNlK0prNVp2RElRUFlKK3hTeGdRaVJxMTFraWlKcFE4Wm1FWgotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==</span><br><span class="line">  proxyURL: <span class="string">&quot;&quot;</span></span><br><span class="line">  secretRef:</span><br><span class="line">    name: kind<span class="literal">-cluster1-dbxns</span></span><br><span class="line">status:</span><br><span class="line">  conditions:</span><br><span class="line">  - lastProbeTime: <span class="string">&quot;2021-12-24T17:00:47Z&quot;</span></span><br><span class="line">    lastTransitionTime: <span class="string">&quot;2021-12-24T17:00:07Z&quot;</span></span><br><span class="line">    message: /healthz responded with ok</span><br><span class="line">    reason: ClusterReady</span><br><span class="line">    status: <span class="string">&quot;True&quot;</span></span><br><span class="line">    <span class="built_in">type</span>: Ready</span><br></pre></td></tr></table></figure>
<p>要想将cluster2从主集群中移除，可以执行 kubefedctl unjoin kind-cluster2 –cluster-context kind-cluster2 –host-cluster-context kind-cluster1 –v&#x3D;2</p>
<h1 id="应用发布"><a href="#应用发布" class="headerlink" title="应用发布"></a>应用发布</h1><h2 id="集群联邦API"><a href="#集群联邦API" class="headerlink" title="集群联邦API"></a>集群联邦API</h2><p>kubefed将资源分为普通k8s资源类型和联邦的资源类型。在默认的场景下，kubefed已经内置将很多资源类型做了集群联邦。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> k get FederatedTypeConfig <span class="literal">-n</span> kube<span class="literal">-federation-system</span></span><br><span class="line">NAME                                            AGE</span><br><span class="line">clusterrolebindings.rbac.authorization.k8s.io   <span class="number">19</span><span class="built_in">h</span></span><br><span class="line">clusterroles.rbac.authorization.k8s.io          <span class="number">19</span><span class="built_in">h</span></span><br><span class="line">configmaps                                      <span class="number">19</span><span class="built_in">h</span></span><br><span class="line">deployments.apps                                <span class="number">19</span><span class="built_in">h</span></span><br><span class="line">ingresses.extensions                            <span class="number">19</span><span class="built_in">h</span></span><br><span class="line">jobs.batch                                      <span class="number">19</span><span class="built_in">h</span></span><br><span class="line">namespaces                                      <span class="number">19</span><span class="built_in">h</span></span><br><span class="line">replicasets.apps                                <span class="number">19</span><span class="built_in">h</span></span><br><span class="line">secrets                                         <span class="number">19</span><span class="built_in">h</span></span><br><span class="line">serviceaccounts                                 <span class="number">19</span><span class="built_in">h</span></span><br><span class="line">services                                        <span class="number">19</span><span class="built_in">h</span></span><br></pre></td></tr></table></figure>
<p>将crd资源类型集群联邦，执行 kubefedctl enable 命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> kubefedctl enable customresourcedefinitions</span><br><span class="line">I1224 <span class="number">20</span>:<span class="number">32</span>:<span class="number">54.537112</span>  <span class="number">687543</span> util.go:<span class="number">141</span>] Api resource found.</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/federatedcustomresourcedefinitions.types.kubefed.io created</span><br><span class="line">federatedtypeconfig.core.kubefed.io/customresourcedefinitions.apiextensions.k8s.io created <span class="keyword">in</span> namespace kube<span class="literal">-federation-system</span></span><br></pre></td></tr></table></figure>
<p>可以看到会多出一个名字为federatedcustomresourcedefinitions.types.kubefed.io 的CRD 资源，同时会新创建一个FederatedTypeConfig类型的资源。当创建了FederatedTypeConfig后，就可以通过创建federatedcustomresourcedefinition类型的实例来向各个子集群发布CRD资源了。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> k get crd federatedcustomresourcedefinitions.types.kubefed.io</span><br><span class="line">NAME                                                  CREATED AT</span><br><span class="line">federatedcustomresourcedefinitions.types.kubefed.io   <span class="number">2021</span><span class="literal">-12-24T12</span>:<span class="number">32</span>:<span class="number">54</span>Z</span><br><span class="line"></span><br><span class="line"><span class="variable">$</span> k get FederatedTypeConfig <span class="literal">-n</span> kube<span class="literal">-federation-system</span> customresourcedefinitions.apiextensions.k8s.io <span class="literal">-o</span> yaml</span><br><span class="line">apiVersion: core.kubefed.io/v1beta1</span><br><span class="line">kind: FederatedTypeConfig</span><br><span class="line">metadata:</span><br><span class="line">  finalizers:</span><br><span class="line">  - core.kubefed.io/federated<span class="literal">-type-config</span></span><br><span class="line">  name: customresourcedefinitions.apiextensions.k8s.io</span><br><span class="line">  namespace: kube<span class="literal">-federation-system</span></span><br><span class="line">spec:</span><br><span class="line">  federatedType:</span><br><span class="line">    <span class="built_in">group</span>: types.kubefed.io</span><br><span class="line">    kind: FederatedCustomResourceDefinition</span><br><span class="line">    pluralName: federatedcustomresourcedefinitions</span><br><span class="line">    scope: Cluster</span><br><span class="line">    version: v1beta1</span><br><span class="line">  propagation: Enabled</span><br><span class="line">  targetType:</span><br><span class="line">    <span class="built_in">group</span>: apiextensions.k8s.io</span><br><span class="line">    kind: CustomResourceDefinition</span><br><span class="line">    pluralName: customresourcedefinitions</span><br><span class="line">    scope: Cluster</span><br><span class="line">    version: v1</span><br><span class="line">status:</span><br><span class="line">  observedGeneration: <span class="number">1</span></span><br><span class="line">  propagationController: Running</span><br><span class="line">  statusController: NotRunning</span><br></pre></td></tr></table></figure>
<p>在example&#x2F;sample1下包含了很多例子，可以直接参考。接下来使用sample1中的例子进行试验。<br>​</p>
<p>在父集群创建namespace test-namespace</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> kubectl create <span class="operator">-f</span> namespace.yaml</span><br><span class="line">namespace/<span class="built_in">test-namespace</span> created</span><br></pre></td></tr></table></figure>
<p>在主集群中创建federatednamespace资源</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> k apply <span class="operator">-f</span> federatednamespace.yaml</span><br><span class="line">federatednamespace.types.kubefed.io/<span class="built_in">test-namespace</span> created</span><br></pre></td></tr></table></figure>
<p>在子集群中即可查询到新创建的namespace资源</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> k get ns <span class="built_in">test-namespace</span></span><br><span class="line">NAME             STATUS   AGE</span><br><span class="line"><span class="built_in">test-namespace</span>   Active   <span class="number">4</span>m49s</span><br></pre></td></tr></table></figure>
<p>其他的对象均可以按照跟上述namespace同样的方式来创建，比较特殊的对象为clusterrulebinding，该对象在默认情况下没有联邦api FederatedClusterRoleBinding，因此需要手工先创建FederatedClusterRoleBinding联邦api类型。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> kubefedctl enable clusterrolebinding</span><br><span class="line">I1225 <span class="number">01</span>:<span class="number">46</span>:<span class="number">42.779166</span>  <span class="number">818254</span> util.go:<span class="number">141</span>] Api resource found.</span><br><span class="line">customresourcedefinition.apiextensions.k8s.io/federatedclusterrolebindings.types.kubefed.io created</span><br><span class="line">federatedtypeconfig.core.kubefed.io/clusterrolebindings.rbac.authorization.k8s.io created <span class="keyword">in</span> namespace kube<span class="literal">-federation-system</span></span><br></pre></td></tr></table></figure>
<p>在创建完成FederatedClusterRoleBinding联邦api类型后，即可以创建出FederatedClusterRoleBinding类型的对象。</p>
<h2 id="子集群的个性化配置"><a href="#子集群的个性化配置" class="headerlink" title="子集群的个性化配置"></a>子集群的个性化配置</h2><p>通过Fedrated<Kind>中的spec.overrides来完成，可以覆盖spec.template中的内容</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: types.kubefed.io/v1beta1</span><br><span class="line">kind: FederatedDeployment</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test-deployment</span></span><br><span class="line">  namespace: <span class="built_in">test-namespace</span></span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      replicas: <span class="number">3</span></span><br><span class="line">      selector:</span><br><span class="line">        matchLabels:</span><br><span class="line">          app: nginx</span><br><span class="line">      template:</span><br><span class="line">        metadata:</span><br><span class="line">          labels:</span><br><span class="line">            app: nginx</span><br><span class="line">        spec:</span><br><span class="line">          containers:</span><br><span class="line">          - image: nginx</span><br><span class="line">            name: nginx</span><br><span class="line">  placement:</span><br><span class="line">    clusters:</span><br><span class="line">    - name: cluster2</span><br><span class="line">    - name: cluster1</span><br><span class="line">  overrides:</span><br><span class="line">  - clusterName: cluster2</span><br><span class="line">    clusterOverrides:</span><br><span class="line">    - path: <span class="string">&quot;/spec/replicas&quot;</span></span><br><span class="line">      value: <span class="number">5</span></span><br><span class="line">    - path: <span class="string">&quot;/spec/template/spec/containers/0/image&quot;</span></span><br><span class="line">      value: <span class="string">&quot;nginx:1.17.0-alpine&quot;</span></span><br><span class="line">    - path: <span class="string">&quot;/metadata/annotations&quot;</span></span><br><span class="line">      op: <span class="string">&quot;add&quot;</span></span><br><span class="line">      value:</span><br><span class="line">        foo: bar</span><br><span class="line">    - path: <span class="string">&quot;/metadata/annotations/foo&quot;</span></span><br><span class="line">      op: <span class="string">&quot;remove&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="多集群应用调度"><a href="#多集群应用调度" class="headerlink" title="多集群应用调度"></a>多集群应用调度</h2><h3 id="发布应用到特定的子集群"><a href="#发布应用到特定的子集群" class="headerlink" title="发布应用到特定的子集群"></a>发布应用到特定的子集群</h3><p>在Fedrated<Kind>的spec.placement.clusters中，定义了要发布到哪个子集群的信息。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">placement:</span><br><span class="line">    clusters:</span><br><span class="line">    - name: cluster2</span><br><span class="line">    - name: cluster1</span><br></pre></td></tr></table></figure>
<p>不过上述方法需要指定特定的集群，为了有更丰富的灵活性，kubefed还提供了label selector的机制，可以提供spec.placement.clusterSelector来指定一组集群。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">  placement:</span><br><span class="line">    clusters: []</span><br><span class="line">    clusterSelector:</span><br><span class="line">      matchLabels:</span><br><span class="line">        foo: bar</span><br></pre></td></tr></table></figure>
<p>标签选择器通过跟kubefedclusters对象的label来进行匹配，可以执行下述命令给kubefedclusters来打标签。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl label kubefedclusters <span class="literal">-n</span> kube<span class="literal">-federation-system</span> kind<span class="literal">-cluster1</span> foo=bar</span><br></pre></td></tr></table></figure>

<h3 id="子集群差异化调度"><a href="#子集群差异化调度" class="headerlink" title="子集群差异化调度"></a>子集群差异化调度</h3><p>上述调度功能被选择的子集群为平等关系，如果要想子集群能够有所差异，可以使用ReplicaSchedulingPreference来完成，目前仅支持deployment和replicaset两种类型的资源，还不支持statefulset。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">apiVersion: scheduling.kubefed.io/v1alpha1</span><br><span class="line">kind: ReplicaSchedulingPreference</span><br><span class="line">metadata:</span><br><span class="line">  name: <span class="built_in">test-deployment</span></span><br><span class="line">  namespace: <span class="built_in">test-ns</span></span><br><span class="line">spec:</span><br><span class="line">  targetKind: FederatedDeployment</span><br><span class="line">  totalReplicas: <span class="number">9</span></span><br><span class="line">  clusters:</span><br><span class="line">    A:</span><br><span class="line">      minReplicas: <span class="number">4</span></span><br><span class="line">      maxReplicas: <span class="number">6</span></span><br><span class="line">      weight: <span class="number">1</span></span><br><span class="line">    B:</span><br><span class="line">      minReplicas: <span class="number">4</span></span><br><span class="line">      maxReplicas: <span class="number">8</span></span><br><span class="line">      weight: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>spec.targetKind用来指定管理的类型，仅支持FederatedDeployment和FederatedReplicaset。<br>spec.totalReplicas用来指定所有子集群的副本数总和。优先级要高于FederatedDeployment和FederatedReplicaset的spec.template中指定的副本数。<br>spec.clusters用来指定每个子集群的最大、最小副本数和权重。<br>spec.rebalance自动调整整个集群中的副本数，比如一个集群中的pod挂掉后，可以将pod迁移到另外的集群中。</p>
<h1 id="子集群之间的交互"><a href="#子集群之间的交互" class="headerlink" title="子集群之间的交互"></a>子集群之间的交互</h1><p>无</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ol>
<li>父集群充当了所有集群的单一控制面</li>
<li>通过联邦CRD来管理资源，无法直接使用k8s原生的资源，集群间维护CRD版本和API版本一致性导致升级比较复杂。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>官方文档：<a href="https://github.com/kubernetes-sigs/kubefed/blob/master/docs/userguide.md#using-cluster-selector">https://github.com/kubernetes-sigs/kubefed/blob/master/docs/userguide.md#using-cluster-selector</a></li>
</ul>
]]></content>
      <tags>
        <tag>多集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Kubernetes组织下开源项目（持续更新）</title>
    <url>/post/kubernetes-opensource-project/</url>
    <content><![CDATA[<p>在k8s官方的Github kubernetes group下除了k8s的核心组件外，还有很多开源项目，本文用来简要分析这些开源项目的用途。</p>
<h1 id="apimachinery"><a href="#apimachinery" class="headerlink" title="apimachinery"></a><a href="https://github.com/kubernetes/apimachinery">apimachinery</a></h1><p>关于k8s的scheme等的sdk项目，代码跟kubernetes项目的如下路径保持同步：<br><a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery">https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery</a></p>
<h1 id="autoscaler"><a href="#autoscaler" class="headerlink" title="autoscaler"></a><a href="https://github.com/kubernetes/autoscaler">autoscaler</a></h1><p>跟k8s的弹性扩缩容相关的组件，有如下两个功能：</p>
<h2 id="vpa（pod垂直扩缩容）"><a href="#vpa（pod垂直扩缩容）" class="headerlink" title="vpa（pod垂直扩缩容）"></a>vpa（pod垂直扩缩容）</h2><p>k8s的kube-controller-manager默认支持了hpa功能，即水平扩缩容。同时k8s还提供了vpa功能，即垂直扩缩容，会根据pod历史的资源占用，修改pod的request值，并不会修改pod的limit值。之所以k8s没有默认提供vpa功能，原因是因为vpa实现要复杂很多，需要通过webhook的技术来在pod创建的时候修改pod的request值。vpa的功能通常用于大型单体应用。</p>
<p>autoscaler的功能之一即提供了vpa的实现。</p>
<h2 id="Cluster-Autoscaler（node节点自动扩缩容）"><a href="#Cluster-Autoscaler（node节点自动扩缩容）" class="headerlink" title="Cluster Autoscaler（node节点自动扩缩容）"></a>Cluster Autoscaler（node节点自动扩缩容）</h2><p>该功能是为了重新利用k8s node的节点资源，在节点资源不足的时候可以动态创建资源，在节点资源空闲的时候可以自动回收资源。k8s node的创建和释放需要公有云平台的支持，该功能对接了多个公有云厂商的api。</p>
<h1 id="cloud-provider"><a href="#cloud-provider" class="headerlink" title="cloud-provider"></a><a href="https://github.com/kubernetes/cloud-provider">cloud-provider</a></h1><p>k8s的cloud provider功能用来跟云厂商对接以实现对k8s的node、LoadBalancer Service管理，比如LoadBalancer Service申请vip需要跟云厂商的LB API进行对接。</p>
<p>在k8s 1.6版本之前，cloud provider的代码完全是耦合在k8s的kube-apiserver、kubelet、kube-contorller-manager的代码中的，如果要支持更多的云厂商，只能修改k8s的代码，扩展性比较差。</p>
<p>从k8s 1.6版本之后，cloud provider作为单独的二进制组件来提供服务，并提供了接口定义。本项目为非二进制项目，仅包含k8s的cloud-provider机制的接口定义，为了让第三方的cloud-provider的实现项目引用接口定义方便，将kubernetes项目中的定义为单独的项目，且代码跟<a href="https://github.com/kubernetes/kubernetes/tree/master/staging/src/k8s.io/cloud-provider">kubernetes项目</a>中的保持同步。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/a_540yJ1EGVroJ9TpvYtPw">从 K8S 的 Cloud Provider 到 CCM 的演进之路</a></li>
</ul>
<h1 id="Descheduler"><a href="#Descheduler" class="headerlink" title="Descheduler"></a>Descheduler</h1><p>项目地址：<a href="https://github.com/kubernetes-sigs/descheduler">https://github.com/kubernetes-sigs/descheduler</a></p>
<p>k8s的pod调度完全动态的，kube-scheduler组件在调度pod的时候会根据当时k8s集群的运行时环境来决定pod可以调度的节点，可以保证pod的调度在当时是最优的。但是随着的推移，比如环境中增加了新的node、创建了一批亲和节点的pod，都有可能会导致如果相同的pod再重新调度会到其他的节点上。但k8s的设计是，一旦pod调度完成后，就不会再重新调度。</p>
<p>Descheduler组件用来解决pod的重新调度问题，可以根据配置的一系列的规则来触发驱逐pod，让pod可以重新调度，从而使k8s集群内的pod尽可能达到最优状态，有点类似于计算机在运行了一段时间后的磁盘脆片整理功能。Descheduler组件可以以job、cronjob或者deployment的方式运行在k8s集群中。</p>
<h1 id="kubernetes-template-project"><a href="#kubernetes-template-project" class="headerlink" title="kubernetes-template-project"></a><a href="https://github.com/kubernetes/kubernetes-template-project">kubernetes-template-project</a></h1><p>用来存放了k8s项目的标准模板，里面包含了一些必要的文件，新建的项目可以fork该项目。</p>
<h1 id="node-problem-detector-npd"><a href="#node-problem-detector-npd" class="headerlink" title="node-problem-detector(npd)"></a>node-problem-detector(npd)</h1><p>项目地址：<a href="https://github.com/kubernetes/node-problem-detector">https://github.com/kubernetes/node-problem-detector</a></p>
<p>k8s的管控组件对于iaas层的node运行状态是完全不感知的，比如节点出现了ntp服务挂掉、硬件告警（cpu、内存、磁盘故障）、内核死锁。node-problem-detector旨在将node节点的问题转换k8s node event，以DaemonSet的方式部署在所有的k8s节点上。</p>
<p>上报故障的方式支持如下两种方式：</p>
<ul>
<li>对于永久性故障，通过修改node status中的condition上报给apiserver</li>
<li>对于临时性故障，通过Event的方式上报</li>
</ul>
<p>node-problem-detector在将节点的故障信息上报给k8s后，通常会配合一些自愈系统搭配使用，比如Draino和Descheduler 。</p>
<h1 id="sample-apiserver"><a href="#sample-apiserver" class="headerlink" title="sample-apiserver"></a><a href="https://github.com/kubernetes/sample-apiserver">sample-apiserver</a></h1><p>k8s提供了aggregated apiserver的方式来扩展api，该项目为一个简单的aaggregated apiserver的例子，可以直接编译出二进制文件。要想开发一个AA类型的服务，只需要frok一下该项目，并在项目的基础上进行修改即可完成。</p>
<p>相关资料：</p>
<ul>
<li>[Set up an Extension API Server](Set up an Extension API Server)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>大规模C++程序设计第1部分读书笔记</title>
    <url>/post/large_scale_c++_software_desigin_part_1/</url>
    <content><![CDATA[<h1 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h1><p>声明将一个名字引入到了程序中，；定义提供了一个实体（如类型、实例、函数）在程序中的唯一描述，为变量分配存储空间；</p>
<p>在一个给定的作用于中重复一个给定的声明是合法的，而重复定义是非法的。声明仅对当前编译单元有效，仅会在.o文件中加入了一个未定义符号。特定的类型不必与实际的定义类型匹配。</p>
<h1 id="内部链接和外部链接"><a href="#内部链接和外部链接" class="headerlink" title="内部链接和外部链接"></a>内部链接和外部链接</h1><p>内部链接和外部链接是根据链接过程中一个符号是在编译单元内部还是外部进行划分的，编译单元是按照一个.c或.cpp文件的作用域进行划分的。</p>
<p>内部链接：一个标识符对于编译单元（一个目标文件）来说是局部的，并在链接时与其他编译单元中的标识符不冲突。</p>
<p>内部链接包括：</p>
<ul>
<li>static类型的变量、函数</li>
<li>const类型的变量</li>
<li>枚举类型的定义</li>
<li>typedef定义的类型</li>
<li>class、struct、union的定义</li>
<li>inline函数</li>
</ul>
<p>外部链接：在多文件程序中，链接时这个标识符可以和其他编译单元交互。这些外部符号在程序中必须是唯一的，用来被其他编译单元中未定义的符号访问。</p>
<p>将带有外部链接的定义放在头文件中是错误的。</p>
<p>外部链接包括：</p>
<ul>
<li>类的非内联成员函数</li>
<li>非内联且非static函数</li>
<li>类的static数据成员</li>
</ul>
<h1 id="const类型的变量为内部链接的实例"><a href="#const类型的变量为内部链接的实例" class="headerlink" title="const类型的变量为内部链接的实例"></a>const类型的变量为内部链接的实例</h1><p>test1.h内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>test1.cpp内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_length = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;max_length=%d\n&quot;</span>, max_length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test2.h内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>test2.cpp内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_length = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;max_length=%d\n&quot;</span>, max_length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.cpp内容如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">print1</span>();</span><br><span class="line">	<span class="built_in">print2</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从实例可以看出在全局作用域内声明的const类型的变量为内部链接的，在多个文件的作用域中分别定义相同的const类型的变量并不会产生冲突。</p>
<h1 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h1><p>直接访问类的数据成员违反了面向对象中的封装原则，应该将类的数据成员私有化，并提供接口供部访问，类似于java bean规范。</p>
<p>避免使用全局变量，应该将全局变量封装到类中，并提供接口供外部访问。</p>
<p>为避免命名冲突，将全局函数封装到类中。</p>
<p>避免在头文件的作用域中使用enum、typedef和const数据，应该将这些数据封装到头文件的类作用域中。</p>
<p>在头文件中只应该包含如下内容：类、结构体、联合体和运算符函数的声明，类、结构体、联合体和内联函数的定义。</p>
]]></content>
  </entry>
  <entry>
    <title>大型网站技术架构读书笔记</title>
    <url>/post/large_website_architecture/</url>
    <content><![CDATA[<p>最近粗读了一遍《大型网站技术架构-核心原理与案例分析》，并对其中的内容通过思维导图的形式进行了整理。本书的所讲解的内容均为大型网站中涉及到的问题及相关技术，但并未展开深入讨论相关技术的解决办法，非常适合入门。下面我将我的思维导图以图片的形式贴出来，并提供XMind编辑的.xmid格式的文件。</p>
<p><img src="http://kuring.qiniudn.com/large_website_architecture.png"></p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="http://pan.baidu.com/s/1lngiq">大型网站技术架构读书笔记</a></p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Unique Binary Search Trees II</title>
    <url>/post/leetcode_unique_binary_search_trees_ii/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Given n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p>
<p>For example,<br>Given n &#x3D; 3, your program should return all 5 unique BST’s shown below.</p>
<pre style="font-family: Courier, monospace;">
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre>

<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>要想能够生成多个树并存储到vector中，最容易想到的就是递归算法。要想能够递归，题目中提供的函数仅有一个参数，结合题目不能够完成递归的条件，考虑到unique binary search trees中的解法，需要递归具有两个参数的函数。</p>
<p>考虑到了递归的问题，还需要利用循环不断将树添加到vector中，这编写起来也是比较有难度，需要掌握循环的次数和什么时候将树添加到vector中。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;TreeNode *&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	vector&lt;TreeNode *&gt; sub_tree = <span class="built_in">generateTrees</span>(<span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">return</span> sub_tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;TreeNode *&gt; <span class="title">generateTrees</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">	vector&lt;TreeNode *&gt; result;</span><br><span class="line">	<span class="keyword">if</span> (low &gt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		result.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (low == high)</span><br><span class="line">	&#123;</span><br><span class="line">		TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(low);</span><br><span class="line">		result.<span class="built_in">push_back</span>(node);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=low; i&lt;=high; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		vector&lt;TreeNode *&gt; left = <span class="built_in">generateTrees</span>(low, i - <span class="number">1</span>);</span><br><span class="line">		vector&lt;TreeNode *&gt; right = <span class="built_in">generateTrees</span>(i + <span class="number">1</span>, high);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;left.<span class="built_in">size</span>(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;right.<span class="built_in">size</span>(); k++)</span><br><span class="line">			&#123;</span><br><span class="line">				TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">				root-&gt;left = left[j];</span><br><span class="line">				root-&gt;right = right[k];</span><br><span class="line">				result.<span class="built_in">push_back</span>(root);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux From Scratch学习笔记</title>
    <url>/post/lfs/</url>
    <content><![CDATA[<p>最近买了本新书《深度探索Linux操作系统》，在按照书中步骤学习的过程中，无奈在安装步骤中出错，于是只能到网上找书评。在浏览书评的过程中偶然看到LFS三个名词，google之，发现是手动安装Linux的官方学习手册，学习之。</p>
<h1 id="解压命令"><a href="#解压命令" class="headerlink" title="解压命令"></a>解压命令</h1><p>一直对解压命令的参数记不清楚，记录一下：<br>tar -Jvxf *.tar.xz<br>tar -zvxf *.tar.gz<br>tar -xvf *.tar.bz2</p>
<h1 id="将一般用户可以使用sudo命令执行命令的方法"><a href="#将一般用户可以使用sudo命令执行命令的方法" class="headerlink" title="将一般用户可以使用sudo命令执行命令的方法"></a>将一般用户可以使用sudo命令执行命令的方法</h1><p>执行visudo命令来修改文件内容，将本用户添加到文本文件中。修改的文件为&#x2F;etc&#x2F;sudoers，该文件默认为只读的，但是可以通过visudo命令来修改。</p>
<h1 id="login-shell和non-login-shell"><a href="#login-shell和non-login-shell" class="headerlink" title="login shell和non-login shell"></a>login shell和non-login shell</h1><p>login shell：shell会重新读取&#x2F;etc&#x2F;profile和<del>&#x2F;.bash_profile来应用新的环境变量。通过<code>su - 用户名</code>的方式登录为login shell方式。<br>non-login shell：此时shell不会读取&#x2F;etc&#x2F;profile和</del>&#x2F;.bash_profile，而是读取~&#x2F;.bashrc来应用新的环境变量。通过<code>su 用户名</code>登录的方式为non-login shell方式。</p>
<p>文中lfs用户下的~&#x2F;.bash_profile的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec env -i HOME=$HOME TERM=$TERM PS1=&#x27;\u:\w\$ &#x27; /bin/bash</span><br></pre></td></tr></table></figure>

<p>而lfs用户下的~&#x2F;.bashrc文件的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set +h</span><br><span class="line">umask 022</span><br><span class="line">LFS=/mnt/lfs</span><br><span class="line">LC_ALL=POSIX</span><br><span class="line">LFS_TGT=$(uname -m)-lfs-linux-gnu</span><br><span class="line">PATH=/tools/bin:/bin:/usr/bin</span><br><span class="line">export LFS LC_ALL LFS_TGT PATH</span><br></pre></td></tr></table></figure>

<p>而最令人奇怪的是即使通过<code>su - lfs</code>命令登录也会执行到.bashrc文件的内容，不信可以通过在.bash_profile和.bashrc文件的开始地方打印内容来验证。之所以出现如此奇怪的问题，原因在于~&#x2F;.bash_profile中的命令。其中exec命令和linux系统中的exec系列函数的含义是一致的，即在当前bash中直接执行exec后面的命令，而不用fork一个新的进程来执行。env命令会通过当前用户的HOME和TERM环境变量及自定义的PS1环境变量来执行新的&#x2F;bin&#x2F;bash，而新执行的bash为non-login shell方式，因此会执行lfs用户下的.bahsrc文件。</p>
<p>总结一下，就是~&#x2F;.bash_profile文件中的env命令通过non-login shell方式执行了新的bash，exec命令的作用是不在当前bash中执行新的bash，而不是通过产生一个新进程的方式来执行bash。</p>
<h1 id="POSIX-amp-amp-FHS-amp-amp-LSB"><a href="#POSIX-amp-amp-FHS-amp-amp-LSB" class="headerlink" title="POSIX &amp;&amp; FHS &amp;&amp; LSB"></a>POSIX &amp;&amp; FHS &amp;&amp; LSB</h1><p><a href="http://pubs.opengroup.org/onlinepubs/9699919799/">POSIX.1-2008</a>，通过该网站来查询系统函数等非常方便。<br>Filesystem Hierarchy Standard (FHS)<br><a href="http://www.pathname.com/fhs/pub/fhs-2.3.html">Filesystem Hierarchy Standard (FHS)</a>，可以通过此标准来学习Linux的目录含义。<br><a href="http://refspecs.linuxfoundation.org/lsb.shtml">Linux Standard Base (LSB) Specifications</a></p>
<h1 id="set-h"><a href="#set-h" class="headerlink" title="set +h"></a>set +h</h1><p>The set +h command turns off bash’s hash function. Hashing is ordinarily a useful feature—bash uses a hash table to remember the full path of executable files to avoid searching the PATH time and again to find the same executable.</p>
<h1 id="虚拟终端PTYs"><a href="#虚拟终端PTYs" class="headerlink" title="虚拟终端PTYs"></a>虚拟终端PTYs</h1><p>PTY 设备与终端设备（terminal device）相类似——它接受来自键盘的输入，并将文字传递给运行在其上的程序以备输出。PTY 被依次编号，且每个 PTY 的编号就是它在 &#x2F;dev&#x2F;pts 目录中对应设备文件的文件名。</p>
<h1 id="devpts-file-system"><a href="#devpts-file-system" class="headerlink" title="devpts file system"></a>devpts file system</h1><p>远程登陆(telnet,ssh等)后创建的控制台设备文件所在的目录。 </p>
<h1 id="specs文件"><a href="#specs文件" class="headerlink" title="specs文件"></a>specs文件</h1><p>gcc 是一个驱动式的程序. 它调用其它程序来依次进行编译, 汇编和链接. GCC 分析命令行参数, 然后决定该调用哪一个子程序, 哪些参数应该传递给子程序. 所有这些行为都是由 SPEC 字符串(spec strings)来控制的. 通常情况下, 每一个 GCC 可以调用的子程序都对应着一个 SPEC 字符串, 不过有少数的子程序需要多个 SPEC 字符串来控制他们的行为.</p>
<h1 id="查看当前shell"><a href="#查看当前shell" class="headerlink" title="查看当前shell"></a>查看当前shell</h1><ol>
<li>查看默认shell可以用命令：<code>echo $SHELL</code>。</li>
<li>查看当前shell：<code>ps | grep $$ | awk &#39;&#123;print $4&#125;&#39; </code>。</li>
<li>通过输入一个不存在的命令来查看，如输入tom，可显示<code>bash: tom: command not found</code>，说明当前的shell为bash。</li>
</ol>
<h1 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h1><p>一种提供自动交互的脚本语言。</p>
<h1 id="tee命令"><a href="#tee命令" class="headerlink" title="tee命令"></a>tee命令</h1><p>重定向输出到多个文本文件命令。</p>
<h1 id="pkg-config"><a href="#pkg-config" class="headerlink" title="pkg-config"></a>pkg-config</h1><p>configure脚本在检查相应依赖环境时(例：所依赖软件的版本、相应库版本等)，通常会通过pkg-config的工具来检测相应依赖环境。</p>
<p>详细内容见：<a href="http://www.mike.org.cn/articles/description-configure-pkg-config-pkg_config_path-of-the-relations-between/">简述configure、pkg-config、pkg_config_path三者的关系</a></p>
]]></content>
  </entry>
  <entry>
    <title>linux auditd</title>
    <url>/post/linux-auditd/</url>
    <content><![CDATA[<h2 id="audit简介"><a href="#audit简介" class="headerlink" title="audit简介"></a>audit简介</h2><p>audit为linux内核安全体系的重要组成部分，用来记录内核的系统调用，文件修改等事件，用于审计目的。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/linux_audit.png"></p>
<ul>
<li>auditctl: 面向用户的工具，类似于iptables命令</li>
<li>auditd: 负责将审计信息写入到&#x2F;var&#x2F;</li>
</ul>
<h2 id="启动auditd服务"><a href="#启动auditd服务" class="headerlink" title="启动auditd服务"></a>启动auditd服务</h2><p>auditd作为单独的服务运行在系统上，Redhat系统使用<code>systemctl start auditd</code>启动服务，启动后通过 <code>ps -ef | grep auditd</code>查看进程是否启动成功。</p>
<h2 id="auditctl"><a href="#auditctl" class="headerlink" title="auditctl"></a>auditctl</h2><p>查看auditd的运行状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ auditctl -s</span><br><span class="line">enabled 1</span><br><span class="line">failure 1</span><br><span class="line">pid 638</span><br><span class="line">rate_limit 0</span><br><span class="line">backlog_limit 8192</span><br><span class="line">lost 0</span><br><span class="line">backlog 0</span><br><span class="line">loginuid_immutable 0 unlocked</span><br></pre></td></tr></table></figure>

<p>查看当前环境规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ auditctl -l</span><br><span class="line">-w /tmp/hosts -p rwxa</span><br><span class="line">-w /proc/sys/net/ipv4/tcp_retries1 -p rwxa</span><br><span class="line">-w /proc/sys/net/ipv4/tcp_retries2 -p rwxa</span><br><span class="line">-w /proc/sys/net/ipv4/tcp_retries2 -p wa</span><br></pre></td></tr></table></figure>

<p>删除所有的audit规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ auditctl -D</span><br><span class="line">No rules</span><br></pre></td></tr></table></figure>

<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="监控文件变化"><a href="#监控文件变化" class="headerlink" title="监控文件变化"></a>监控文件变化</h3><ol>
<li>执行 auditctl -w $file -p wa 来监控文件，比如监控内核参数 auditctl -w &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_retries2 -p wa，其中-p指定了监控文件的行为，支持rwxa。</li>
<li>查看文件 cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_retries2。</li>
<li>使用vim打开文件 vim &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_retries2。</li>
<li>执行 ausearch -f &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_retries2 命令查看，可以看到如下的日志</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ausearch -f /proc/sys/net/ipv4/tcp_retries1</span><br><span class="line">----</span><br><span class="line">time-&gt;Mon Mar 28 12:44:48 2022</span><br><span class="line">type=PROCTITLE msg=audit(1648442688.159:6232591): proctitle=76696D002F70726F632F7379732F6E65742F697076342F7463705F7265747269657331</span><br><span class="line">type=PATH msg=audit(1648442688.159:6232591): item=1 name=&quot;/proc/sys/net/ipv4/tcp_retries1&quot; inode=46629229 dev=00:03 mode=0100644 ouid=0 ogid=0 rdev=00:00 objtype=NORMAL cap_fp=0000000000000000 cap_fi=0000000000000000 cap_fe=0 cap_fver=0</span><br><span class="line">type=PATH msg=audit(1648442688.159:6232591): item=0 name=&quot;/proc/sys/net/ipv4/&quot; inode=8588 dev=00:03 mode=040555 ouid=0 ogid=0 rdev=00:00 objtype=PARENT cap_fp=0000000000000000 cap_fi=0000000000000000 cap_fe=0 cap_fver=0</span><br><span class="line">type=CWD msg=audit(1648442688.159:6232591):  cwd=&quot;/root&quot;</span><br><span class="line">type=SYSCALL msg=audit(1648442688.159:6232591): arch=c000003e syscall=2 success=yes exit=3 a0=11687a0 a1=241 a2=1a4 a3=7ffe33dc14e0 items=2 ppid=8375 pid=8629 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts1 ses=250225 comm=&quot;vim&quot; exe=&quot;/usr/bin/vim&quot; key=(null)</span><br></pre></td></tr></table></figure>

<h3 id="监控文件夹变化"><a href="#监控文件夹变化" class="headerlink" title="监控文件夹变化"></a>监控文件夹变化</h3><p>监控文件夹同样采用跟上述文件相同的方式，但有个问题是如果文件夹下内容较多，会一起监控，从而导致audit的log内容过多。</p>
<h3 id="监控系统定期reboot"><a href="#监控系统定期reboot" class="headerlink" title="监控系统定期reboot"></a>监控系统定期reboot</h3><p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auditctl -w /bin/systemctl -p rwxa -k systemd_call</span><br><span class="line">auditctl -a always,exit -F arch=b64 -S reboot -k reboot_call</span><br></pre></td></tr></table></figure>

<p>待系统重启后执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ausearch -f reboot</span><br></pre></td></tr></table></figure>

<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/chap-system_auditing">RedHat auditd文档</a></p>
]]></content>
  </entry>
  <entry>
    <title>Linux TCP backlog</title>
    <url>/post/linux-backlog/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/tcp_connect.webp"></p>
<p>一个正常的tcp server在处理请求时会经过如下的系统调用：socket() bind() listen() accept() read() write() close()。一个请求在被应用程序读取之前，可能处于SYN_RCVD和ESTABLISHED两种状态。</p>
<p>第一个队列：SYN_RCVD状态是server端接收到了client端的SYN包，server端会将该连接放到半连接队列中，并向客户端发送SYN+ACK包，此时连接处于半连接状态。通常该队列被称为半连接队列。</p>
<p>第二个队列：ESTABLISHED状态为已经完成了三次握手，但是server端的应用程序还未调用accept系统调用的情况。通常该队列被称为全连接队列。</p>
<p>这两种情况下都需要操作系统提供相应队列来保存连接状态。</p>
<p>backlog用来设置这两个队列的最大值，但在不同的操作系统中有不同的含义，下面的说明以linux操作系统为准。</p>
<p>其中第一个维护SYN_RCVD状态的队列使用内核参数<code>net.ipv4.tcp_max_syn_backlog</code>来控制，如果队列超过这一阈值，连接会被拒绝。该值默认为1000.</p>
<p>第二个维护ESTABLISHED状态的队列，该队列的长度由应用程序调用listen系统调用时指定。</p>
<h1 id="内核参数"><a href="#内核参数" class="headerlink" title="内核参数"></a>内核参数</h1><ol>
<li>net.ipv4.tcp_max_syn_backlog</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp_max_syn_backlog (integer; default: see below; since Linux 2.2)</span><br><span class="line">              The  maximum number of queued connection requests which have still not received an acknowledgement from the connecting client.  If this number is exceeded, the kernel will begin dropping requests.  The default value of 256 is increased to 1024 when the memory present in the system is adequate or greater (&gt;= 128Mb), and  reduced  to 128  for  those systems with very low memory (&lt;= 32Mb).  It is recommended that if this needs to be increased above 1024, TCP_SYNQ_HSIZE in include/net/tcp.h be modified to keep TCP_SYNQ_HSIZE*16&lt;=tcp_max_syn_backlog, and the kernel be recompiled.</span><br></pre></td></tr></table></figure>

<p>用来设置 syn 队列的大小，通常也会称为半连接队列。该参数的默认值一般为 1024。如果 syn 队列满，此时 syn 报文会被丢弃，无法回复 syn + ack 报文。可以通过 <code>netstat -s</code> 命令看到 “XX SYNs to LISTEN sockets dropped”. 的报错信息。</p>
<ol start="2">
<li>net.ipv4.tcp_syncookies</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp_syncookies (Boolean; since Linux 2.2) Enable TCP syncookies. The kernel must be compiled with CONFIG_SYN_COOKIES.  Send out syncookies when the syn backlog queue of a socket overflows.  The syncookies feature attempts to protect a socket from a SYN flood attack.  This should be used as a last resort, if at all.  This is a violation of the  TCP  protocol,  and  con‐ flicts  with other areas of TCP such as TCP extensions.  It can cause problems for clients and relays.  It is not recommended as a tuning mechanism for heavily loaded servers to help with overloaded or misconfigured conditions.  For recommended alternatives see tcp_max_syn_backlog, tcp_synack_retries, and tcp_abort_on_overflow.</span><br></pre></td></tr></table></figure>

<p>因为 syn 队列的存在，当客户端一直在发送 syn 包，但是不回 ack 报文时，一旦服务端的队列超过 <code>net.ipv4.tcp_max_syn_backlog</code> 设置的大小就会存在队列溢出的问题，从而导致服务端无法响应客户端的请求，这就是 syn flood 攻击。</p>
<p>为了防止 syn flood 攻击，引入了 syn cookies 机制，该机制并非 tcp 协议的一部分。原理参见：<a href="https://segmentfault.com/a/1190000019292140">深入浅出TCP中的SYN-Cookies</a></p>
<p>一旦开启了 syn cookies 机制后，即使 syn 队列满，仍可以对新建的连接回复 syn + ack 报文，但是不需要进入队列。</p>
<p>因为 syn cookies 存在部分缺陷，只有当 syn 队列满时该特性才会生效。</p>
<ol start="3">
<li>net.ipv4.tcp_abort_on_overflow</li>
</ol>
<p>在三次握手完成后，该连接会进入到 ESTABLISHED 状态，并将该连接放入到用户程序队列中。若该队列已满，默认会将该连接重新设置为 SYN_ACK 状态，相当于是服务端没有接收到客户端的 syn + ack 报文，后续可以利用客户端的重传机制重新接收报文。</p>
<p>一旦开启了 <code>net.ipv4.tcp_abort_on_overflow</code> 选项后，会直接发送 RST 报文给到客户端，客户端会终止该连接，并报错 <code>104 Connection reset by peer</code>。</p>
<ol start="4">
<li>net.core.somaxconn</li>
</ol>
<p>全连接队列的最大值，该配置为全局默认配置。单个 socket 的全连接队列的长度选择为 Min(backlog, somaxconn)。</p>
<h1 id="内核源码"><a href="#内核源码" class="headerlink" title="内核源码"></a>内核源码</h1><p>在整个内核模块中主要涉及到 listen() 和 accept() 系统调用，listen() 系统调用的作用是申请和初始化半连接队列和全连接队列。队列位于内核代码的 include&#x2F;net&#x2F;inet_connection_sock.h 中的如下位置:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inet_connection_sock</span> &#123;</span></span><br><span class="line">	<span class="comment">/* inet_sock has to be the first member! */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span>	  <span class="title">icsk_inet</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request_sock_queue</span> <span class="title">icsk_accept_queue</span>;</span> <span class="comment">// 队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_bind_bucket</span>	  *<span class="title">icsk_bind_hash</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何参看"><a href="#如何参看" class="headerlink" title="如何参看"></a>如何参看</h1><p>查看 tcp 状态为 SYN_RECV 的链接即为半连接状态的请求：<code>netstat -napt | grep SYN_RECV</code>。也可以通过 <code>netstat -s | grep &#39;SYNs to LISTEN&#39;</code> 查看。</p>
<p>全连接队列可以使用 <code>ss -nlt | grep 8080</code> 的方式查看 Recv-Q 的值。<br>也可通过如下命令来查看全连接队列的溢出情况。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">netstat -s | grep overflow</span></span><br><span class="line">    3255 times the listen queue of a socket overflowed</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Linux Buffer与Cache的含义</title>
    <url>/post/linux-buffer-cache/</url>
    <content><![CDATA[<p>Linux中的Buffer与Cache的含义通常非常容易混淆，两者翻译成中文都可以叫做缓存，都是数据在内存中的临时存储，而且网络上很多文章都是错误的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           125G         12G        347M        9.3M        113G        113G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure>

<p>free命令直接将buff和cache写到了一块，说明两者有很多共同点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vmstat 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 7  1      0 364076  18664 118624552    0    0   214 11198  106  118  6  4 89  1  0</span><br><span class="line">13  1      0 349096  18664 118638192    0    0     0 1012404 171031 270124 20 13 66  2  0</span><br></pre></td></tr></table></figure>

<p>而通过vmstat命令可以分别看到buffer和cache的大小，单位为KB。</p>
<p>使用<code>man free</code>命令看到的解释如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buffers: Memory used by kernel buffers (Buffers in /proc/meminfo)</span><br><span class="line"></span><br><span class="line">cache: Memory used by the page cache and slabs (Cached and Slab in /proc/meminfo)</span><br></pre></td></tr></table></figure>

<p>查看proc的man手册结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Buffers %lu</span><br><span class="line">    Relatively temporary storage for raw disk blocks that shouldn&#x27;t get tremendously large (20MB or so).</span><br><span class="line"></span><br><span class="line">Cached %lu</span><br><span class="line">    In-memory cache for files read from the disk (the pagecache).  Doesn&#x27;t include SwapCached.</span><br><span class="line"></span><br><span class="line">SReclaimable %lu (since Linux 2.6.19)</span><br><span class="line">    Part of Slab, that might be reclaimed, such as caches.</span><br><span class="line"></span><br><span class="line">SUnreclaim %lu (since Linux 2.6.19)</span><br><span class="line">    Part of Slab, that cannot be reclaimed on memory pressure.</span><br></pre></td></tr></table></figure>

<p>上述信息，文档写的并不是非常明确。</p>
<p>可以看出buffers是磁盘数据的缓存，通常不会特别大，缓存的数据包括磁盘的写请求和读请求。内核用于将分散的写磁盘操作集中起来，批量写入磁盘。</p>
<p>Cached是文件数据的缓存，同样可以缓存读请求和写请求。</p>
<p>Slab包括了SReclaimalbe和Sunreclaim两部分信息，其中SReclaimable是可回收部分，SUnreclaim是不可回收部分。</p>
<p>关于文件和磁盘的区别如下：</p>
<p>磁盘是一个块设备，可以划分为多个分区，每个分区上可以构建不同的文件系统，文件系统挂载到目录上后，就可以对该文件系统进行读写文件操作了。</p>
<p>读写普通文件系统中的文件时，会经过文件系统，由文件系统跟磁盘进行交互，而文件系统的缓存为cache。读写磁盘或者分区时，会跳过文件系统，直接对磁盘进行操作，而操作系统对磁盘的缓存称之为buffer。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="http://man7.org/linux/man-pages/man5/proc.5.html">Linux Programmer’s Manual PROC[5]</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux下debug内核coredump</title>
    <url>/post/linux-debug-crash/</url>
    <content><![CDATA[<p>Linux内核会存在一些严重的bug，导致内核crash，会在&#x2F;var&#x2F;crash目录下产生类似”127.0.0.1-2019-09-30-21:33:38“这种的文件夹，里面包含了vmcore文件，该文件对于debug 内核crash的原因非常有帮助。</p>
<p>本文在CentOS 7下操作。</p>
<p>执行<code>yum install crash</code>来安装crash</p>
<p>另外还需要两个rpm包：kernel-debuginfo-3.10.0-957.el7.x86_64.rpm 和 kernel-debuginfo-common-x86_64-3.10.0-957.el7.x86_64.rpm，需要关注下操作系统的内核版本，这两个rpm包可以通过搜索引擎找到。</p>
<p>下到包后即可执行<code>rpm -ivh *.rpm</code>的方式来安装rpm包。</p>
<p>在机器上执行<code>crash /usr/lib/debug/lib/modules/3.10.0-957.el7.x86_64/vmlinux /var/crash/xx/vmcore</code>进行debug，可以输入<code>bt</code>命令来查看栈信息。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux中断</title>
    <url>/post/linux-interrupt/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>中断由硬件产生，并发送到中断控制器，中断控制器再发送中断到CPU，CPU检测到中断信号后，会中断当前的工作，每个中断都有IRQ（中断请求），基于IRQ，CPU将中断请求分发到对应的硬件驱动上通知操作系统，操作系统会对中断进行处理。</p>
<h2 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h2><p>常见的中断控制器有两种：可编程中断控制器8259A和高级可编程中断控制器（APIC）。传统的8259A只适合单CPU的情况，现在都是多CPU、多核心的SMP体系，所以为了充分利用SMP体系结构，把中断传递给系统上的每个CPU以便更好实现并行和提高性能，Intel引入了高级可编程中断控制器（APIC）。</p>
<p>光有高级可编程中断控制器的硬件支持还不够，Linux内核还必须能利用这些硬件的特质，所以只有kernel 2.4以后的版本才支持把不同的硬件中断请求（IRQs）分配到特定的CPU核心上，这个绑定技术被称为SMP IRQ Affinity。</p>
<p>在设置网卡中断的cpu core时，有一个限制就是，IO-APIC 有两种工作模式：logic 和 physical，在 logic 模式下 IO-APIC 可以同时分布同一种 IO 中断到8颗 CPU (core) 上（受到 bitmask 寄存器的限制，因为 bitmask 只有8位长。）；在 physical 模式下不能同时分布同一中断到不同 CPU 上，比如，不能让 eth0 中断同时由 CPU0 和 CPU1 处理，这个时候只能定位 eth0 到 CPU0、eth1 到 CPU1，也就是说 eth0 中断不能像 logic 模式那样可以同时由多个 CPU 处理。</p>
<h2 id="软中断和硬中断"><a href="#软中断和硬中断" class="headerlink" title="软中断和硬中断"></a>软中断和硬中断</h2><p>为了解决中断处理程序执行时间过长和中断丢失的问题，Linux系统将中断分为上半部和下半部。</p>
<p>上半部在中断禁止模式下运行，用来快速处理中断，主要用来处理跟硬件密切相关的工作。</p>
<p>下半部处理上半部未完成的工作，通常以内核线程的方式运行。</p>
<p>以Linux接收网卡数据包为例进行说明：</p>
<p>网卡接收到一个数据包后，会通过硬件中断的方式通知内核新的数据到了。内核会调用中断处理程序进行处理。</p>
<p>上半部将网卡中的数据写入到内存中，并更新一下硬件寄存器的状态，最后发送一个软中断信号，通知下半部进一步的处理。</p>
<p>下半部被软中断信号唤醒后，从内存中读到数据，按照网络协议栈对数据进行解析和处理，并发送给应用程序。</p>
<p>上面所说的上半部即硬中断，下半部即软中断，但一些内核自定义的事件也属于软中断，比如内核调度和RCU锁等。</p>
<p>硬中断：由外设产生，用来通知操作系统外设状态的变化。在处理中断的同时要关闭中断。特点为处理要尽可能的快。</p>
<p>软中断：为了满足实时性要求，硬中断处理时间都比较短，将时间比较长的中断放到软中断中来完成，称为下半部。int就是软中断指令，中断向量表是中断号和中断处理程序的对应表。每个CPU对应一个软中断内核线程<code>ksoftirqd/cpu编号</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@120-14-29-SH-1037-B07 ~]# ps -ef | grep ksoft</span><br><span class="line">root           3       2  0  2016 ?        01:47:12 [ksoftirqd/0]</span><br><span class="line">root          21       2  0  2016 ?        00:47:51 [ksoftirqd/1]</span><br><span class="line">root          26       2  0  2016 ?        00:47:34 [ksoftirqd/2]</span><br><span class="line">root          31       2  0  2016 ?        00:47:46 [ksoftirqd/3]</span><br></pre></td></tr></table></figure>

<p>中断嵌套：硬中断可以嵌套，即新的硬中断可以打断正在执行的中断，但同种中断不可以。软中断不可嵌套，但相同类型中断可在不同的cpu上执行。</p>
<h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><h2 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示cpu处理的中断数量</span><br><span class="line">[root@103-17-164-sh-100-k07 ~]# mpstat -I SUM 1</span><br><span class="line">Linux 3.10.0-327.10.1.el7.x86_64 (103-17-164-sh-100-k07.yidian.com)     09/09/2017      _x86_64_        (4 CPU)</span><br><span class="line"></span><br><span class="line">05:27:59 PM  CPU    intr/s</span><br><span class="line">05:28:00 PM  all  61274.00</span><br><span class="line">05:28:01 PM  all  61712.00</span><br><span class="line">05:28:02 PM  all  62315.00</span><br><span class="line">05:28:03 PM  all  59280.00</span><br><span class="line">^C</span><br><span class="line">Average:     all  61145.25</span><br><span class="line"></span><br><span class="line"># 显示每个核处理的中断数量</span><br><span class="line">[root@103-17-164-sh-100-k07 ~]# mpstat -I SUM 1 -P ALL</span><br><span class="line">Linux 3.10.0-327.10.1.el7.x86_64 (103-17-164-sh-100-k07.yidian.com)     09/09/2017      _x86_64_        (4 CPU)</span><br><span class="line"></span><br><span class="line">05:30:30 PM  CPU    intr/s</span><br><span class="line">05:30:31 PM  all  61446.00</span><br><span class="line">05:30:31 PM    0  40489.00</span><br><span class="line">05:30:31 PM    1   6839.00</span><br><span class="line">05:30:31 PM    2   6935.00</span><br><span class="line">05:30:31 PM    3   7185.00</span><br><span class="line"></span><br><span class="line"># 显示更详细的信息</span><br><span class="line">[root@120-14-31-SH-1037-B07 ~]# mpstat -P ALL 1</span><br><span class="line">Linux 3.10.0-327.el7.x86_64 (120-14-31-SH-1037-B07.yidian.com)  09/10/2017      _x86_64_        (4 CPU)</span><br><span class="line"></span><br><span class="line">01:15:09 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">01:15:10 AM  all    6.35    0.00   11.64    0.00    0.00    7.67    0.00    0.00    0.00   74.34</span><br><span class="line">01:15:10 AM    0    5.05    0.00   11.11    0.00    0.00    0.00    0.00    0.00    0.00   83.84</span><br><span class="line">01:15:10 AM    1    6.38    0.00   12.77    0.00    0.00    9.57    0.00    0.00    0.00   71.28</span><br><span class="line">01:15:10 AM    2    8.70    0.00   10.87    0.00    0.00   14.13    0.00    0.00    0.00   66.30</span><br><span class="line">01:15:10 AM    3    6.32    0.00   12.63    0.00    0.00    7.37    0.00    0.00    0.00   73.68</span><br></pre></td></tr></table></figure>

<h2 id="lspci"><a href="#lspci" class="headerlink" title="lspci"></a>lspci</h2><p>可以来查看网卡型号，驱动等信息，内容较多</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@103-17-164-sh-100-k07 ~]# lspci -vvv | more</span><br><span class="line">00:00.0 Host bridge: Intel Corporation Xeon E7 v2/Xeon E5 v2/Core i7 DMI2 (rev 04)</span><br><span class="line">        Subsystem: Super Micro Computer Inc Device 0668</span><br><span class="line">        Control: I/O- Mem- BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx-</span><br><span class="line">        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-</span><br><span class="line">        Interrupt: pin A routed to IRQ 0</span><br><span class="line">        Capabilities: [90] Express (v2) Root Port (Slot-), MSI 00</span><br><span class="line">                DevCap: MaxPayload 128 bytes, PhantFunc 0</span><br><span class="line">                        ExtTag- RBE+</span><br><span class="line">                DevCtl: Report errors: Correctable- Non-Fatal- Fatal- Unsupported-</span><br><span class="line">                        RlxdOrd- ExtTag- PhantFunc- AuxPwr- NoSnoop-</span><br><span class="line">                        MaxPayload 128 bytes, MaxReadReq 128 bytes</span><br><span class="line">                DevSta: CorrErr- UncorrErr- FatalErr- UnsuppReq- AuxPwr- TransPend-</span><br><span class="line">                LnkCap: Port #0, Speed 5GT/s, Width x4, ASPM not supported, Exit Latency L0s &lt;64ns, L1 &lt;16us</span><br><span class="line">                        ClockPM- Surprise+ LLActRep+ BwNot+</span><br><span class="line">                LnkCtl: ASPM Disabled; RCB 64 bytes Disabled- CommClk-</span><br><span class="line">                        ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-</span><br><span class="line">                LnkSta: Speed unknown, Width x0, TrErr- Train- SlotClk- DLActive- BWMgmt- ABWMgmt-</span><br><span class="line">                RootCtl: ErrCorrectable- ErrNon-Fatal- ErrFatal- PMEIntEna- CRSVisible-</span><br><span class="line">                RootCap: CRSVisible-</span><br><span class="line">                RootSta: PME ReqID 0000, PMEStatus- PMEPending-</span><br><span class="line">                DevCap2: Completion Timeout: Range BCD, TimeoutDis+, LTR-, OBFF Not Supported ARIFwd-</span><br><span class="line">                DevCtl2: Completion Timeout: 50us to 50ms, TimeoutDis-, LTR-, OBFF Disabled ARIFwd-</span><br><span class="line">                LnkCtl2: Target Link Speed: 2.5GT/s, EnterCompliance- SpeedDis-</span><br><span class="line">                         Transmit Margin: Normal Operating Range, EnterModifiedCompliance- ComplianceSOS-</span><br><span class="line">                         Compliance De-emphasis: -6dB</span><br><span class="line">                LnkSta2: Current De-emphasis Level: -6dB, EqualizationComplete-, EqualizationPhase1-</span><br><span class="line">                         EqualizationPhase2-, EqualizationPhase3-, LinkEqualizationRequest-</span><br><span class="line">        Capabilities: [e0] Power Management version 3</span><br><span class="line">                Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold+)</span><br><span class="line">                Status: D0 NoSoftRst- PME-Enable- DSel=0 DScale=0 PME-</span><br><span class="line">        Capabilities: [100 v1] Vendor Specific Information: ID=0002 Rev=0 Len=00c &lt;?&gt;</span><br><span class="line">        Capabilities: [144 v1] Vendor Specific Information: ID=0004 Rev=1 Len=03c &lt;?&gt;</span><br><span class="line">        Capabilities: [1d0 v1] Vendor Specific Information: ID=0003 Rev=1 Len=00a &lt;?&gt;</span><br><span class="line">        Capabilities: [280 v1] Vendor Specific Information: ID=0005 Rev=3 Len=018 &lt;?&gt;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="ethtool"><a href="#ethtool" class="headerlink" title="ethtool"></a>ethtool</h2><p>用来查看网卡信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@103-17-164-sh-100-k07 ~]# ethtool eth3</span><br><span class="line">Settings for eth3:</span><br><span class="line">        Supported ports: [ FIBRE ]</span><br><span class="line">        Supported link modes:   1000baseT/Full</span><br><span class="line">                                10000baseT/Full</span><br><span class="line">        Supported pause frame use: No</span><br><span class="line">        Supports auto-negotiation: Yes</span><br><span class="line">        Advertised link modes:  1000baseT/Full</span><br><span class="line">                                10000baseT/Full</span><br><span class="line">        Advertised pause frame use: No</span><br><span class="line">        Advertised auto-negotiation: Yes</span><br><span class="line">        Speed: 10000Mb/s</span><br><span class="line">        Duplex: Full</span><br><span class="line">        Port: FIBRE</span><br><span class="line">        PHYAD: 0</span><br><span class="line">        Transceiver: external</span><br><span class="line">        Auto-negotiation: on</span><br><span class="line">        Supports Wake-on: d</span><br><span class="line">        Wake-on: d</span><br><span class="line">        Current message level: 0x00000007 (7)</span><br><span class="line">                               drv probe link</span><br><span class="line">        Link detected: yes</span><br><span class="line"></span><br><span class="line"># 可查看Ring buffer的大小</span><br><span class="line">[root@103-17-164-sh-100-k07 ~]# ethtool -g eth3</span><br><span class="line">Ring parameters for eth3:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:             4096</span><br><span class="line">RX Mini:        0</span><br><span class="line">RX Jumbo:       0</span><br><span class="line">TX:             4096</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:             512</span><br><span class="line">RX Mini:        0</span><br><span class="line">RX Jumbo:       0</span><br><span class="line">TX:             512</span><br><span class="line"></span><br><span class="line"># 列出信息较多，包含网卡的统计信息，包括丢包量信息</span><br><span class="line">[root@103-17-164-sh-100-k07 ~]# ethtool -S eth3 | more</span><br><span class="line">NIC statistics:</span><br><span class="line">     rx_packets: 680955795162</span><br><span class="line">     tx_packets: 27260701850</span><br><span class="line">     rx_bytes: 248285654162670</span><br><span class="line">     tx_bytes: 195321924245892</span><br><span class="line">     rx_pkts_nic: 683081802539</span><br><span class="line">     tx_pkts_nic: 27260700665</span><br><span class="line">     rx_bytes_nic: 251132784690871</span><br><span class="line">     tx_bytes_nic: 195447730645152</span><br><span class="line">     lsc_int: 11</span><br><span class="line">     tx_busy: 0</span><br><span class="line">     non_eop_descs: 1811095697</span><br><span class="line">     rx_errors: 67381</span><br><span class="line">     tx_errors: 0</span><br><span class="line">     rx_dropped: 0</span><br><span class="line">     tx_dropped: 0</span><br><span class="line">     multicast: 1025690658</span><br><span class="line">     broadcast: 206937242</span><br><span class="line">     rx_no_buffer_count: 0</span><br><span class="line">     collisions: 0</span><br><span class="line">     rx_over_errors: 0</span><br><span class="line">     rx_crc_errors: 67302</span><br><span class="line">     rx_frame_errors: 0</span><br><span class="line">     hw_rsc_aggregated: 2358414213</span><br><span class="line">     hw_rsc_flushed: 232402327</span><br><span class="line">     fdir_match: 10634169417</span><br><span class="line">     fdir_miss: 669277016191</span><br><span class="line">     fdir_overflow: 3321</span><br><span class="line">     rx_fifo_errors: 0</span><br><span class="line">     rx_missed_errors: 2538</span><br><span class="line">     tx_aborted_errors: 0</span><br><span class="line">     tx_carrier_errors: 0</span><br><span class="line">     tx_fifo_errors: 0</span><br><span class="line">     tx_heartbeat_errors: 0</span><br><span class="line">     tx_timeout_count: 0</span><br><span class="line">     tx_restart_queue: 0</span><br><span class="line">     rx_long_length_errors: 80264</span><br><span class="line">     rx_short_length_errors: 0</span><br><span class="line">     tx_flow_control_xon: 1</span><br><span class="line">     rx_flow_control_xon: 0</span><br><span class="line">     tx_flow_control_xoff: 51</span><br><span class="line">     rx_flow_control_xoff: 0</span><br><span class="line">     rx_csum_offload_errors: 0</span><br><span class="line">     alloc_rx_page_failed: 0</span><br><span class="line">     alloc_rx_buff_failed: 0</span><br><span class="line">     rx_no_dma_resources: 0</span><br><span class="line">     os2bmc_rx_by_bmc: 0</span><br><span class="line">     os2bmc_tx_by_bmc: 0</span><br><span class="line">     os2bmc_tx_by_host: 0</span><br><span class="line">     os2bmc_rx_by_host: 0</span><br><span class="line"></span><br><span class="line"># 查看网卡多队列的支持情况，当前网卡支持8个队列，使用了8个队列</span><br><span class="line">[root@103-17-6-sh-100-j11 ~]# ethtool -l eth0</span><br><span class="line">Channel parameters for eth0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:             0</span><br><span class="line">TX:             0</span><br><span class="line">Other:          1</span><br><span class="line">Combined:       8</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:             0</span><br><span class="line">TX:             0</span><br><span class="line">Other:          1</span><br><span class="line">Combined:       8</span><br><span class="line"></span><br><span class="line"># 设置网卡当前使用的多队列，当前使用的网卡数量不能超过最大值8，该值跟网卡的中断数量一一对应，即/proc/interrupts中看到的eth0的中断数量</span><br><span class="line">[root@103-17-6-sh-100-j11 ~]# ethtool -L eth0 combined 2</span><br><span class="line">[root@103-17-6-sh-100-j11 ~]# ethtool -l eth0</span><br><span class="line">Channel parameters for eth0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:             0</span><br><span class="line">TX:             0</span><br><span class="line">Other:          1</span><br><span class="line">Combined:       8</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:             0</span><br><span class="line">TX:             0</span><br><span class="line">Other:          1</span><br><span class="line">Combined:       2</span><br></pre></td></tr></table></figure>

<h2 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列出网卡的接收包信息，比iftop更直观</span><br><span class="line">[root@103-17-164-sh-100-k07 ~]# sar -n DEV 1</span><br><span class="line">Linux 3.10.0-327.10.1.el7.x86_64 (103-17-164-sh-100-k07.yidian.com)     09/09/2017      _x86_64_        (4 CPU)</span><br><span class="line"></span><br><span class="line">05:06:12 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">05:06:13 PM      eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">05:06:13 PM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">05:06:13 PM      eth2      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">05:06:13 PM      eth3  77893.00   4328.00  31413.92  30134.16      0.00      0.00     46.00</span><br><span class="line">05:06:13 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line"># 可列出错误包的相关信息</span><br><span class="line">[root@103-17-164-sh-100-k07 ~]# sar -n EDEV 1</span><br><span class="line">Linux 3.10.0-327.10.1.el7.x86_64 (103-17-164-sh-100-k07.yidian.com)     09/09/2017      _x86_64_        (4 CPU)</span><br><span class="line"></span><br><span class="line">05:07:13 PM     IFACE   rxerr/s   txerr/s    coll/s  rxdrop/s  txdrop/s  txcarr/s  rxfram/s  rxfifo/s  txfifo/s</span><br><span class="line">05:07:14 PM      eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">05:07:14 PM      eth1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">05:07:14 PM      eth2      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">05:07:14 PM      eth3      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">05:07:14 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>

<p>通过中断可以看到网卡包含四个中断55-58，均位于cpu0上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@103-17-164-sh-100-k07 ~]# cat /proc/interrupts</span><br><span class="line">           CPU0       CPU1       CPU2       CPU3</span><br><span class="line">  0:         44          0          0          0  IR-IO-APIC-edge      timer</span><br><span class="line">  1:          3          0          0          0  IR-IO-APIC-edge      i8042</span><br><span class="line">  8:         42          0          0          0  IR-IO-APIC-edge      rtc0</span><br><span class="line">  9:          1          0          0          0  IR-IO-APIC-fasteoi   acpi</span><br><span class="line"> 12:          4          0          0          0  IR-IO-APIC-edge      i8042</span><br><span class="line"> 16:         99          0          0          0  IR-IO-APIC-fasteoi   ehci_hcd:usb1</span><br><span class="line"> 18:          0          0          0          0  IR-IO-APIC-fasteoi   i801_smbus</span><br><span class="line"> 23:         83          0          0          0  IR-IO-APIC-fasteoi   ehci_hcd:usb2</span><br><span class="line"> 37:   12019917          0          0          0  IR-PCI-MSI-edge      0000:00:1f.2</span><br><span class="line"> 48:          0          0          0          0  DMAR_MSI-edge      dmar0</span><br><span class="line"> 55:  746827548          0          0          0  IR-PCI-MSI-edge      eth3-TxRx-0</span><br><span class="line"> 56: 2674693551          0          0          0  IR-PCI-MSI-edge      eth3-TxRx-1</span><br><span class="line"> 57: 2341522223          0          0          0  IR-PCI-MSI-edge      eth3-TxRx-2</span><br><span class="line"> 58: 3587929355          0          0          0  IR-PCI-MSI-edge      eth3-TxRx-3</span><br><span class="line"> 59:       3334          0          0          0  IR-PCI-MSI-edge      eth3</span><br><span class="line"> 61:          2          0          0          0  IR-PCI-MSI-edge      ioat-msix</span><br><span class="line"> 63:          2          0          0          0  IR-PCI-MSI-edge      ioat-msix</span><br><span class="line"> 64:          2          0          0          0  IR-PCI-MSI-edge      ioat-msix</span><br><span class="line"> 65:          2          0          0          0  IR-PCI-MSI-edge      ioat-msix</span><br><span class="line"> 66:          2          0          0          0  IR-PCI-MSI-edge      ioat-msix</span><br><span class="line"> 67:          2          0          0          0  IR-PCI-MSI-edge      ioat-msix</span><br><span class="line"> 68:          2          0          0          0  IR-PCI-MSI-edge      ioat-msix</span><br><span class="line"> 69:          2          0          0          0  IR-PCI-MSI-edge      ioat-msix</span><br><span class="line">NMI:    1100069     693493     635982     615953   Non-maskable interrupts</span><br><span class="line">LOC: 1120358899  146726541 4134846029  168005659   Local timer interrupts</span><br><span class="line">SPU:          0          0          0          0   Spurious interrupts</span><br><span class="line">PMI:    1100069     693493     635982     615953   Performance monitoring interrupts</span><br><span class="line">IWI:   57255892  115292160  113458706  112987848   IRQ work interrupts</span><br><span class="line">RTR:          0          0          0          0   APIC ICR read retries</span><br><span class="line">RES:  525229423 2791640970  427214674 1986396041   Rescheduling interrupts</span><br><span class="line">CAL: 4294536344 4294488238 4294478163 4294552026   Function call interrupts</span><br><span class="line">TLB:   65239533   57937650   55104990   52690662   TLB shootdowns</span><br><span class="line">TRM:          0          0          0          0   Thermal event interrupts</span><br><span class="line">THR:          0          0          0          0   Threshold APIC interrupts</span><br><span class="line">MCE:          0          0          0          0   Machine check exceptions</span><br><span class="line">MCP:     160132     160132     160132     160132   Machine check polls</span><br><span class="line">ERR:          0</span><br><span class="line">MIS:          0</span><br></pre></td></tr></table></figure>

<h2 id="修改中断的cpu分配"><a href="#修改中断的cpu分配" class="headerlink" title="修改中断的cpu分配"></a>修改中断的cpu分配</h2><p>echo “2” &gt; &#x2F;proc&#x2F;irq&#x2F;49&#x2F;smp_affinity</p>
<p>其中2表示cpu1, 49表示中断号。</p>
<h2 id="查看软中断"><a href="#查看软中断" class="headerlink" title="查看软中断"></a>查看软中断</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@120-14-31-SH-1037-B07 ~]# cat /proc/softirqs</span><br><span class="line">                    CPU0       CPU1       CPU2       CPU3</span><br><span class="line">          HI:          1          3          0          1</span><br><span class="line">       TIMER: 1795378091 3617740778 2674553229 1524071492</span><br><span class="line">      NET_TX:  202188392   22218135   17427628   17205883</span><br><span class="line">      NET_RX: 3388060179   60871361   68145291   38670323</span><br><span class="line">       BLOCK:    4741950       2422       1309       1489</span><br><span class="line">BLOCK_IOPOLL:          0          0          0          0</span><br><span class="line">     TASKLET: 2102131738    3720214    3104944    1942912</span><br><span class="line">       SCHED:  526046585  612421231  496815061  456047989</span><br><span class="line">     HRTIMER:          0          0          0          0</span><br><span class="line">         RCU: 3147020579 4237695975 3820083676 3267816268</span><br></pre></td></tr></table></figure>

<p>软中断包括10个类别，NET_RX（网络接收中断）、NET_TX（网络发送中断）</p>
<h2 id="查看数据包统计"><a href="#查看数据包统计" class="headerlink" title="查看数据包统计"></a>查看数据包统计</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@c1-g08-120-166-30 ~]# netstat -s</span><br><span class="line">Ip:</span><br><span class="line">    7586513384 total packets received</span><br><span class="line">    0 forwarded</span><br><span class="line">    741 with unknown protocol</span><br><span class="line">    0 incoming packets discarded</span><br><span class="line">    7586512643 incoming packets delivered</span><br><span class="line">    7948370396 requests sent out</span><br><span class="line">Icmp:</span><br><span class="line">    23 ICMP messages received</span><br><span class="line">    0 input ICMP message failed.</span><br><span class="line">    ICMP input histogram:</span><br><span class="line">        destination unreachable: 1</span><br><span class="line">        echo requests: 19</span><br><span class="line">        echo replies: 3</span><br><span class="line">    46 ICMP messages sent</span><br><span class="line">    0 ICMP messages failed</span><br><span class="line">    ICMP output histogram:</span><br><span class="line">        destination unreachable: 9</span><br><span class="line">        echo request: 18</span><br><span class="line">        echo replies: 19</span><br><span class="line">IcmpMsg:</span><br><span class="line">        InType0: 3</span><br><span class="line">        InType3: 1</span><br><span class="line">        InType8: 19</span><br><span class="line">        OutType0: 19</span><br><span class="line">        OutType3: 9</span><br><span class="line">        OutType8: 18</span><br><span class="line">Tcp:</span><br><span class="line">    561299810 active connections openings</span><br><span class="line">    2005002 passive connection openings</span><br><span class="line">    8 failed connection attempts</span><br><span class="line">    282644949 connection resets received</span><br><span class="line">    725 connections established</span><br><span class="line">    7585817181 segments received</span><br><span class="line">    13957880471 segments send out</span><br><span class="line">    1742807 segments retransmited</span><br><span class="line">    136 bad segments received.</span><br><span class="line">    523811266 resets sent</span><br><span class="line">Udp:</span><br><span class="line">    445457 packets received</span><br><span class="line">    3 packets to unknown port received.</span><br><span class="line">    0 packet receive errors</span><br><span class="line">    553840367 packets sent</span><br><span class="line">    0 receive buffer errors</span><br><span class="line">    0 send buffer errors</span><br><span class="line">UdpLite:</span><br><span class="line">    InErrors: 3</span><br><span class="line">TcpExt:</span><br><span class="line">    341304 invalid SYN cookies received</span><br><span class="line">    1 resets received for embryonic SYN_RECV sockets</span><br><span class="line">    1 ICMP packets dropped because they were out-of-window</span><br><span class="line">    1997421 TCP sockets finished time wait in fast timer</span><br><span class="line">    222787 delayed acks sent</span><br><span class="line">    1819 delayed acks further delayed because of locked socket</span><br><span class="line">    Quick ack mode was activated 178186 times</span><br><span class="line">    13 packets directly queued to recvmsg prequeue.</span><br><span class="line">    3280604069 packet headers predicted</span><br><span class="line">    1972740996 acknowledgments not containing data payload received</span><br><span class="line">    798190042 predicted acknowledgments</span><br><span class="line">    642444 times recovered from packet loss by selective acknowledgements</span><br><span class="line">    Detected reordering 23 times using FACK</span><br><span class="line">    Detected reordering 1618 times using SACK</span><br><span class="line">    59 congestion windows fully recovered without slow start</span><br><span class="line">    16 congestion windows partially recovered using Hoe heuristic</span><br><span class="line">    17089 congestion windows recovered without slow start by DSACK</span><br><span class="line">    9594 congestion windows recovered without slow start after partial ack</span><br><span class="line">    TCPLostRetransmit: 2849</span><br><span class="line">    4926 timeouts after SACK recovery</span><br><span class="line">    672451 fast retransmits</span><br><span class="line">    28946 forward retransmits</span><br><span class="line">    680 retransmits in slow start</span><br><span class="line">    5024 other TCP timeouts</span><br><span class="line">    TCPLossProbes: 1390602</span><br><span class="line">    TCPLossProbeRecovery: 997235</span><br><span class="line">    4723 SACK retransmits failed</span><br><span class="line">    178189 DSACKs sent for old packets</span><br><span class="line">    979863 DSACKs received</span><br><span class="line">    62 DSACKs for out of order packets received</span><br><span class="line">    282645553 connections reset due to unexpected data</span><br><span class="line">    9 connections reset due to early user close</span><br><span class="line">    TCPDSACKIgnoredNoUndo: 936061</span><br><span class="line">    TCPSpuriousRTOs: 5150</span><br><span class="line">    TCPSackShifted: 233309</span><br><span class="line">    TCPSackMerged: 733778</span><br><span class="line">    TCPSackShiftFallback: 1768422</span><br><span class="line">    IPReversePathFilter: 1</span><br><span class="line">    TCPRetransFail: 11</span><br><span class="line">    TCPRcvCoalesce: 1290965687</span><br><span class="line">    TCPOFOQueue: 1753072</span><br><span class="line">    TCPChallengeACK: 136</span><br><span class="line">    TCPSYNChallenge: 136</span><br><span class="line">    TCPSpuriousRtxHostQueues: 73</span><br><span class="line">    TCPAutoCorking: 272452106</span><br><span class="line">    TCPSynRetrans: 4538</span><br><span class="line">    TCPOrigDataSent: 9260789170</span><br><span class="line">    TCPHystartTrainDetect: 3721895</span><br><span class="line">    TCPHystartTrainCwnd: 64417412</span><br><span class="line">    TCPHystartDelayDetect: 80</span><br><span class="line">    TCPHystartDelayCwnd: 2579</span><br><span class="line">    TCPACKSkippedSynRecv: 4</span><br><span class="line">IpExt:</span><br><span class="line">    InMcastPkts: 249744</span><br><span class="line">    OutMcastPkts: 83317</span><br><span class="line">    InBcastPkts: 226</span><br><span class="line">    InOctets: 12312144006244</span><br><span class="line">    OutOctets: 12449967070063</span><br><span class="line">    InMcastOctets: 22309104</span><br><span class="line">    OutMcastOctets: 9664620</span><br><span class="line">    InBcastOctets: 104240</span><br><span class="line">    InNoECTPkts: 7586513474</span><br><span class="line">    InECT0Pkts: 47</span><br></pre></td></tr></table></figure>

<h1 id="irqbalance"><a href="#irqbalance" class="headerlink" title="irqbalance"></a>irqbalance</h1><p>查看是否运行：systemctl status irqbalance</p>
<p>irqbalance根据系统中断负载的情况，自动迁移中断保持中断的平衡，同时会考虑到省电因素等等。 但是在实时系统中会导致中断自动漂移，对性能造成不稳定因素，在高性能的场合建议关闭。</p>
<p>irqbalance用于优化中断分配，它会自动收集系统数据以分析使用模式，并依据系统负载状况将工作状态置于 Performance mode 或 Power-save mode。处于Performance mode 时，irqbalance 会将中断尽可能均匀地分发给各个 CPU core，以充分利用 CPU 多核，提升性能。<br>处于Power-save mode 时，irqbalance 会将中断集中分配给第一个 CPU，以保证其它空闲 CPU 的睡眠时间，降低能耗。</p>
<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul>
<li><a href="http://www.vpsee.com/2010/07/load-balancing-with-irq-smp-affinity/">Linux 多核下绑定硬件中断到不同 CPU（IRQ Affinity）</a></li>
<li><a href="http://blog.yufeng.info/archives/2422">深度剖析告诉你irqbalance有用吗？</a></li>
<li><a href="https://time.geekbang.org/column/article/71868">怎么理解Linux软中断？</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux内核参数（持续更新）</title>
    <url>/post/linux-kernel/</url>
    <content><![CDATA[<h1 id="内核参数项"><a href="#内核参数项" class="headerlink" title="内核参数项"></a>内核参数项</h1><p>以CentOS7 系统为例，可以看到有1088个内核参数项。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">$ uname -a</span><br><span class="line">Linux iZbp17o12gcsq2d87y7x1hZ <span class="number">3.10</span><span class="number">.0</span><span class="number">-1160.36</span><span class="number">.2</span>.el7.x86_64 #<span class="number">1</span> SMP Wed Jul <span class="number">21</span> <span class="number">11</span><span class="punctuation">:</span><span class="number">57</span><span class="punctuation">:</span><span class="number">15</span> UTC <span class="number">2021</span> x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line">$ sysctl -a <span class="number">2</span>&gt;/dev/<span class="literal"><span class="keyword">null</span></span> | wc -l</span><br><span class="line"><span class="number">1088</span></span><br></pre></td></tr></table></figure>
<p>Linux的内核参数均位于&#x2F;proc&#x2F;sys目录下，涉及到如下几个目录：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>abi</td>
<td></td>
</tr>
<tr>
<td>crypto</td>
<td></td>
</tr>
<tr>
<td>debug</td>
<td></td>
</tr>
<tr>
<td>dev</td>
<td>用来配置特定设备，比如raid、scsi设备</td>
</tr>
<tr>
<td>fs</td>
<td>文件子系统</td>
</tr>
<tr>
<td>kernel</td>
<td>内核子系统</td>
</tr>
<tr>
<td>net</td>
<td>网络子系统</td>
</tr>
<tr>
<td>user</td>
<td></td>
</tr>
<tr>
<td>vm</td>
<td>内存子系统</td>
</tr>
</tbody></table>
<h2 id="kernel子系统"><a href="#kernel子系统" class="headerlink" title="kernel子系统"></a>kernel子系统</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>kernel.panic</td>
<td>内核出现panic，重新引导前需要等待的时间，单位为秒。如果该值为0，，说明内核禁止自动引导</td>
</tr>
<tr>
<td>kernel.core_pattern</td>
<td>core文件的存放路径</td>
</tr>
</tbody></table>
<h2 id="vm子系统"><a href="#vm子系统" class="headerlink" title="vm子系统"></a>vm子系统</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>vm.min_free_kbytes</td>
<td>系统所保留空闲内存的最小值。该值通过公式计算，跟当前机器的物理内存相关。</td>
</tr>
<tr>
<td>vm.swappiness</td>
<td>用来控制虚拟内存，支持如下值：<br> 0：关闭虚拟内存 <br> 1：允许开启虚拟内存设置的最小值 <br> 10：剩余内存少于10%时开启虚拟内存 <br> 100：完全适用虚拟内存。<br><br> 该参数可以通过swapon 命令开启，swapoff关闭。<br>参考链接：<a href="https://linuxhint.com/understanding_vm_swappiness/">https://linuxhint.com/understanding_vm_swappiness&#x2F;</a></td>
</tr>
</tbody></table>
<h2 id="net子系统"><a href="#net子系统" class="headerlink" title="net子系统"></a>net子系统</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>net.ipv4.ip_local_reserved_ports</td>
<td>随机端口的黑名单列表，系统在发起连接时，不使用该内核参数内的端口号</td>
</tr>
<tr>
<td>net.ipv4.ip_local_port_range</td>
<td>随机端口的白名单范围，网络连接可以作为源端口的最小和最大端口限制</td>
</tr>
<tr>
<td>net.ipv4.rp_filter</td>
<td>是否开启对数据包源地址的校验, 收到包后根据source ip到route表中检查是否否和最佳路由，否的话扔掉这个包。这次如下值：<br>1. 不开启源地址校验<br> 2. 开启严格的反向路径校验。对每个进来的数据包，校验其反向路径是否是最佳路径。如果反向路径不是最佳路径，则直接丢弃该数据包。<br> 3. 开启松散的反向路径校验。对每个进来的数据包，校验其源地址是否可达，即反向路径是否能通（通过任意网口），如果反向路径不通，则直接丢弃该数据包。该内核参数 net.ipv4.conf.all.log_martians 可以来控制是否打开日志，日志打开后可以在&#x2F;var&#x2F;log&#x2F;message中观察到。</td>
</tr>
</tbody></table>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>tcp 相关内核参数可以使用 <code>man 7 tcp</code> 查看。</p>
<h4 id="建连相关"><a href="#建连相关" class="headerlink" title="建连相关"></a>建连相关</h4><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/tcp_connect.webp"></p>
<p>syn 队列又称为半连接队列。服务端在接收到客户端的 SYN 包后，服务端向客户端发送 SYN + ACK 报文，此时会进入到半连接队列。</p>
<p>相关文章：<a href="/post/linux-backlog">Linux TCP backlog</a></p>
<h4 id="断开连接相关"><a href="#断开连接相关" class="headerlink" title="断开连接相关"></a>断开连接相关</h4><p><a href="/post/time-wait">TCP TIME_WAIT</a></p>
<h2 id="文件子系统"><a href="#文件子系统" class="headerlink" title="文件子系统"></a>文件子系统</h2><h3 id="fs-mount-max"><a href="#fs-mount-max" class="headerlink" title="fs.mount-max"></a>fs.mount-max</h3><blockquote>
<p>The value in this file specifies the maximum number of mounts that may exist in a mount namespace. The default value in this file is 100,000.</p>
</blockquote>
<p>Linux 4.19 内核引入。当 mount namespace 中加载的文件数超过该值后，会报错 “No space left on device”。</p>
<h2 id="内核参数在k8s的支持情况"><a href="#内核参数在k8s的支持情况" class="headerlink" title="内核参数在k8s的支持情况"></a>内核参数在k8s的支持情况</h2><table>
<thead>
<tr>
<th>大类</th>
<th>子类</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>namespace内核参数</td>
<td>安全的内核参数</td>
<td>k8s默认支持的内核参数非常少，仅支持如下的内核参数：<br> 1. kernel.shm_rmid_forced<br> 2. net.ipv4.ip_local_port_range<br> 3. net.ipv4.tcp_syncookies（在内核4.4之前为非namespace化）<br> 4. net.ipv4.ping_group_range （从 Kubernetes 1.18 开始）<br> 5. net.ipv4.ip_unprivileged_port_start （从 Kubernetes 1.22 开始）</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>namespace内核参数</td>
<td>非安全内核参数</td>
<td>默认禁用，pod可以调度成功，但会报错SysctlForbidden。修改kubelet参数开启 <code>kubelet --allowed-unsafe-sysctls &#39;kernel.msg*,net.core.somaxconn&#39;</code></td>
</tr>
<tr>
<td>非namespace内核参数</td>
<td>在容器中没有的内核参数</td>
<td>如：<br>net.core.netdev_max_backlog &#x3D; 10000<br>net.core.rmem_max &#x3D; 2097152<br>net.core.wmem_max &#x3D; 2097152</td>
</tr>
<tr>
<td>非namespace隔离参数</td>
<td>直接修改宿主机的内核参数</td>
<td>在容器中需要开启特权容器来设置，如：<br>vm.overcommit_memory &#x3D; 2 <br>vm.overcommit_ratio &#x3D; 95</td>
</tr>
</tbody></table>
<p>操作系统的namespace化的内核参数仅支持：</p>
<ul>
<li>kernel.shm*,</li>
<li>kernel.msg*,</li>
<li>kernel.sem,</li>
<li>fs.mqueue.*,</li>
<li>net.*（内核中可以在容器命名空间里被更改的网络配置项相关参数）。然而也有一些特例 （例如，net.netfilter.nf_conntrack_max 和 net.netfilter.nf_conntrack_expect_max 可以在容器命名空间里被更改，但它们是非命名空间的）。</li>
</ul>
<p>k8s在pod中声明内核参数的方式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span>   </span><br><span class="line">  <span class="attr">name:</span> <span class="string">sysctl-example</span></span><br><span class="line"><span class="attr">spec:</span>   </span><br><span class="line">  <span class="attr">securityContext:</span>     </span><br><span class="line">    <span class="attr">sysctls:</span>     </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span></span><br><span class="line">      <span class="string">kernel.shm_rmid_forced</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure>


<h1 id="业界解决方案"><a href="#业界解决方案" class="headerlink" title="业界解决方案"></a>业界解决方案</h1><h2 id="ACK-安全沙箱容器"><a href="#ACK-安全沙箱容器" class="headerlink" title="ACK - 安全沙箱容器"></a>ACK - 安全沙箱容器</h2><p>阿里云ACK服务的安全沙箱容器，底层实现为runV，pod拥有独立的内核参数，相互之间不受影响。通过扩展pod的annotation来完成内核参数的修改：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">annotations<span class="punctuation">:</span></span><br><span class="line">  securecontainer.alibabacloud.com/sysctls<span class="punctuation">:</span> <span class="string">&quot;net.bridge.bridge-nf-call-ip6tables=1,net.bridge.bridge-nf-call-iptables=1,net.ipv4.ip_forward=1&quot;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://help.aliyun.com/document_detail/198645.html">阿里云ACK - 配置安全沙箱Pod内核参数</a></p>
<h2 id="弹性容器实例"><a href="#弹性容器实例" class="headerlink" title="弹性容器实例"></a>弹性容器实例</h2><p>完全利用k8s的功能，有限内核参数修改。<br><a href="https://help.aliyun.com/document_detail/163023.html">https://help.aliyun.com/document_detail&#x2F;163023.html</a></p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://help.aliyun.com/document_detail/163023.html">ASI 配置Security Context</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux网络接口特性</title>
    <url>/post/linux-netcard-feature-md/</url>
    <content><![CDATA[<h2 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h2><p>MTU是指一个以太网帧能够携带的最大数据部分的大小，并不包含以太网的头部部分。一般情况下MTU的值为1500字节。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/mtu1.png"></p>
<p>当指定的数据包大小超过MTU值时，ip层会根据当前的mtu值对超过数据包进行分片，并会设置ip层头部的More Fragments标志位，并会设置Fragment offset属性，即分片的第二个以及后续的数据包会增加offset，第一个数据包的offset值为0。接收方会根据ip头部的More Fragment标志位和Fragment offset属性来进行切片的重组。</p>
<p>如果手工将发送方的MTU值设置为较大值，比如9000（巨型帧），如果发送方设置了不分片（ip头部的Don’t fragment），此时如果发送的链路上有地方不支持该MTU，报文就会被丢弃。</p>
<h2 id="offload特性"><a href="#offload特性" class="headerlink" title="offload特性"></a>offload特性</h2><p>执行 <code>ethtool -k $&#123;device&#125;</code> 可以看到很多跟网络接口相关的特性，这些特性的目的是为了提升网络的收发性能。TSO、UFO和GSO是对应网络发送，LRO、GRO对应网络接收。</p>
<p>执行<code>ethtool -K $&#123;device&#125; gro off/on</code> 来开启或者关闭相关的特性。</p>
<h3 id="LRO-Large-Receive-Offload"><a href="#LRO-Large-Receive-Offload" class="headerlink" title="LRO(Large Receive Offload)"></a>LRO(Large Receive Offload)</h3><p>通过将接收的多个tcp segment聚合为一个大的tcp包，然后传送给网络协议栈处理，以减少上层网络协议栈的处理开销。</p>
<p>但由于tcp segment并不是在同一时刻到达网卡，因此组装起来就会变得比较困难。</p>
<p>由于LRO的一些局限性，在最新的网络上，该功能已经删除。</p>
<h3 id="GRO-Generic-Receive-Offload"><a href="#GRO-Generic-Receive-Offload" class="headerlink" title="GRO(Generic Receive Offload)"></a>GRO(Generic Receive Offload)</h3><p>GRO是LRO的升级版，正在逐渐取代LRO。运行与内核态，不再依赖于硬件。</p>
<h2 id="RSS-hash-特性"><a href="#RSS-hash-特性" class="headerlink" title="RSS hash 特性"></a>RSS hash 特性</h2><p>网卡可以根据数据包放到不同的网卡队列来处理，并可以根据不同的数据协议来设置不同的值。</p>
<p>注意：该特性并非所有的网卡都支持</p>
<p>下面命令为查询 udp 协议的设置，可以看到 hash 的策略为根据源 ip 地址和目的 ip 地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ethtool -n eth0 rx-flow-hash udp4</span><br><span class="line">UDP over IPV4 flows use these fields for computing Hash flow key:</span><br><span class="line">IP SA</span><br><span class="line">IP DA</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>ethtool -N eth0 rx-flow-hash udp4 sdfn</code>来修改hash 策略，<code>sdfn</code>对应的含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m   Hash on the Layer 2 destination address of the rx packet.</span><br><span class="line">v   Hash on the VLAN tag of the rx packet.</span><br><span class="line">t   Hash on the Layer 3 protocol field of the rx packet.</span><br><span class="line">s   Hash on the IP source address of the rx packet.</span><br><span class="line">d   Hash on the IP destination address of the rx packet.</span><br><span class="line">f   Hash on bytes 0 and 1 of the Layer 4 header of the rx packet.</span><br><span class="line">n   Hash on bytes 2 and 3 of the Layer 4 header of the rx packet.</span><br><span class="line">r   Discard all packets of this flow type. When  this  option  is</span><br><span class="line">    set, all other options are ignored.</span><br></pre></td></tr></table></figure>

<p>修改完成后再查看网卡的 hash 策略如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ethtool -n eth0 rx-flow-hash udp4</span><br><span class="line">UDP over IPV4 flows use these fields for computing Hash flow key:</span><br><span class="line">IP SA</span><br><span class="line">IP DA</span><br><span class="line">L4 bytes 0 &amp; 1 [TCP/UDP src port]</span><br><span class="line">L4 bytes 2 &amp; 3 [TCP/UDP dst port]</span><br></pre></td></tr></table></figure>



<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://segmentfault.com/a/1190000019206098">关于MTU，这里也许有你不知道的地方</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/44683790">常见网络加速技术浅谈</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux虚拟网络设备 - tap/tun</title>
    <url>/post/linux-network-tap-tun/</url>
    <content><![CDATA[<h1 id="Linux虚拟网络设备-tap-x2F-tun"><a href="#Linux虚拟网络设备-tap-x2F-tun" class="headerlink" title="Linux虚拟网络设备 - tap&#x2F;tun"></a>Linux虚拟网络设备 - tap&#x2F;tun</h1><p>tap&#x2F;tun常用于隧道通讯，通过一个字符设备来实现用户态和内核态的通讯，字符设备一端连接着用户空间，一端连接着内核空间。</p>
<p>对应的字符设备文件位置：</p>
<ul>
<li>tap: &#x2F;dev&#x2F;tap0</li>
<li>tun: &#x2F;dev&#x2F;net&#x2F;tun</li>
</ul>
<p>当应用程序打开字符设备文件时，驱动程序会创建并注册相应的虚拟设备接口，以tunX或tapX命名。应用程序关闭设备文件时，驱动程序会删除tunX和tapX网络虚拟设备，并删除建立起来的路由信息。</p>
<p>两个设备的不同点：</p>
<ul>
<li>tap是一个二层网络设备，只能处理二层的以太网帧</li>
<li>tun是一个点对点的三层网络设备，只能处理处理三层的IP数据包</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                ┌──────────────┐</span><br><span class="line">                │              │</span><br><span class="line">                │     APP      │</span><br><span class="line">                │              │</span><br><span class="line">                └───────┬──────┘</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">           ┌────────────▼──────────┐</span><br><span class="line">           │                       │</span><br><span class="line">─ ─ ─ ─ ─ ─│     /dev/net/tun      ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br><span class="line">           │                       │</span><br><span class="line">           └────────────┬──────────┘</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                        │</span><br><span class="line">                ┌───────▼──────┐                 ┌──────────────┐</span><br><span class="line">                │              │                 │              │</span><br><span class="line">                │     tunX     ├────────────────▶│Network Stack │</span><br><span class="line">                │              │                 │              │</span><br><span class="line">                └──────────────┘                 └──────────────┘</span><br></pre></td></tr></table></figure>



<h2 id="tun设备应用举例"><a href="#tun设备应用举例" class="headerlink" title="tun设备应用举例"></a>tun设备应用举例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          ┌──────────────┐         ┌──────────────┐</span><br><span class="line">          │              │         │              │</span><br><span class="line">          │    APP A     │         │    APP B     │◀┐</span><br><span class="line">          │              │         │              │ │</span><br><span class="line">          └───────┬──────┘         └───────┬──────┘ │</span><br><span class="line">                  │                        │        │</span><br><span class="line">                  │                        │        │</span><br><span class="line">                 1│                        │        │</span><br><span class="line">                  │                       5│        │</span><br><span class="line">                  │                        │        │</span><br><span class="line">  ─ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│─ ─ ─ ─ ┼ ─ ─ ─ ─ ─</span><br><span class="line">                  │                        │        │</span><br><span class="line">                  │                        │       4│</span><br><span class="line">                  │                        │        │</span><br><span class="line">     ┌────────────▼────────────────────────▼─────┐  │</span><br><span class="line">     │                                           │  │</span><br><span class="line">     │               Network Stack               │  │</span><br><span class="line">     │                                           │  │</span><br><span class="line">     └────────────┬───────────────────────┬──────┘  │</span><br><span class="line">                  │                       │         │</span><br><span class="line">                 6│                      3│         │</span><br><span class="line">                  │                       │         │</span><br><span class="line">          ┌───────▼──────┐              ┌─▼─────────┴──┐</span><br><span class="line">          │              │              │              │</span><br><span class="line">10.1.1.11 │     eth0     │              │     tun0     │ 192.168.1.11</span><br><span class="line">          │              │              │              │</span><br><span class="line">          └───────┬──────┘              └──────────────┘</span><br><span class="line">                  │</span><br><span class="line">                 7│</span><br><span class="line">                  │</span><br><span class="line">                  ▼</span><br><span class="line"></span><br><span class="line">             10.1.1.100 / 192.168.1.100</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>应用程序A要发送数据到其他物理机192.168.1.100，由于物理网络环境下只有10.1.1.11和10.1.1.100是相互连通的，192.168.1.11和192.168.1.100是不通的，为了192.168.1.11和192.168.1.100能够进行通讯，需要将数据包进行一次封装。</p>
<p>应用程序B是通过打开字符设备文件&#x2F;dev&#x2F;net&#x2F;tun0的方式来打开网络设备</p>
<p>流程如下：</p>
<ol>
<li>A构造数据包，目的ip为192.168.1.100，并发送给协议栈</li>
<li>协议栈根据数据包中的ip地址，匹配路由规则，要从tun0出去</li>
<li>内核协议栈将数据包发送给tun0网络设备</li>
<li>tun0发送应用程序B打开，于是将数据发送给应用程序B</li>
<li>B收到数据包后，在用户态构造一个新的数据包，源IP为eth0的IP 10.1.1.11，目的IP为配置的对端10.1.1.100，并封装原来的数据包</li>
<li>协议栈根据当前数据包的IP地址选择路由，将数据包发送给eth0</li>
</ol>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://www.cnblogs.com/bakari/p/10450711.html">详解云计算网络底层技术——虚拟网络设备 tap&#x2F;tun 原理解析</a></li>
<li><a href="https://www.cnblogs.com/bakari/p/10449664.html">Linux 网络工具详解之 ip tuntap 和 tunctl 创建 tap&#x2F;tun 设备</a></li>
<li><a href="https://segmentfault.com/a/1190000009249039">Linux虚拟网络设备之tun&#x2F;tap</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux Seccomp</title>
    <url>/post/linux-seccomp/</url>
    <content><![CDATA[<p>seccomp是secure computing mode的缩写，是Linux内核中的一个安全计算工具，机制用于限制应用程序可以使用的系统调用，增加系统的安全性。可以理解为系统调用的防火墙，利用BPF来规律系统调用。</p>
<p>在&#x2F;proc&#x2F;${pid}&#x2F;status文件中的Seccomp字段可以看到进程的Seccomp。</p>
<h2 id="prctl"><a href="#prctl" class="headerlink" title="prctl"></a>prctl</h2><p>下面程序使用prctl来设置程序的seccomp为strict模式，仅允许read、write、_exit和sigreturn四个系统调用。当调用未在seccomp白名单中的系统调用后，应用程序会被kill。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>         <span class="comment">/* printf */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span>     <span class="comment">/* prctl */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span> <span class="comment">/* seccomp&#x27;s constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>        <span class="comment">/* dup2: just for test */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;step 1: unrestricted\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enable filtering</span></span><br><span class="line">  prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;step 2: only &#x27;read&#x27;, &#x27;write&#x27;, &#x27;_exit&#x27; and &#x27;sigreturn&#x27; syscalls\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Redirect stderr to stdout</span></span><br><span class="line">  dup2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;step 3: !! YOU SHOULD NOT SEE ME !!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Success (well, not so in this case...)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上述程序后会输出如下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">step <span class="number">1</span>: unrestricted</span><br><span class="line">step <span class="number">2</span>: only <span class="string">&#x27;read&#x27;</span>, <span class="string">&#x27;write&#x27;</span>, <span class="string">&#x27;_exit&#x27;</span> and <span class="string">&#x27;sigreturn&#x27;</span> syscalls</span><br><span class="line">Killed</span><br></pre></td></tr></table></figure>

<h2 id="基于BPF的seccomp"><a href="#基于BPF的seccomp" class="headerlink" title="基于BPF的seccomp"></a>基于BPF的seccomp</h2><p>上述基于prctl系统调用的seccomp机制不够灵活，在linux 3.5之后引入了基于BPF的可定制的系统调用过滤功能。</p>
<p>需要先安装依赖包：<code>yum install libseccomp-dev</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;   /* printf */</span><br><span class="line">#include &lt;unistd.h&gt;  /* dup2: just for test */</span><br><span class="line">#include &lt;seccomp.h&gt; /* libseccomp */</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  printf(&quot;step 1: unrestricted\n&quot;);</span><br><span class="line"></span><br><span class="line">  // Init the filter</span><br><span class="line">  scmp_filter_ctx ctx;</span><br><span class="line">  ctx = seccomp_init(SCMP_ACT_KILL); // default action: kill</span><br><span class="line"></span><br><span class="line">  // setup basic whitelist</span><br><span class="line">  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), 0);</span><br><span class="line">  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);</span><br><span class="line">  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);</span><br><span class="line">  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0);</span><br><span class="line"></span><br><span class="line">  // setup our rule</span><br><span class="line">  seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(dup2), 2,</span><br><span class="line">                        SCMP_A0(SCMP_CMP_EQ, 1),</span><br><span class="line">                        SCMP_A1(SCMP_CMP_EQ, 2));</span><br><span class="line"></span><br><span class="line">  // build and load the filter</span><br><span class="line">  seccomp_load(ctx);</span><br><span class="line">  printf(&quot;step 2: only &#x27;write&#x27; and dup2(1, 2) syscalls\n&quot;);</span><br><span class="line"></span><br><span class="line">  // Redirect stderr to stdout</span><br><span class="line">  dup2(1, 2);</span><br><span class="line">  printf(&quot;step 3: stderr redirected to stdout\n&quot;);</span><br><span class="line"></span><br><span class="line">  // Duplicate stderr to arbitrary fd</span><br><span class="line">  dup2(2, 42);</span><br><span class="line">  printf(&quot;step 4: !! YOU SHOULD NOT SEE ME !!\n&quot;);</span><br><span class="line"></span><br><span class="line">  // Success (well, not so in this case...)</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">step 1: unrestricted</span><br><span class="line">step 2: only &#x27;write&#x27; and dup2(1, 2) syscalls</span><br><span class="line">step 3: stderr redirected to stdout</span><br><span class="line">Bad system call</span><br></pre></td></tr></table></figure>

<h2 id="docker中的应用"><a href="#docker中的应用" class="headerlink" title="docker中的应用"></a>docker中的应用</h2><p>通过如下方式可以查看docker是否启用seccomp：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker info --format &quot;&#123;&#123; .SecurityOptions &#125;&#125;&quot;</span><br><span class="line">[name=seccomp,profile=default]</span><br></pre></td></tr></table></figure>

<p>docker每个容器默认都设置了一个seccomp profile，启用的系统调用可以从<a href="https://github.com/moby/moby/blob/master/profiles/seccomp/default.json">default.json</a>中看到。</p>
<p>docker会将seccomp传递给runc中的sepc.linux.seccomp。</p>
<p>可以通过<code>—security-opt seccomp=xxx</code>来设置docker的seccomp策略，xxx为json格式的文件，其中定义了seccomp规则。</p>
<p>也可以通过<code>--security-opt seccomp=unconfined</code>来关闭docker引入默认的seccomp规则的限制。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://blog.yadutaf.fr/2014/05/29/introduction-to-seccomp-bpf-linux-syscall-filter/">Introduction to seccomp: BPF linux syscall filter</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI0NjI4MDg5MQ==&mid=2715292188&idx=1&sn=2b7f26203aa594027550e324460bc901&chksm=cd6d15c8fa1a9cde757868fd34c8336433c4877d3e7689ed0a2bd90eb1ef6271bda97aa3bb03&mpshare=1&scene=1&srcid=12045vIwpmKLu97HvFOssitt%23rd">如何在Docker内部使用gdb调试器</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux下搭建网桥及脚本编写</title>
    <url>/post/linux_bridge/</url>
    <content><![CDATA[<p>网桥工作在数据链路层，将两个LAN连起来，根据MAC地址来转发帧。Linux下要配置网桥的方法有两种，一种是通过修改配置文件，另外一种是通过brctl工具。修改配置文件的方式是通过修改&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcgg-eth*文件来完成的，这种方式没有仔细研究。本文将编写两个脚本来完成网桥的创建和删除，脚本的功能为将机器上的网卡eth1和eth2桥接，而网桥本身未设置ip。</p>
<h1 id="网桥创建脚本"><a href="#网桥创建脚本" class="headerlink" title="网桥创建脚本"></a>网桥创建脚本</h1><p>本脚本利用brctl命令将网卡eth1和eth2桥接，可以通过<code>brctl show</code>命令查看结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 脚本作用为将两个网卡桥接</span><br><span class="line"></span><br><span class="line"># 检测brctl命令是否存在</span><br><span class="line">brctl &gt; /dev/null</span><br><span class="line">if [ $? != 1 ]; then</span><br><span class="line">	echo Command brctl not exist, please setup it. The setup execute command is \&quot;yum install bridge-utils\&quot;</span><br><span class="line">	exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 检测网桥br0是否存在，如果存在首先删除</span><br><span class="line">declare -i result=$(brctl show | grep eth0 | wc -l)</span><br><span class="line">if [ $result &gt; 0 ]; then</span><br><span class="line">	echo detect the bridge br0 have already exist, first delete it	</span><br><span class="line">	ifconfig br0 down</span><br><span class="line">	brctl delbr br0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">ifconfig eth1 0.0.0.0</span><br><span class="line">ifconfig eth2 0.0.0.0</span><br><span class="line">brctl addbr br0</span><br><span class="line">brctl addif br0 eth1</span><br><span class="line">brctl addif br0 eth2</span><br><span class="line">ifconfig br0 up</span><br><span class="line">echo create bridge br0 success, you can use command : \&quot;brctl show\&quot; to check</span><br></pre></td></tr></table></figure>

<h1 id="网桥删除脚本"><a href="#网桥删除脚本" class="headerlink" title="网桥删除脚本"></a>网桥删除脚本</h1><p>本脚本将桥接网卡br0删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 检测是否存在网桥br0</span><br><span class="line">declare -i result=$(brctl show | grep br0 | wc -l)</span><br><span class="line">if [ $result == 0 ]; then</span><br><span class="line">	echo &quot;bridge br0 not exists, exit immediately&quot;</span><br><span class="line">	exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 删除网桥br0</span><br><span class="line">ifconfig br0 down</span><br><span class="line">brctl delbr br0</span><br><span class="line">echo &quot;delete bridge br0 success&quot;</span><br></pre></td></tr></table></figure>

<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>brctl命令创建的桥接网卡在机器重启后会删除，最好将创建桥接网卡的命令放入到linux的开机启动脚本中，这样每次开机的时候都可以自动创建桥接网卡了。</p>
<h1 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h1><p><a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/bridge">bridge命令介绍</a></p>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux更改网卡名称</title>
    <url>/post/linux_change_netcardname/</url>
    <content><![CDATA[<p>本实验为在虚拟机环境中实验，操作系统为Red Hat Enterprise6.0 32位，当前网卡列表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ifconfig </span><br><span class="line">eth1      Link encap:Ethernet  HWaddr 00:0C:29:8C:58:06  </span><br><span class="line">          inet addr:192.168.124.140  Bcast:192.168.124.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::20c:29ff:fe8c:5806/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:123 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:57 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:18770 (18.3 KiB)  TX bytes:11684 (11.4 KiB)</span><br><span class="line">          Interrupt:19 Base address:0x2024</span><br><span class="line"></span><br><span class="line">eth2      Link encap:Ethernet  HWaddr 00:50:56:3F:B3:90</span><br><span class="line">          inet addr:192.168.124.141  Bcast:192.168.124.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::250:56ff:fe3f:b390/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:111 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:43 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:16101 (15.7 KiB)  TX bytes:10343 (10.1 KiB)</span><br><span class="line">          Interrupt:19 Base address:0x20a4</span><br></pre></td></tr></table></figure>

<p>目的为将网卡eth1更改为eth0，将eth2更改为eth3。</p>
<h1 id="修改grub-conf文件"><a href="#修改grub-conf文件" class="headerlink" title="修改grub.conf文件"></a>修改grub.conf文件</h1><p>在文件中内核启动时增加_biosdevname&#x3D;0_选项。修改后的文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default=0</span><br><span class="line">timeout=5</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xpm.gz</span><br><span class="line">hiddenmenu</span><br><span class="line">title Red Hat Enterprise Linux (2.6.32-71.el6.i686)</span><br><span class="line">        root (hd0,0)</span><br><span class="line">        kernel /vmlinuz-2.6.32-71.el6.i686 ro root=/dev/mapper/VolGroup-lv_root rd_LVM_LV=VolGroup/lv_root rd_LVM_LV=VolGroup/lv_swap rd_NO_LUKS rd_NO_MD rd_NO_DM LANG=zh_CN.UTF-8 KEYBOARDTYPE=pc KEYTABLE=us nomodeset crashkernel=auto rhgb quiet biosdevname=0</span><br><span class="line">        initrd /initramfs-2.6.32-71.el6.i686.img</span><br></pre></td></tr></table></figure>

<h1 id="更改网卡配置文件内容和文件名称"><a href="#更改网卡配置文件内容和文件名称" class="headerlink" title="更改网卡配置文件内容和文件名称"></a>更改网卡配置文件内容和文件名称</h1><p>在&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts目录中将原有的网卡配置文件ifcfg_Auto_eth1和ifcfg_Auto_eth2更改为ifcfg_eth0和ifcfg_eth3，同时修改文件的内容，将文件的内容中的网卡设备名称进行替换。替换后的文件ifcfg_eth0内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=dhcp</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=yes</span><br><span class="line">IPV6INIT=no</span><br><span class="line">NAME=&quot;Auto eth0&quot;</span><br><span class="line">UUID=995d037e-3b65-4490-a1fa-f26f6abf066d</span><br><span class="line">ONBOOT=yes</span><br><span class="line">HWADDR=00:0C:29:8C:58:06</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">DEVICE=eth0</span><br></pre></td></tr></table></figure>

<h1 id="删除70-persistent-net-rules文件"><a href="#删除70-persistent-net-rules文件" class="headerlink" title="删除70-persistent-net.rules文件"></a>删除70-persistent-net.rules文件</h1><p>该文件存在于&#x2F;etc&#x2F;udev&#x2F;rules.d目录下。该文件如果不存在，开始时会自动创建，里面包含了网卡名称的配置信息。</p>
<hr>
<p>在修改完上述内容后重新启动机器配置就修改过来了,修改完成之后的网卡配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost rules.d]# ifconfig                                                                                                                  </span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:0C:29:8C:58:06                                                                                             </span><br><span class="line">          inet addr:192.168.124.140  Bcast:192.168.124.255  Mask:255.255.255.0                                                                      </span><br><span class="line">          inet6 addr: fe80::20c:29ff:fe8c:5806/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:87 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:75 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:17174 (16.7 KiB)  TX bytes:14520 (14.1 KiB)</span><br><span class="line">          Interrupt:19 Base address:0x2024</span><br><span class="line"></span><br><span class="line">eth3      Link encap:Ethernet  HWaddr 00:50:56:3F:B3:90</span><br><span class="line">          inet addr:192.168.124.141  Bcast:192.168.124.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::250:56ff:fe3f:b390/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:72 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:76 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:14164 (13.8 KiB)  TX bytes:14955 (14.6 KiB)</span><br><span class="line">          Interrupt:19 Base address:0x20a4</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Linux下通过命令行进行进制转换</title>
    <url>/post/linux_convert_ary/</url>
    <content><![CDATA[<p>在Windows下可以通过计算器进行进制之间的转换，非常方便。本文总结Linux下可用的进行进制之间的转换方法。</p>
<h1 id="利用shell"><a href="#利用shell" class="headerlink" title="利用shell"></a>利用shell</h1><p>shell脚本默认数值是由10进制数处理，除非这个数字某种特殊的标记法或前缀开头，才可以表示其它进制类型数值。如：以0开头就是8进制、以0x开头就是16进制数。使用“BASE#NUMBER”这种形式可以表示其它进制。BASE值的范围为2-64。</p>
<p>其他进制转10进制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kuring@T420:~$ echo $((16#4000000))</span><br><span class="line">67108864</span><br><span class="line">kuring@T420:~$ echo $((2#111))</span><br><span class="line">7</span><br><span class="line">kuring@T420:~$ echo $((0x10))</span><br><span class="line">16</span><br><span class="line">kuring@T420:~$ echo $((010))</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">// 对进制转换为10进制进行运算，稍显啰嗦</span><br><span class="line">kuring@T420:~$ echo $(($((16#4000000))/1014/1024));</span><br><span class="line">64</span><br></pre></td></tr></table></figure>

<h1 id="利用let命令"><a href="#利用let命令" class="headerlink" title="利用let命令"></a>利用let命令</h1><p>let用来执行算数运算和数值表达式测试。可以利用该命令完成简单的计算，并将计算结果赋给其他变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 对进制转换为10进制后进行运算，比纯shell方式简洁</span><br><span class="line">kuring@T420:~$ let a=$((16#4000000))/1014/1024;</span><br><span class="line">kuring@T420:~$ echo $a</span><br><span class="line">64</span><br></pre></td></tr></table></figure>

<h1 id="利用bc命令"><a href="#利用bc命令" class="headerlink" title="利用bc命令"></a>利用bc命令</h1><p>该命令是一个强大的计算器软件，可以利用其中的ibase和obase进行输入进制的转换，ibase表示输入数字的进制，obase表示输出数字的进制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 如果没有制定，则默认为10进制</span><br><span class="line">// 对于16进制，要使用F，而不能使用f</span><br><span class="line">kuring@T420:~$ echo &quot;ibase=16;FF&quot; | bc</span><br><span class="line">255</span><br><span class="line">kuring@T420:~$ echo &quot;obase=2;ibase=16;FF&quot; | bc</span><br><span class="line">11111111</span><br></pre></td></tr></table></figure>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.cnblogs.com/chengmo/archive/2010/10/14/1851570.html">linux shell 不同进制数据转换（二进制，八进制，十六进制，base64)</a></p>
<p><a href="http://blog.csdn.net/fengyuxing168/article/details/8896955">Shell进制转换小结</a></p>
]]></content>
  </entry>
  <entry>
    <title>linux中创建新进程的方式</title>
    <url>/post/linux_create_process_methods/</url>
    <content><![CDATA[<h1 id="system函数"><a href="#system函数" class="headerlink" title="system函数"></a>system函数</h1><p>函数包含在C语言的标准库中，在头文件stdlib.h中声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int system(const char *command);</span><br></pre></td></tr></table></figure>
<p>该函数会创建一个独立的进程，该进程拥有独立的进程空间，为阻塞函数，只有当新进程执行完毕该函数才返回。</p>
<p>返回值：可以通过返回值来获取新进程的main函数的返回值，返回值保存在int类型的第二个字节即8-15比特，可以通过向右移位或者利用宏WEXITSTATUS(status)来获取新进程的返回值。其中WEXITSTATUS(status)宏包含在头文件&lt;sys&#x2F;wait.h&gt;中。</p>
<p>这里以调用ls命令为例来展示用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r=system(<span class="string">&quot;ls&quot;</span>);</span><br><span class="line">    <span class="comment">// 用右移位的方式来获取新进程的返回值</span></span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,r&gt;&gt;8&amp;255);</span></span><br><span class="line">    <span class="comment">// 用WEXITSTATUS(status)宏的方式来获取新进程的返回值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,WEXITSTATUS(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="popen函数"><a href="#popen函数" class="headerlink" title="popen函数"></a>popen函数</h1><p>函数包含在头文件stdio.h中，相关函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<p>popen函数在父子进程之间建立一个管道，其中type指定管道的类型，可以为”r”或”w”即只读或可写。在shell中的管道符”|”即采用此函数来实现。popen函数为阻塞函数，函数的具体用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    FILE *f=popen(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据管道获取文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd=fileno(f);  </span><br><span class="line">    <span class="type">int</span> r;     </span><br><span class="line">    <span class="keyword">while</span>((r=read(fd,buf,<span class="number">1024</span>))&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        buf[r]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">    &#125; </span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="comment">// 关闭管道</span></span><br><span class="line">    pclose(f);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="exec系列函数"><a href="#exec系列函数" class="headerlink" title="exec系列函数"></a>exec系列函数</h1><p>该系列函数并不创建新的进程，而是将程序加载到当前进程的代码空间来执行并替换当前进程的代码空间，在exec*函数后面的代码将无法执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ..., <span class="type">char</span> * <span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br></pre></td></tr></table></figure>
<h1 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h1><p>该函数非常常用。函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>调用该函数会产生一个子进程，该子进程不仅复制了父进程的代码空间、堆、栈，而且还复制了父进程的执行位置。之后父子进程同时执行，通常由于操作系统任务调度的原因，子进程会先执行。父进程和子进程之间的并不会共享堆、栈上的数据，可以通过文件或共享内存的方式来通讯。</p>
<p>返回值：该函数父进程返回子进程的id，子进程返回0。通常在代码中通过返回值来判断是子进程还是父进程，用来执行不同的代码。</p>
<p>如果父进程先结束，则子进程会成为孤儿进程，子进程仍然可以继续执行。进程数中的根进程init会成为该子进程的父进程。</p>
<p>如果子进程先结束，则子进程会成为僵尸进程。僵尸进程并不再占用内存和CPU资源，但是会在进程数中看到僵尸进程。因此代码中必须对僵尸进程的情况做处理，通常的处理办法为采用wait函数和信号机制。子进程在结束的时候会向父进程发送一个信号SIGCHLD，整数值为17。父进程扑捉到该信号后通过调用wait函数来回收子进程的资源。其中wait函数为阻塞函数，会一直等待子进程结束。wait函数返回子进程退出时的状态码。下面通过实例演示一下当子进程先结束时父进程怎样回收子进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">processChildProcess</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;receive the child process end\n&quot;</span>);</span><br><span class="line">    wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        signal(SIGCHLD, processChildProcess);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process end\n&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于fork的详细理解可以看这里：<a href="http://coolshell.cn/articles/7965.html">一个fork的面试题</a>。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设备驱动程序实例之hello world</title>
    <url>/post/linux_driver_hello_world/</url>
    <content><![CDATA[<p>本文为Linux设备驱动程序的入门实践文章，编写一个hello world程序，并在Linux上执行。</p>
<h1 id="编写驱动程序"><a href="#编写驱动程序" class="headerlink" title="编写驱动程序"></a>编写驱动程序</h1><p>驱动程序hello.c文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef __KERNEL__</span><br><span class="line">#  define __KERNEL__</span><br><span class="line">#endif</span><br><span class="line">#ifndef MODULE</span><br><span class="line">#  define MODULE</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#include &lt;linux/kernel.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line"></span><br><span class="line">int hello_init()</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_WARNING &quot;Hello kernel!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void hello_exit()</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;Bye, kernel!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit)</span><br></pre></td></tr></table></figure>

<h1 id="编写Makefile"><a href="#编写Makefile" class="headerlink" title="编写Makefile"></a>编写Makefile</h1><p>Makefile文件的写法可以采用传统的make方式，也可以采用kbuild的方式。</p>
<p>采用传统的make方式的写法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifeq ($(KERNELRELEASE),)</span><br><span class="line">KERNELDIR ?= /lib/modules/$(shell uname -r)/build</span><br><span class="line">PWD := $(shell pwd)</span><br><span class="line"></span><br><span class="line">modules:</span><br><span class="line">        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">modules_install:</span><br><span class="line">        $(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br><span class="line"></span><br><span class="line">.PHONY: modules modules_install clean</span><br><span class="line">else</span><br><span class="line">        obj-m := hello.o</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>采用kbuild方式的Makefile内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-m := hello.o</span><br><span class="line"></span><br><span class="line">all :</span><br><span class="line">        $(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        $(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</span><br></pre></td></tr></table></figure>

<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>将hello.c和Makefile文件放在任意目录中，执行make命令编译。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>执行<code>insmod hello.ko</code>命令安装驱动程序，通过<code>lsmod</code>命令即可看到驱动程序已经安装。</p>
<p>通过查看&#x2F;var&#x2F;log&#x2F;messages文件即可看到hello驱动程序打印的内容。</p>
<h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>执行<code>rmmod hello.ko</code>命令即可卸载驱动程序模块。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>《深入理解Linux设备驱动程序》<br>《Linux那些事之我是USB》<br><a href="http://www.cnblogs.com/QuLory/archive/2012/10/23/2736339.html">Ubuntu12.10 内核源码外编译 linux模块–编译驱动模块的基本方法</a></p>
]]></content>
  </entry>
  <entry>
    <title>Linux函数高级特性</title>
    <url>/post/linux_funtion_advance_feature/</url>
    <content><![CDATA[<p>最近在看《Linux&#x2F;Unix系统编程手册》一书，这里对书中提到的函数类型进行总结。</p>
<h1 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h1><p>POSIX标准中的解释如下：</p>
<blockquote>
<p>Reentrant Function:<br>A function whose effect, when called by two or more threads,is guaranteed to be as if the threads each executed thefunction one after another in an undefined order, even ifthe actual execution is interleaved.</p>
</blockquote>
<p>可重入函数跟信号相关，一种更容易理解的解释为：</p>
<p>程序执行到某个函数foo()时，收到信号，于是暂停目前正在执行的函数，转到信号处理函数，而这个信号处理函数的执行过程中，又恰恰也会进入到刚刚执行的函数foo()，便发生了所谓的重入。此时如果foo()能够正确的运行，而且处理完成后，之前暂停的foo()也能够正确运行，则说明它是可重入的。</p>
<p>可重入函数需要满足如下几个条件：</p>
<ul>
<li>不在函数内部使用静态或全局数据</li>
<li>不返回静态或全局数据，所有数据均有函数调用者提供</li>
<li>使用本地数据或通过复制全局数据来保护全局数据</li>
<li>不调用不可重入函数</li>
</ul>
<h1 id="标准的异步安全信号函数"><a href="#标准的异步安全信号函数" class="headerlink" title="标准的异步安全信号函数"></a>标准的异步安全信号函数</h1><p>异步信号安全的函数指当从信号处理函数调用时，可保证实现是安全的。如果某一个函数是可重入的，或者信号处理函数无法将其中断时，称该函数是异步信号安全的。</p>
<p>我的理解是可重入函数和标准的异步安全信号函数基本等同，只是描述层面不同。</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>若函数可同时供多个线程安全的调用，则该函数为线程安全的函数。比较容易理解。</p>
<h1 id="线程安全与可重入之间的关系"><a href="#线程安全与可重入之间的关系" class="headerlink" title="线程安全与可重入之间的关系"></a>线程安全与可重入之间的关系</h1><p>可重入函数一定为线程安全的函数。线程安全函数不一定是可重入函数。</p>
<p>不可重入函数，函数调用结果不具有可再现性，可通过互斥锁等机制供多个线程安全的调用，这样该不可重入函数即为线程安全的函数。</p>
<p>malloc函数内部维护了全局数据结构，因此为不可重入的，但是内部通过递归互斥量来确保为线程安全的函数。并且该互斥量必须是可递归的，否则当malloc函数重入的情况下，会造成死锁。在glibc中，malloc有线程安全和非线程安全两个版本，两个区别在于内部是否使用递归锁，当编译程序时使用了<code>_pthreads</code>选项时使用线程安全版本，否则使用非线程安全版本。</p>
<h1 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h1><p>Linux中的某些系统调用在阻塞的过程中，如果接受到信号并转去处理信号处理函数，当从信号处理函数返回时这些阻塞的系统调用默认会返回EINTR。为了避免信号处理函数对阻塞中的系统调用的打断，可以通过设置SA_RESTART标志的sigaction()来建立信号处理函数，从而令内核代表进程自动重启系统调用，而无需处理系统调用返回的EINTR错误。</p>
<p>并非所有的系统调用都支持自动重启，具体可参考《Linux&#x2F;Unix系统编程手册（上册）》的21.5节。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《Linux&#x2F;Unix系统编程手册（上册）》</p>
<p><a href="http://blog.csdn.net/lovekatherine/article/details/1544644">对可重性和线程安全的小结</a></p>
]]></content>
  </entry>
  <entry>
    <title>在linux程序中获取和设置环境变量</title>
    <url>/post/linux_get_and_set_env_variable/</url>
    <content><![CDATA[<h1 id="shell中的环境变量"><a href="#shell中的环境变量" class="headerlink" title="shell中的环境变量"></a>shell中的环境变量</h1><h3 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h3><ol>
<li>通过env命令可以查看所有的环境变量</li>
<li>通过echo $环境变量名方式来查看单个环境变量</li>
</ol>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>export命令来设置环境变量</p>
<p>在程序中该如何获取和设置环境变量呢？</p>
<h1 id="通过main函数的第三个参数"><a href="#通过main函数的第三个参数" class="headerlink" title="通过main函数的第三个参数"></a>通过main函数的第三个参数</h1><p>通常大家接触比较多的是两个参数的main函数，实际上还有一个包含三个参数的main函数，第三个参数为包含了系统的环境变量的二级指针。<br>用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *arge[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (*arge)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *arge);</span><br><span class="line">        arge++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例将会输出该用户的所有环境变量。</p>
<h1 id="通过外部环境变量environ"><a href="#通过外部环境变量environ" class="headerlink" title="通过外部环境变量environ"></a>通过外部环境变量environ</h1><p>该变量定义在“unistd.h”头文件中，定义为：extern char **environ;<br>用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">( <span class="type">int</span> argc, <span class="type">char</span> *argv[] )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> **env = environ;</span><br><span class="line">    <span class="keyword">while</span> (*env)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *env);</span><br><span class="line">        env++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>实例将会输出该用户的所有环境变量。</p>
<h1 id="通过系统函数"><a href="#通过系统函数" class="headerlink" title="通过系统函数"></a>通过系统函数</h1><p>在C语言的头文件“stdlib.h”中定义了三个和环境变量相关的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">int</span> overwrite)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<p>比较简单，不再举例。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux中获取错误信息的方式</title>
    <url>/post/linux_get_error_of_function/</url>
    <content><![CDATA[<p>当linux中的函数内部出错时通常函数会返回-1，并且将错误码保存到全局变量errno中，用来表示错误代码。errno全局变量包含在头文件errno.h文件中。下面给出三种打印错误信息的方法。</p>
<h1 id="perror函数"><a href="#perror函数" class="headerlink" title="perror函数"></a>perror函数</h1><p>应用举例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp ;</span><br><span class="line">    fp = fopen( <span class="string">&quot;/root/noexitfile&quot;</span>, <span class="string">&quot;r+&quot;</span> );</span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == fp )</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;error : &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：<br>Permission denied</p>
<h1 id="strerror函数"><a href="#strerror函数" class="headerlink" title="strerror函数"></a>strerror函数</h1><p>strerror函数原型为：char *strerror(int errnum);将参数errnum转换为对应的错误码。<br>应用举例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp ;</span><br><span class="line">    fp = fopen( <span class="string">&quot;/root/noexitfile&quot;</span>, <span class="string">&quot;r+&quot;</span> );</span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == fp )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：<br>Permission denied</p>
<h1 id="printf中的-m打印"><a href="#printf中的-m打印" class="headerlink" title="printf中的%m打印"></a>printf中的%m打印</h1><p>应用举例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp ;</span><br><span class="line">    fp = fopen( <span class="string">&quot;/root/noexitfile&quot;</span>, <span class="string">&quot;r+&quot;</span> );</span><br><span class="line">    <span class="keyword">if</span> ( <span class="literal">NULL</span> == fp )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%m\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：<br>Permission denied</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux IO模型</title>
    <url>/post/linux_io/</url>
    <content><![CDATA[<p>由于I&#x2F;O模型现在掌握还不够透彻，本文仅列出了一些I&#x2F;O模型中的一些常用概念，对于select、poll、epoll和信号驱动I&#x2F;O等模型理解还不够透彻，待理解透彻后补上。</p>
<h1 id="阻塞I-x2F-O与非阻塞I-x2F-O"><a href="#阻塞I-x2F-O与非阻塞I-x2F-O" class="headerlink" title="阻塞I&#x2F;O与非阻塞I&#x2F;O"></a>阻塞I&#x2F;O与非阻塞I&#x2F;O</h1><p>阻塞I&#x2F;O：当进行I&#x2F;O操作后，程序处于等待状态，直到需要的资源可用为止。</p>
<p>非阻塞I&#x2F;O：当进行I&#x2F;O操作后，函数直接返回，不需要等待。</p>
<h1 id="两种文件描述符准备就绪的通知模式"><a href="#两种文件描述符准备就绪的通知模式" class="headerlink" title="两种文件描述符准备就绪的通知模式"></a>两种文件描述符准备就绪的通知模式</h1><p>水平触发通知：如果文件描述符上可以非阻塞地执行I&#x2F;O系统调用，此时认为它已经就绪。允许在任意时刻重复检测I&#x2F;O状态，没有必要每次当文件描述符就绪后尽可能多的执行I&#x2F;O。其中select()和poll()属于水平触发通知模式。</p>
<p>边缘触发通知：如果文件描述符自上次状态检查以来有了新的I&#x2F;O活动，此时需要触发通知。只有当I&#x2F;O事件发生后才会得到通知，在另外一个I&#x2F;O事件到来之前不会得到通知。因此，在接收到一个I&#x2F;O事件后，程序在某个时刻应该在相应的文件描述符上尽可能多地执行I&#x2F;O。每个被检查的文件描述符被置为非阻塞模式，在得到I&#x2F;O事件通知后重复执行I&#x2F;O操作，直到系统调用返回错误为止。其中信号驱动I&#x2F;O属于此种类型。</p>
<p>将的通俗一点，假设通过异步I&#x2F;O读取socket数据，当接收到100个字节的数据后，这时候会触发通知给应用程序。如果应用程序仅读取了50字节的数据，重新调用异步I&#x2F;O函数时，在水平触发时仍然会得到通知，而采用边缘触发时不会得到通知。</p>
<p>epoll即可以采用水平触发通知方式，也可以采用边缘触发通知方式。</p>
<p>这两个概念对于理解Linux的I&#x2F;O模型非常重要，但是却是不容易理解。可以通过举例说明：一个管道内收到了数据，注册该管道描述符的epoll返回，但是用户只读取了一部分数据，然后再次调用了epoll。这时，如果是水平触发方式，epoll将立刻返回，因为当前有数据可读，满足IO就绪的要求；但是如果是边沿触发方式，epoll不会返回，因为调用之后还没有新的IO事件发生，直到有新的数据到来，epoll才会返回，用户可以一并读到老的数据和新的数据。</p>
<h1 id="同步I-x2F-O与异步I-x2F-O"><a href="#同步I-x2F-O与异步I-x2F-O" class="headerlink" title="同步I&#x2F;O与异步I&#x2F;O"></a>同步I&#x2F;O与异步I&#x2F;O</h1><p>同步I&#x2F;O：发出I&#x2F;O操作后，后面操作不能进行，要么等待I&#x2F;O操作完成，要么放弃I&#x2F;O操作。后面的操作和当前的操作只能有一个进行。</p>
<p>异步I&#x2F;O：发出I&#x2F;O操作后，马上返回继续执行后面的操作，而I&#x2F;O操作同时执行。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li>《Linux&#x2F;UNIX系统编程手册》第63章</li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM1NjUwMQ==&amp;mid=200266959&amp;idx=1&amp;sn=fa2240310c3995284bc9da3878ca07be&amp;scene=1#rd">浅析Linux IO技术体系</a></li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下内核编译安装</title>
    <url>/post/linux_kernel_setup/</url>
    <content><![CDATA[<p>本文仅为了练习Linux内核源码的编译安装，安装环境为VMWare下的CentOS，现有CentOS版本为<code>2.6.32-358.el6.x86_64</code>。<br>&#x2F;boot&#x2F;grub&#x2F;grub.conf文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 注释部分去掉</span><br><span class="line">default=0</span><br><span class="line">timeout=5</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xpm.gz</span><br><span class="line">hiddenmenu</span><br><span class="line">title CentOS (2.6.32-358.el6.x86_64)</span><br><span class="line">        root (hd0,0)</span><br><span class="line">        kernel /vmlinuz-2.6.32-358.el6.x86_64 ro root=/dev/mapper/vg_livedvd-lv_root rd_NO_LUKS rd_LVM_LV=vg_livedvd/lv_root rd_NO_MD crashkernel=auto rd_LVM_LV=vg_livedvd/lv_swap  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM LANG=zh_CN.UTF-8 rhgb quiet</span><br><span class="line">        initrd /initramfs-2.6.32-358.el6.x86_64.img</span><br></pre></td></tr></table></figure>

<h1 id="获取内核源码"><a href="#获取内核源码" class="headerlink" title="获取内核源码"></a>获取内核源码</h1><p>首先从Linux的<a href="www.kernel.org">官方网站</a>下载最新版内核Linux3.13。</p>
<p>执行<code>tar Jxvf linux-3.13.tar.xz -C/usr/src/kernels</code>命令将内核源码解压到内核源代码存放目录&#x2F;usr&#x2F;src&#x2F;kernels&#x2F;，该源码目录并不固定，但推荐将内核源码存放到该目录下。</p>
<p>为了将上次编译时的目标文件及相关设置文件删除，执行<code>make mrproper</code>。</p>
<h1 id="挑选功能"><a href="#挑选功能" class="headerlink" title="挑选功能"></a>挑选功能</h1><p>可以采用了多种方式，这里采用<code>make menuconfig</code>的方式来挑选内核功能，该方式不需要X Window（<code>make xconfig</code>方式）的支持，而且要比纯命令行方式（<code>make config</code>）要直观。执行<code>make menuconfig</code>遇到如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost linux-3.13]# make menuconfig</span><br><span class="line">  HOSTCC  scripts/basic/fixdep</span><br><span class="line">  HOSTCC  scripts/kconfig/conf.o</span><br><span class="line"> *** Unable to find the ncurses libraries or the</span><br><span class="line"> *** required header files.</span><br><span class="line"> *** &#x27;make menuconfig&#x27; requires the ncurses libraries.</span><br><span class="line"> ***</span><br><span class="line"> *** Install ncurses (ncurses-devel) and try again.</span><br><span class="line"> ***</span><br><span class="line">make[1]: *** [scripts/kconfig/dochecklxdialog] 错误 1</span><br><span class="line">make: *** [menuconfig] 错误 2</span><br></pre></td></tr></table></figure>

<p>这是因为需要ncurses库的支持，下面采用从源码安装的方式安装ncurses。</p>
<p>从ncurses的<a href="https://www.gnu.org/software/ncurses/">官方网站</a>下载最新版的ncurses-5.9.tar.gz。然后分别执行<code>./configure</code>、make<code>、</code>make install&#96;命令安装。</p>
<h1 id="更改内核版本号标识"><a href="#更改内核版本号标识" class="headerlink" title="更改内核版本号标识"></a>更改内核版本号标识</h1><p>为了能够在编译完成后的内核版本中通过<code>uname -r</code>看到定义的内核版本号，修改Makefile文件。其中<code>EXTRAVERSION</code>字段值为空，将其赋值为kuring。</p>
<h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><p>执行<code>make</code>命令，该过程需要话费很长时间，我在512MB的VM下跑，花费了大约1个半小时时间。</p>
<h1 id="编译内核模块"><a href="#编译内核模块" class="headerlink" title="编译内核模块"></a>编译内核模块</h1><p>执行<code>make modules</code>命令。</p>
<h1 id="安装内核模块"><a href="#安装内核模块" class="headerlink" title="安装内核模块"></a>安装内核模块</h1><p>执行<code>make modules_install</code>命令，会将内核模块安装到&#x2F;lib&#x2F;modules目录下。</p>
<h1 id="安装内核"><a href="#安装内核" class="headerlink" title="安装内核"></a>安装内核</h1><p>执行<code>make install</code>命令，产生如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh /usr/src/kernels/linux-3.13/arch/x86/boot/install.sh 3.13.0kuring arch/x86/boot/bzImage \</span><br><span class="line">                System.map &quot;/boot&quot;</span><br><span class="line">ERROR: modinfo: could not find module vmhgfs</span><br><span class="line">ERROR: modinfo: could not find module vsock</span><br><span class="line">ERROR: modinfo: could not find module vmware_balloon</span><br><span class="line">ERROR: modinfo: could not find module vmci</span><br></pre></td></tr></table></figure>
<p>这个错误跟vmware的vmware tools有关，暂时不去管。</p>
<p>这样再去看&#x2F;boot&#x2F;grub&#x2F;grub.conf文件，会看到文件已经变化，已经将新内核添加到开机启动项中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 注释部分去掉</span><br><span class="line">default=1</span><br><span class="line">timeout=5</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xpm.gz</span><br><span class="line">hiddenmenu</span><br><span class="line">title CentOS (3.13.0kuring)</span><br><span class="line">        root (hd0,0)</span><br><span class="line">        kernel /vmlinuz-3.13.0kuring ro root=/dev/mapper/vg_livedvd-lv_root rd_NO_LUKS rd_LVM_LV=vg_livedvd/lv_root rd_NO_MD crashkernel=auto rd_LVM_LV=vg_livedvd/lv_swap  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM LANG=zh_CN.UTF-8 rhgb quiet</span><br><span class="line">        initrd /initramfs-3.13.0kuring.img</span><br><span class="line">title CentOS (2.6.32-358.el6.x86_64)</span><br><span class="line">        root (hd0,0)</span><br><span class="line">        kernel /vmlinuz-2.6.32-358.el6.x86_64 ro root=/dev/mapper/vg_livedvd-lv_root rd_NO_LUKS rd_LVM_LV=vg_livedvd/lv_root rd_NO_MD crashkernel=auto rd_LVM_LV=vg_livedvd/lv_swap  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM LANG=zh_CN.UTF-8 rhgb quiet</span><br><span class="line">        initrd /initramfs-2.6.32-358.el6.x86_64.img</span><br></pre></td></tr></table></figure>

<p>同时在&#x2F;boot目录下已经多出了vmlinuz-3.13.0kuring、System.map-3.13.0kuring、initramfs-3.13.0kuring.img文件。</p>
<p>重启系统后，在启动菜单中多出了新内核选项。进入新内核后，执行<code>uname -r</code>显示<code>3.13.0kuring</code>，说明新内核已经安装完成。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux下父进程定期杀死超时子进程的例子</title>
    <url>/post/linux_kill_child_process/</url>
    <content><![CDATA[<p>在Linux下会父进程通过fork()出的子进程可能会由于某种原因死锁或睡眠而无法终止，这时候需要父进程杀死子进程。本程序是父进程检测到子进程运行一段时间后杀死子进程的例子。</p>
<p>父进程的检测代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// parent process</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">pid_t</span> result = waitpid(pid, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child process is running\n&quot;</span>);</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count &gt;= <span class="number">60</span> * <span class="number">60</span>)   <span class="comment">// one hour</span></span><br><span class="line">                &#123;</span><br><span class="line">                    kill(pid, <span class="number">9</span>);   <span class="comment">// kill child process</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (result == pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child process has exit\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;result=%d\n&quot;</span>, result);</span><br><span class="line">            &#125;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// child process</span></span><br><span class="line">        execv(<span class="string">&quot;/home/kuring/source/child&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork() error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子进程调用execv()函数执行的child代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子比较简单，不作过多解释。</p>
]]></content>
  </entry>
  <entry>
    <title>一个Linux下的监听脚本程序</title>
    <url>/post/linux_listen_shell/</url>
    <content><![CDATA[<p>为了避免linux下的控制台程序A死掉，可以通过一个另外一个程序B来监听A程序，当A程序异常退出时将B程序带起来。当然程序设计的最好方式为程序不崩溃，但是程序中存在bug很难避免，该方法还是有一定的实践意义。对于B程序可以通过shell脚本或者单独一个应用程序来解决。本文将通过shell脚本来解决此问题。</p>
<h1 id="shell脚本的内容"><a href="#shell脚本的内容" class="headerlink" title="shell脚本的内容"></a>shell脚本的内容</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">check_process()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">check parameter</span></span><br><span class="line">	if [ $1 = &quot;&quot; ];</span><br><span class="line">	then</span><br><span class="line">		return -1</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">get the running process</span></span><br><span class="line">	process_names=$(ps -ef | grep $1 | grep -v grep | awk &#x27;&#123;print $8&#125;&#x27;)</span><br><span class="line">	for process_name in $process_names</span><br><span class="line">	do</span><br><span class="line">		if [ $process_name = $1 ] ;</span><br><span class="line">		then</span><br><span class="line">			return 1</span><br><span class="line">		fi</span><br><span class="line">	done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">not run and run the process</span></span><br><span class="line">	echo &quot;$(date) : process $1 not run, just run it&quot;</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">1</span></span><br><span class="line">	return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while [ 1 ];do</span><br><span class="line">	check_process &quot;/usr/bin/app/process&quot;	# programe path</span><br><span class="line">	sleep 5</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h1 id="将shell脚本在脱离控制台下可以运行"><a href="#将shell脚本在脱离控制台下可以运行" class="headerlink" title="将shell脚本在脱离控制台下可以运行"></a>将shell脚本在脱离控制台下可以运行</h1><p>一旦断开了控制台，shell脚本就会由于接收到SIGHUP信号而退出。这里有两种思路来解决该问题，一种是通过系统的crontab来定期调用脚本程序，另外一种是通过神奇的screen程序来解决该问题，我这里通过screen程序来解决该问题，具体screen程序的应用见我的另外一篇文章《》。</p>
<h1 id="应用程序为daemon方式运行"><a href="#应用程序为daemon方式运行" class="headerlink" title="应用程序为daemon方式运行"></a>应用程序为daemon方式运行</h1><p>为了能够保证该脚本监控多个应用程序，需要将应用程序设置为daemon方式运行，可以调用函数daemon实现。也可以调用单独实现的daemon函数，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void init_daemon(void) </span><br><span class="line">&#123; </span><br><span class="line">    int pid; </span><br><span class="line">    int i;  </span><br><span class="line"></span><br><span class="line">    if(pid=fork()) </span><br><span class="line">        exit(0);//是父进程，结束父进程 </span><br><span class="line">    else if(pid&lt; 0)  </span><br><span class="line">        exit(1);//fork失败，退出 </span><br><span class="line">    //是第一子进程，后台继续执行 </span><br><span class="line"></span><br><span class="line">    setsid();//第一子进程成为新的会话组长和进程组长 </span><br><span class="line">    //并与控制终端分离 </span><br><span class="line">    if(pid=fork()) </span><br><span class="line">        exit(0);//是第一子进程，结束第一子进程 </span><br><span class="line">    else if(pid&lt; 0)  </span><br><span class="line">        exit(1);//fork失败，退出 </span><br><span class="line">    //是第二子进程，继续 </span><br><span class="line">    //第二子进程不再是会话组长 </span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt; NOFILE;++i)//关闭打开的文件描述符 </span><br><span class="line">        close(i); </span><br><span class="line">    chdir(&quot;/tmp&quot;);//改变工作目录到/tmp </span><br><span class="line">    umask(0);//重设文件创建掩模 </span><br><span class="line">    return; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Linux常用网络诊断工具整理</title>
    <url>/post/linux_net_tools/</url>
    <content><![CDATA[<p>本文对Linux常用的网络命令进行整理和总结。</p>
<h1 id="连通性测试"><a href="#连通性测试" class="headerlink" title="连通性测试"></a>连通性测试</h1><h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><p>最常用的网络诊断命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kuring@localhost ~]$ ping www.baidu.com</span><br><span class="line">PING www.a.shifen.com (61.135.169.125) 56(84) bytes of data.</span><br><span class="line">64 bytes from 61.135.169.125: icmp_seq=1 ttl=128 time=25.5 ms</span><br><span class="line">64 bytes from 61.135.169.125: icmp_seq=2 ttl=128 time=20.3 ms</span><br><span class="line">64 bytes from 61.135.169.125: icmp_seq=3 ttl=128 time=25.0 ms</span><br><span class="line">64 bytes from 61.135.169.125: icmp_seq=4 ttl=128 time=21.7 ms</span><br><span class="line">64 bytes from 61.135.169.125: icmp_seq=5 ttl=128 time=23.4 ms</span><br><span class="line">64 bytes from 61.135.169.125: icmp_seq=6 ttl=128 time=21.9 ms</span><br></pre></td></tr></table></figure>
<p>通过上述输出可以看出，ping命令可得到DNS对应的IP信息、ping的数据包大小、网络延迟信息。</p>
<p>另外，可以通过-s参数指定ping的数据包大小。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kuring@ubuntu:~$ ping www.baidu.com -s 1024</span><br><span class="line">PING www.a.shifen.com (61.135.169.125) 1024(1052) bytes of data.</span><br><span class="line">1032 bytes from 61.135.169.125: icmp_req=1 ttl=55 time=22.6 ms</span><br><span class="line">1032 bytes from 61.135.169.125: icmp_req=2 ttl=55 time=22.9 ms</span><br><span class="line">1032 bytes from 61.135.169.125: icmp_req=3 ttl=55 time=53.0 ms</span><br><span class="line">1032 bytes from 61.135.169.125: icmp_req=4 ttl=55 time=28.0 ms</span><br><span class="line">1032 bytes from 61.135.169.125: icmp_req=5 ttl=55 time=54.7 ms</span><br><span class="line">1032 bytes from 61.135.169.125: icmp_req=6 ttl=55 time=93.1 ms</span><br><span class="line">1032 bytes from 61.135.169.125: icmp_req=7 ttl=55 time=26.9 ms</span><br><span class="line">1032 bytes from 61.135.169.125: icmp_req=8 ttl=55 time=25.2 ms</span><br><span class="line">1032 bytes from 61.135.169.125: icmp_req=9 ttl=55 time=25.4 ms</span><br><span class="line">^C1032 bytes from 61.135.169.125: icmp_req=10 ttl=55 time=21.2 ms</span><br><span class="line"></span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">10 packets transmitted, 10 received, 0% packet loss, time 45436ms</span><br><span class="line">rtt min/avg/max/mdev = 21.225/37.350/93.149/21.966 ms</span><br></pre></td></tr></table></figure>
<p>会发现ping命令的响应时间变长了，这正是由于ping发送数据包变大了。</p>
<h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><p>可以显示路由信息。</p>
<h2 id="mtr"><a href="#mtr" class="headerlink" title="mtr"></a>mtr</h2><p>traceroute命令的升级版，可以动态刷新路由信息，可以显示路由上每个节点的丢包率和时间等信息，信息比较全面和直观。</p>
<h1 id="arp相关"><a href="#arp相关" class="headerlink" title="arp相关"></a>arp相关</h1><h2 id="arping"><a href="#arping" class="headerlink" title="arping"></a>arping</h2><p>可以通过该命令查看IP地址对应的mac地址。<code>arping IP地址</code>会立即发送一个arp广播，可以根据收到的arp回应的多少看局域网内是否中arp病毒、IP地址冲突等情况。</p>
<h2 id="arp"><a href="#arp" class="headerlink" title="arp"></a>arp</h2><p>跟arp协议相关，可以设置arp表、读取arp表等。</p>
<h1 id="端口相关"><a href="#端口相关" class="headerlink" title="端口相关"></a>端口相关</h1><h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>可以利用该命令来测试某个端口是否打开。例如执行<code>telnet localhost 881</code>其中881为本机的未打开端口，会产生如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Trying 127.0.0.1...</span><br><span class="line">telnet: connect to address 127.0.0.1: Connection refused</span><br></pre></td></tr></table></figure>

<p>执行<code>telnet localhost 22</code>，其中22端口为本机的ssh服务端口且已经打开，会产生如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">SSH-2.0-OpenSSH_5.3</span><br></pre></td></tr></table></figure>

<p>则表示本机的22端口已经打开。</p>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>查看本机网络端口命令，常用<code>netstat -aunp</code>。</p>
<p>#DNS相关</p>
<h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kuring@ubuntu:~$ host www.google.com.hk</span><br><span class="line">www.google.com.hk is an alias for www-wide.l.google.com.</span><br><span class="line">www-wide.l.google.com has address 74.125.128.199</span><br><span class="line">www-wide.l.google.com has IPv6 address 2404:6800:4005:c00::c7</span><br></pre></td></tr></table></figure>

<h2 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kuring@ubuntu:~$ nslookup www.google.com.hk</span><br><span class="line">Server:		127.0.0.1</span><br><span class="line">Address:	127.0.0.1#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.google.com.hk	canonical name = www-wide.l.google.com.</span><br><span class="line">Name:	www-wide.l.google.com</span><br><span class="line">Address: 74.125.128.199</span><br></pre></td></tr></table></figure>

<h2 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h2><p>可以代替nslookup的命令，显示的域名信息更为详细。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h1 id="ab"><a href="#ab" class="headerlink" title="ab"></a>ab</h1><p>Linux下的压力测试工具，可以模拟多个客户端发送多个请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kuring@ubuntu:~$ ab -c 100 -n 100 http://kuring.me/</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking kuring.me (be patient).....done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:        Tengine/2.0.0</span><br><span class="line">Server Hostname:        kuring.me</span><br><span class="line">Server Port:            80</span><br><span class="line"></span><br><span class="line">Document Path:          /</span><br><span class="line">Document Length:        707 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      100</span><br><span class="line">Time taken for tests:   1.547 seconds</span><br><span class="line">Complete requests:      100</span><br><span class="line">Failed requests:        10</span><br><span class="line">   (Connect: 0, Receive: 0, Length: 10, Exceptions: 0)</span><br><span class="line">Write errors:           0</span><br><span class="line">Non-2xx responses:      90</span><br><span class="line">Total transferred:      145330 bytes</span><br><span class="line">HTML transferred:       126570 bytes</span><br><span class="line">Requests per second:    64.64 [#/sec] (mean)</span><br><span class="line">Time per request:       1546.990 [ms] (mean)</span><br><span class="line">Time per request:       15.470 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          91.74 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:      173  223  43.8    200     289</span><br><span class="line">Processing:   167  340 301.5    236    1368</span><br><span class="line">Waiting:      166  339 300.5    235    1364</span><br><span class="line">Total:        345  563 295.4    438    1546</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    438</span><br><span class="line">  66%    555</span><br><span class="line">  75%    562</span><br><span class="line">  80%    597</span><br><span class="line">  90%   1108</span><br><span class="line">  95%   1474</span><br><span class="line">  98%   1484</span><br><span class="line">  99%   1546</span><br><span class="line"> 100%   1546 (longest request)</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://edu.51cto.com/lesson/id-12697.html">解决Linux服务器访问比较慢的问题-网络测试命令讲解</a></li>
<li>《鸟哥的Linux私房菜-服务器架设篇》</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux下的网卡速度提升方案</title>
    <url>/post/linux_netcard_promote/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>本文研究了Linux下的一些网卡调优，用于提升网卡的性能。</p>
<p>下文中的所有关于网络的参数可以在&#x2F;etc&#x2F;sysctl.conf文件中修改，如果没有相应的参数，可以添加。</p>
<p>查看相应参数在当前运行机器的值可以通过&#x2F;proc&#x2F;sys&#x2F;net&#x2F;目录下的文件内容查看，也可以对该目录下相应文件的值进行修改，但是由于&#x2F;proc目录下的文件全部位于内存中，修改的值不会保存到下次开机时。因此要修改参数的值可以通过修改&#x2F;etc&#x2F;sysctl.conf文件来完成。</p>
<p>还可以通过sysctl -a命令来查看所有的系统配置参数。</p>
<h1 id="IP协议相关参数配置"><a href="#IP协议相关参数配置" class="headerlink" title="IP协议相关参数配置"></a>IP协议相关参数配置</h1><ul>
<li>net.ipv4.ip_default_ttl：设置从本机发出的ip包的生存时间，参数值为整数，范围为0～128，缺省值为64。如果系统经常得到“Time to live exceeded”的icmp回应，可以适当增大该参数的值，但是也不能过大，因为如果你的路由的环路的话，就会增加系统报错的时间。</li>
</ul>
<h1 id="TCP协议相关参数配置"><a href="#TCP协议相关参数配置" class="headerlink" title="TCP协议相关参数配置"></a>TCP协议相关参数配置</h1><p>TCP链接是有很多开销的，一个是会占用文件描述符，另一个是会开缓存，一般来说一个系统可以支持的TCP链接数是有限的。</p>
<h2 id="TCP常规参数"><a href="#TCP常规参数" class="headerlink" title="TCP常规参数"></a>TCP常规参数</h2><ul>
<li><p>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_window_scaling：设置tcp&#x2F;ip会话的滑动窗口大小是否可变。参数值为布尔值，为1时表示可变，为0时表示不可变。Tcp&#x2F;ip 通常使用的窗口最大可达到65535字节，对于高速网络，该值可能太小，这时候如果启用了该功能，可以使tcp&#x2F;ip滑动窗口大小增大数个数量级，从而提高数据传输的能力。</p>
</li>
<li><p>net.core.rmem_default：默认的接收窗口大小。</p>
</li>
<li><p>net.core.rmem_max：接收窗口的最大大小。</p>
</li>
<li><p>net.core.wmem_default：默认的发送窗口大小。</p>
</li>
<li><p>net.core.wmem_max：发送窗口的最大大小。</p>
</li>
<li><p>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;wmem_max。最大的TCP发送数据缓冲区大小。</p>
</li>
<li><p>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_timestamps。时间戳在(请参考RFC 1323)TCP的包头增加10个字节，以一种比重发超时更精确的方法（请参阅 RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。</p>
</li>
</ul>
<h2 id="配置KeepAlive参数"><a href="#配置KeepAlive参数" class="headerlink" title="配置KeepAlive参数"></a>配置KeepAlive参数</h2><p>这个参数的意思是定义一个时间，如果链接上没有数据传输，系统会在这个时间发一个包，如果没有收到回应，那么TCP就认为链接断了，然后就会把链接关闭，这样可以回收系统资源开销。（注：HTTP层上也有KeepAlive参数）对于像HTTP这样的短链接，设置一个1-2分钟的keepalive非常重要。</p>
<ul>
<li><p>net.ipv4.tcp_keepalive_time：当keepalive打开的情况下，TCP发送keepalive消息的频率。缺省值为7200,即两小时，建议将其更改为1800。</p>
</li>
<li><p>net.ipv4.tcp_keepalive_probes：TCP发送keepalive探测以确定该连接已经断开的次数。(默认值是9，设置为5比较合适)。</p>
</li>
<li><p>net.ipv4.tcp_keepalive_intvl：探测消息发送的频率，乘以tcp_keepalive_probes就得到对于从开始探测以来没有响应的连接杀除的时间。(默认值为75秒，推荐设为15秒)</p>
</li>
</ul>
<h2 id="配置建立连接参数"><a href="#配置建立连接参数" class="headerlink" title="配置建立连接参数"></a>配置建立连接参数</h2><ul>
<li><p>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_syn_retries：设置开始建立一个tcp会话时，重试发送syn连接请求包的次数。参数值为小于255的整数，缺省值为10。假如你的连接速度很快，可以考虑降低该值来提高系统响应时间，即便对连接速度很慢的用户，缺省值的设定也足够大了。</p>
</li>
<li><p>net.ipv4.tcp_retries1：建立一个连接的最大重试次数，默认为3,不建议修改。</p>
</li>
</ul>
<h2 id="配置关闭连接参数"><a href="#配置关闭连接参数" class="headerlink" title="配置关闭连接参数"></a>配置关闭连接参数</h2><p>主动关闭的一方进入TIME_WAIT状态，TIME_WAIT状态将持续2个MSL(Max Segment Lifetime)，默认为4分钟，TIME_WAIT状态下的资源不能回收。有大量的TIME_WAIT链接的情况一般是在HTTP服务器上。</p>
<ul>
<li><p>net.ipv4.tcp_retries2：普通数据的重传次数，在丢弃激活(已建立通讯状况)的TCP连接之前﹐需要进行多少次重试。默认值为15，根据RTO的值来决定，相当于13-30分钟(RFC1122规定，必须大于100秒)。</p>
</li>
<li><p>net.ipv4.tcp_tw_reuse：该文件表示是否允许重新应用处于TIME-WAIT状态的socket用于新的TCP连接。可以将其设置为1</p>
</li>
<li><p>net.ipv4.tcp_tw_recycle：打开快速TIME-WAIT sockets回收。默认关闭，建议打开。</p>
</li>
<li><p>net.ipv4.tcp_fin_timeout：在一个tcp会话过程中，在会话结束时，A首先向B发送一个fin包，在获得B的ack确认包后，A就进入FIN WAIT2状态等待B的fin包然后给B发ack确认包。这个参数就是用来设置A进入FIN WAIT2状态等待对方fin包的超时时间。如果时间到了仍未收到对方的fin包就主动释放该会话。参数值为整数，单位为秒，缺省为180秒，建议设置成30秒。</p>
</li>
</ul>
<h1 id="网卡的参数设置"><a href="#网卡的参数设置" class="headerlink" title="网卡的参数设置"></a>网卡的参数设置</h1><h2 id="调整网卡的txqueuelen"><a href="#调整网卡的txqueuelen" class="headerlink" title="调整网卡的txqueuelen"></a>调整网卡的txqueuelen</h2><p>txqueuelen的涵义为网卡的发送队列长度，可以通过ifconfig命令找到网卡的txqueuelen参数配置，默认为1000,建议将其更改为5000。</p>
<h2 id="网卡的中断设置"><a href="#网卡的中断设置" class="headerlink" title="网卡的中断设置"></a>网卡的中断设置</h2><p>网卡的读写是通过硬件的中断机制来实现的，默认网卡是中断在cpu的内核0上。CPU0非常重要，CPU0具有调整功能，如果CPU0利用率过高，其他cpu核心的利用率也会下降。因此可以考虑将linux的网卡中断绑定到其他的cpu内核上。</p>
<p>可以通过&#x2F;proc&#x2F;interrupt文件内容来查看网卡在cpu核的中断情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">           CPU0       CPU1       CPU2       CPU3       </span><br><span class="line">  0:         16          0          0          0   IO-APIC-edge      timer</span><br><span class="line">  1:      17144       2552       2312       2011   IO-APIC-edge      i8042</span><br><span class="line">  5:          0          0          0          0   IO-APIC-edge      parport0</span><br><span class="line">  8:          1          0          0          0   IO-APIC-edge      rtc0</span><br><span class="line">  9:          0          0          0          0   IO-APIC-fasteoi   acpi</span><br><span class="line"> 19:      75011     144479      28826      16212   IO-APIC-fasteoi   ata_piix, ata_piix</span><br><span class="line"> 23:     214627          1          0          2   IO-APIC-fasteoi   ehci_hcd:usb1, ehci_hcd:usb2</span><br><span class="line"> 41:          0          0          0          0   PCI-MSI-edge      xhci_hcd</span><br><span class="line"> 42:     245675         11         17          6   PCI-MSI-edge      eth0</span><br><span class="line"> 43:         18          6          0          0   PCI-MSI-edge      mei</span><br><span class="line"> 44:     423481      80408      67559      54037   PCI-MSI-edge      i915</span><br><span class="line"> 45:        268        488        112         16   PCI-MSI-edge      snd_hda_intel</span><br><span class="line">NMI:         21         18         23         18   Non-maskable interrupts</span><br><span class="line">LOC:    7076902    6761203    8711912    9042018   Local timer interrupts</span><br><span class="line">SPU:          0          0          0          0   Spurious interrupts</span><br><span class="line">PMI:         21         18         23         18   Performance monitoring interrupts</span><br><span class="line">IWI:          0          0          0          0   IRQ work interrupts</span><br><span class="line">RTR:          2          0          0          0   APIC ICR read retries</span><br><span class="line">RES:     365564     155654      52242      40754   Rescheduling interrupts</span><br><span class="line">CAL:      12775      15182      23713      23003   Function call interrupts</span><br><span class="line">TLB:      31028      26721      21584      25548   TLB shootdowns</span><br><span class="line">TRM:          0          0          0          0   Thermal event interrupts</span><br><span class="line">THR:          0          0          0          0   Threshold APIC interrupts</span><br><span class="line">MCE:          0          0          0          0   Machine check exceptions</span><br><span class="line">MCP:         32         32         32         32   Machine check polls</span><br><span class="line">ERR:          0</span><br><span class="line">MIS:          0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到eth0的中断是在CPU0上，可以通过&#x2F;proc&#x2F;irq&#x2F;42&#x2F;smp_affinity文件查看eth0默认的中断分配情况，文件的内容为1,对应二进制为0001,对应的为CPU0。</p>
<p>要想修改中断分配方式，需要先停掉IRQ自动调节的服务进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/init.d/irqbalance stop</span><br><span class="line">echo &quot;2&quot; &gt; /proc/irq/42/smp_affinity</span><br></pre></td></tr></table></figure>
<p>这里的2表示将中断分配到CPU1上。</p>
<h2 id="双网卡负载均衡"><a href="#双网卡负载均衡" class="headerlink" title="双网卡负载均衡"></a>双网卡负载均衡</h2><p>两个网卡共用一个IP地址，中断用两个核，效率可以提升一倍。</p>
<h1 id="服务器的其他设置"><a href="#服务器的其他设置" class="headerlink" title="服务器的其他设置"></a>服务器的其他设置</h1><h2 id="修改服务器启动级别"><a href="#修改服务器启动级别" class="headerlink" title="修改服务器启动级别"></a>修改服务器启动级别</h2><p>可以通过runlevel命令查看机器的启动级别，带图形界面的启动级别为5。可以通过<code>init 3</code>来切换到启动级别3;可以修改&#x2F;etc&#x2F;inittab文件中<code>id:5:initdefault:</code>来修改默认级别。</p>
<h2 id="修改系统的文件描述符数"><a href="#修改系统的文件描述符数" class="headerlink" title="修改系统的文件描述符数"></a>修改系统的文件描述符数</h2><p>如果网络链接较多，可以修改每个进程打开的最大文件描述符数目，默认为1024.可以通过ulimit -a查看，可以通过ulimit -n 32768来修改。</p>
<h1 id="参考网页"><a href="#参考网页" class="headerlink" title="参考网页"></a>参考网页</h1><ul>
<li><a href="http://coolshell.cn/articles/7490.html/comment-page-1">性能调优攻略</a></li>
<li><a href="http://www.cnblogs.com/gunl/archive/2010/09/25/1834526.html">Linux 内核网络参数配置资料</a></li>
<li><a href="http://www.vpsee.com/2010/07/load-balancing-with-irq-smp-affinity/">Linux 多核下绑定硬件中断到不同 CPU（IRQ Affinity）</a></li>
<li><a href="http://www.vpsee.com/2010/07/smp-irq-affinity/">计算 SMP IRQ Affinity</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-hisock.html">提高 Linux 上 socket 性能</a></li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux难点之权限类型</title>
    <url>/post/linux_permission/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>在Linux操作系统中，每个文件都有一组9个权限位来控制谁能够读写和执行该文件的内容。这组权限对于文件的意义非常容易理解。但是对于目录而言就不是那么容易理解了。要想搞明白权限机制需要了解文件系统中的inode节点和block等概念，并大致了解文件系统的内部实现原理。</p>
<h1 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h1><p>这部分比较容易理解。比较容易搞错的为：</p>
<p>w位：包含对文件的添加、修改该文件内容的权限，但不包含删除文件或移动该文件的权限，因为文件的文件名信息存储在父目录的block中，而不是在该文件的inode节点中。父目录的block中包含该文件的inode节点和文件名信息，通过父目录中的inode节点找到该文件。</p>
<h1 id="目录的权限"><a href="#目录的权限" class="headerlink" title="目录的权限"></a>目录的权限</h1><p>r位：表示具有读取该目录列表的权限。</p>
<p>w位：对该文件夹下创建新的文件或目录进行增加、删除、修改操作。</p>
<p>x位：这个稍微难以理解。表示用户能否进入该目录成为工作目录，即是否可以cd到该目录。通常和r位组合一块使用。</p>
<h2 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h2><p>假设root用户对testing目录和testing目录下的testing文件拥有的如下权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# ls -ald testing/ testing/testing</span><br><span class="line">drwxr--r--. 2 root root 4096 3月   1 11:44 testing/</span><br><span class="line">-rw-------. 1 root root    0 3月   1 11:44 testing/testing</span><br></pre></td></tr></table></figure>

<p>kuring用户拥有对该文件夹的读权限，但是没有x权限。当kuring用户访问时会提示如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 拥有r的权限可以查询文件名，但是没有x权限，不能读取除文件名外的其他信息，产生了问号。</span><br><span class="line">[kuring@localhost tmp]$ ll testing/</span><br><span class="line">ls: 无法访问testing/testing: 权限不够</span><br><span class="line">总用量 0</span><br><span class="line">-????????? ? ? ? ?            ? testing    </span><br><span class="line"></span><br><span class="line">// 没有x权限，不能进入该目录</span><br><span class="line">[kuring@localhost tmp]$ cd testing/</span><br><span class="line">bash: cd: testing/: 权限不够</span><br></pre></td></tr></table></figure>

<h2 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h2><p>在上述例子中，给kuring用户增加对目录testing的rwx权限，却只拥有testing目录下的testing文件的r权限。权限情况如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kuring@localhost tmp]$ ls -ald testing testing/testing</span><br><span class="line">drwxr--rwx. 2 root root 4096 3月   1 13:29 testing</span><br><span class="line">-rw-r--r--. 1 root root    0 3月   1 13:29 testing/testing</span><br></pre></td></tr></table></figure>

<p>kuring用户执行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 当对文件进行更改时由于没有对文件的w权限，操作失败</span><br><span class="line">[kuring@localhost tmp]$ echo &quot;world&quot; &gt;&gt; testing/testing</span><br><span class="line">bash: testing/testing: 权限不够</span><br><span class="line"></span><br><span class="line">// 当对文件进行删除操作时却可以删除该文件，这是因为文件删除操作的权限是由该文件所在目录的w位决定的</span><br><span class="line">// 文件删除操作会修改父目录中block节点中的文件名内容，而父目录的权限为rx，不可写。</span><br><span class="line">[kuring@localhost tmp]$ rm testing/testing</span><br><span class="line">rm：是否删除有写保护的普通文件 &quot;testing/testing&quot;？y</span><br><span class="line">[kuring@localhost tmp]$ ls testing/</span><br><span class="line">[kuring@localhost tmp]$</span><br></pre></td></tr></table></figure>

<p>只有了解了原理，就可以理解在多级目录并且目录的权限不一致的情况下相应的权限问题了。</p>
<hr>
<h1 id="进程用户ID"><a href="#进程用户ID" class="headerlink" title="进程用户ID"></a>进程用户ID</h1><p>要讲解set uid和set gid，就涉及到进程的用户ID概念。用户ID又可以分为两部分：</p>
<ul>
<li><p>实际用户ID和实际组ID：标识了究竟是哪个用户执行了该程序，跟命令行中的登录用户一致，可以通过id命令查看。</p>
</li>
<li><p>有效用户ID和有效组ID：系统通过有效用户ID、有效组ID和附加组ID来决定进行对系统资源的访问权限。在Linux系统中一个用户可以属于多个组，在&#x2F;etc&#x2F;passwd文件中一个用户仅能标识出隶属于一个组ID，该组ID叫做默认的组ID。在&#x2F;etc&#x2F;group为文件中可以标识出一个用户隶属于多个组，这多个组中除去默认的组ID叫做附加组ID。</p>
</li>
</ul>
<h1 id="set-uid"><a href="#set-uid" class="headerlink" title="set uid"></a>set uid</h1><ul>
<li>该权限位仅对二进制文件有效</li>
<li>执行者对该程序需要具有x的权限</li>
<li>该权限仅在执行该程序过程中有效</li>
<li>执行者将具有该程序拥有者的权限</li>
</ul>
<p>以&#x2F;usr&#x2F;bin&#x2F;passwd命令为例，该程序的权限为：rwsr-xr-x。普通用户可以调用该程序修改自己的密码，而密码文件&#x2F;etc&#x2F;shadow未设置任何权限，即只有root用户可以操作该文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# ll /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x. 1 root root 30768 2月  22 2012 /usr/bin/passwd</span><br><span class="line">[root@localhost tmp]# ll /etc/shadow</span><br><span class="line">----------. 1 root root 1248 11月 30 10:50 /etc/shadow</span><br></pre></td></tr></table></figure>

<p>passwd文件的s标志表明setuid位被设置。</p>
<p>passwd的拥有者为root；当普通用户执行passwd命令时，普通用户具有该命令的执行权限；passwd执行该命令时会暂时获得root用户权限；&#x2F;etc&#x2F;shadow就可以被修改。</p>
<p>也许看到这里就会有疑问：那岂不是普通用户可以通过&#x2F;etc&#x2F;passwd命令修改其他用户的密码了。之所以不可以这么操作是因为passwd命令内部通过逻辑实现。</p>
<h1 id="set-gid"><a href="#set-gid" class="headerlink" title="set gid"></a>set gid</h1><p>设置在文件上的情况：</p>
<ul>
<li>该权限位仅对二进制文件有效</li>
<li>执行者对该程序需要具有x的权限</li>
<li>执行者在运行程序的过程中将会获得该执行群组的权限</li>
</ul>
<p>设置在目录上的情况：</p>
<ul>
<li>用户对目录具有r和x的权限</li>
<li>用户在目录下的有效群组将会变成该目录的群组</li>
<li>若用户在此目录下具有w的权限，使用者建立的群组与该目录的群组相同</li>
</ul>
<h1 id="粘附位（sticky-bit）"><a href="#粘附位（sticky-bit）" class="headerlink" title="粘附位（sticky bit）"></a>粘附位（sticky bit）</h1><p>该权限位仅对目录有效，如果在目录上设置了粘附位，只有该目录的属主、该文件的属主或root用户可以删除或重命名该目录文件。</p>
<p>&#x2F;tmp文件夹的权限如下，其中的t位表示粘附位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kuring@localhost /]$ ll -ad tmp/</span><br><span class="line">drwxrwxrwt. 25 root root 4096 3月   1 14:51 tmp/</span><br></pre></td></tr></table></figure>

<p>如果在&#x2F;tmp下kuring用户创建了自己的文件kuring_file，并设置权限为777，test用户并不能删除该文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kuring@localhost tmp]$ touch kuring_file</span><br><span class="line">[kuring@localhost tmp]$ ll kuring_file</span><br><span class="line">-rw-rw-r--. 1 kuring kuring 0 3月   1 15:05 kuring_file</span><br><span class="line">[kuring@localhost tmp]$ chmod 777 kuring_file</span><br><span class="line">[kuring@localhost tmp]$ ll kuring_file</span><br><span class="line">-rwxrwxrwx. 1 kuring kuring 0 3月   1 15:05 kuring_file</span><br><span class="line"></span><br><span class="line">[kuring@localhost tmp]$ su - test</span><br><span class="line">密码：</span><br><span class="line">[test@localhost ~]$ cd /tmp/</span><br><span class="line">[test@localhost tmp]$ rm kuring_file</span><br><span class="line">rm: 无法删除&quot;kuring_file&quot;: 不允许的操作</span><br></pre></td></tr></table></figure>

<h1 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h1><p>如果设置了setuid位，属主的执行权限中的x用s来代替；<br>如果设置了setgid位，组执行权限中的x用s来代替；<br>如果设置了sticky位，权限最后的那个字符被设置为t；<br>如果设置了setuid、setgid或sticky位中一个，又没有设置相应的执行位，这些位显示为S或T。</p>
<h1 id="权限设定方式"><a href="#权限设定方式" class="headerlink" title="权限设定方式"></a>权限设定方式</h1><p>4为setuid位，2为setgid位，1为sticky位。具体参考《鸟哥的Linux私房菜》。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>《鸟哥的Linux私房菜》<br>《UNIX&#x2F;Linux系统管理技术手册》</p>
]]></content>
  </entry>
  <entry>
    <title>Linux下的screen命令</title>
    <url>/post/linux_screen/</url>
    <content><![CDATA[<p>在使用SSH或者telent远程登录到Linux 服务器，经常运行一些需要很长时间才能完成的任务，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为它们执行的时间太长了。必须等待它们执行完毕，在此期间不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>CentOS下默认没有安装该命令，从screen的官方网站下载，下载地址：<a href="http://ftp.gnu.org/gnu/screen/%E3%80%82">http://ftp.gnu.org/gnu/screen/。</a></p>
<ol>
<li>解压后执行<code>./configure</code>。</li>
<li>执行<code>make</code>命令。在执行make命令时会遇到错误<code>pty.c:38:26: 错误：sys/stropts.h：没有那个文件或目录</code>，在&#x2F;usr&#x2F;install&#x2F;sys&#x2F;目录下创建一个stropts.h的空文件即可。</li>
<li>执行<code>make install</code>，该命令并不会将screen命令复制到系统的PATH变量包含的路径下，即不能执行screen命令。</li>
<li>执行<code>install -m 644 etc/etcscreenrc /etc/screenrc</code>。</li>
<li>执行<code>cp screen /bin/</code>。</li>
<li>执行<code>cp doc/man/man1/screen.1 /usr/share/man/man1/</code>，即可以可使用<code>man screen</code>查看帮助。</li>
</ol>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>当关闭窗口或断开连接时，内核会将SIGHUP信号发送到会话期首进程，进程对SIGHUP的处理动作为终止。如果会话期首进程终止，则该信号发送到该会话期前台进程组。一个进程退出导致一个孤儿进程组中产生时，如果任意一个孤儿进程组进程处于STOP状态，发送SIGHUP和SIGCONT信号到该进程组中所有进程。因此当网络断开或终端窗口关闭后，控制进程收到SIGHUP信号退出，会导致该会话期内其他进程退出。</p>
<p>为解决上述问题，Linux程序在设计时可设计成守护进程的方式启动。</p>
<p>另外也可以通过<code>nohup 命令 &amp;</code>的方式启动来解决问题。</p>
<h1 id="新建screen"><a href="#新建screen" class="headerlink" title="新建screen"></a>新建screen</h1><ul>
<li>直接输入<code>screen</code>命令即可使用。</li>
<li>输入<code>screen -S kuring</code>，这里给screen取了一个名字，方便辨认。</li>
<li><code>screen 命令</code>直接在screen中执行命令，命令结束后screen退出。</li>
</ul>
<h1 id="分离与恢复"><a href="#分离与恢复" class="headerlink" title="分离与恢复"></a>分离与恢复</h1><p>在screen窗口中执行<code>ctrl + a d</code>命令，screen会给出_[detached]_提示，并恢复到执行screen之前的bash。<br>查找之前的screen执行<code>screen -ls</code>，会列出当前打开的screen。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are screens on:</span><br><span class="line">        8576.pts-3.localhost    (Attached)</span><br><span class="line">        8449.kuring     (Detached)</span><br><span class="line">2 Sockets in /tmp/uscreens/S-kuring.</span><br></pre></td></tr></table></figure>
<p>这里系统中打开了两个screen，一个为Attached，另一个为Detached。</p>
<p>重新连接执行<code>screen -r kuring</code>或<code>screen -r 8449</code>或<code>screen -r</code>，当系统中仅有一个处于Detached状态的screen时就可以直接执行<code>screen -r</code>命令。</p>
<h1 id="关闭窗口"><a href="#关闭窗口" class="headerlink" title="关闭窗口"></a>关闭窗口</h1><p>在screen的shell中执行<code>exit</code>命令即可关闭screen。</p>
<p>也可以执行<code>ctrl + a k</code>，会杀死当前screen中的所有运行进程。</p>
<h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>在screen中执行vi命令时会提示_E437: terminal capability “cm” required_错误，执行<code>echo $TERM</code>查看发现打印值为_screen_，而未执行screen时的bash打印值为_xterm_，在screen中执行<code>export TERM=xterm</code>即可解决该问题。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>更多高级使用方法请参考以下文档：</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-screen/">linux 技巧：使用 screen 管理你的远程会话</a><br><a href="http://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html">linux screen 命令详解</a></p>
]]></content>
  </entry>
  <entry>
    <title>Linux信号机制学习</title>
    <url>/post/linux_signal/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>信号机制在Linux编程中一直是一个难点，因为信号往往跟进程、线程、定时器、I&#x2F;O等多个层面都有牵涉，这些情况存在错综复杂的关系，堪比娱乐圈错综复杂的男女关系，要想全面理解信号机制确实不易。</p>
<h1 id="信号种类"><a href="#信号种类" class="headerlink" title="信号种类"></a>信号种类</h1><p>在Linux中可以通过如下命令来查看所有的信号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kuring@localhost ~]$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>共64个信号，分为两种信号：非实时信号和实时信号。其中1-31个信号为非实时信号，32-64为实时信号。</p>
<p>当一信号在阻塞状态下产生多次信号，当解除该信号的阻塞后，非实时信号仅传递一次信号，而实时信号会传递多次。</p>
<p>对于非实时信号：内核会为每个信号维护一个信号掩码，并阻塞信号针对该进程的传递。如果将阻塞的信号发送给某进程，对该信号的传递将延时，直至从进程掩码中移除该信号为止。当从进程掩码中移除该信号时该信号将传递给该进程。如果信号在阻塞期间传递过多次该信号，信号解除阻塞后仅传递一次。</p>
<p>对于实时信号：实时信号采用队列化处理，一个实时信号的多个实例发送给进程，信号将会传递多次。可以制定伴随数据，用于产生信号时的数据传递。不同实时信号的传递顺序是固定的，优先传递信号编号小的。</p>
<h1 id="信号阻塞"><a href="#信号阻塞" class="headerlink" title="信号阻塞"></a>信号阻塞</h1><p>内核会为每个信号维护一个信号掩码，来阻塞内核将信号传递给该进程。如果将阻塞的信号发送给该进程，信号的传递将延后，从进程信号掩码中移除该信号后内核立刻将信号传递给该进程。如果一个信号在阻塞状态下产生多次，对于非实时信号稍后仅会传递一次，对于实时信号内核会进行排队处理，会传递多次。</p>
<h1 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h1><p>要想在进程中设置信号处理函数有两种选择：signal()和sigaction()。其中signal()函数提供的接口比较简单，但是在不同的UNIX系统之间存在差异，跨平台特性不是很好,signal()函数由于是C库函数，实现往往是采用sigaction()系统调用完成。sigaction()具有很好的跨平台性，但是使用较为复杂，但是却可以在信号处理程序中完成阻塞信号的作用。</p>
<p>在sigaction函数中可以指定调用信号处理函数时要阻塞的信号集，不允许这些信号中断信号处理函数的调用，直到信号处理函数调用完毕后信号才会传递。这一点通过signal函数是完不成的，利用signal函数设定的信号处理函数只能在信号处理函数开始时使用sigprocmask设置要阻塞的信号，在信号处理函数尾部利用sigprocmask还原信号，但在调用第一次调用sigprocmask函数之前和第二次调用sigprocmask函数之后的空白期内却无法防止要阻塞信号的传递。</p>
<p>信号处理函数中调用的函数尽量是异步信号安全的，C库中的函数不是异步信号安全的函数。</p>
<p>在信号处理函数中尽量避免访问全局变量，要访问全局变量可以使用<code>volatile sig_atomic_t flag</code>，volatile防止将编译器将变量优化到内存中，sig_atomic_t是一种整形数据类型，用来保证读写操作的原子性。</p>
<h1 id="系统调用的中断"><a href="#系统调用的中断" class="headerlink" title="系统调用的中断"></a>系统调用的中断</h1><p>当系统调用阻塞时，之前创建了处理函数的信号传递过来。在信号处理函数返回后，默认情况下，系统调用会失败，并将errno置为EINTR。</p>
<p>如果调用指定了SA_RESTART标志的sigaction()函数来创建信号处理器函数，内核会在信号处理函数返回后自动重启系统调用，从而避免了信号处理函数对阻塞的系统调用产生的影响。比较不幸的是，并非所有的系统调用都支持该特性。</p>
<h1 id="信号的同步生成和异步生成"><a href="#信号的同步生成和异步生成" class="headerlink" title="信号的同步生成和异步生成"></a>信号的同步生成和异步生成</h1><p>这里的同步是对信号产生方式的描述，跟具体哪个信号无关。所有的信号均可同步生成，也可异步生成。</p>
<p>异步生成：引发信号产生的事件与进程的执行无关。例如，用户输入了中断字符、子进程终止等事件，这些信号的产生该进程是无法左右的。</p>
<p>同步生成：当执行特定的机制指令产生硬件异常时或进程使用raise()、kill()等向自身发生信号时，信号是同步传递的。这些信号的产生时间该进程是可以左右的。</p>
<h1 id="信号传递的时机和顺序"><a href="#信号传递的时机和顺序" class="headerlink" title="信号传递的时机和顺序"></a>信号传递的时机和顺序</h1><p>同步产生的信号会立即传递给该进程。例如，当使用raise()函数向自身发送信号时，信号会在raise()调用前发生。</p>
<p>异步产生一个信号时，且在进程并未阻塞的情况下，信号也不会立即被传递。当且仅当进程正在执行，并且由内核态到用户态的下一次切换时才会传递信号。说人话就是在以下两种情况下会传递信号：进程获得调度时和系统调用完成时。这是因为内核会在进程在内核态和用户态进行的切换的时候才会检测信号。</p>
<p>非实时信号的传递顺序无法保障，实时信号的传递顺序是固定的，当多个不同的实时信号处于等待状态时，优先传递最小编号的信号。</p>
<h1 id="信号和线程"><a href="#信号和线程" class="headerlink" title="信号和线程"></a>信号和线程</h1><p>信号模型是基于进程模型而设计的，应尽量避免在多线程中使用信号模型。</p>
<p>信号的发送可以针对整个进程，也可以针对特定线程。</p>
<p>当进程收到一个信号后，内核会任选一个线程来接收信号，并调用信号处理函数对信号进行处理。</p>
<p>每个线程可以独立设置信号掩码。</p>
<p>如果信号处理程序中断了对pthread_mutex_lock()和pthread_cond_wait()的调用，该调用会自动重启。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>《Linux&#x2F;Unix系统编程手册》</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中信号处理举例</title>
    <url>/post/linux_signal_deal_example/</url>
    <content><![CDATA[<h1 id="Linux处理ctrl-c信号的例子"><a href="#Linux处理ctrl-c信号的例子" class="headerlink" title="Linux处理ctrl+c信号的例子"></a>Linux处理ctrl+c信号的例子</h1><p>当按下ctrl+c时如果代码正在执行sleep则会停止睡眠，调用信号处理函数。中断位置可能位于for循环代码段的任意位置，中断位置不可控。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">h</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;抽空处理int信号\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	signal(SIGINT,h);</span><br><span class="line">	<span class="type">sigset_t</span> sigs;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=i;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,sum);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Over!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="信号屏蔽的例子1"><a href="#信号屏蔽的例子1" class="headerlink" title="信号屏蔽的例子1"></a>信号屏蔽的例子1</h1><p>当按下ctrl+c时不会调用信号处理函数，当循环执行完毕后会调用信号处理函数，并且printf(“Over!\n”)会被执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">h</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;抽空处理int信号\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 声明信号集合</span></span><br><span class="line">    <span class="type">sigset_t</span> sigs;</span><br><span class="line">    signal(SIGINT,h);</span><br><span class="line">    <span class="comment">// 清空集合</span></span><br><span class="line">    sigemptyset(&amp;sigs);</span><br><span class="line">    <span class="comment">// 加入屏蔽信号</span></span><br><span class="line">    sigaddset(&amp;sigs,SIGINT);</span><br><span class="line">    <span class="comment">// 屏蔽信号</span></span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;sigs,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,sum);</span><br><span class="line">    <span class="comment">// 消除屏蔽信号</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK,&amp;sigs,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果在上面按下ctrl+c，在此句不执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Over!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在循环中按下ctrl+c后，该函数输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum=55</span><br><span class="line">抽空处理int信号</span><br><span class="line">Over!</span><br></pre></td></tr></table></figure>
<h1 id="信号屏蔽的例子2"><a href="#信号屏蔽的例子2" class="headerlink" title="信号屏蔽的例子2"></a>信号屏蔽的例子2</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">h</span><span class="params">(<span class="type">int</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;抽空处理int信号\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	signal(SIGINT,h);</span><br><span class="line">	<span class="type">sigset_t</span> sigs,sigp,sigq;</span><br><span class="line">	sigemptyset(&amp;sigs);</span><br><span class="line">	sigemptyset(&amp;sigp);</span><br><span class="line">	sigemptyset(&amp;sigq);</span><br><span class="line">	</span><br><span class="line">	sigaddset(&amp;sigs,SIGINT);</span><br><span class="line">	sigprocmask(SIG_BLOCK,&amp;sigs,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=i;</span><br><span class="line">		sigpending(&amp;sigp);</span><br><span class="line">		<span class="keyword">if</span>(sigismember(&amp;sigp,SIGINT))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;SIGINT在排队!\n&quot;</span>);</span><br><span class="line">			<span class="comment">// 是信号SIGINT有效</span></span><br><span class="line">			sigsuspend(&amp;sigq);</span><br><span class="line">			<span class="comment">// 函数调用完毕后信号SIGINT无效</span></span><br><span class="line">		&#125;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,sum);</span><br><span class="line">    <span class="comment">// 消除屏蔽信号</span></span><br><span class="line">	sigprocmask(SIG_UNBLOCK,&amp;sigs,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Over!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例子可以实现在指定的代码处处理信号。<br>其中sigsuspend函数原先如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sigsuspend(const sigset_t *mask);</span><br></pre></td></tr></table></figure>
<p>函数解释：屏蔽新的信号，原来的屏蔽信号失效。是一个阻塞函数，该函数屏蔽mask信号；对非mask信号不屏蔽，信号处理函数调用完毕该函数返回；如果非mask信号没有信号处理函数，则此函数不返回。即返回条件：信号发生且信号为非屏蔽信号且信号必须要调用信号处理函数完毕。</p>
]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux上一个界面程序的开机自启动设置</title>
    <url>/post/linux_ui_autorun/</url>
    <content><![CDATA[<p>最近设置一个Linux下的截屏程序的开机自启动，Linux的XWindow系统为gnome。</p>
<p>最先想到的方式是修改&#x2F;etc&#x2F;inittab文件，因为Linux在开机自启动的时候会执行该文件，该文件的读取时机是在界面启动之前。我写了一个在main函数中睡眠10分钟的小程序，然后将程序添加到&#x2F;etc&#x2F;inittab文件中，结果开不了机了，因为需要睡眠10分钟后才能往下执行程序。幸好我用的虚拟机做的测试，并且在做测试之前备份了虚拟机。</p>
<p>仔细想一下在&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件中启动截屏程序肯定是不合适的，因为如果用户默认是以运行级别非5启动，则程序仍然会被调用，但是没有XWindow，谈何截屏。</p>
<p>接下来考虑将程序放到&#x2F;etc&#x2F;rc5.d目录下，这样就可以保证程序在XWindow环境下运行了。仔细一想也不合适，rc5.d仅在系统启动时运行，而Linux系统是多用户系统，允许多个用户同时登陆，多个用户登陆时截屏程序会怎样处理呢？这样显然不合适。</p>
<p>然后想到程序既然为截屏程序，多个用户登陆的时候应该有几个用户就跑几个程序，这样才能保证每个用户的屏幕都能截取到。因此应该放到用户登录后的启动程序列表中。类似于windows系统中的开机启动项。我用的桌面为gnome，找到了gnome-session-properties命令来启动添加程序启动的界面，然后将我的程序添加到界面中即可。</p>
<p>如果桌面系统为KDE，则应该也可以找到相关的设置界面。</p>
<p>题外：利用&#x2F;etc&#x2F;inittab和rc5.d目录下添加脚本的方式来启动程序的用户为root，很多程序未了避免root权限带来的安全问题，程序内部采用了<code>su - 用户名</code>的方式切换到一半用户执行代码。程序还可以通过chroot的方式更改根目录的路径达到保护系统的目的。</p>
]]></content>
  </entry>
  <entry>
    <title>UNIX网络编程读书笔记</title>
    <url>/post/linux_unp/</url>
    <content><![CDATA[<p>第一遍阅读unpv3后，对书中讲述的内容有了大体的认识，但对书中的具体细节地方却是早已忘记。重新阅读unpv3，这次不希望仍然是阅后即忘，于是通过编写代码的方式对书中的例子和注意事项加深理解。</p>
<p>为了能够将书中的很多细节问题理解清楚并且便于记忆，本文采用了编写书中代码并运行的方式，并将书中容易出错和意想不到的问题记在代码中。</p>
<p>本文的代码实例并未完全按照书中的代码实例，本着单个文件即能编译通过并运行的原则，本文对于很多系统调用并未做防御式编程处理。针对每个版本的程序中缺点和注意事项在代码中已经进行了标注。</p>
<p>鉴于高性能的epoll机制出现比较晚，晚于unp的编写时间，书中并未做介绍。</p>
<h1 id="TCP客户端程序"><a href="#TCP客户端程序" class="headerlink" title="TCP客户端程序"></a>TCP客户端程序</h1><p>客户端函数执行效率情况：select非阻塞式I&#x2F;O版本&gt;线程化版本&gt;fork版本&gt;select阻塞式I&#x2F;O版本&gt;停等版本，停等版本的执行效率非常低，在实际生产环境中不建议使用。</p>
<p>其中poll和select机制基本类似，书中并未给出poll版本。</p>
<h2 id="停-等版本"><a href="#停-等版本" class="headerlink" title="停-等版本"></a>停-等版本</h2><p>最常规的实现思路，但效率非常低，且当程序阻塞在读取要发送内容时，程序是无法收到服务端的状态变化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 停-等版本</span></span><br><span class="line"><span class="comment"> * 该版本缺陷为当服务端发生某些事件时，客户端可能仍然阻塞于fgets调用中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line">	<span class="keyword">while</span> (fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 当阻塞在fgets函数时将服务器进程关闭时虽然给客户端发送了FIN信号，客户端并不会知道，</span></span><br><span class="line"><span class="comment">		 * 服务端关闭时第一次调用write服务器会返回RST，</span></span><br><span class="line"><span class="comment">		 * 当一个进程向某个收到RST的套接字执行写操作时，内核会向该进程发送一个SIGPIPE信号</span></span><br><span class="line"><span class="comment">		 * 该问题需要使用I/O复用技术来解决，或者使用fork处理的方式来解决</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		write(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">		<span class="type">int</span> n = read(sockfd, recvline, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;str_cli: server terminated prematurely\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 向标准输出写内容，既可以使用write也可以使用fputs</span></span><br><span class="line">		write(STDOUT_FILENO, recvline, n);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用fputs时需要注意将recvline数组有效内容的后面一位设置为&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">//		recvline[n] = &#x27;\0&#x27;;</span></span><br><span class="line"><span class="comment">//		fputs(recvline, stdout);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sockfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>	<span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: tcpcli &lt;IPaddress&gt;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当一个进程向某个收到RST的套接字执行写操作时，内核会向该进程发送一个SIGPIPE信号</span></span><br><span class="line">	<span class="comment">// 最好的方式是忽略此信号的处理方式，并在程序下面处理该异常情况</span></span><br><span class="line">	signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">	connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	str_cli(<span class="built_in">stdin</span>, sockfd);		<span class="comment">/* do it all */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fork版本"><a href="#fork版本" class="headerlink" title="fork版本"></a>fork版本</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞式I/O的fork版本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 即使服务端已经退出，子进程的read方法仍然能够感知到并且退出while循环，并给父进程发送SIGTERM,父进程对该信号的默认处理方式为退出</span></span><br><span class="line"><span class="comment"> * 优点：代码量比较少，每个进程只处理2个I/O流，从一个复制到另一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// child process : server -&gt; stdout</span></span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="keyword">while</span> ((n = read(sockfd, recvline, MAXLINE)) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			recvline[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		kill(getppid(), SIGTERM);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// parent process : stdin -&gt; server</span></span><br><span class="line">	<span class="keyword">while</span> (fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		write(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">	&#125;</span><br><span class="line">	shutdown(sockfd, SHUT_WR);</span><br><span class="line">	pause();</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sockfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>	<span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: tcpcli &lt;IPaddress&gt;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当一个进程向某个收到RST的套接字执行写操作时，内核会向该进程发送一个SIGPIPE信号</span></span><br><span class="line">	<span class="comment">// 最好的方式是忽略此信号的处理方式，并在程序下面处理该异常情况</span></span><br><span class="line">	signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connect error...\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	str_cli(<span class="built_in">stdin</span>, sockfd);		<span class="comment">/* do it all */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阻塞式I-x2F-O的select版本"><a href="#阻塞式I-x2F-O的select版本" class="headerlink" title="阻塞式I&#x2F;O的select版本"></a>阻塞式I&#x2F;O的select版本</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞式I/O的select版本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缺点：使用了阻塞式I/O，如果在向套接字调用write发送给服务器时，套接字缓冲区已满，write调用会阻塞，从而影响了后续的套接字缓冲区的读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> maxfdp1;</span><br><span class="line">	fd_set rset;</span><br><span class="line">	<span class="type">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line">	<span class="type">int</span> stdineof = <span class="number">0</span>;</span><br><span class="line">	FD_ZERO(&amp;rset);</span><br><span class="line">	<span class="keyword">for</span> (; ;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// select</span></span><br><span class="line">		FD_SET(fileno(fp), &amp;rset);</span><br><span class="line">		FD_SET(sockfd, &amp;rset);</span><br><span class="line">		maxfdp1 = (fileno(fp) &gt; sockfd ? fileno(fp) : sockfd) + <span class="number">1</span>;</span><br><span class="line">		select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// socket</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> n = read(sockfd, recvline, MAXLINE);</span><br><span class="line">			<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (stdineof == <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;str_cli: server terminated prematurely\n&quot;</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			recvline[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="comment">//			write(STDOUT_FILENO, recvline, n);</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// input</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 此处不能使用fgets函数，该函数带有缓冲区功能，select跟带有缓冲区的c函数混合使用有问题</span></span><br><span class="line"><span class="comment">//			if (fgets(sendline, MAXLINE, fp) == NULL)</span></span><br><span class="line"><span class="comment">//			&#123;</span></span><br><span class="line"><span class="comment">//				return ;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">			<span class="type">int</span> n = read(fileno(fp), sendline, MAXLINE);</span><br><span class="line">			<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				stdineof = <span class="number">1</span>;</span><br><span class="line">				shutdown(sockfd, SHUT_WR);	<span class="comment">// 关闭写</span></span><br><span class="line">				FD_CLR(fileno(fp), &amp;rset);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			write(sockfd, sendline, n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sockfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>	<span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: tcpcli &lt;IPaddress&gt;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connect error...\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	str_cli(<span class="built_in">stdin</span>, sockfd);		<span class="comment">/* do it all */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非阻塞式I-x2F-O的select版本"><a href="#非阻塞式I-x2F-O的select版本" class="headerlink" title="非阻塞式I&#x2F;O的select版本"></a>非阻塞式I&#x2F;O的select版本</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非阻塞式I/O的select版本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) ( ((a)&gt;(b)) ? (a):(b) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优点：速度是最快的，可以防止进程在做任何工作时发生阻塞</span></span><br><span class="line"><span class="comment"> * 缺点：同时管理4个不同的I/O流，每个流都是非阻塞的，需要考虑到4个流的部分读和部分写问题。编码量是最多的，需要引入缓冲区管理机制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 将socket、标准输入和标准输出描述符设置为非阻塞方式</span></span><br><span class="line">	<span class="type">int</span> val = fcntl(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">	fcntl(sockfd, F_SETFL, val | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">	val = fcntl(STDIN_FILENO, F_GETFL, <span class="number">0</span>);</span><br><span class="line">	fcntl(STDIN_FILENO, F_SETFL, val | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">	val = fcntl(STDOUT_FILENO, F_GETFL, <span class="number">0</span>);</span><br><span class="line">	fcntl(STDOUT_FILENO, F_SETFL, val | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> to[MAXLINE], fr[MAXLINE];</span><br><span class="line">	<span class="type">char</span> *toiptr, *tooptr, *friptr, *froptr;</span><br><span class="line">	toiptr = tooptr = to;</span><br><span class="line">	friptr = froptr = fr;</span><br><span class="line">	<span class="type">int</span> stdineof = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> maxfdp1 = max(max(STDIN_FILENO, STDOUT_FILENO), sockfd) + <span class="number">1</span>;</span><br><span class="line">	fd_set rset, wset;</span><br><span class="line">	<span class="keyword">for</span> (; ;)</span><br><span class="line">	&#123;</span><br><span class="line">		FD_ZERO(&amp;rset);</span><br><span class="line">		FD_ZERO(&amp;wset);</span><br><span class="line">		<span class="keyword">if</span> (stdineof == <span class="number">0</span> &amp;&amp; toiptr &lt; &amp;to[MAXLINE])</span><br><span class="line">		&#123;</span><br><span class="line">			FD_SET(STDIN_FILENO, &amp;rset);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (friptr &lt; &amp;fr[MAXLINE])</span><br><span class="line">		&#123;</span><br><span class="line">			FD_SET(sockfd, &amp;rset);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tooptr != toiptr)</span><br><span class="line">		&#123;</span><br><span class="line">			FD_SET(sockfd, &amp;wset);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (froptr != friptr)</span><br><span class="line">		&#123;</span><br><span class="line">			FD_SET(STDOUT_FILENO, &amp;wset);</span><br><span class="line">		&#125;</span><br><span class="line">		select(maxfdp1, &amp;rset, &amp;wset, <span class="literal">NULL</span>, <span class="literal">NULL</span>);	<span class="comment">// select函数仍然是阻塞的</span></span><br><span class="line">		<span class="comment">// 标准输入</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;rset))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> n;</span><br><span class="line">			<span class="keyword">if</span> ((n = read(STDIN_FILENO, toiptr, &amp;to[MAXLINE] - toiptr)) &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 对于非阻塞式IO，如果操作不能满足，相应系统调用会返回EWOULDBLOCK错误</span></span><br><span class="line">				<span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;read error on stdin\n&quot;</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;EOF on stdin\n&quot;</span>);</span><br><span class="line">				stdineof = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (tooptr == toiptr)</span><br><span class="line">				&#123;</span><br><span class="line">					shutdown(sockfd, SHUT_WR);	<span class="comment">// 缓冲区中没有数据要发送，关闭socket</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read %d bytes from stdin\n&quot;</span>, n);</span><br><span class="line">				toiptr += n;</span><br><span class="line">				FD_SET(sockfd, &amp;wset);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从套接字读</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> n;</span><br><span class="line">			<span class="keyword">if</span> ((n = read(sockfd, friptr, &amp;fr[MAXLINE] - friptr)) &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;read error on socket\n&quot;</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;EOF on socket\n&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (stdineof)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;server terminated prematurely\n&quot;</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read %d bytes from socket\n&quot;</span>, n);</span><br><span class="line">				friptr += n;</span><br><span class="line">				FD_SET(STDOUT_FILENO, &amp;wset);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 标准输出</span></span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(STDOUT_FILENO, &amp;wset) &amp;&amp; ((n = friptr - froptr) &gt; <span class="number">0</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> nwritten;</span><br><span class="line">			<span class="keyword">if</span> ((nwritten = write(STDOUT_FILENO, froptr, n)) &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;write error to stdout\n&quot;</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;wrote %d bytes to stdout\n&quot;</span>, nwritten);</span><br><span class="line">				froptr += nwritten;</span><br><span class="line">				<span class="keyword">if</span> (froptr == friptr)</span><br><span class="line">				&#123;</span><br><span class="line">					froptr = friptr = fr;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 向socket写</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(sockfd, &amp;wset) &amp;&amp; ((n = toiptr - tooptr)) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> nwritten;</span><br><span class="line">			<span class="keyword">if</span> ((nwritten = write(sockfd, tooptr, n)) &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;write error to socket\n&quot;</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;wrote %d bytes to socket\n&quot;</span>, nwritten);</span><br><span class="line">				tooptr += nwritten;</span><br><span class="line">				<span class="keyword">if</span> (tooptr == toiptr)</span><br><span class="line">				&#123;</span><br><span class="line">					toiptr = tooptr = to;</span><br><span class="line">					<span class="keyword">if</span> (stdineof)</span><br><span class="line">					&#123;</span><br><span class="line">						shutdown(sockfd, SHUT_WR);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * connect的非阻塞版本</span></span><br><span class="line"><span class="comment"> * 连接建立成功时，描述符变为可写；连接建立错误时，描述符变为即可读又可写</span></span><br><span class="line"><span class="comment"> * 优点：</span></span><br><span class="line"><span class="comment"> * 1、阻塞式的connect调用会消耗CPU时间，非阻塞式connect可以充分利用CPU时间，在等待的过程中可以处理其他工作</span></span><br><span class="line"><span class="comment"> * 2、可以同时建立多个连接，浏览器中会用到此技术</span></span><br><span class="line"><span class="comment"> * 3、阻塞式connect的函数超时过长，可以通过该函数设置超时时间</span></span><br><span class="line"><span class="comment"> * 4、阻塞式的套接字调用connect时，在TCP的三次握手完成之前被某些信号中断时并且connect未设置内核自动重启的标志时，connect将返回EINTR错误</span></span><br><span class="line"><span class="comment"> * 当再次调用connect等待未完成的连接时将会返回EADDRINUSE错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect_nonb</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *saptr, <span class="type">socklen_t</span> salen, <span class="type">int</span> nsec)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 将套接字设置为非阻塞状态</span></span><br><span class="line">	<span class="type">int</span> flags = fcntl(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">	fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">if</span> ((n = connect(sockfd, saptr, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 连接未成功建立，正常情况下返回EINPROGRESS错误，表示操作正在处理</span></span><br><span class="line">		<span class="keyword">if</span> (errno != EINPROGRESS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// EINPROGRESS表示连接建立已经启动，但是尚未完成</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 当服务器和客户端在一台主机上时会立即建立连接</span></span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当代码执行到如下过程中时，connect正在建立连接，可以在此位置执行业务相关代码</span></span><br><span class="line">	<span class="comment">// 当然真正使用时，在此位置加入其他代码并不合适，需要根据具体情况重新调整代码</span></span><br><span class="line">	<span class="comment">// 可以参照书中的web客户程序例子</span></span><br><span class="line"></span><br><span class="line">	fd_set rset, wset;</span><br><span class="line">	FD_ZERO(&amp;rset);</span><br><span class="line">	FD_SET(sockfd, &amp;rset);</span><br><span class="line">	wset = rset;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tval</span>;</span></span><br><span class="line">	tval.tv_sec = nsec;</span><br><span class="line">	tval.tv_usec = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> ((n = select(sockfd + <span class="number">1</span>, &amp;rset, &amp;wset, <span class="literal">NULL</span>, nsec ? &amp;tval : <span class="literal">NULL</span>)) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 发生超时</span></span><br><span class="line">		close(sockfd);</span><br><span class="line">		errno = ETIMEDOUT;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当连接建立成功时sockfd变为可写，当连接建立失败时sockfd变为即可读又可写</span></span><br><span class="line">	<span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset) || FD_ISSET(sockfd, &amp;wset))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> len = <span class="keyword">sizeof</span>(error);</span><br><span class="line">		<span class="comment">// 非可移植性函数，连接建立成功返回0，连接建立失败将错误值返回给error</span></span><br><span class="line">		<span class="comment">// 连接建立失败时，有返回-1和返回0的情况</span></span><br><span class="line">		<span class="keyword">if</span> (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// solaris连接建立失败返回-1</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;select error:sockfd not set&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">done:</span><br><span class="line">	<span class="comment">// 恢复套接字的文件状态标志</span></span><br><span class="line">	fcntl(sockfd, F_SETFL, flags);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">	&#123;</span><br><span class="line">		close(sockfd);</span><br><span class="line">		errno = error;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sockfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>	<span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: tcpcli &lt;IPaddress&gt;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当一个进程向某个收到RST的套接字执行写操作时，内核会向该进程发送一个SIGPIPE信号</span></span><br><span class="line">	<span class="comment">// 最好的方式是忽略此信号的处理方式，并在程序下面处理该异常情况</span></span><br><span class="line">	signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//connect(sockfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr));</span></span><br><span class="line">	<span class="keyword">if</span> (connect_nonb(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr), <span class="number">50</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;socket connect error\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	str_cli(<span class="built_in">stdin</span>, sockfd);		<span class="comment">/* do it all */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TCP服务端程序"><a href="#TCP服务端程序" class="headerlink" title="TCP服务端程序"></a>TCP服务端程序</h1><p>服务器程序要处理大量并发，在设计时更要注重效率。</p>
<h2 id="fork版本-1"><a href="#fork版本-1" class="headerlink" title="fork版本"></a>fork版本</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * fork版本</span></span><br><span class="line"><span class="comment"> * PPC(Process per Connection)模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE		4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_chld</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (signo != SIGIO)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> stat;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 此处不可以使用wait函数，当多个SIGCHLD信号同时发出时会因为信号覆盖而出现僵尸进程的情况</span></span><br><span class="line"><span class="comment">	pid_t pid = wait(&amp;stat);</span></span><br><span class="line"><span class="comment">	printf(&quot;child %d terminated\n&quot;, pid);	// 非异步信号安全函数，此处不应该调用</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用非阻塞的参数WNOHANG来循环处理信号，避免信号丢失问题 */</span></span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>, pid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_echo</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span>	n;</span><br><span class="line">	<span class="type">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">while</span> ( (n = read(sockfd, buf, MAXLINE)) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		write(sockfd, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">		<span class="keyword">goto</span> again;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str_echo: read error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * fork版本</span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * 		1.fork需要将父进程的内存映像复制到子进程，并在子进程中复制所有的描述符，尽管现在的操作系统已经都实现了写时复制技术，但是耗时仍然比较多</span></span><br><span class="line"><span class="comment"> * 		2.父进程和子进程之间需要IPC机制进行通信，从子进程返回信息到父进程比较麻烦</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	signal(SIGCHLD, sig_chld);</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd,  (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen</span></span><br><span class="line">    <span class="comment">// 套接字排队的最大连接数为20</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">20</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">socklen_t</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    	<span class="comment">// 处理accept被信号中断时返回EINTR错误</span></span><br><span class="line">		<span class="keyword">if</span> ((connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* child process */</span></span><br><span class="line">			close(listenfd); <span class="comment">/* close listening socket */</span></span><br><span class="line">			str_echo(connfd); <span class="comment">/* process the request */</span></span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		close(connfd); <span class="comment">/* parent closes connected socket */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="select版本"><a href="#select版本" class="headerlink" title="select版本"></a>select版本</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * select版本</span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * 		1. 有最大并发数限制，一个进程最多打开FD_SETSIZE个文件描述符，FD_SETSIZE往往是1024或2048字节</span></span><br><span class="line"><span class="comment"> * 		2. select每次调用都会线性扫描全部的FD集合，这样效率就会呈现线性下降，把FD_SETSIZE改大的后果就是所有FD处理都慢慢来</span></span><br><span class="line"><span class="comment"> * 		3. 内核/用户空间内存拷贝问题，内核把FD消息通知给用户空间采取了内存拷贝方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE		4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用select的需要维护client数组和allset的描述符集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish socket...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd,  (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish bind...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen</span></span><br><span class="line">    <span class="comment">// 套接字排队的最大连接数为20</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">20</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish listening...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxfd = listenfd;</span><br><span class="line">    <span class="type">int</span> maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> client[FD_SETSIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;FD_SETSIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	client[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd_set allset;</span><br><span class="line">    FD_ZERO(&amp;allset);</span><br><span class="line">    FD_SET(listenfd, &amp;allset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">    	fd_set rset = allset;</span><br><span class="line">    	<span class="type">int</span> nready = select(maxfd + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    	<span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset))</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="comment">// 设置client数组</span></span><br><span class="line">    		<span class="type">socklen_t</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    		<span class="comment">// 调用select时有个问题，见书中16.6节</span></span><br><span class="line">    		<span class="comment">// 如果调用accept时客户端已经关闭连接，此时accept会阻塞并直到新的客户端连接到来</span></span><br><span class="line">    		<span class="comment">// 为了解决该问题可以将套接字设置为非阻塞再调用accept</span></span><br><span class="line">			<span class="type">int</span> connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;accept one client:%d...\n&quot;</span>, connfd);</span><br><span class="line">			<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (; i&lt;FD_SETSIZE; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					client[i] = connfd;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			FD_SET(connfd, &amp;allset);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i == FD_SETSIZE)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (connfd &gt; maxfd)</span><br><span class="line">			&#123;</span><br><span class="line">				maxfd = connfd;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">			&#123;</span><br><span class="line">				maxi = i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 检测所有客户端的数据</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=maxi; i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">continue</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span> (FD_ISSET(client[i], &amp;rset))</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="type">int</span> n;</span><br><span class="line">    			<span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    			<span class="built_in">printf</span>(<span class="string">&quot;start reading form one client...\n&quot;</span>);</span><br><span class="line">    			<span class="keyword">if</span> ((n = read(client[i], buf, MAXLINE)) == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">    				close(client[i]);</span><br><span class="line">    				FD_CLR(client[i], &amp;allset);</span><br><span class="line">    				client[i] = <span class="number">-1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">    			<span class="keyword">else</span></span><br><span class="line">    			&#123;</span><br><span class="line">    				write(client[i], buf, n);</span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">    			&#123;</span><br><span class="line">    				<span class="keyword">break</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="poll版本"><a href="#poll版本" class="headerlink" title="poll版本"></a>poll版本</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * poll版本</span></span><br><span class="line"><span class="comment"> * poll版本的解决了select文件描述符限制问题，但是仍然具备select的缺点中的2和3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stropts.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE		4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_MAX 1024  <span class="comment">// 该宏已经从limit.h中移除，用来表示一个进程可以打开的最大描述符数目</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用select的缺点为需要维护client数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish socket...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd,  (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish bind...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen</span></span><br><span class="line">    <span class="comment">// 套接字排队的最大连接数为20</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">20</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish listening...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">    client[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">    client[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;OPEN_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	client[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxi = <span class="number">0</span>;	<span class="comment">// 当前client正在使用的最大下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">int</span> nready = poll(client, maxi + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    	<span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="comment">// 设置client数组</span></span><br><span class="line">    		<span class="type">socklen_t</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">			<span class="type">int</span> connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;accept one client:%d...\n&quot;</span>, connfd);</span><br><span class="line">			<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (; i&lt;OPEN_MAX; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					client[i].fd = connfd;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i == OPEN_MAX)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			client[i].events = POLLIN;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">			&#123;</span><br><span class="line">				maxi = i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 检测所有客户端的数据</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=maxi; i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">continue</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span> (client[i].revents &amp; (POLLIN | POLLERR))</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="type">int</span> n;</span><br><span class="line">    			<span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    			<span class="built_in">printf</span>(<span class="string">&quot;start reading form one client...\n&quot;</span>);</span><br><span class="line">    			<span class="keyword">if</span> ((n = read(client[i].fd, buf, MAXLINE)) &lt; <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">    				<span class="keyword">if</span> (errno == ECONNRESET)</span><br><span class="line">    				&#123;</span><br><span class="line">    					close(client[i].fd);</span><br><span class="line">    					client[i].fd = <span class="number">-1</span>;</span><br><span class="line">    				&#125;</span><br><span class="line">    				<span class="keyword">else</span></span><br><span class="line">    				&#123;</span><br><span class="line">    					<span class="built_in">printf</span>(<span class="string">&quot;read client error\n&quot;</span>);</span><br><span class="line">    					<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    				&#125;</span><br><span class="line">				&#125;</span><br><span class="line">    			<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    			&#123;</span><br><span class="line">    				<span class="built_in">printf</span>(<span class="string">&quot;client %d close\n&quot;</span>, client[i].fd);</span><br><span class="line">    				close(client[i].fd);</span><br><span class="line">    				client[i].fd = <span class="number">-1</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">else</span></span><br><span class="line">    			&#123;</span><br><span class="line">    				write(client[i].fd, buf, n);</span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">    			&#123;</span><br><span class="line">    				<span class="keyword">break</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程版本"><a href="#多线程版本" class="headerlink" title="多线程版本"></a>多线程版本</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程版本</span></span><br><span class="line"><span class="comment"> * TPC(Thread Per Connection)模型</span></span><br><span class="line"><span class="comment"> * 线程的开销虽然比进程小，但是仍然有比较大开销，因此并发数不是很高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE		4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_echo</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span>	n;</span><br><span class="line">	<span class="type">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">while</span> ( (n = read(sockfd, buf, MAXLINE)) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		write(sockfd, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">		<span class="keyword">goto</span> again;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str_echo: read error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">doit</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_detach(pthread_self());</span><br><span class="line">	str_echo((<span class="type">int</span>)arg);</span><br><span class="line">	close((<span class="type">int</span>)arg);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;close socket...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd,  (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen</span></span><br><span class="line">    <span class="comment">// 套接字排队的最大连接数为20</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">20</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">socklen_t</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    	<span class="comment">// 处理accept被信号中断时返回EINTR错误</span></span><br><span class="line">		<span class="keyword">if</span> ((connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;receive new client...\n&quot;</span>);</span><br><span class="line">		<span class="type">pthread_t</span> tid;</span><br><span class="line">		pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;doit, (<span class="type">void</span> *)connfd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>由于udp比较简单，书中并未将udp协议当做重点来讲解。</p>
<h2 id="UDP客户端程序"><a href="#UDP客户端程序" class="headerlink" title="UDP客户端程序"></a>UDP客户端程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE		4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sendto、recvfrom方式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dg_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *pservaddr, <span class="type">socklen_t</span> servlen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> sendline[MAXLINE], recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">preply_addr</span> =</span> (<span class="keyword">struct</span> sockaddr *)<span class="built_in">malloc</span>(servlen);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sendto(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>, pservaddr, servlen);</span><br><span class="line">		<span class="type">int</span> len = servlen;</span><br><span class="line">		<span class="type">int</span> n = recvfrom(sockfd, recvline, MAXLINE, <span class="number">0</span>, preply_addr, &amp;len);</span><br><span class="line">		<span class="comment">// 为了防止接收到其他进程的数据，通过条件判断去除</span></span><br><span class="line">		<span class="keyword">if</span> (len != servlen || <span class="built_in">memcmp</span>(pservaddr, preply_addr, len) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;reply from others (!ignore)\n&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		recvline[n] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connect、write、read方式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dg_cli2</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *pservaddr, <span class="type">socklen_t</span> servlen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> sendline[MAXLINE], recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	connect(sockfd, (<span class="keyword">struct</span> sockaddr *)pservaddr, servlen);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		write(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">		<span class="type">int</span> n = read(sockfd, recvline, MAXLINE);</span><br><span class="line">		recvline[n] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: tcpcli &lt;IPaddress&gt;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	dg_cli2(<span class="built_in">stdin</span>, sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP服务端程序"><a href="#UDP服务端程序" class="headerlink" title="UDP服务端程序"></a>UDP服务端程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE		4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dg_echo</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *pcliaddr, <span class="type">socklen_t</span> clilen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> mesg[MAXLINE];</span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">socklen_t</span> len = clilen;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		bzero(mesg, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> ((n = recvfrom(sockfd, mesg, MAXLINE, <span class="number">0</span>,  pcliaddr, &amp;len)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			close(sockfd);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;recvfrom error, error=%m\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;recv %s\n&quot;</span>, mesg);</span><br><span class="line">		sendto(sockfd, mesg, n, <span class="number">0</span>, pcliaddr, len);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	<span class="keyword">if</span> (bind(sockfd,  (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dg_echo(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP服务端信号驱动式I-x2F-O版本"><a href="#UDP服务端信号驱动式I-x2F-O版本" class="headerlink" title="UDP服务端信号驱动式I&#x2F;O版本"></a>UDP服务端信号驱动式I&#x2F;O版本</h2><p>信号驱动式I&#x2F;O：进程执行I&#x2F;O系统调用告知内核启动某个I&#x2F;O操作，内核启动I&#x2F;O操作后立即返回到进程。进程在I&#x2F;O操作发生期间继续执行。当操作完成或遇到错误时，内核以进程在I&#x2F;O系统调用中指定的方式通知进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信号驱动式I/O在TCP套接字用途不大，该信号产生的过于频繁，它的出现并未指示发生的事情</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE		4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXDG 4096</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">void</span> *dg_data;				<span class="comment">// 实际数据</span></span><br><span class="line">	<span class="type">size_t</span> dg_len;				<span class="comment">// 实际数据长度</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">dg_sa</span>;</span>		<span class="comment">// 包含客户端地址</span></span><br><span class="line">	<span class="type">socklen_t</span> dg_salen;			<span class="comment">// 客户端地址长度</span></span><br><span class="line">&#125; DG;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QSIZE 8</span></span><br><span class="line"><span class="type">static</span> DG dg[QSIZE];			<span class="comment">// 存放数据的环形缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> cntread[QSIZE + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 需要处理的下一个数据元素的下标</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> iget;</span><br><span class="line"><span class="comment">// 存放数据元素的下一个位置</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> iput;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> nqueue;				<span class="comment">// 队列中的数据个数</span></span><br><span class="line"><span class="type">static</span> <span class="type">socklen_t</span> clilen;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_hup</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt;= QSIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;cntread[%d = %ld\n&quot;</span>, i, cntread[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_io</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nread;</span><br><span class="line">	<span class="comment">// 为了解决非实时信号不排队问题，采用循环读取方式</span></span><br><span class="line">	<span class="keyword">for</span> (nread = <span class="number">0</span>; ; )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 检查队列是否已满</span></span><br><span class="line">		<span class="keyword">if</span> (nread &gt;= QSIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;receive overflow\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		DG *ptr = &amp;dg[iput];</span><br><span class="line">		ptr-&gt;dg_salen = clilen;</span><br><span class="line">		<span class="type">ssize_t</span> len = recvfrom(sockfd, ptr-&gt;dg_data, MAXDG, <span class="number">0</span>, ptr-&gt;dg_sa, &amp;ptr-&gt;dg_salen);</span><br><span class="line">		<span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EWOULDBLOCK)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;recvfrom error\n&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ptr-&gt;dg_len = len;</span><br><span class="line">		nread++;</span><br><span class="line">		nqueue++;</span><br><span class="line">		<span class="keyword">if</span> (++iput &gt;= QSIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			iput = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cntread[nread]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dg_echo</span><span class="params">(<span class="type">int</span> sockfd_arg, <span class="keyword">struct</span> sockaddr *pcliaddr, <span class="type">socklen_t</span> clilen_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	sockfd = sockfd_arg;</span><br><span class="line">	clilen = clilen_arg;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i&lt;QSIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dg[i].dg_data = <span class="built_in">malloc</span>(MAXDG);</span><br><span class="line">		dg[i].dg_sa = (<span class="keyword">struct</span> sockaddr *)<span class="built_in">malloc</span>(clilen);</span><br><span class="line">		dg[i].dg_salen = clilen;</span><br><span class="line">	&#125;</span><br><span class="line">	iget = iput = nqueue = <span class="number">0</span>;</span><br><span class="line">	signal(SIGHUP, sig_hup);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在启动信号I/O前设置信号处理函数</span></span><br><span class="line">	signal(SIGIO, sig_io);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置接收信号通知的进程，让本进程接收SIGIO信号</span></span><br><span class="line">	fcntl(sockfd, F_SETOWN, getpid());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了能够在得到I/O事件后重复执行I/O操作，需要将文件描述符设置为非阻塞方式</span></span><br><span class="line">	<span class="comment">// O_ASYNC表示在文件描述符上使用信号驱动I/O</span></span><br><span class="line">	<span class="type">int</span> flags = fcntl(sockfd, F_GETFL);</span><br><span class="line">	fcntl(sockfd, F_SETFL, flags | O_ASYNC | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">	<span class="type">sigset_t</span> zeromask, newmask, oldmask;</span><br><span class="line">	sigemptyset(&amp;zeromask);</span><br><span class="line">	sigemptyset(&amp;newmask);</span><br><span class="line">	sigemptyset(&amp;oldmask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置新的信号掩码，阻塞SIGIO信号</span></span><br><span class="line">	sigaddset(&amp;newmask, SIGIO);</span><br><span class="line">	sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);</span><br><span class="line">	<span class="keyword">for</span> (; ;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (nqueue == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 挂起进程直到收到任何信号，该函数返回后SIGIO继续被阻塞</span></span><br><span class="line">			sigsuspend(&amp;zeromask);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 解除SIGIO的阻塞</span></span><br><span class="line">		sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">		sendto(sockfd, dg[iget].dg_data, dg[iget].dg_len, <span class="number">0</span>, dg[iget].dg_sa, dg[iget].dg_salen);</span><br><span class="line">		<span class="keyword">if</span> (++iget &gt;= QSIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			iget = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 为了能够修改nqueue的值，阻塞SIGIO信号</span></span><br><span class="line">		sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);</span><br><span class="line">		nqueue--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	<span class="keyword">if</span> (bind(sockfd,  (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dg_echo(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p>本文中的实例，代码采用eclipse CDT编写，可以直接导入eclipse中运行。</p>
<p><a href="http://pan.baidu.com/s/1o6zCNOm">下载实例</a></p>
]]></content>
      <tags>
        <tag>linux 读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下vnc的配置</title>
    <url>/post/linux_vnc/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>VNC（Virtual Network Computing）是一套由AT&amp;T实验室所开发的可操控远程的计算机的软件，其采用了GPL授权条款，任何人都可免费取得该软件。VNC软件主要由两个部分组成：VNC server及VNC viewer。用户需先将VNC server安装在被控端的计算机上后，才能在主控端执行VNC viewer控制被控端。VNC与操作系统无关，因此可跨平台使用，例如可用Windows连接到某Linux的电脑，反之亦同。</p>
<p>该软件在RedHat或CentOS中默认是安装的，但是没有启用，一可以通过<code>which vncserver</code>命令来查看该命令是否安装。本文讲解在Linux下的搭建server，在Windows下搭建client的步骤。</p>
<h1 id="设置vncserver的密码"><a href="#设置vncserver的密码" class="headerlink" title="设置vncserver的密码"></a>设置vncserver的密码</h1><p>vncserver需要设置一个密码，该密码并不等同于系统帐号的密码，而是vnc客户端登录的时候输入的密码。执行<code>vncpasswd</code>命令来创建密码。</p>
<h1 id="修改vncserver配置文件"><a href="#修改vncserver配置文件" class="headerlink" title="修改vncserver配置文件"></a>修改vncserver配置文件</h1><p>修改文件&#x2F;etc&#x2F;sysconfig&#x2F;vncservers，在该文件末尾添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VNCSERVERS=&quot;1:root&quot;</span><br><span class="line">VNCSERVERARGS[1]=&quot;-geometry 1024x768 -alwaysshared -depth 24&quot;</span><br></pre></td></tr></table></figure>

<h1 id="启动vncserver"><a href="#启动vncserver" class="headerlink" title="启动vncserver"></a>启动vncserver</h1><p>执行<code>service vncserver start</code>命令来开启vncserver服务。</p>
<h1 id="客户端连接到服务端"><a href="#客户端连接到服务端" class="headerlink" title="客户端连接到服务端"></a>客户端连接到服务端</h1><p>这里采用windows下的vnc viewer工具来连接到vncserver。在输入IP的地方输入：<code>IP地址:1</code>来连接到vncserver端，其中<code>:1</code>要跟&#x2F;etc&#x2F;sysconfig&#x2F;vncservers文件中的对应标号一致。这样就可以连接上vncserver，但是连接后界面非常简单，跟命令行界面类似。还需要对vncserver进一步配置。</p>
<h1 id="配置vncserver"><a href="#配置vncserver" class="headerlink" title="配置vncserver"></a>配置vncserver</h1><p>vncserver的配置文件在~&#x2F;.vnc&#x2F;xstartup文件中，该文件默认创建的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"># Uncomment the following two lines for normal desktop:</span><br><span class="line"># unset SESSION_MANAGER</span><br><span class="line"># exec /etc/X11/xinit/xinitrc</span><br><span class="line"></span><br><span class="line">[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup</span><br><span class="line">[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresources</span><br><span class="line">xsetroot -solid grey</span><br><span class="line">vncconfig -iconic &amp;</span><br><span class="line">xterm -geometry 80x24+10+10 -ls -title &quot;$VNCDESKTOP Desktop&quot; &amp;</span><br><span class="line">twm &amp;</span><br></pre></td></tr></table></figure>

<p>将其中的注释打开，即文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">unset SESSION_MANAGER</span><br><span class="line">exec /etc/X11/xinit/xinitrc</span><br><span class="line"></span><br><span class="line">[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup</span><br><span class="line">[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresources</span><br><span class="line">xsetroot -solid grey</span><br><span class="line">vncconfig -iconic &amp;</span><br><span class="line">xterm -geometry 80x24+10+10 -ls -title &quot;$VNCDESKTOP Desktop&quot; &amp;</span><br><span class="line">twm &amp;</span><br></pre></td></tr></table></figure>

<p>然后执行<code>service vncserver restart</code>重新启动vncserver服务。客户端再重新连接vncserver既可以看到正常的界面了。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.ha97.com/4634.html">CentOS Linux下VNC Server远程桌面配置详解</a></p>
]]></content>
  </entry>
  <entry>
    <title>Linux和Windows平台下的网络通信问题</title>
    <url>/post/linux_windows_network/</url>
    <content><![CDATA[<p>大小端问题跟CPU的架构直接相关，我们常见的80x86系列CPU采用小端字节序模式。Windows平台就采用的80x86系列CPU，因此为小端字节序。<br>而主机之间进行网络通信时往往采用大端字节序，因此小端字节序机器在发送数据前需要进行字节序转换，在接收到数据处理处理数据之前要将网络字节序转换成本地字节序。</p>
<p>在Linux平台下提供了四个函数用来字节序转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">uint32_t htonl(uint32_t hostlong);</span><br><span class="line">uint16_t htons(uint16_t hostshort);</span><br><span class="line">uint32_t ntohl(uint32_t netlong);</span><br><span class="line">uint16_t ntohs(uint16_t netshort);</span><br></pre></td></tr></table></figure>

<p>Windows平台下也提供了相关的自己序转换函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;WinSock2.h&gt;</span><br><span class="line">unsigned __int64 __inline htond(</span><br><span class="line">  double value</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">unsigned __int32 __inline htonf(</span><br><span class="line">  float value</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">u_long WSAAPI htonl(</span><br><span class="line">  _In_  u_long hostlong</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">unsigned __int64 __inline htonll(</span><br><span class="line">  unsigned __int64 value</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">u_short WSAAPI htons(</span><br><span class="line">  _In_  u_short hostshort</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">double __inline ntohd(</span><br><span class="line">  unsigned __int64 value</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">float __inline ntohf(</span><br><span class="line">  unsigned __int32 value</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">u_long WSAAPI ntohl(</span><br><span class="line">  _In_  u_long netlong</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">u_long __inline ntohll(</span><br><span class="line">  unsigned __int64 value</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">u_short WSAAPI ntohs(</span><br><span class="line">  _In_  u_short netshort</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里有个技巧需要说明以下，比如要发送如下的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct foo</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    long b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了避免每个成员都调用字节序转换函数，可以在结构体的内部定义两个方法用于转换字节序，添加字节序后的foo如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct foo</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    long b;</span><br><span class="line">    void ntoh()</span><br><span class="line">    &#123;</span><br><span class="line">         a = ntohl(a);</span><br><span class="line">         b = ntohl(b);</span><br><span class="line">    &#125;</span><br><span class="line">    void hton()</span><br><span class="line">    &#123;</span><br><span class="line">         a = htonl(a);</span><br><span class="line">         b = htonl(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要特别注意的是，在发送结构体类型的数据时要注意字节对齐的问题，这里不再展开讨论，不同的平台有不同的解决办法。大体分为Winodws平台、AIX平台和GNU类平台。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>本地连接远程的内网k8s集群</title>
    <url>/post/local-connect-remote-k8s/</url>
    <content><![CDATA[<p>在日常开发的过程中，经常会需要在本地开发的程序需要在k8s中调试的场景，比如，写了一个operator。如果此时，本地又没有可以直接可达的k8s集群，比如k8s是在公有云的vpc环境内，外面无法直接访问。此时，ssh又是可以直接通过公网vip访问的vpc的网络内的。为了满足此类需要，可以采用ssh tunnel的方式来打通本地跟远程的k8s集群。</p>
<h2 id="1-本地建立ssh-tunnel到远程集群网络"><a href="#1-本地建立ssh-tunnel到远程集群网络" class="headerlink" title="1. 本地建立ssh tunnel到远程集群网络"></a>1. 本地建立ssh tunnel到远程集群网络</h2><p>mac用户可以通过SSH TUNNEL这个软件来在界面上自动化配置，具体的配置方式如下：</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/local-connect-remote-k8s-1.jpg"></p>
<p>需要增加一个ssh的动态代理，监听本地的9909端口号。</p>
<h2 id="2-将远程集群的kubeconfig文件复制到本地"><a href="#2-将远程集群的kubeconfig文件复制到本地" class="headerlink" title="2. 将远程集群的kubeconfig文件复制到本地"></a>2. 将远程集群的kubeconfig文件复制到本地</h2><p>将k8s集群中<code>~/.kube/config</code>文件复制到本地的<code>~/.kube/config</code>目录下</p>
<h2 id="3-在命令行中执行kubectl命令"><a href="#3-在命令行中执行kubectl命令" class="headerlink" title="3. 在命令行中执行kubectl命令"></a>3. 在命令行中执行kubectl命令</h2><p>在命令行中配置http和https代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export http_proxy=127.0.0.1:9909</span><br><span class="line">export https_proxy=127.0.0.1:9909</span><br></pre></td></tr></table></figure>

<p>然后至此就可以通过kubectl命令来访问远程的k8s集群了。</p>
]]></content>
  </entry>
  <entry>
    <title>使用logstash收集php-fpm slow log</title>
    <url>/post/logstash-php-fpm/</url>
    <content><![CDATA[<p>目前php-fpm的服务部署在了docker中，对php-fpm的log和php error log可以通过syslog协议的形式发送出去，而php-fpm的slow log却不能配置为syslog协议，只能输出到文件中，因为一条slow log的是有多行组成的。</p>
<p>在docker中使用时发现fpm-slowlog不能正常输出，后经发现是docker默认没有ptrace系统调用的权限，而slow log的产生需要该系统调用。通过在docker启动的时候增加”–cap-add SYS_PTRACE”启动项可修正该问题。</p>
<p>为了收集slow log，可以通过logstash、flume等工具进行收集，本文采用logstash对slow log进行收集，并将收集的log写入到kafka中，便于后续的处理。logstash的input采用读取文件的方式，即跟tail -f的原理类似。为了能够将多行日志作为一行，采用了filter中的multiline来对多行日志进行合并操作。logstash的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">        path =&gt; [“/var/log/php-fpm/fpm-slow.log&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">    multiline &#123;</span><br><span class="line">        pattern =&gt; &quot;^$&quot;</span><br><span class="line">        negate =&gt; true</span><br><span class="line">        what =&gt; &quot;previous&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    stdout&#123;codec =&gt; rubydebug&#125;</span><br><span class="line">    kafka &#123;</span><br><span class="line">        codec =&gt; plain &#123;</span><br><span class="line">           format =&gt; “tag|%&#123;host&#125;%&#123;message&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        topic_id =&gt; &quot;fpm-slowlog&quot;</span><br><span class="line">        bootstrap_servers =&gt; “kafka1.hostname:8082,kafka2.hostname:8082&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>lvm</title>
    <url>/post/lvm/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/lvm.png"></p>
<ol>
<li>物理卷PV(Physical Volume)：可以是整块物理磁盘或者物理磁盘上的分区</li>
<li>卷组VG(Volume Group)：由一个或多个物理卷PV组成，可在卷组上创建一个或者多个LV，可以动态增加pv到卷组</li>
<li>逻辑卷LV(Logical Volume)：类似于磁盘分区，建立在VG之上，在LV上可以创建文件系统 逻辑卷建立后可以动态的增加或缩小空间</li>
<li>PE(Physical Extent): PV可被划分为PE的基本单元，具有唯一编号的PE是可以被LVM寻址的最小单元。PE的大小是可以配置的，默认为4MB。</li>
<li>LE(Logical Extent): LV可被划分为LE的基本单元，LE跟PE是一对一的关系。</li>
</ol>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>lvm相关的目录如果没有按照，在centos下使用<code>yum install lvm2</code>进行安装。</p>
<p>初始磁盘状态如下，&#x2F;dev&#x2F;sda上有40g磁盘空间未分配：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1        40G  2.8G   38G   7% /</span><br><span class="line">devtmpfs        236M     0  236M   0% /dev</span><br><span class="line">tmpfs           244M     0  244M   0% /dev/shm</span><br><span class="line">tmpfs           244M  4.5M  240M   2% /run</span><br><span class="line">tmpfs           244M     0  244M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs            49M     0   49M   0% /run/user/1000</span><br><span class="line"></span><br><span class="line"># fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 85.9 GB, 85899345920 bytes, 167772160 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x000a05f8</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048    83886079    41942016   83  Linux</span><br></pre></td></tr></table></figure>

<p>对磁盘的操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># fdisk /dev/sda</span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line"># 创建主分区2，空间为1g，磁盘格式为lvm</span><br><span class="line">Command (m for help): n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">Partition number (2-4, default 2): 2</span><br><span class="line">First sector (83886080-167772159, default 83886080):</span><br><span class="line">Using default value 83886080</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (83886080-167772159, default 167772159): +1G</span><br><span class="line">Partition 2 of type Linux and of size 1 GiB is set</span><br><span class="line"></span><br><span class="line">Command (m for help): t</span><br><span class="line">Partition number (1,2, default 2): 2</span><br><span class="line">Hex code (type L to list all codes): 8e</span><br><span class="line">Changed type of partition &#x27;Linux&#x27; to &#x27;Linux LVM&#x27;</span><br><span class="line"></span><br><span class="line"># 创建主分区3，空间为5g，磁盘格式为lvm</span><br><span class="line">Command (m for help): n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (2 primary, 0 extended, 2 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">Partition number (3,4, default 3): 3</span><br><span class="line">First sector (85983232-167772159, default 85983232):</span><br><span class="line">Using default value 85983232</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (85983232-167772159, default 167772159): +5G</span><br><span class="line">Partition 3 of type Linux and of size 5 GiB is set</span><br><span class="line"></span><br><span class="line">Command (m for help): t</span><br><span class="line">Partition number (1-3, default 3): 3</span><br><span class="line">Hex code (type L to list all codes): 8e</span><br><span class="line">Changed type of partition &#x27;Linux&#x27; to &#x27;Linux LVM&#x27;</span><br><span class="line"></span><br><span class="line"># 保存上述操作</span><br><span class="line">Command (m for help): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line"></span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span><br><span class="line">The kernel still uses the old table. The new table will be used at</span><br><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>

<p>当前磁盘空间状态如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 85.9 GB, 85899345920 bytes, 167772160 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x000a05f8</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048    83886079    41942016   83  Linux</span><br><span class="line">/dev/sda2        83886080    85983231     1048576   8e  Linux LVM</span><br><span class="line">/dev/sda3        85983232    96468991     5242880   8e  Linux LVM</span><br></pre></td></tr></table></figure>

<p>将上述两个lvm磁盘分区创建pv，使用<code>pvremove /dev/sda2</code>可以删除pv</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># pvcreate /dev/sda2 /dev/sda3</span><br><span class="line">  Physical volume &quot;/dev/sda2&quot; successfully created.</span><br><span class="line">  Physical volume &quot;/dev/sda3&quot; successfully created.</span><br><span class="line">[root@localhost vagrant]# pvdisplay</span><br><span class="line">  &quot;/dev/sda2&quot; is a new physical volume of &quot;1.00 GiB&quot;</span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/sda2</span><br><span class="line">  VG Name</span><br><span class="line">  PV Size               1.00 GiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0</span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               MgarF2-Ka6D-blDi-8ecd-1SEU-y2GD-JtiK2c</span><br><span class="line"></span><br><span class="line">  &quot;/dev/sda3&quot; is a new physical volume of &quot;5.00 GiB&quot;</span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/sda3</span><br><span class="line">  VG Name</span><br><span class="line">  PV Size               5.00 GiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0</span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               ToKp2T-30mS-0P8c-ZrcB-2lO4-ayo9-62fuDx</span><br></pre></td></tr></table></figure>

<p>接下来创建vg，vg的名字可以随便定义，并将创建的两个pv都添加到vg中，可以看到vg的空间为两个pv之和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vgcreate vg1 /dev/sda1</span><br><span class="line"># vgdisplay -v</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               vg1</span><br><span class="line">  System ID</span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  1</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                0</span><br><span class="line">  Open LV               0</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               5.99 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              1534</span><br><span class="line">  Alloc PE / Size       0 / 0</span><br><span class="line">  Free  PE / Size       1534 / 5.99 GiB</span><br><span class="line">  VG UUID               XI8Biv-JtUv-tsur-wuvm-IJQz-HLZu-6a2u5G</span><br><span class="line"></span><br><span class="line">  --- Physical volumes ---</span><br><span class="line">  PV Name               /dev/sda2</span><br><span class="line">  PV UUID               MgarF2-Ka6D-blDi-8ecd-1SEU-y2GD-JtiK2c</span><br><span class="line">  PV Status             allocatable</span><br><span class="line">  Total PE / Free PE    255 / 255</span><br><span class="line"></span><br><span class="line">  PV Name               /dev/sda3</span><br><span class="line">  PV UUID               ToKp2T-30mS-0P8c-ZrcB-2lO4-ayo9-62fuDx</span><br><span class="line">  PV Status             allocatable</span><br><span class="line">  Total PE / Free PE    1279 / 1279</span><br></pre></td></tr></table></figure>

<p>接下来创建lv，并从vg1中分配空间2g</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># lvcreate -L 2G -n lv1 vg1</span><br><span class="line">  Logical volume &quot;lv1&quot; created.</span><br><span class="line"></span><br><span class="line"># lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/vg1/lv1</span><br><span class="line">  LV Name                lv1</span><br><span class="line">  VG Name                vg1</span><br><span class="line">  LV UUID                EesY4i-lSqY-ef1R-599C-XTrZ-IcVL-P7W46Q</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time localhost.localdomain, 2019-06-16 07:29:38 +0000</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 0</span><br><span class="line">  LV Size                2.00 GiB</span><br><span class="line">  Current LE             512</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     8192</span><br><span class="line">  Block device           253:0</span><br></pre></td></tr></table></figure>

<p>接下来给lv1格式化磁盘格式为ext4，并将磁盘挂载到&#x2F;tmp&#x2F;lvm目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mkfs.ext4 /dev/vg1/lv1</span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS type: Linux</span><br><span class="line">Block size=4096 (log=2)</span><br><span class="line">Fragment size=4096 (log=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">131072 inodes, 524288 blocks</span><br><span class="line">26214 blocks (5.00%) reserved for the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=536870912</span><br><span class="line">16 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">	32768, 98304, 163840, 229376, 294912</span><br><span class="line"></span><br><span class="line">Allocating group tables: done</span><br><span class="line">Writing inode tables: done</span><br><span class="line">Creating journal (16384 blocks): done</span><br><span class="line">Writing superblocks and filesystem accounting information: done</span><br><span class="line"></span><br><span class="line"># mkdir /tmp/lvm</span><br><span class="line">[root@localhost vagrant]# mount /dev/vg1/lv1 /tmp/lvm</span><br><span class="line">[root@localhost vagrant]# df -h</span><br><span class="line">Filesystem           Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1             40G  2.9G   38G   8% /</span><br><span class="line">devtmpfs             236M     0  236M   0% /dev</span><br><span class="line">tmpfs                244M     0  244M   0% /dev/shm</span><br><span class="line">tmpfs                244M  4.5M  240M   2% /run</span><br><span class="line">tmpfs                244M     0  244M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs                 49M     0   49M   0% /run/user/1000</span><br><span class="line">/dev/mapper/vg1-lv1  2.0G  6.0M  1.8G   1% /tmp/lvm</span><br></pre></td></tr></table></figure>

<p>接下来对lv的空间从2G扩展到3G，此时通过df查看分区空间大小仍然为2g，需要执行<code>resize2fs</code>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># lvextend -L +1G /dev/vg1/lv1</span><br><span class="line">  Size of logical volume vg1/lv1 changed from 2.00 GiB (512 extents) to 3.00 GiB (768 extents).</span><br><span class="line">  Logical volume vg1/lv1 successfully resized.</span><br><span class="line"></span><br><span class="line"># resize2fs /dev/vg1/lv1</span><br><span class="line">resize2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem at /dev/vg1/lv1 is mounted on /tmp/lvm; on-line resizing required</span><br><span class="line">old_desc_blocks = 1, new_desc_blocks = 1</span><br><span class="line">The filesystem on /dev/vg1/lv1 is now 786432 blocks long.</span><br><span class="line"></span><br><span class="line"># df -h</span><br><span class="line">Filesystem           Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1             40G  2.9G   38G   8% /</span><br><span class="line">devtmpfs             236M     0  236M   0% /dev</span><br><span class="line">tmpfs                244M     0  244M   0% /dev/shm</span><br><span class="line">tmpfs                244M  4.5M  240M   2% /run</span><br><span class="line">tmpfs                244M     0  244M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs                 49M     0   49M   0% /run/user/1000</span><br><span class="line">/dev/mapper/vg1-lv1  2.9G  6.0M  2.8G   1% /tmp/lvm</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>试验时操作失误，出现了先格式化磁盘，后发现pv找不到对应设备。vg删除不成功。</p>
<p>正常删除vg的方式，此时lv会自动消失</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vgreduce --removemissing vg1</span><br><span class="line">vgremove vg1</span><br></pre></td></tr></table></figure>

<p>lvremove操作执行的时候经常会出现提示“Logical volume xx contains a filesystem in use.”的情况，该问题一般是由于有其他进程在使用该文件系统导致的。网络上经常看到的是通过fuser或者lsof命令来查找使用方，但偶尔该命令会失效，尤其在本机上有容器的场景下。另外一个可行的办法是通过 <code>grep -nr &quot;/data&quot; /proc/*/mount</code> 命令，可以找到挂载该目录的所有进程，简单有效。</p>
<h1 id="三种Logic-Volume"><a href="#三种Logic-Volume" class="headerlink" title="三种Logic Volume"></a>三种Logic Volume</h1><p>LVM的机制可以类比于RAID，RAID一个核心的机制是性能和数据冗余，并提供了多种数据的冗余模块可供配置。lvm在性能和数据冗余方面支持如下三种Logic Volume: 线性逻辑卷、条带化逻辑卷和镜像逻辑卷。上述几种模式是在vg已经创建完成后创建lv的时候指定的模式，会影响到lv中的pe分配。</p>
<p>下面使用如下的机器配置来进行各个模式的介绍和功能测试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">vda    253:0    0   40G  0 disk</span><br><span class="line">└─vda1 253:1    0   40G  0 part /</span><br><span class="line">vdb    253:16   0  100G  0 disk</span><br><span class="line">vdc    253:32   0  200G  0 disk</span><br><span class="line">vdd    253:48   0  300G  0 disk</span><br><span class="line">vde    253:64   0  400G  0 disk</span><br></pre></td></tr></table></figure>

<h2 id="线性逻辑卷-Linear-Logic-Volume"><a href="#线性逻辑卷-Linear-Logic-Volume" class="headerlink" title="线性逻辑卷 Linear Logic Volume"></a>线性逻辑卷 Linear Logic Volume</h2><p>当一个VG中有两个或者多个磁盘的时候，LV分配磁盘容量的时候是按照VG中的PV安装顺序分配的，即一个PV用完后才会分配下一块PV。也可以在创建LV的通过指定PV中的PE段来将数据分散到多个PV上。该模式也是LVM的默认模式。</p>
<p>使用&#x2F;dev&#x2F;vdb和&#x2F;dev&#x2F;vdc两块磁盘来进行测试，先创建对应的PV。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pvcreate /dev/vdb /dev/vdc</span><br><span class="line">  Physical volume &quot;/dev/vdb&quot; successfully created.</span><br><span class="line">  Physical volume &quot;/dev/vdc&quot; successfully created.</span><br><span class="line"></span><br><span class="line">$ pvdisplay</span><br><span class="line">  &quot;/dev/vdb&quot; is a new physical volume of &quot;100.00 GiB&quot;</span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/vdb</span><br><span class="line">  VG Name               </span><br><span class="line">  PV Size               100.00 GiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0   </span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               8NnlYc-4f3f-fkeW-a3l3-LXoC-9UEH-fvpb5V</span><br><span class="line"></span><br><span class="line">  &quot;/dev/vdc&quot; is a new physical volume of &quot;200.00 GiB&quot;</span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/vdc</span><br><span class="line">  VG Name               </span><br><span class="line">  PV Size               200.00 GiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0   </span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               I9ffpN-c1vc-PQOB-yKyd-MdzO-Ngff-6e116t</span><br></pre></td></tr></table></figure>

<p>创建VG vg1，该容量为上面两个磁盘空间之和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vgcreate vg1 /dev/vdb /dev/vdc</span><br><span class="line">  Volume group &quot;vg1&quot; successfully created</span><br><span class="line"></span><br><span class="line">$ vgdisplay</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               vg1</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  1</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                0</span><br><span class="line">  Open LV               0</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               299.99 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              76798</span><br><span class="line">  Alloc PE / Size       0 / 0   </span><br><span class="line">  Free  PE / Size       76798 / 299.99 GiB</span><br><span class="line">  VG UUID               Gi0bJx-jqY8-YpSo-kB0l-9wdk-ZfCT-GpgFZY</span><br></pre></td></tr></table></figure>

<p>从vg1中创建LV lv1，其大小为vg的全部大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lvcreate --type linear -l 100%VG -n lv1 vg1</span><br><span class="line">  Logical volume &quot;lv1&quot; created.</span><br><span class="line"></span><br><span class="line">$ lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/vg1/lv1</span><br><span class="line">  LV Name                lv1</span><br><span class="line">  VG Name                vg1</span><br><span class="line">  LV UUID                JQZ193-dz6A-I0Ue-rTKC-6XrQ-gb1F-Qy9kDl</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time iZt4nd6wiprf8foracovwqZ, 2022-01-08 23:28:45 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 0</span><br><span class="line">  LV Size                299.99 GiB</span><br><span class="line">  Current LE             76798</span><br><span class="line">  Segments               2</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           252:0</span><br><span class="line"></span><br><span class="line">$ lvs -o lv_name,lv_attr,lv_size,seg_pe_ranges</span><br><span class="line">  LV   Attr       LSize   PE Ranges       </span><br><span class="line">  lv1  -wi-a----- 299.99g /dev/vdc:0-51198</span><br><span class="line">  lv1  -wi-a----- 299.99g /dev/vdb:0-25598</span><br></pre></td></tr></table></figure>

<h2 id="条带化逻辑卷-Striped-Logic-Volume"><a href="#条带化逻辑卷-Striped-Logic-Volume" class="headerlink" title="条带化逻辑卷 Striped Logic Volume"></a>条带化逻辑卷 Striped Logic Volume</h2><p>类似于raid0模式，在该模式下，多块磁盘均会分配PE给LV。可以通过-i参数来指定可以使用VG中多少个PV。</p>
<p>优点：将数据的读写压力分散到了多个磁盘，可以提升读写性能。<br>缺点：一个磁盘损坏后会导致数据丢失。</p>
<p>但在使用striped模式时，需要注意：</p>
<ol>
<li>如果PV来自于同一个磁盘的不同分区，会导致更多的随机读写，不仅不能提升磁盘性能，反而会导致性能下降。</li>
<li>如果VG中某一个PV过小，则无法将所有的PV平均使用起来，存在木桶效应。</li>
</ol>
<p>使用<code>--type striped</code>来指定为striped模式，<code>--stripes</code>来指定需要使用的pv数量，<code>--stripesize</code>指定写足够数量的数据后再更换为另外一个pv。在下面的创建命令中，可以看到创建出来了12800个LE，PE是平均分配到了两个pv上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lvcreate --type striped --stripes 2 --stripesize 32k -L 50G -n lv1 vg1</span><br><span class="line">  Logical volume &quot;lv1&quot; created.</span><br><span class="line"></span><br><span class="line">$ lvs -o lv_name,lv_attr,lv_size,seg_pe_ranges                          </span><br><span class="line">  LV   Attr       LSize  PE Ranges                      </span><br><span class="line">  lv1  -wi-a----- 50.00g /dev/vdb:0-6399 /dev/vdc:0-6399</span><br><span class="line"></span><br><span class="line">$ lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/vg1/lv1</span><br><span class="line">  LV Name                lv1</span><br><span class="line">  VG Name                vg1</span><br><span class="line">  LV UUID                FnOmCM-IkuE-3Rvv-fQqk-Cv1Q-lb8S-l5X7O3</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time iZt4nd6wiprf8foracovwqZ, 2022-01-09 00:07:08 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 0</span><br><span class="line">  LV Size                50.00 GiB</span><br><span class="line">  Current LE             12800</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     256</span><br><span class="line">  Block device           252:0</span><br></pre></td></tr></table></figure>

<p>如果指定的lv大小为250G，由于分配到两块磁盘上，由于最小的磁盘只有100G，100G * 2无法满足250G的磁盘大小需求，此时会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lvcreate --type striped --stripes 2 --stripesize 32k -L 250G -n lv1 vg1</span><br><span class="line">  Insufficient suitable allocatable extents for logical volume lv1: 12802 more required</span><br></pre></td></tr></table></figure>

<h2 id="镜像逻辑卷-Mirror-Logic-Volume"><a href="#镜像逻辑卷-Mirror-Logic-Volume" class="headerlink" title="镜像逻辑卷 Mirror Logic Volume"></a>镜像逻辑卷 Mirror Logic Volume</h2><p>类似于raid1。可以解决磁盘的单点问题，一块磁盘挂掉后不至于丢失数据。</p>
<p>通过使用<code>--type mirror</code>来指定为镜像模式，-m参数来指定冗余的数量。</p>
<h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><ul>
<li><a href="https://linux.cn/article-3218-1.html">Linux LVM简明教程</a></li>
<li><a href="https://yq.aliyun.com/articles/572204">初识LVM及ECS上LVM分区扩容</a></li>
<li><a href="https://www.cnblogs.com/xibuhaohao/p/11731699.html">Linux LVM–三种Logic Volume</a></li>
</ul>
]]></content>
      <tags>
        <tag>磁盘</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux macvlan network</title>
    <url>/post/macvlan/</url>
    <content><![CDATA[<p>macvlan的原理是在宿主机物理网卡上虚拟出多个子接口，每个子接口有独立的mac地址，通过不同的MAC地址在数据链路层（Data Link Layer）进行网络数据转发的。达到的效果类似，一块物理网卡上有多个IP地址，多个IP地址有自己的mac地址。</p>
<p>它是比较新的网络虚拟化技术，需要较新的内核支持（Linux kernel v3.9–3.19 and 4.0+）。</p>
<p>macvlan设备跟物理设备之间并不直接互通。</p>
<p>macvlan不以交换机端口来划分vlan，一个交换机端口可接收来自多个mac地址的数据。</p>
<p>一个交换机端口要处理多个vlan的数据，需要开启trunk模式。</p>
<h2 id="四种模式"><a href="#四种模式" class="headerlink" title="四种模式"></a>四种模式</h2><p>以下四种模式为每个macvlan设备单独配置，而不是一个物理设备就只有一个配置。</p>
<h3 id="VEPA"><a href="#VEPA" class="headerlink" title="VEPA"></a>VEPA</h3><p>所有发送出去的报文都经过交换机，交换机再发送到对应的目标地址。默认模式。物理网卡接收到macvlan设备的数据后，总是将数据发送出去，即使是发往本设备上其他macvlan设备的数据包。这样在交换机设备上可以看到所有网络的流量。如果是本机的macvlan设备流量仍然是发往本机的macvlan设备，可能会被交换机的生成树协议阻止。需要交换机开启hairpin模式或者reflective relay模式，该模式在目前的交换机上未广泛支持，vepa模式的应用较少。</p>
<p>linux的网桥支持hairpin模式。</p>
<h3 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h3><p>最常用，同一个物理设备上的不同macvlan设备间的通讯可以直接转发，不再需要经过外部的交换机。转发非常快速，macvlan设备相对固定，不需要生成树协议。</p>
<h3 id="Private"><a href="#Private" class="headerlink" title="Private"></a>Private</h3><p>本质上是VEPA模式，但同一个物理设备上的macvlan设备之间无法直接通讯，不常用。</p>
<h3 id="Passthru"><a href="#Passthru" class="headerlink" title="Passthru"></a>Passthru</h3><p>后来增加的模式，比较少用</p>
<p>vepa和passthru都会将不同macvlan接口之间的数据发送到交换机，然后发回，对性能的影响比较明显。</p>
<p>物理网卡收到包后，根据包的mac地址来判断这个包交给哪个虚拟接口。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/macvlan-workmode-1.png" alt="image"></p>
<h2 id="手工创建实践"><a href="#手工创建实践" class="headerlink" title="手工创建实践"></a>手工创建实践</h2><p>以下实验为在virturalbox虚拟机下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建两个network namespace net1和net2</span><br><span class="line">ip netns add net1</span><br><span class="line">ip netns add net2</span><br><span class="line"></span><br><span class="line"># 创建macvlan接口</span><br><span class="line"># enp0s8相当于物理网卡eth0</span><br><span class="line">ip link add link enp0s8 mac1 type macvlan</span><br><span class="line"></span><br><span class="line"># 可以看到创建了接口mac1@enp0s8</span><br><span class="line">[root@localhost vagrant]# ip link</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 08:00:27:6c:3e:95 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000</span><br><span class="line">    link/ether 08:00:27:cf:b0:b4 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: docker_gwbridge: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT</span><br><span class="line">    link/ether 02:42:8e:cf:a9:da brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: br-b3e83aa45886: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT</span><br><span class="line">    link/ether 02:42:bf:b4:e5:36 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">6: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT</span><br><span class="line">    link/ether 02:42:25:e7:40:32 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">19: br-ec6c4e77321d: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT</span><br><span class="line">    link/ether 02:42:e0:d8:38:6d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">24: mac1@enp0s8: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT</span><br><span class="line">    link/ether 3e:b8:e9:1d:3b:c8 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>

<p>创建macvlan接口的格式为：<code>ip link add link &lt;PARENT&gt; &lt;NAME&gt; type macvlan</code>， <PARENT>是macvlan接口的父接口名称，name是新创建的macvlan接口名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将mac1放入到net1 namespace中</span><br><span class="line">[root@localhost vagrant]# ip link set mac1 netns net1</span><br><span class="line">[root@localhost vagrant]# ip netns exec net1 ip link</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">24: mac1@if3: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT</span><br><span class="line">    link/ether 3e:b8:e9:1d:3b:c8 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line"></span><br><span class="line"># 在net1中将mac1接口命名为eth0</span><br><span class="line">[root@localhost vagrant]# ip netns exec net1 ip link set mac1 name eth0</span><br><span class="line">[root@localhost vagrant]# ip netns exec net1 ip link</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">24: eth0@if3: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT</span><br><span class="line">    link/ether 3e:b8:e9:1d:3b:c8 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line"></span><br><span class="line"># 在net1中分配eth0网卡的ip地址为192.168.8.120</span><br><span class="line">[root@localhost vagrant]# ip netns exec net1 ip addr add 192.168.8.120/24 dev eth0</span><br><span class="line">[root@localhost vagrant]# ip netns exec net1 ip link set eth0 up</span><br><span class="line">[root@localhost vagrant]# ip netns exec net1 ip link</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">24: eth0@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT</span><br><span class="line">    link/ether 3e:b8:e9:1d:3b:c8 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure>

<h2 id="在docker上的实践"><a href="#在docker上的实践" class="headerlink" title="在docker上的实践"></a>在docker上的实践</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost vagrant]# docker network create -d macvlan --subnet=10.0.2.100/24 --gateway=10.0.2.2 -o parent=enp0s3 mcv</span><br><span class="line">5c637798d559471bd8d1036cdd947d3949e1973f724568da066d9c60c00fb5e6</span><br><span class="line"></span><br><span class="line">[root@localhost vagrant]# docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">b6a128f1730e        bridge              bridge              local</span><br><span class="line">a65957cd6c3f        docker_gwbridge     bridge              local</span><br><span class="line">540bb390028a        host                host                local</span><br><span class="line">b3e83aa45886        isolated_nw         bridge              local</span><br><span class="line">ec6c4e77321d        local_alias         bridge              local</span><br><span class="line">5c637798d559        mcv                 macvlan             local</span><br><span class="line">3d247d0414d0        none                null                local</span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://backreference.org/2014/03/20/some-notes-on-macvlanmacvtap/">Some notes on macvlan&#x2F;macvtap</a><br><a href="http://backreference.org/2014/03/20/some-notes-on-macvlanmacvtap/"></a></p>
]]></content>
      <tags>
        <tag>docker macvlan</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode题目之Majority Element</title>
    <url>/post/majority_element/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n&#x2F;2 ⌋ times.<br>You may assume that the array is non-empty and the majority element always exist in the array.</p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题是一道非常简单的题目，但我能想到的思路有限，仅能想到排序法和哈希法两种算法，在Solution中提供了另外几种方法，这是非常值得我学习和思考的。本文仅将网站的思路拿过来，可以直接看该问题的<a href="https://leetcode.com/problems/majority-element/solution/">Solution</a>。</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h2><p>最原始的解决办法，逐个元素比较是否为该数组中的最多元素，只要满足条件即可终止。时间复杂度为O(n^2)。</p>
<h2 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h2><p>将数组中的元素遍历一遍，并将数组中元素的个数保存到哈希中。然后遍历哈希，从哈希中找到最多元素。时间复杂度O(n)，但需要占用一定的空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">        std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; result_map;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = num.<span class="built_in">begin</span>(); iter != num.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result_map.<span class="built_in">find</span>(*iter) == result_map.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                result_map.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(*iter, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result_map[*iter]++;                                                                                                                                            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">for</span> (std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator iter = result_map.<span class="built_in">begin</span>(); iter != result_map.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;second &gt; max_count)</span><br><span class="line">            &#123;</span><br><span class="line">                result = iter-&gt;first;</span><br><span class="line">                max_count = iter-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h2><p>直接对元素进行排序，排序后元素的中间元素即为要求的最多元素。时间复杂度为O(nlogn)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElementSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">   <span class="keyword">return</span> num[num.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随机抽取法"><a href="#随机抽取法" class="headerlink" title="随机抽取法"></a>随机抽取法</h2><p>随机从数组中抽取元素，然后遍历数组判断该元素是否为最多元素。该算法利用了最多元素被随机抽取的概率最大的特点，但该算法效率的随机性较大，最好时间复杂度为O(n)，最坏情况下一直随机不到最多元素。</p>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>将数组均分为两份，分别求出两个数组中的最多元素A和B，则整个数组中的最多元素必然在两个子数组的最多元素A和B中，这一点可以通过举例子的方式来证明，但是仅凭感觉不太容易得出该结论。如果A&#x3D;&#x3D;B，则结果就是A。如果A!&#x3D;B，则分别求出A和B在这个数组中的元素个数。时间复杂度接近O(nlogn)。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有一些比较不容易想到的算法，这里就不列举了。至少我看过一次之后，下次这些算法仍然是记不住的。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>市长热线12345</title>
    <url>/post/mayor_hotline/</url>
    <content><![CDATA[<p><img src="/ref/life/mayor_hotline.jpg" alt="Image Title"></p>
<p>前段时间在家看书学习，难得的学习的好时机。</p>
<p>楼下有一个卖饭的小摊及其猖狂，不仅占用了人行道来炒菜，而且还在马路上摆了一溜桌子供客人吃饭，不仅占用了人行道，连车行道都给占用了。这些也就罢了，对我影响都不算太大，更可气的是每天中午和晚上吃饭的时候会开着大音响放着恼人的音乐，我不想惹麻烦，我忍。</p>
<p>今天中午我刚开始看书，看到难处需要精心思考，恼人的音乐又开始了，我实在忍不住了，TMD，维权。打市长热线12345投诉，市长热线让我打110投诉。继续打110投诉，然后跟110说了下具体情况后，说给相应的派出所去处理。派出所的小片警立刻就给我回电话了，说外放音乐正常经营范围，只要不在晚上或清晨放音乐就不算违规，他们管不着，建议我去下面跟卖饭的商量，好一个商量。然后我又说，他们非法占道经营，小片警又说这个归城管管，让我给城管打电话，好一个给城管打电话。好一个推卸责任，这些把我给惹毛了。</p>
<p>挂断电话后，寻思这个理不太对，然后继续给市长热线12345打电话，告诉情况后，市长热线的妹子告诉我说这个事情我给你处理，好一个我给你处理，这才是为人民服务的态度，鼓掌。</p>
<p>这是第二次机会接触小片警，每次都是让我失望，绝望，恨之入骨。第一次接触小片警我甚至kill him的心都有了。不一心想着为人民服务，却是一心想着推卸责任，处处刁难市民并从中谋取私利，对市民爱理不理，这就是小片警在我心中的形象，很难改变。越是权利小的小兵，架子越大，这也就决定了永远是个小兵的身份。</p>
<p>如果没有市长热线那这件扰民的事情也就不了了之了，因为投诉110都不管用了，作为市民已经没有可以维权的机构了。还好有市长热线的存在给市民多了一个维权的途径。</p>
<p>上周五打的电话，这个周一给我回复电话问我饭馆在哪一次，周二又打电话问我饭馆在哪，然后周三终于给处理了，下班途中派出所给我电话回复说：“已经处理好了，让小饭馆的音响声音调小了，以后如果再有这种情况可以继续打电话”。等我回家一看，果然音响不见了，世界一下子清净了，zf终于替我办事了。</p>
<p>也许是因为我的事情不是很紧急的原因，整个处理流程过于慢了，等了足足五天的时间才处理好。</p>
<p>当大家的权益受到损害时，请大家多给市长热线打电话维护自己的权益。</p>
]]></content>
  </entry>
  <entry>
    <title>从0开始学习微服务阅读笔记</title>
    <url>/post/micro-service/</url>
    <content><![CDATA[<p>本文为极客时间专栏从0开始学习微服务的阅读笔记。</p>
<p>在了解微服务之前，先来了解一下单体应用。</p>
<p>在上学那会，做过一些企业站，技术往往是基于LAMP（Linux + Apache + MySQL + PHP），这种业务较为简单的企业站，就是单体应用。所有的业务代码都是放在一个PHP程序中，代码只需要我自己来维护就可以了，测试、上线、运维全部搞定。</p>
<p>但这种单体应用要是放到稍微有点规模的互联网公司中必然是行不通的。一个公司里有很多的人，不可能公司这么多技术人员共同维护一套代码，这样子团队的写作必然是个问题。系统的健壮性也会比较差，一旦单体应用中的一个模块出问题后往往会影响到其他的模块，导致整个系统不可用，比如PHP的服务业界通常使用php-fpm来管理，而php-fpm处理连接的方式一个请求一个线程，当一部分请求因为延时高时会消耗过多的线程资源，导致其他请求没有可用的线程可以处理。</p>
<p>单体应用的其他缺点不再罗列，比如代码膨胀过度、发布较慢、系统高可用性差、团队协作成本高等。</p>
<p>为了解决单体应用的这些缺点，方法只有一个就是将单体应用拆分为多个服务即服务化，服务之间通过RPC的方式相互调用。</p>
<p>即服务化后，业界又提出了微服务的概念。</p>
<p>维基百科中有如下定义：</p>
<blockquote>
<p>2014年，Martin Fowler 与 James Lewis 共同提出了微服务的概念，定义了微服务是由以单一应用程序构成的小服务，自己拥有自己的行程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通讯。同时服务会使用最小的规模的集中管理 (例如 Docker) 能力，服务可以用不同的编程语言与数据库等元件实作。</p>
</blockquote>
<p>但看这个定义，看的我一脸懵逼，实在太过抽象。其实微服务也没有一个特别明确的定义。</p>
<p>那么服务化和微服务之间有什么不同之处呢？</p>
<ol>
<li>服务拆分粒度更细。</li>
<li>每个微服务都独立部署和维护。</li>
<li>微服务需要服务治理。由于微服务会将服务变多，势必需要一个服务管理平台来对微服务进行管理。</li>
</ol>
<p>将单体应用向微服务拆分的方式可以分为纵向拆分和横向拆分。这里以一点资讯app为例来解释纵向拆分和横向拆分。</p>
<p>一点资讯分为信息流、正文页等模块，而这些功能都依赖于用户信息获取模块，纵向拆分即将信息流、正文页拆分为微服务，横向拆分即将信息流、正文页都依赖的用户信息获取模块拆分为单独的服务。</p>
<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>采用微服务后会带来一系列复杂的问题，新技术在解决了一部分问题的同时，总会带来一些新的问题，比如服务怎么定义接口、服务的发布方式和服务发现、服务的监控、服务的治理（包括依赖关系梳理、熔断机制等）、故障快速定位等。</p>
<p>那么一个标准的微服务架构应该长什么样子呢？</p>
<p>服务提供方在服务启动时向服务注册中心注册服务，声明自己能够提供的服务及当前服务的地址等信息。</p>
<p>服务调用者请求注册中心，查询所要调用服务的地址，并通过约定好的协议向服务提供者发起请求，获取到结果后按照数据协议格式将数据进行反序列化。</p>
<p>在整个服务的调用过程中，服务的请求耗时、调用量、调用成功与否等信息都会作为监控记录下来，服务的调用关系会通过trace系统记录下来，以便用于后续的故障定位和追踪。如果服务调用失败，则需要服务治理的方式来保证调用方的正常运行。</p>
<h2 id="服务的接口定义"><a href="#服务的接口定义" class="headerlink" title="服务的接口定义"></a>服务的接口定义</h2><p>需要解决的问题是服务的接口有哪些？每个接口的输入什么？每个接口的输出是什么？</p>
<h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>HTTP协议的接口定义通常使用该协议，常见Wiki或者Swagger的方式来管理。</p>
<h3 id="IDL文件"><a href="#IDL文件" class="headerlink" title="IDL文件"></a>IDL文件</h3><p>IDL（interface description language）用于描述接口，使得不同的编程语言不同的平台服务之间可以相互通讯。常见实现包括Thrift和protobuf，protobuf作为序列化方式的一种，通常会使用gRPC进行通讯。</p>
<h3 id="XML文件方式"><a href="#XML文件方式" class="headerlink" title="XML文件方式"></a>XML文件方式</h3><p>服务提供者将接口描述信息保存在xml配置文件，服务启动后会加载配置文件，将服务暴露出去。</p>
<p>服务消费者将要调用的接口信息写在xml配置文件中，进程启动后加载xml配置文件。</p>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>服务提供者通常需要提供服务的超时时间等参数，而消费者端也需要该信息，为了让消费者端能看到生产者端的配置，可以将信息放在配置中心中，但这却增大了配置中心的内容，当一旦配置变化需要同步时，同步的数据会变多。</p>
<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>要想实现服务之间的调用，通常会使用反向代理和服务注册中心的方法。</p>
<p>反向代理的方法业界一般使用较多的包括nginx、haproxy以及业界新秀envoy等。</p>
<p>在微服务架构中更多提及的方案为采用服务注册中心的方法，而注册中心的稳定性就显得尤其重要。</p>
<p>业界注册中心采用较多的方案为zookeeper、etcd、consul、eureka。这些注册中心的存储数结构要么是树状接口，要么是key-value形式，其中k-v形式的可以变更key的值以实现类似树状结构。</p>
<h3 id="注册中心的设计"><a href="#注册中心的设计" class="headerlink" title="注册中心的设计"></a>注册中心的设计</h3><h4 id="注册中心API及功能"><a href="#注册中心API及功能" class="headerlink" title="注册中心API及功能"></a>注册中心API及功能</h4><p>注册中心需要提供以下api以供服务提供方和服务调用方使用。</p>
<ol>
<li>服务注册接口，提供服务提供方使用</li>
<li>服务反注册接口，提供服务提供方以便销毁服务</li>
<li>心跳汇报接口，服务提供方通过心跳汇报服务是存活状态的。一旦当服务出现异常时，服务注册中心应该立即将服务从注册中心剔除。</li>
<li>服务订阅接口，服务调用方用于获取服务提供方的实例列表</li>
<li>服务变更接口，服务调用方用于获取最新可用服务。一旦注册中心探测到有新的服务实例或者实例减少，应该立即通知所有订阅该服务的服务调用者更新本地的节点信息。</li>
</ol>
<h4 id="注册中心存储哪些服务信息"><a href="#注册中心存储哪些服务信息" class="headerlink" title="注册中心存储哪些服务信息"></a>注册中心存储哪些服务信息</h4><p>通常可以按照“服务名-分组-节点信息”三层结构来存储，其中节点信息包括：节点ip地址、节点端口号、请求失败时重试次数、请求结果是否压缩。</p>
<p>分组的划分原则包括：</p>
<ol>
<li>按照业务的核心程度</li>
<li>按照机房维度</li>
<li>线上环境、测试环境</li>
</ol>
<h4 id="注册中心如何工作"><a href="#注册中心如何工作" class="headerlink" title="注册中心如何工作"></a>注册中心如何工作</h4><h5 id="服务提供者注册节点"><a href="#服务提供者注册节点" class="headerlink" title="服务提供者注册节点"></a>服务提供者注册节点</h5><ol>
<li>查看注册节点是否在白名单内，即是否可以向注册中心注册</li>
<li>查看注册的服务名、服务分组是否存在</li>
<li>将节点信息添加到对应的存储位置</li>
</ol>
<h5 id="服务提供者反注册"><a href="#服务提供者反注册" class="headerlink" title="服务提供者反注册"></a>服务提供者反注册</h5><ol>
<li>查看服务名、服务分组对应的服务是否存在</li>
<li>将节点删除</li>
</ol>
<h5 id="服务消费者查询节点信息"><a href="#服务消费者查询节点信息" class="headerlink" title="服务消费者查询节点信息"></a>服务消费者查询节点信息</h5><ol>
<li>从本机内存中查找服务信息</li>
<li>如果有本地快照存储可以从中查找</li>
</ol>
<h5 id="服务消费者订阅服务变更"><a href="#服务消费者订阅服务变更" class="headerlink" title="服务消费者订阅服务变更"></a>服务消费者订阅服务变更</h5><ol>
<li>消费者获取到服务信息后，在本地保留cluster的sign值</li>
<li>每个一段时间从注册中心获取cluster的sign值，如果不一致，就从注册中心拉取服务节点，并更新内存环境和本地快照</li>
</ol>
<h2 id="服务框架"><a href="#服务框架" class="headerlink" title="服务框架"></a>服务框架</h2><p>完整的服务框架包括：通讯框架、通讯协议、序列化和反序列化。</p>
<h3 id="开源RPC框架"><a href="#开源RPC框架" class="headerlink" title="开源RPC框架"></a>开源RPC框架</h3><p>跟语言相关的框架：Dubbo、Motan（微博）、Tars（腾讯）、Spring Cloud</p>
<p>跨平台的开源RPC框架：gRPC、Thrift</p>
<h2 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h2><p>常用的开源监控软件包括：ELK、Graphite、TICK、Prometheus</p>
<h2 id="服务追踪"><a href="#服务追踪" class="headerlink" title="服务追踪"></a>服务追踪</h2><p>使用分布式会话跟踪技术，利用traceid</p>
<p>开源方案包括OpenZipkin、jaeger等</p>
<h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><p>通过一系列的手段保证在意外情况下，服务仍然能够正常运行。</p>
<h3 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h3><p>服务调用失败可能是服务提供者自身出现了问题，也可能是网络问题导致。</p>
<p>1.注册中心自动摘除机制</p>
<p>服务提供者和注册中心之间保持心跳，当超时后注册中心自动摘除服务提供者。</p>
<p>2.服务消费者摘除</p>
<p>将服务提供者的探活机制放到消费者端，消费者在探测到服务提供者失败后自动摘除服务提供者。这种情况可以避免服务提供者和注册中心之间网络出现异常，但是服务提供者和服务消费者之间可以通讯的情况。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>常用的包括随机算法、轮询、加权轮询算法、最少活跃调用、一致性hash算法（可以配合着静态注册中心达到比较好的效果）</p>
<p><strong>自适应最优选择算法</strong>：在客户端维护一份每一个服务节点的性能统计快照，每隔一段时间去更新快照。在发起请求时，根据二八原则，将服务节点分成两部分，找出20%的那部分响应最慢的节点并降低权重。也可称为动态加权轮询算法。1分钟的更新时间间隔是个不错的选择。</p>
<p>个人感觉<strong>自适应最优选择算</strong>是个不错的选择，但还可以针对业务场景继续优化，比如权重进行动态调整。</p>
<h3 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h3><p>用于限定服务消费者可选择服务提供者节点的范围。</p>
<p>应用场景：分组调用（组的划分可以按照机房等维度）、灰度发布、流量切换（比如机房故障后，用于机房之间的流量调度）、读写分离（读接口部署在一起，写接口部署在一起）。</p>
<h5 id="规则的写法"><a href="#规则的写法" class="headerlink" title="规则的写法"></a>规则的写法</h5><p>A.条件路由</p>
<ul>
<li>某个ip的消费者仅访问某个ip的服务提供者</li>
<li>排除某个服务节点（所有的服务消费者都不能访问某个服务提供者）</li>
<li>白名单和黑名单</li>
<li>机房级别的隔离（可以基于ip地址的规则来做）</li>
<li>读写分离（所有get类方法仅访问某些节点等）</li>
</ul>
<p>B.脚本路由</p>
<p>使用脚本语言的形式来描述</p>
<h4 id="路由的获取方式"><a href="#路由的获取方式" class="headerlink" title="路由的获取方式"></a>路由的获取方式</h4><ul>
<li>本地配置：存储在服务消费者本地</li>
<li>配置中心配置，可以修改规则后动态下发</li>
</ul>
<h3 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h3><p>手段包括超时、重试、双发、熔断等。</p>
<p>双发的思路为服务调用者在发起一次服务调用后，在给定的时间内（该时间要比服务超时的时间短）没有得到结果，再发起另外一个请求。</p>
<p>熔断的思路为在某一个时间内如果服务调用失败次数超过一定值，则触发熔断，不再向服务提供者发起请求。</p>
<p>断路器中的状态包括：Closed、Open、Half Open（半打开状态，用于探测后端服务是否已经正常）</p>
<p>Hystrix是最出名的熔断器，计算服务调用的失败率是通过滑动窗口来实现，滑动窗口内包含10个桶，每个桶为1秒内的服务调用情况。</p>
<p>FailOver，失败自动切换。消费者调用失败后，自动从可以节点中选择下一个节点重新调用，可设置失败的次数。通常适合只读的场景。</p>
<p>FailBack，失败通知。调用失败后，不能重试，而是根据失败的信息来决定后续的执行策略。通常用于写场景。</p>
<p>FailCache，失败缓存。调用失败后，隔一段时间后再重试。</p>
<p>FailFast，快速失败。调用失败后不再重试。</p>
<h3 id="如何识别服务节点是否存活"><a href="#如何识别服务节点是否存活" class="headerlink" title="如何识别服务节点是否存活"></a>如何识别服务节点是否存活</h3><p>如果注册中心为zk，在服务节点变化的时候，注册中心会向服务调用方推送服务节点变化的通知。但当网络抖动的时候，可能会存在节点的状态频繁变化的问题，导致服务消费者频繁收到节点变更通知，或者导致注册中心获取到的服务节点过少。可通过以下手段来避免该问题。</p>
<h3 id="服务端故障时的应对策略"><a href="#服务端故障时的应对策略" class="headerlink" title="服务端故障时的应对策略"></a>服务端故障时的应对策略</h3><p>故障包括：集群故障、单个idc故障、单机故障</p>
<h4 id="集群故障"><a href="#集群故障" class="headerlink" title="集群故障"></a>集群故障</h4><p>比如触发bug、突发流量等</p>
<p>限流：限制超出接口阈值的部分请求</p>
<p>降级：一种思路为通过开关来实现。具体可以分为多种等级：一级降级对业务影响比较小，可以设置为自动降级；二级降级对业务有一定影响，设置为手工降级；三级降级需要谨慎操作。</p>
<h4 id="单idc故障"><a href="#单idc故障" class="headerlink" title="单idc故障"></a>单idc故障</h4><p>基于dns的流量切换：延时稍高，比较适合入口流量。</p>
<p>基于rpc的分组流量切换：将之前单个机房内访问的流量切换为多个机房访问。</p>
<h4 id="单机故障"><a href="#单机故障" class="headerlink" title="单机故障"></a>单机故障</h4><p>可以通过自动重启服务的手段来解决。但要避免一次性重启服务过多的问题。</p>
<h4 id="动态注册中心的保护机制"><a href="#动态注册中心的保护机制" class="headerlink" title="动态注册中心的保护机制"></a>动态注册中心的保护机制</h4><ol>
<li>心跳开关保护机制，给注册中心设置一个开关，当开发打开时，即使网络频繁抖动，注册中心也不会通知消费者节点变更，后者设置一定的百分比打开该开关。正常情况下该开关可以不打开。</li>
<li>服务节点摘除保护机制，设定一个阈值比例，在出现网络抖动的情况下，注册中心也不会将超过这个阈值的节点给下掉，防止一下子下掉过多节点。该机制正常情况下，应该开启。</li>
</ol>
<h4 id="静态注册中心的保护机制"><a href="#静态注册中心的保护机制" class="headerlink" title="静态注册中心的保护机制"></a>静态注册中心的保护机制</h4><p>在服务消费者端来判断是否服务提供者是否存活。服务消费者调用某一个节点失败超过一定次数就将节点标记为不可用。并隔一段时间后再去探测该节点是否存活。</p>
<p>注册中心的服务正常情况下不改变的，只有当服务在发布的时候才去修改注册中心中的节点。注册中心中的节点变化后仍然通知服务消费者，只是在网络出现抖动的时候，不再去通知。</p>
<p><strong>个人感觉这个思路更靠谱。</strong></p>
<h3 id="服务治理平台"><a href="#服务治理平台" class="headerlink" title="服务治理平台"></a>服务治理平台</h3><p>1.服务管理 包括服务上下线、节点添加和删除、服务查询、服务节点查询等</p>
<p>2.服务治理 限流、降级、切流量</p>
<p>3.服务监控 可以包含服务的tracing监控等</p>
<p>4.问题定位</p>
<p>5.日志查询</p>
<p>6.服务运维 发布部署和扩缩容</p>
<h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>业内采用的开源配置中心包括:</p>
<ul>
<li>Spring Cloud 功能相对较弱，变更配置需要通过git操作</li>
<li>Apollo 对Spring Boot的支持比较好</li>
</ul>
<h2 id="进阶内容"><a href="#进阶内容" class="headerlink" title="进阶内容"></a>进阶内容</h2><h3 id="做好容量规划"><a href="#做好容量规划" class="headerlink" title="做好容量规划"></a>做好容量规划</h3><p>包括容量评估和调度决策两方面。</p>
<p>压测服务的单机最大容量可以采用区间加权的方式来计算，比如0 ~ 10ms区间权重为1，10 ~ 50ms区间权重为2,500ms以上权重为32，通过累加的方式计算出单机的权重，从而评估出单机最大容量。(<strong>该评估容量的方式非常实用</strong>)</p>
<p>调度策略可以根据水位线来做决定，一条是安全线，一条是致命线。当水位线处于致命线需要立即扩容，当水位线回到安全线以上时可以进行缩容。（<strong>水位线的方式很赞</strong>）</p>
<p>缩容的思路是采用逐步缩容，每隔5分钟判断一次水位线是否在致命线以上，并按照10%、30%的比例进行缩容。</p>
<p>为了防止水位线的抖动，可以一分钟采集一个点，当5个点中的3个点都满足条件时才进行缩容。</p>
<h3 id="多机房部署"><a href="#多机房部署" class="headerlink" title="多机房部署"></a>多机房部署</h3><p>1.主从架构</p>
<p>所有的写请求都发给主机房，主机房更新本机房的缓存和数据库，其他机房的缓存和数据库从主机房同步。主机房出现问题后，就没法更新了。</p>
<p>2.独立机房架构</p>
<p>缓存层，每个机房都有写请求，每个机房的写请求通过消息同步组件将写请求同步给另外一个机房。数据库mysql只有一个主库，另外机房的mysql同步数据到该机房。</p>
<p>以上缓存消息同步组件的实现大概如下：</p>
<p>包括两个模块reship和collector，reship负责将本机房的写请求发一份给别的机房，collector负责从别的机房读取写请求，并发给本机房的处理服务器。</p>
<p>可以通过消息队列和rpc调用来实现reship和collector的通讯。</p>
<p>3.多机房的数据一致性</p>
<p>可通过消息对账机制来保证一致性，原理为通过一个单独的程序后面来验证是否一个写请求是否已经被所有的机房都处理，如果没有处理，则重新发送写请求。</p>
<h3 id="混合云部署"><a href="#混合云部署" class="headerlink" title="混合云部署"></a>混合云部署</h3><p>公有云上为了安全往往不部署数据库</p>
<h3 id="DevOps实践"><a href="#DevOps实践" class="headerlink" title="DevOps实践"></a>DevOps实践</h3><p>持续集成：确保每一次代码的merge request都通过，分为四个阶段：build（开发分支代码的编译与单元测试）、package（开发分支代码打包成docker镜像）、deploy（开发分支代码部署到测试环境）、test（集成测试）。包括了代码检查和单元测试环节。</p>
<p>持续交付：代码merge request到develop分支后，develop分支的代码能够在生产环境中测试通过，并进行小流量灰度验证，可以随时上线。分为五个阶段：build（develop分支的代码编译与单元测试）、package（develop分支代码打包）、deploy、test、canary（develop分支代码的小流量灰度验证）。</p>
<p>持续部署：合并develop代码到master分支，并打包成docker镜像，并可随时上线。包括：build、package、clear、production。</p>
<h3 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h3><p>Service Mesh技术以轻量级网络代理的方式与应用代码部署在一起，主要有两个关键点技术。</p>
<p>SideCar用于转发服务之间的调用，在服务消费者端SideCar用于将请求转发到服务提供者端的SideCar中，在服务提供者端的SideCar在接收到请求后转发给本机上的服务提供者。</p>
<p>SideCar实现方式有基于ipstables的网络拦截和直接转发请求两种方式。</p>
<p>Control plane用于基于SideCar的服务调用的治理，用来取代微服务中需要服务框架干的事情，包括服务发现、负载均衡、请求路由、故障处理、安全认证、监控上报、日志记录、配额限制等。</p>
<h3 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h3><p>Pilot主要用于流量控制，包括Rules API（提供API，用于流量控制）、Envoy API（给Envoy提供API，获取服务注册信息、流量控制信息等）、抽象模型（对服务注册信息、流量控制进行抽象）、平台适配层（适配k8s、Mesos等多个平台，将平台特定的注册信息转换成平台无关的抽象模型）。</p>
<p>Pilot的流量控制功能包括服务发现和负载均衡、请求路由、超时重试、故障注入。</p>
<p>Mixer实现策略控制和监控日志收集等功能，理论上Envoy发起的每次请求都会发送到Mixer，可以异步发送。</p>
<p>Mixer的策略控制包括对服务的访问频率限制和访问控制。</p>
<p>Citadel用于保证服务之间的安全，需要Envoy的配合。Citadel中存储了秘钥和证书，通过Pilot将授权策略和安全命名信息分发给Envoy，Envoy和Envoy之间通过双向TLS证书来进行通讯，由Mixer来管理授权和审计。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="http://www.infoq.com/cn/articles/micro-service-technology-stack">微服务架构技术栈选型手册
</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode题目之Min Stack</title>
    <url>/post/min_stack/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>Memory Limit Exceeded</p>
</blockquote>
<blockquote>
<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
</blockquote>
<blockquote>
<p>push(x) – Push element x onto stack.<br>pop() – Removes the element on top of the stack.<br>top() – Get the top element.<br>getMin() – Retrieve the minimum element in the stack.</p>
</blockquote>
<h1 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h1><p>看到此题目，以为是用实现一个简单的栈结构，于是就直接写下了如下代码，采用了双向链表的方式来实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="type">int</span> data;</span><br><span class="line">		Node *next;</span><br><span class="line">		Node *pre;</span><br><span class="line">		Node() : next(<span class="literal">NULL</span>),pre(<span class="literal">NULL</span>) &#123;&#125;; </span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	MinStack()</span><br><span class="line">	&#123;</span><br><span class="line">		header = new Node();</span><br><span class="line">		tail = header;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        Node *node = new Node();</span><br><span class="line">		node-&gt;data = x;</span><br><span class="line">		node-&gt;pre = tail;</span><br><span class="line">		tail-&gt;next = node;</span><br><span class="line">		tail = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        Node *pre = tail-&gt;pre;</span><br><span class="line">		delete tail;</span><br><span class="line">		tail = pre;</span><br><span class="line">		tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (tail == header)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> tail-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">		Node *begin = header-&gt;next;</span><br><span class="line">		<span class="type">int</span> min = INT_MIN;</span><br><span class="line">        <span class="keyword">while</span>(begin)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (min &gt; begin-&gt;data)</span><br><span class="line">			&#123;</span><br><span class="line">				min = begin-&gt;data;</span><br><span class="line">			&#125;</span><br><span class="line">			begin = begin-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	Node *header;</span><br><span class="line">	Node *tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>提交后提示<code>Memory Limit Exceeded</code>错误，开始考虑是不是双向链表占用的空间过多。</p>
<h1 id="正确代码"><a href="#正确代码" class="headerlink" title="正确代码"></a>正确代码</h1><p>仔细看题目后发现<code>retrieving the minimum element in constant time</code>，即时间复杂度为O(1)，上述实现代码时间复杂度为O(n)，明显不符合要求。看来理解题目有误，不是为了实现栈类，而是为了利用数据结构解决获取最小值问题。</p>
<p>经过考虑后可以通过在类内部维护存储最小值的栈来解决，存储最小值的栈除了需要存储最小值外，还需要维护最小值个数。</p>
<p>实现代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">MinUnit</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="type">int</span> count;</span><br><span class="line">		<span class="type">int</span> value;</span><br><span class="line">		MinUnit(<span class="type">int</span> count, <span class="type">int</span> value) : count(count), value(value) &#123;&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        data_stack.push(x);</span><br><span class="line">		<span class="keyword">if</span> (min_stack.empty() || x &lt; min_stack.top()-&gt;value)</span><br><span class="line">		&#123;</span><br><span class="line">			MinUnit *p_unit = new MinUnit(<span class="number">1</span>, x);</span><br><span class="line">			min_stack.push(p_unit);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (x == min_stack.top()-&gt;value)</span><br><span class="line">		&#123;</span><br><span class="line">			min_stack.top()-&gt;count++;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data_stack.top() == min_stack.top()-&gt;value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (min_stack.top()-&gt;count == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				MinUnit *punit = min_stack.top();</span><br><span class="line">				min_stack.pop();</span><br><span class="line">				delete punit;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				min_stack.top()-&gt;count--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		data_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> data_stack.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> min_stack.top()-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="type">int</span>&gt; data_stack;</span><br><span class="line">	<span class="comment">// 最小栈，为了便于修改栈单元中的count值，采用存储指针方式</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;MinUnit*&gt; min_stack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《金字塔原理》总结</title>
    <url>/post/minto-pyramid/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/jinzita.jpeg"></p>
<p>《金字塔原理》是一本教你如何清晰的思考问题，表达观点的畅销书籍，但其并非万能的，其层层架构建立在因果关系基础之上。但现实世界中的很多问题并非简单的因果关系，此时金字塔原理就用不上了。</p>
<h1 id="什么是金字塔原理"><a href="#什么是金字塔原理" class="headerlink" title="什么是金字塔原理"></a>什么是金字塔原理</h1><p>定义：任何一件事情都可以归纳出一个中心论点，而这个中心论点由3到7个论据进行支撑。每一个论据它本身又可以拆分成一个论点，该论点同样也可以拆分成3到7个论据，如此重复形状就像金字塔一样。</p>
<p>三个注意点：</p>
<ul>
<li>结论先行</li>
<li>每层结论下面的论据不要超过7个</li>
<li>每一个论点要言之有物，有明确的思想</li>
</ul>
<h1 id="组织思想的方法"><a href="#组织思想的方法" class="headerlink" title="组织思想的方法"></a>组织思想的方法</h1><p>在有了论点之后，论据该怎么拆分呢？可以按照下面四个原则来组织思想：</p>
<ul>
<li>时间顺序</li>
<li>空间顺序</li>
<li>重要性顺序，比如按照老弱优先原则</li>
<li>逻辑演绎顺序。所以的逻辑演绎，就是三大段：大前提、小前提和结论。比如，凡人皆有一死，苏格拉底是人，所以苏格拉底也会死。但不推荐用此方法，因为对于听众的要求比较高，必须能够集中注意力才能听明白。</li>
</ul>
<p>在思考的过程中，如果还没有论点，也可以使用上述方法先得出论据，然后推理出论点。<br>梳理出的论据必须符合MECE法则：每一个论点下的论据，都应该相互独立，但又可以完全穷尽，即论据要做到不遗漏不重叠。</p>
<h1 id="如何让别人对自己的观点感兴趣"><a href="#如何让别人对自己的观点感兴趣" class="headerlink" title="如何让别人对自己的观点感兴趣"></a>如何让别人对自己的观点感兴趣</h1><p>SCQ法则：Situation（设置背景）、Complication（冲突）和Question（疑问）。背景即先介绍大家都认同的背景信息从而引入话题。在SCQ都讲完后，就可以引入自己的论点了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>得到 - 《金字塔原理》成甲解读</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>参加完姐姐的婚礼之后</title>
    <url>/post/my_cousin_wedding/</url>
    <content><![CDATA[<p>参加完姐姐的婚礼回到家后，静下心来之后内心莫名的感伤。也许是早晨三点醒四点起床导致身体在下午已经出现了疲惫。也许是生活本来就应该是平淡的，兴奋的多了，也自然疲惫的多，总之要保持一个符合每个人性格的平衡。也许是因为如女朋友同事的例子中一样，当丈夫娶妻过门的时候，丈夫的妹妹是哭的，因为妹妹有恋哥情节，难不成我也有恋姐情节的存在，还好我仅是有点伤感而已，不严重。也许是因为对时间流逝的无奈，总以为我们还没有长大，转眼间姐姐已经步入了婚姻的殿堂，成立了自己的新家庭，逝者如斯。趁着自己还有点文艺范的精神状态，写写这两天的一些感想，要不然明天一接触需要理性思考的计算机语言，这种感性点的状态又会归于平淡，又会在我鲜有的心路历程文章里少了一篇。</p>
<p>小的时候总是羡慕姐姐在城里的生活，每年在仅有的几次见面中总能感受到一个不一样的姐姐。那时的我对于城市的大小、城市的好坏还没有概念，仅仅知道城市要比农村好不少倍，仅仅知道姐姐是城里的，是城市小朋友的代言人，是引以为荣的小榜样。也许下面这张小时候的珍贵照片最能反应出城市孩子和农村孩子之间的区别。<br><img src="/ref/life/i_and_my_cousin_in_childhood.jpg" alt="Image Title"><br>记得大约上八年级寒假的时候见过姐姐写的字，字迹铿锵有力且独特，不是常见的楷体字，由特定的字体加上自己的独到之处柔和而成。分明是经过训练方能造就，我从未在我认识的同学中见过能够写出如此华丽的字体，即使有书法天赋的同学由于没有经过特定的练习，字体往往都是课本上常见的楷体字。因为从上高中起，我已经开始渐渐地融入曾经向往的城市生活，直到如今我也算半个城市人。我和姐姐之间的差距在不断的缩短。当然会发现原来城市生活也有城市生活的弊端，如果让我选择一次我还会选择在农村度过我的童年，那种各种玩各种贴近大自然的生活是在高楼间无法体会到的。</p>
<p>姐姐终于找到了可以寄托的归宿，姐夫是很优秀的。姐姐属于离不开爱情的类型，但身体却不是很好，也许是姐夫喊姐姐玉妹的缘由。期望在外来姐夫能够好好照顾姐姐，同时姐姐应该多注意身体，多吃粗粮。</p>
<p>一个我想象不到的地方是随着现在人民文化水平的提高，婚礼的举办方式正在朝着复杂化的方向发展。现在的婚礼已经将旧有的当地风俗和现代的风俗结合在了一起，而且这两者是叠加的关系，意味着风俗越来越多，需要处理的事情越来越复杂。其实婚礼的作用无非就是热闹、喜庆， 我实在是搞不太明白复杂和热闹之间是一个什么样的关系。我期望我婚礼是简单的，简单的不能再简单，我甚至期望不需要亲朋好友的过多参与，我甚至不期望举办复杂的婚礼仪式，热闹的背后是家人的操劳，是长达数月的准备。我只希望能有一次难忘的旅行，两个人的旅行就足够幸福。</p>
<p>祝福的含义我是不理解的，祝福原本是一个人向另外一个人的未来的美好祝愿，就是说些客套话，说些不切实际的话。其实一个人很难对另外一个人的外来向好的方面发展做出贡献，就如同大臣们天天喊着万岁万岁万万岁，却未见过哪个皇帝超过百岁一般。很多人都会向姐姐的婚礼说出祝福，但有多少是过后还记得自己曾经说过的。我在这里同样祝福姐姐和姐夫新婚快乐，生活幸福，和睦相处，恩恩爱爱，当然我是发自内心的，而且我的话是有文字可考究的。同样在给姐姐的红包里我写下了“原寻寻觅觅，现卿卿我我，年年岁岁情爱深，岁岁年年无不同”的祝福，这里同样做一个备忘。</p>
<p>目前的婚庆已经完全市场化，只要是服务项没有不收费的可能性，而且往死里要。没有信仰的民族是个可怕的民族，如果马克思主义不能所谓一种信仰，那么中国人中的绝大多数是没有信仰的。即使大家上初中、高中、大学、研究生阶段都在马克思的理论，在当前的国情下估计也没有多少人能视马克思如珍宝。如果在国外我估计会出现在教堂举办婚礼非常廉价，甚至免费的可能性，因为能够为新郎新娘主持婚礼本身就是一件非常荣幸的事情，金钱不是最重要的，当然我不了解海外的真实情况。总感觉一件本来可以免费的事情只要跟金钱沾边总会变味。</p>
<p>中国父母的典型形象是碎碎念，对于子女总会絮絮叨叨那么一箩筐。在不经意间，子女已经长大成人，可在父母的眼中子女永远是未长大的孩子。中国的父母在子女身上花费了太多的心血，以至于子女比自己更重要。</p>
<p>一个活动的缺点是非常容易被人察觉的，而活动的优点往往不容易被人发觉。因此，要想顺利完成一个活动是不容易的。举办婚礼的时候我发现有很多事先未准备妥当的地方，而这些恰恰是最容易被发现的，而做得特别好的地方却是较难被人们发现。</p>
<p>年龄之间的代沟还是比较明显的，这一点在酒桌上特别能够体现，在酒桌上话语最多的永远是上一辈人，因为年轻人跟上一辈人在思想上还是有较大的差距，这是好事。如果两代人之间差距过小，说明这个社会变化太慢。年轻人应该吸取上一代人的长处，去其槽粕，取其精华。我想未来的酒桌文化会大变样。</p>
<p>我目前的理想生活状态是平淡充实的，我喜欢静下心来学习，我喜欢那种学习的充实感，我喜欢跟同龄人人心贴心的交谈，而不是在噪杂的环境中大家泛泛而谈。我的性格中腼腆的一面表现在我在与人沟通时内心的想法总会羞于表达，比如很难从我的嘴里向父母说出生日快乐之类的话语，向姐姐当面说出新婚快乐，白头偕老。一方面想着跟人沟通，另一方面却羞与吐露自己的内心想法，貌似有点矛盾的样子。</p>
<p>人类本该是感性的，接触的外部环境多了之后会渐渐趋于理性，当然人类的科技进步需要理性。理性多了，自然感性就会少一些。这几年跟计算机打交道的时间成了生活、工作的最重要部分，我大部分生活状态处于理性状态，心情以平淡居多。包括我现在写这篇文章，也是在用理性的思维方式来写感性的文章，换成在高中时期写的文章却是用感性的思维方式来写感性的文章。</p>
<p>我的性格未曾被工作改变，甚至是相貌在工作三年的时间里也未曾有大的变动。我现在仍然看上去像个学生，路人也经常会将我当成一名学生。女朋友说这是我不成熟的表现，我不知道成熟如何去界定，我认为我每天学到的东西都在助我向成熟迈进，直到我老去的那一刻我也不可能成熟，因为只要我还有进步我就不会成熟。我对于三年来的未改变我引以为豪，至少我没有被这个残缺的社会给同化掉，至少我还拥有自己的思想，同时也证明了一点我在大学期间思想就已经在保持了一种相对稳定的状态。我不认为工作后在官场上混的如鱼得水，在酒桌上的机智多变是一种成熟的表现，我对此持悲观态度。</p>
<p>行行出状元。今天看到我姑在玩QQ农场、QQ牧场的游戏，熟练程度相当高。由于我姑空闲时间较多，常常一个人在家，已经玩了多年的游戏。我姑对电脑的使用还处在初级阶段，平常电脑的作用还定位在玩农场的阶段。只要做的次数多了，行行都可以出状元。</p>
<p>本来想着把自己参加完姐姐婚礼之后的感想记录下来，结果写着写着开始有些怀旧，写自己的居多，困的不知所云，到此为止。不知等我老去的那天当我读到此文章时会是一种什么样的心情，难不成还会跟现在一样有点压抑的感觉？</p>
]]></content>
  </entry>
  <entry>
    <title>我的个人数据备份方案</title>
    <url>/post/my_data_bak/</url>
    <content><![CDATA[<p>没有一成不坏的硬件，尤其是数据放到物理硬盘中，说不定哪天硬盘闹脾气就崩掉了，硬盘不值钱，可是里面的数据值钱。下面分享下我的数据备份方案，我的原则是数据无论何时都至少留有一个备份。</p>
<h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><p>我的博客是放到Dropbox中的，在云端和本地均有备份，确保了博客数据的绝对安全，即使云端坏掉还有本地，本地丢了还有云端。</p>
<h1 id="个人照片"><a href="#个人照片" class="headerlink" title="个人照片"></a>个人照片</h1><p>由于照片都较大，放到本地硬盘很容易占满空间，而且还不经常用。除了在自己电脑上留有照片之外，选择将照片压缩并加密后按照年份放到百度云上。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>工作几年了，已经积攒了一些代码，有些代码时不时的会查看到。对于可以公开的自己写的代码我以后打算放到我的Github上，一方面是由于Github上可以在线浏览代码，另一方面可以向别人分享我的代码。<br>对于私有的代码，暂时放到了金山快盘上，没有找到可以方便浏览代码的云端。</p>
<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>由于文档之类的资料也是经常用到，我选择了金山快盘。</p>
]]></content>
  </entry>
  <entry>
    <title>我的Makefile文件</title>
    <url>/post/my_makefile/</url>
    <content><![CDATA[<p>最近学习了《GNU Make项目管理》，改进了我之前一直在用的Makefile文件，解决我之前的Makefile中一直存在的修改依赖头文件后不能自动编译cpp文件的问题。本文列举了我常用的两个Makefile文件，其中第一个为我常用的Makefile，第二个为从网上找到的其他Makefile文件。</p>
<h1 id="第一个Makefile"><a href="#第一个Makefile" class="headerlink" title="第一个Makefile"></a>第一个Makefile</h1><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">INCLUDE = -I./</span><br><span class="line"></span><br><span class="line">FLAGS = -g -Wall <span class="variable">$(INCLUDE)</span></span><br><span class="line">FLAGS += -fPIC</span><br><span class="line"></span><br><span class="line">LIBDIR = -lz -lm -lcrypto</span><br><span class="line"></span><br><span class="line">LINK = <span class="variable">$(LIBDIR)</span> -lpthread</span><br><span class="line"></span><br><span class="line">GCC = g++</span><br><span class="line"></span><br><span class="line"><span class="comment"># for C++ language</span></span><br><span class="line">CODE.cpp = main.cpp \</span><br><span class="line">			trim.cpp</span><br><span class="line"></span><br><span class="line">CPP.o = $(CODE.cpp:.cpp=.o)</span><br><span class="line">OBJS.d = $(CODE.cpp:.cpp=.d)</span><br><span class="line"></span><br><span class="line">OBJS.o = $(CPP.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决头文件依赖</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(<span class="built_in">subst</span> .cpp,.d,$(CODE.cpp)</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">%.d: %.cpp</span></span><br><span class="line">	<span class="variable">$(GCC)</span> -M <span class="variable">$(FLAGS)</span> <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span>.$$$$;		\</span><br><span class="line">	sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.$$$$ &gt; <span class="variable">$@</span>;	\</span><br><span class="line">	rm -f <span class="variable">$@</span>.$$$$</span><br><span class="line"></span><br><span class="line"><span class="comment"># rule for C++ language</span></span><br><span class="line">%.o : %.cpp	</span><br><span class="line">	<span class="variable">$(GCC)</span> <span class="variable">$(FLAGS)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span>	</span><br><span class="line">	@echo <span class="variable">$*</span>.o build successfully!......</span><br><span class="line"></span><br><span class="line">TARGET = main</span><br><span class="line">	</span><br><span class="line"><span class="variable">$(TARGET)</span> : $(OBJS.o) </span><br><span class="line">	<span class="variable">$(GCC)</span> $(OBJS.o) -o <span class="variable">$(TARGET)</span> <span class="variable">$(LINK)</span></span><br><span class="line">	@echo <span class="variable">$(TARGET)</span> BUILD OK!.........</span><br><span class="line"></span><br><span class="line">all : <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(TARGET)</span></span><br><span class="line">	rm -rf $(OBJS.o)</span><br><span class="line">	rm -rf $(OBJS.d)</span><br><span class="line">	rm -rf *.d</span><br></pre></td></tr></table></figure>

<p>该文件特点为需要手工将需要编译的源文件手动添加到Makefile中，可能比较麻烦，但是编译时比较灵活。可以随意修改需要编译源文件的顺序和是否需要编译源文件。</p>
<h1 id="第二个Makefile"><a href="#第二个Makefile" class="headerlink" title="第二个Makefile"></a>第二个Makefile</h1><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># KEFILE FOR C/C++ PROJECT</span></span><br><span class="line"><span class="comment"># Author: swm8023 &lt;swm8023@gmail.com&gt;</span></span><br><span class="line"><span class="comment"># Date:   2014/01/30</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"><span class="section">all: </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># annotation when release version</span></span><br><span class="line">DEBUG       := y</span><br><span class="line">TARGET_PROG := main</span><br><span class="line"></span><br><span class="line"><span class="comment"># project directory	</span></span><br><span class="line">DEBUG_DIR   := ./Debug</span><br><span class="line">RELEASE_DIR := ./Release</span><br><span class="line">BIN_DIR     := <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(DEBUG)</span>, <span class="variable">$(DEBUG_DIR)</span>, <span class="variable">$(RELEASE_DIR)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell command</span></span><br><span class="line">CC    := gcc</span><br><span class="line">CXX   := g++</span><br><span class="line">RM    := rm -rf</span><br><span class="line">MKDIR := mkdir -p</span><br><span class="line">SED   := sed</span><br><span class="line">MV    := mv</span><br><span class="line"></span><br><span class="line"><span class="comment"># init sources &amp; objects &amp; depends</span></span><br><span class="line">sources_all := <span class="variable">$(<span class="built_in">shell</span> find . -name &quot;*.c&quot; -o -name &quot;*.cpp&quot; -o -name &quot;*.h&quot;)</span></span><br><span class="line">sources_c   := <span class="variable">$(<span class="built_in">filter</span> %.c, <span class="variable">$(sources_all)</span>)</span></span><br><span class="line">sources_cpp := <span class="variable">$(<span class="built_in">filter</span> %.cpp, <span class="variable">$(sources_all)</span>)</span></span><br><span class="line">sources_h   := <span class="variable">$(<span class="built_in">filter</span> %.h, <span class="variable">$(sources_all)</span>)</span></span><br><span class="line">objs        := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(BIN_DIR)</span>/,$(<span class="built_in">strip</span> $(sources_cpp:.cpp=.o)</span> $(sources_c:.c=.o)))</span><br><span class="line">deps        := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(BIN_DIR)</span>/,$(<span class="built_in">strip</span> $(sources_cpp:.cpp=.d)</span> $(sources_c:.c=.d)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># create directory</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> dirname,$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(sources_c)</span> <span class="variable">$(sources_cpp)</span>)</span>),\</span><br><span class="line">  <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(MKDIR)</span> <span class="variable">$(BIN_DIR)</span>/<span class="variable">$(dirname)</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># complie &amp; link variable</span></span><br><span class="line">CFLAGS     := <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(DEBUG)</span>,-g -O, -O2)</span></span><br><span class="line">CFLAGS     += <span class="variable">$(<span class="built_in">addprefix</span> -I ,$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(sources_h)</span>)</span>))</span><br><span class="line">CXXFLAGS    = <span class="variable">$(CFLAGS)</span></span><br><span class="line">LDFLAGS    := </span><br><span class="line">LOADLIBES  += <span class="comment">#-L/usr/include/mysql</span></span><br><span class="line">LDLIBS     += <span class="comment">#-lpthread -lmysqlclient</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add vpath</span></span><br><span class="line"><span class="keyword">vpath</span> %.h <span class="variable">$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(sources_h)</span>)</span>)</span><br><span class="line"><span class="keyword">vpath</span> %.c <span class="variable">$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(sources_c)</span>)</span>)</span><br><span class="line"><span class="keyword">vpath</span> %.cpp <span class="variable">$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(sources_cpp)</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate depend files</span></span><br><span class="line"><span class="comment"># actually generate after object generated, beacasue it only used when next make)</span></span><br><span class="line"><span class="keyword">ifneq</span> <span class="string">&quot;<span class="variable">$(MAKECMDGOALS)</span>&quot;</span> <span class="string">&quot;clean&quot;</span></span><br><span class="line"><span class="keyword">sinclude</span> <span class="variable">$(deps)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make-depend(depend-file,source-file,object-file,cc)</span></span><br><span class="line"><span class="keyword">define</span> make-depend</span><br><span class="line">  <span class="variable">$(RM)</span> $1;                                     \</span><br><span class="line">  $4 <span class="variable">$(CFLAGS)</span> -MM $2 |                         \</span><br><span class="line">  <span class="variable">$(SED)</span> &#x27;s,\(<span class="variable">$(<span class="built_in">notdir</span> $3)</span>\): ,$3: ,&#x27; &gt; $1.tmp; \</span><br><span class="line">  <span class="variable">$(SED)</span> -e &#x27;s/<span class="comment">#.*//&#x27;                           \</span></span><br><span class="line">         -e &#x27;s/^[^:]*: *//&#x27;                     \</span><br><span class="line">         -e &#x27;s/ *\\$$//&#x27;                        \</span><br><span class="line">         -e &#x27;/^$$/ d&#x27;                           \</span><br><span class="line">         -e &#x27;s/$$/ :/&#x27; &lt; $1.tmp &gt;&gt; $1.tmp;      \</span><br><span class="line">  <span class="variable">$(MV)</span> $1.tmp $1;</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rules to generate objects file</span></span><br><span class="line"><span class="variable">$(BIN_DIR)</span>/%.o: %.c</span><br><span class="line">	@<span class="variable">$(<span class="built_in">call</span> make-depend,$(<span class="built_in">patsubst</span> %.o,%.d,<span class="variable">$@</span>)</span>,<span class="variable">$&lt;</span>,<span class="variable">$@</span>,<span class="variable">$(CC)</span>)</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BIN_DIR)</span>/%.o: %.cpp</span><br><span class="line">	@<span class="variable">$(<span class="built_in">call</span> make-depend,$(<span class="built_in">patsubst</span> %.o,%.d,<span class="variable">$@</span>)</span>,<span class="variable">$&lt;</span>,<span class="variable">$@</span>,<span class="variable">$(CXX)</span>)</span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add-target(target,objs,cc)</span></span><br><span class="line"><span class="keyword">define</span> add-target</span><br><span class="line">  REAL_TARGET += <span class="variable">$(BIN_DIR)</span>/$1</span><br><span class="line">  <span class="variable">$(BIN_DIR)</span>/$1: $2</span><br><span class="line">	$3 <span class="variable">$(LDFLAGS)</span> $<span class="variable">$^</span> <span class="variable">$(LOADLIBES)</span> <span class="variable">$(LDLIBS)</span> -o $<span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># call add-target</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> targ,<span class="variable">$(TARGET_PROG)</span>,$(<span class="built_in">eval</span> $(<span class="built_in">call</span> add-target,<span class="variable">$(targ)</span>,<span class="variable">$(objs)</span>,<span class="variable">$(CXX)</span>)</span>))</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(REAL_TARGET)</span> <span class="variable">$(TARGET_LIBS)</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(BIN_DIR)</span></span><br></pre></td></tr></table></figure>

<p>该Makefile为从<a href="http://c4fun.cn/blog/2014/01/30/common-makefile/">一个通用的C&#x2F;C++ Makefile</a>中直接获得的，为了避免原博客以后不能访问的情况，这里备份一下。</p>
<p>该Makefile可以动检测Makefile所在目录及其子目录中的.c和.cpp文件，并进行编译，不需要手动修改Makefile来填写需要编译的源文件，比较自动化。</p>
<h1 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h1><p>第二个Makefile文件的作者博客中的两篇文章：<a href="http://c4fun.cn/blog/2014/01/13/gnu-make-study01/">GNU Make学习总结（一）</a>和<a href="http://c4fun.cn/blog/2014/01/13/gnu-make-study02/">GNU Make学习总结（二）</a></p>
<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a href="http://pan.baidu.com/s/1jGDo5ls">一个包含上述两个Makefile的例子</a></p>
]]></content>
  </entry>
  <entry>
    <title>我目前的理想工作状态</title>
    <url>/post/my_perfect_work/</url>
    <content><![CDATA[<p>在外地出差，趁着午休时间躺在机房走廊的地板上想小憩一会却怎么也进入不了状态。突然写着可以写写我心中目前的理想工作状态。随着年龄、阅历和知识水平的增长，每个人心中理想的工作状态也会在变。我现在的理想工作状态跟我刚毕业时肯定是有区别的，刚毕业那会初入茅庐，对公司的很多事情还是懵懂，自然期望找个高手带一带。</p>
<hr>
<p>我期望加入一家技术为王的公司。</p>
<p>技术才是科技公司真正的核心竞争力，而非销售和公关能力。从硅谷中做大做强的公司哪个不是以技术作为领先竞争对手的筹码，十几年前的google的崛起、雅虎的衰落，近几年Github的火爆无不是技术因素在其决定作用。在中国软件行业还未发展成熟，觉大多数企业仍然在以销售为核心盈利方式的畸形发展方式中，但技术为王绝对是个趋势，这个不是靠关系靠政策可以改变的事实，这个是大势所趋、历史必然。</p>
<p>我不奢望技术为王的公司中牛人辈出但是期望能多几个牛人就多几个牛人，至少不期望在公司中见到一看就没有做技术潜质的同事（一个人适不适合做技术有时候是可以看出来的）。</p>
<hr>
<p>我期望加入一家互联网行业的公司。</p>
<p>软件行业按照产品类型大致可以分三类：外包、卖产品和做平台。</p>
<p>外包公司完全以订单为导向，往往涉及到复杂的业务逻辑，技术含量低，自然不在我的考虑范围内。</p>
<p>我之前从事的公司都是在卖产品的公司，往往卖产品的公司需要有一定的技术含量，但是技术不能决定公司发展，这一类公司是以销售为导向的公司，一套产品往往可以卖上多年，甚至十几年也不奇怪。</p>
<p>做平台的公司往往不需要过多的销售，大多数是以用户量为王的，而要想拉拢用户到平台上往往需要靠技术或销售取胜，而技术因素相对更加关键。以Dota对战平台为例，前几年比较火爆的是浩方和VS，现在成了11对战平台的天下了。11对战平台后来者居上就是因为11对战平台率先推出了天梯模式和路人模式，从而落下了竞争对手一大截。互联网行业属于第三类，而济南几乎找不到这类公司。就算有一些这样的公司，往往也是以销售为导向的公司。韩都衣舍也有自己的网站，但是流量应该没有淘宝大，估计网站技术上的投入也一般般。银座集团在电商火爆了后也搞了个网上商城，单从界面看可跟苏宁拉在同一个档次，但效果如何影响怎么样可想而知，估计技术都是外包的，仅是领导拍拍脑袋的产物。我实在想不到在济南有什么互联网公司了，如果你知道请告诉我。</p>
<hr>
<p>我期望加入一家创业型的公司。</p>
<p>我现在还不具备单独创业的实力，但我一直梦想能够加入一家有梦想有激情的创业公司。加入创业公司就意味着不会清闲，我只期望每天能够过的充实并快乐着。《黑客与画家》中提到快速致富的手段就是加入一家创业公司，在美国如此，在中国亦如此。</p>
<hr>
<p>总结一下，我想加入一家技术为王的互联网行业的创业公司。如果你知道在济南有哪家公司可以满足我的要求，请告诉我，谢谢！</p>
]]></content>
  </entry>
  <entry>
    <title>『狗』的故事</title>
    <url>/post/mydog/</url>
    <content><![CDATA[<p>本文讲述的是我家狗的普通一生，我家的狗即没有名贵的种族，也没有喜人的外貌，就是农村家中最常见的看家狗。</p>
<p><img src="http://kuring.qiniudn.com/gougou2.JPG" alt="image"></p>
<p>狗的一生中连个正儿八经的名字都没有，父母平日里呼唤狗都是我们那方言中通用的『嗷（一声）嗷(三声)嗷（一声）』（我们那方言对家里的牲口都有一种特殊的呼唤方式），而我通常会通过舌头跟上颚发出的声音来呼唤。以至于在写本文时，我不知道该如何称呼了，只能约定俗成为『狗』。</p>
<p>『狗』在家中的作用为看家护院的作用，在村中养狗的目的大抵如此，狗的作用也仅仅是传统意义上的一条狗。村民们还没有清闲到靠养狗来娱乐的地步，何况邻里邻外的都认识，随便找个人都能聊上个把小时，靠拉呱聊天来娱乐比遛狗更丰富直接。</p>
<p>自打我记事起，家里共养过三只狗，第一只养了至少五年的样子，最终已经记不清楚为何而失去了，或是因为出去走丢了，亦或是因为误食了东西而死去。第三只狗是只有种族的狗，仅仅是中间的过客，确实家人的最爱，有个优雅的名字『点点』，仅此一点就能将此『狗』秒杀N条街，事实也是如此。</p>
<p>家中也养过一些其他的动物，猪、猫、鸡等。猪等到长肥了也就卖掉了，也就四五个月的样子。小时候家里养过母猪，估计也得有个五年以上，但母猪除了吃和睡之外，似乎也没啥了。猫养过多只，确实跟有些猫是有感情的，但大都比较短暂，猫经常跑出去就回不来了。有些鸡在家里也养过四五年，但鸡给我留下的印象中除了吃和下蛋之外，就剩下美味的鸡汤了。唯独『狗』在家中的时间最长，在家中的地位也最高，给家里的贡献也是最大的，给我留下的印象也是颇为深刻。</p>
<p>『狗』大概是我在刚上初中那会，父亲从集市上花了15或者30元钱抑或60元买的。刚买来的时候记得还不满月的样子，特别的可爱，白灰色毛居多，背上有个大大的灰黑色大圆点，不正不斜圆心就在脊梁骨的位置，而且圆是非常的标准的圆，头和尾巴是黄色的毛。由于小，不会造成什么破坏，就直接放在屋子总天天跑，我们吃饭时，它就在下面转啊转，等待着给点馒头或者菜来吃，一见到有东西吃，那尾巴就摇啊摇，摇啊摇。有时候在屋子里碍事了，我就用手揪住它背上的肉皮，扔到一边去，不一会又会回来，然后又让我给揪到一边去，这样揪来揪去的好好玩，听大人们说，这样狗是不疼的。</p>
<p>揪着揪着『狗』就这样被我揪大了，大了之后自然要发挥指责了，总不能天天让家里白白养着，凡事必然有其存在价值，它的价值就是看家护院。这样一干可就是一辈子，它的一辈子就在家里不大的院子里面绕着铁链转，转啊转，直到再也没有力气转下去。自从被拴上铁链的时刻开始，直到生命的最后一刻，再也没有进过曾经在饭桌底下绕啊绕找食物的屋子，饭桌下再也容不下它。</p>
<p>『狗』的看家还是非常尽职尽责，当然了，要不怎么是狗呢。只要是家里来的是陌生人，都会咬个不停，甚至是我爷爷来我家，都会咬个不停。要是觉得听起来太吵了，只要对它喊一声「狗」就会消停很多，跟家人的默契配合的相当不错。</p>
<p>『狗』的记性也是相当不错的，记得上高中时，一个月只能回一次家，每次回家狗都会认识，从来不会当成陌生人狂咬。后来，上了大学，成了半年回一次家了，刚进家门狗就开始叫，也就是脚踏进院子没多久，狗就不叫了，已经认出我也曾经是这里的主人。每次回家都会跟『狗』玩上半天，喂点吃的，挠挠肚子，看着它围着我转。</p>
<p>虽然对陌生人总是咬个不停，但是当人走到旁边时却不会上去咬人，对它凶点甚至还会吓得跑到狗窝里去，完全不是疯狗那样会咬人。但也确实咬过一次人，记得那是上高一那会，姨夫在我家喝多了，走到它旁边，它还在不停的咬，姨夫由于喝的多，对其踹了几脚，抑或身上酒味过重，这下『狗』可不干了，照着姨夫的脚脖子就咬了一口。这是已知的仅有的一次咬人经历。</p>
<p>『狗』是母狗，大概一岁多的时候生过三只狗，其中两只已经夭折了，另外一只目前在我爷爷家里养着。家里来陌生人时，狗都会从狗窝猛然间钻出来，仿佛早发现一会陌生人就能领到奖赏一般。两只小狗的死都是它猛然间出来时将正在吃奶的小狗用铁链给带出来摔死的，挺可怜的。不知是不是脑子缺根筋，看家的本领远比看护自己孩子来的高超，就好比在休产假的妈妈，却天天想着工作，自此之后再也没生过小狗。</p>
<p>『狗』的一声是用铁链禁锢的一生，成年后99%的时光都是用铁链拴着的，比互联网公司的服务可靠性都好的多。偶尔铁链会松掉，它仍然不知道自己的地盘之外仍然可以活动，直到偶然间走出了自己的活动范围，才发现原来自己的地盘外也可以肆意走动了，不过美好的时光不会太长，因为等着家人发现了，禁锢的铁链又跑到自己的脖子里了。有时家人发现的不及时，发现它又回到了原地了，也许它发现原来曾经向往的陌生地方也不过如此，远没有自己的地盘来的安全可靠和温馨。</p>
<p><img src="http://kuring.qiniudn.com/gougou1.JPG" alt="image"></p>
<p>记得有一次冬天大雾，能见度非常低，『狗』跑出了家门，一路向北，由于雾太大，迷失了方向。我跑出去在家附近找了半个小时未果，爷爷骑着自行车出去打听到别人看见过，父亲终于在离家二里地外的地方找到了，也是虚惊一场。</p>
<p>『狗』对吃得从来不挑，只要有吃的就行。记得之前家里还喂猪的时候，它就在旁边等着猪们吃完后再去吃猪剩下的，每次都会把猪槽舔的溜滑，比可以刷过的还干净。后来家里不喂猪了，就在喂鸡的时候一块喂一下。夏天吃完西瓜后，把西瓜皮扔过去，狗也可以啃得仅剩下一层薄薄的皮。偶尔忘记喂了，『狗』就会zhengzheng的叫，家人自然也能领悟『狗』的意图。</p>
<p>大约刚开始工作那会，姑家的狗『点点』由于没时间照顾在我家里养了半年，『点点』是姐姐给取的名字，长得一副小巧可爱样，在城市的笼子中靠吃狗粮长大。在我们那喂狗几乎是不用狗粮的，估计也买不到，因为没市场。『点点』自然是不能跟『狗』吃一样的，每天都会味一些狗粮，后来家人就买了些过期的方便面和馒头搀和着来喂，而『狗』的主食依旧是吃着跟鸡一样的凉水活玉米面。『点点』白天都在笼子里，只有放出来的时候才会找个地方拉屎撒尿，自然比随地大小便的『狗』更讨人喜欢。晚上『点点』是放在院子里的，院子里的任何角落都是『点点』的活动范围，这点也是『狗』可望不可及的。白天『点点』的笼子是放在大门下的，逢人从门口经过都能看到可人的样子，自然也会吸引很多人的目光。</p>
<p><img src="http://kuring.qiniudn.com/goudiandian.jpg" alt="image"></p>
<p>也就是从『点点』刚来我家的时候，发现有时候从它身旁经过，它都没有任何反应了，因为『狗』的耳朵不好用了。人老了耳朵会聋，狗亦如此。有时候陌生人都进到家里了，发现『狗』仍然在狗窝里或外面太阳下睡觉，即使耳朵是贴在地面上的。狗天生骄傲的就是耳朵，试想一名工程师如果不能用双手敲代码，那怎么称之为码农。</p>
<p>自从『狗』聋了后，明显感觉到『狗』的情绪变得低沉了，也许是因为耳朵不好用了，也许是进入晚年了，也许是因为『点点』的缘故，虽贵为正室，却不再受宠幸。直到半年后的『点点』走后，也一直没有缓过来。</p>
<p>近几年，我每次回家都能感受到『狗』是一年不如一年，最后一次见到是在2015年的十一，那时它很多时候都是趴在窝里睡觉的，除了看家，也没啥本事，既然看家技能已失，那就只能睡觉了。</p>
<p>2016.1.22傍晚听到了『狗』去世的消息，脑海中自然也是联想关于『狗』的往事，历历在目，眼角泪花直流。没有任何仪式，『狗』悄悄的离开了奉献了自己一生的岗位，摆脱了束缚了自己一辈子的锁链，黯然离开了自己的主人。</p>
<p>当天天气极度寒冷，应该是一年中最冷的天气了，家中下起了大雪，也许是老天送给『狗』的葬礼，雪花仿佛跟『狗』的灵魂一般纯洁。</p>
<p>算下来从2000年左右到现在该有16岁的样子了，这16年是我人生中最年轻的时光，我从懵懂的少年已变成了社会中的青年，却是『狗』的一生。</p>
<p>下图是2016.1.22上午时的照片，已经生命垂危，生命在倒计时。</p>
<p><img src="http://kuring.qiniudn.com/gougou3.jpg" alt="image"></p>
<hr>
<p>一个月前，父亲又弄了条小狗，凑巧的是，小狗的模样跟『狗』长的颇为相似，毛色也一致，甚至连背上也有一个灰黑色的圆点。虽没当面见过，但看小狗的照片不禁联想到『狗』的小时候仿佛是狗的小时候，这也许是『狗』的生命的延续。</p>
<p><img src="http://kuring.qiniudn.com/gouxiaogou.jpg" alt="image"></p>
]]></content>
  </entry>
  <entry>
    <title>TCP协议中的Nagle算法</title>
    <url>/post/nagle/</url>
    <content><![CDATA[<p>Nagle算法为了避免网络中存在太多的小数据包，尽可能发送大的数据包。定义为在任意时刻，最多只有一个未被确认的小段。小段为小于MSS尺寸的数据块，未被确认是指数据发出去后未收到对端的ack。</p>
<p>Nagle算法是在网速较慢的时代的产物，目前的网络环境已经不太需要该机制，该算法在linux系统中默认关闭。</p>
<p>延时ACK机制: 在接收到对端的报文后，并不会立即发送ack，而是等待一段时间发送ack，以便将ack和要发送的数据一块发送。当然ack不能无限延长，否则对端会认为包超时而造成报文重传。linux采用动态调节算法来确定延时的时间。</p>
<p>可以举例来描述一下，client连续向server端发送两个小于MSS的数据包。client发送第一个数据包，根据Nagle算法，此时没有未确认的数据段，该数据包可以直接发送。server端接收到数据包后，由于延时ACK机制，并不会立即发送ack，而是需要等到延时ack机制超时后再发送第二个数据包。此时client端由于Nagle算法， 存在一个未被确认的数据包，不能向server端发送第二个数据包。</p>
<p>在延时要求尽量小的情况下，并不适合用Nagle算法，比如SSH会话。可以通过设置<code>TCP_NODELAY</code>来完成。</p>
]]></content>
  </entry>
  <entry>
    <title>docker基础知识之mount namespace</title>
    <url>/post/namespace_mount/</url>
    <content><![CDATA[<p>在使用CLONE_NEWNS来创建新的mount namespace时，子进程会共享父进程的文件系统，如果子进程执行了新的mount操作，仅会影响到子进程自身，不会对父进程造成影响。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小1M */</span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    &quot;/bin/bash&quot;,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int container_main(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Container [%5d] - inside the container!\n&quot;, getpid());</span><br><span class="line">    sethostname(&quot;container&quot;,10);</span><br><span class="line">    /* 重新mount proc文件系统到 /proc下 */</span><br><span class="line">    system(&quot;mount -t proc proc /proc&quot;);</span><br><span class="line">    execv(container_args[0], container_args);</span><br><span class="line">    printf(&quot;Something&#x27;s wrong!\n&quot;);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Parent - start a container!\n&quot;);</span><br><span class="line">    int container_pid = clone(container_main, container_stack+STACK_SIZE,</span><br><span class="line">            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL); /*启用CLONE_NEWUTS Namespace隔离 */</span><br><span class="line">    waitpid(container_pid, NULL, 0);</span><br><span class="line">    printf(&quot;Parent - container stopped!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@centos7 docker_learn]# ./mount</span><br><span class="line">Parent - start a container!</span><br><span class="line">Container [    1] - inside the container!</span><br><span class="line"></span><br><span class="line"># 由于ps是读取的/proc目录下的文件来显示当前系统系统的进程，新进程挂载/proc目录到新的proc文件系统，自然看不到父进程的/proc目录了</span><br><span class="line">[root@container docker_learn]# ps -ef</span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 22:20 pts/3    00:00:00 /bin/bash</span><br><span class="line">root         30      1  0 22:20 pts/3    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>

<p>但是在容器技术中，在容器中不应该看到宿主机上挂载的目录。在Linux中使用chroot技术来实现，在容器中将<code>/</code>挂载到指定目录，这样在容器中就看不到宿主机上的其他挂载项。在容器技术中，chroot所使用的目录即容器镜像的目录。容器镜像中并不包含操作系统的内核。</p>
<p>mount namespace是Linux中第一个namespace，是基于chroot技术改良而来。</p>
<h2 id="Docker-Volume"><a href="#Docker-Volume" class="headerlink" title="Docker Volume"></a>Docker Volume</h2><p>为了解决容器中能够访问宿主机上文件的问题，docker引入了Volume机制，将宿主机上指定的文件或者目录挂载到容器中。而整个的docker Volume机制跟mount namespace的关系不太大。</p>
<p>Volume用到的技术为Linux的绑定挂载机制，该机制将一个指定的目录或者文件挂载到一个指定的目录上。</p>
<p>容器启动顺序如下：</p>
<ol>
<li>创建新的mount namespace</li>
<li>dockerinit根据容器镜像准备好rootfs</li>
<li>dockerinit使用绑定挂载机制将一个指定的目录挂载到rootfs的某个目录上</li>
<li>dockerinit调用chroot</li>
</ol>
<p>容器启动时需要创建新的mount namespace，根据容器镜像准备好rootfs，调用chroot。docker volume的挂载时机是在rootfs准备好之后，调用chroot之前完成。</p>
<p>上文提到进入新的mount namespace后，mount namespace会继承父mount namespace的挂载, docker volume一定是在新的mount namespce中执行，否则会影响到宿主机上的mount。在调用chroot之后已经看不到宿主机上的文件系统，无法进行挂载。</p>
<p>执行这一操作的进程为docker的容器进程dockerinit，该进程会负责完成根目录的准备、挂载设备和目录、配置hostname等一系列需要在容器内进行的初始化操作。在初始化完成后，会调用execv()系统调用，用容器中的ENTRYPOINT进程取代，成为容器中的1号进程。</p>
<p>volume挂载的目录是挂载在读写层，由于使用了mount namespace，在宿主机上看不到挂载目录的信息，因此docker commit操作不会将挂载的目录提交。</p>
<p>下面使用例子来演示docker volume的用法</p>
<p>在宿主机上使用<code>docker run -d -v /test ubuntu sleep 10000</code>创建新的容器，并创建docker容器中的挂载点&#x2F;test，该命令会自动在容器中创建目录，并将宿主机上指定目录下的随机目录挂载到容器中的&#x2F;test目录下。</p>
<p>可在宿主机上通过如下命令查看到volume的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列出当前docker在使用的所有volume</span><br><span class="line">[root@localhost vagrant]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               4ad97e6356707b66cd1cacc4a2e223d9c79d11eca26fe12b1becc9dd664fc5c6</span><br><span class="line"></span><br><span class="line"># 查看volume在宿主机上的挂载点</span><br><span class="line">[root@localhost vagrant]# docker volume inspect 4ad97e6356707b66cd1cacc4a2e223d9c79d11eca26fe12b1becc9dd664fc5c6</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2018-09-15T23:36:09+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/4ad97e6356707b66cd1cacc4a2e223d9c79d11eca26fe12b1becc9dd664fc5c6/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;4ad97e6356707b66cd1cacc4a2e223d9c79d11eca26fe12b1becc9dd664fc5c6&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="docker文件系统"><a href="#docker文件系统" class="headerlink" title="docker文件系统"></a>docker文件系统</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/images/docker_fs.png"></p>
<p>rootfs在最下层为docker镜像的只读层。</p>
<p>rootfs之上为dockerinit进程自己添加的init层，用来存放dockerinit添加或者修改的&#x2F;etc&#x2F;hostname等文件。</p>
<p>rootfs的最上层为可读写层，以Copy-On-Write的方式存放任何对只读层的修改，容器声明的volume挂载点也出现这一层。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>极客时间-深入剖析Kubernetes-08</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础知识之network namespace</title>
    <url>/post/namespace_network/</url>
    <content><![CDATA[<p>network namespace用来隔离Linux系统的网络设备、ip地址、端口号、路由表、防火墙等网络资源。用户可以随意将虚拟网络设备分配到自定义的networknamespace里，而连接真实硬件的物理设备则只能放在系统的根networknamesapce中。</p>
<p>一个物理的网络设备最多存在于一个network namespace，可以通过创建veth pair在不同的network namespace之间创建通道，来达到通讯的目的。</p>
<p>容器的bridge模式的实现思路为创建一个veth pair，一端放置在新的namespace，通常命名为eth0，另外一端放在原先的namespace中连接物理网络设备，以此实现网络通信。</p>
<p>docker daemon负责在宿主机上创建veth pair，把一端绑定到docker0网桥，另一端到新建的network namespace进程中。建立的过程中，docker daemon和dockerinit通过pipe进行通讯。</p>
<h2 id="一、测试例子"><a href="#一、测试例子" class="headerlink" title="一、测试例子"></a>一、测试例子</h2><p>测试network namespace的过程比较复杂。</p>
<p>docker默认采用的为bridge模式，在容器所在的宿主机上看到的网卡情况如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost software]# ip link show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:6c:3e:95 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:a5:78:ca brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link/ether 02:42:a3:75:00:16 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">18: veth71f2650@if17: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default</span><br><span class="line">    link/ether ca:05:f7:db:6f:4c brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure>

<p>其中的enp0s3和enp0s8可以忽略，为虚拟机使用的网卡。docker0和veth71f2650@if17是需要关注的网卡。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost software]# brctl show</span><br><span class="line">bridge name	bridge id		STP enabled	interfaces</span><br><span class="line">docker0		8000.0242a3750016	no		veth71f2650</span><br></pre></td></tr></table></figure>

<p>下面的操作为在已经运行docker的虚拟机上的，以便于跟docker进行比较。</p>
<p>以下命令根据coolshell中的步骤进行配置，并对执行命令的顺序进行了调整。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 增加network namespace ns1</span><br><span class="line">[root@localhost software]# ip netns add ns1</span><br><span class="line">[root@localhost software]# ip netns</span><br><span class="line">ns1</span><br><span class="line"></span><br><span class="line"># 激活namespace ns1中的lo设备</span><br><span class="line">[root@localhost software]# ip netns exec ns1   ip link set dev lo up</span><br><span class="line"></span><br><span class="line"># 创建veth pair</span><br><span class="line">[root@localhost software]# ip link add veth-ns1 type veth peer name lxcbr0.1</span><br><span class="line"># 多出了lxcbr0.1@veth-ns1和veth-ns1@lxcbr0.1两个设备</span><br><span class="line"># 后面的操作步骤中将lxcbr0.1位于主网络命名空间中，veth-ns1位于ns1命名空间中</span><br><span class="line">[root@localhost software]# ip link</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:6c:3e:95 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:a5:78:ca brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link/ether 02:42:a3:75:00:16 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">18: veth71f2650@if17: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default</span><br><span class="line">    link/ether ca:05:f7:db:6f:4c brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">19: lxcbr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether c6:b7:4d:7f:f8:90 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">20: lxcbr0.1@veth-ns1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether c6:8a:26:3d:ba:de brd ff:ff:ff:ff:ff:ff</span><br><span class="line">21: veth-ns1@lxcbr0.1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether f2:03:22:93:d6:f4 brd ff:ff:ff:ff:ff:ff</span><br><span class="line"></span><br><span class="line"># 将设备veth-ns1放入到ns1命名空间中</span><br><span class="line">[root@localhost software]# ip link set veth-ns1 netns ns1</span><br><span class="line"># 可以看到veth-ns1设备在当前命名空间消失了</span><br><span class="line">[root@localhost software]# ip link</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:6c:3e:95 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">3: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:a5:78:ca brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link/ether 02:42:a3:75:00:16 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">18: veth71f2650@if17: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default</span><br><span class="line">    link/ether ca:05:f7:db:6f:4c brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">19: lxcbr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether c6:b7:4d:7f:f8:90 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">20: lxcbr0.1@if21: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether c6:8a:26:3d:ba:de brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line"># 同时在命名空间ns1中看到了设备veth-ns1，同时可以看到veth-ns1设备的状态为DOWN</span><br><span class="line">[root@localhost software]# ip netns exec ns1  ip link</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">21: veth-ns1@if20: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether f2:03:22:93:d6:f4 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line"></span><br><span class="line"># 将ns1中的veth-ns1设备更名为eth0</span><br><span class="line">[root@localhost software]# ip netns exec ns1  ip link set dev veth-ns1 name eth0</span><br><span class="line">[root@localhost software]# ip netns exec ns1  ip link</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">21: eth0@if20: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether f2:03:22:93:d6:f4 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line"></span><br><span class="line"># 为容器中的网卡分配一个IP地址，并激活它</span><br><span class="line">[root@localhost software]# ip netns exec ns1 ifconfig eth0 192.168.10.11/24 up</span><br><span class="line"># 可以看到eth0网卡上有ip地址</span><br><span class="line">[root@localhost software]# ip netns exec ns1  ifconfig</span><br><span class="line">eth0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.10.11  netmask 255.255.255.0  broadcast 192.168.10.255</span><br><span class="line">        ether f2:03:22:93:d6:f4  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line"># 添加一个网桥lxcbr0，类似于docker中的docker0</span><br><span class="line">[root@localhost software]# brctl addbr lxcbr0</span><br><span class="line">[root@localhost software]# brctl show</span><br><span class="line">bridge name	bridge id		STP enabled	interfaces</span><br><span class="line">docker0		8000.0242a3750016	no		veth71f2650</span><br><span class="line">lxcbr0		8000.000000000000	no</span><br><span class="line"></span><br><span class="line"># 关闭生成树协议，默认该协议为关闭状态</span><br><span class="line">[root@localhost software]# brctl stp lxcbr0 off</span><br><span class="line">[root@localhost software]# brctl show</span><br><span class="line">bridge name	bridge id		STP enabled	interfaces</span><br><span class="line">docker0		8000.0242a3750016	no		veth71f2650</span><br><span class="line">lxcbr0		8000.000000000000	no</span><br><span class="line"></span><br><span class="line"># 为网桥配置ip地址</span><br><span class="line">ifconfig lxcbr0 192.168.10.1/24 up</span><br><span class="line">[root@localhost software]# ifconfig lxcbr0</span><br><span class="line">lxcbr0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.10.1  netmask 255.255.255.0  broadcast 192.168.10.255</span><br><span class="line">        inet6 fe80::c4b7:4dff:fe7f:f890  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether c6:b7:4d:7f:f8:90  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 8  bytes 648 (648.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line"># 将veth设备中的其中一个lxcbr0.1添加到网桥lxcbr0上</span><br><span class="line">[root@localhost software]# brctl addif lxcbr0 lxcbr0.1</span><br><span class="line"># 可以看到网桥lxcbr0中已经包含了设备lxcbr0.1</span><br><span class="line">[root@localhost software]# brctl show</span><br><span class="line">bridge name	bridge id		STP enabled	interfaces</span><br><span class="line">docker0		8000.0242a3750016	no		veth71f2650</span><br><span class="line">lxcbr0		8000.c68a263dbade	no		lxcbr0.1</span><br><span class="line"></span><br><span class="line"># 为网络空间ns1增加默认路由规则，出口为网桥ip地址</span><br><span class="line">[root@localhost software]# ip netns exec ns1     ip route add default via 192.168.10.1</span><br><span class="line">[root@localhost software]# ip netns exec ns1 ip route</span><br><span class="line">default via 192.168.10.1 dev eth0</span><br><span class="line">192.168.10.0/24 dev eth0 proto kernel scope link src 192.168.10.11</span><br><span class="line"></span><br><span class="line"># 为ns1增加resolv.conf</span><br><span class="line">[root@localhost software]# mkdir -p /etc/netns/ns1</span><br><span class="line">[root@localhost software]# echo &quot;nameserver 8.8.8.8&quot; &gt; /etc/netns/ns1/resolv.conf</span><br></pre></td></tr></table></figure>

<h2 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h2><h3 id="1-列出当前的network-namespace"><a href="#1-列出当前的network-namespace" class="headerlink" title="1. 列出当前的network namespace"></a>1. 列出当前的network namespace</h3><h4 id="1-1-使用lsns命令"><a href="#1-1-使用lsns命令" class="headerlink" title="1.1 使用lsns命令"></a>1.1 使用<code>lsns</code>命令</h4><p>lsns命令通过读取&#x2F;proc&#x2F;${pid}&#x2F;ns目录下进程所属的命名空间来实现，如果是通过<code>ip netns add</code>场景的命名空间，但是没有使用该命名空间的进程，该命令是看不到的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># lsns -t net</span><br><span class="line">        NS TYPE NPROCS   PID USER  COMMAND</span><br><span class="line">4026531956 net     383     1 root  /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br><span class="line">4026532490 net       1  1026 rtkit /usr/libexec/rtkit-daemon</span><br><span class="line">4026532762 net       2 24872 root  /pause</span><br><span class="line">4026532866 net      20 25817 root  /pause</span><br><span class="line">4026532965 net       3 30763 root  /pause</span><br><span class="line">4026533059 net       3  2794 root  /bin/sh -c python /usr/src/app/clean.py &quot;$&#123;endpoints&#125;&quot; &quot;$&#123;expire&#125;&quot;</span><br><span class="line">4026533163 net       2  1122 102   /docker-java-home/jre/bin/java -Xms2g -Xmx2g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupan</span><br><span class="line">4026533266 net       4 13920 root  /pause</span><br><span class="line">4026533371 net       2  1844 root  /pause</span><br><span class="line">4026533559 net       3  1067 root  sleep 4</span><br></pre></td></tr></table></figure>

<h4 id="1-2-通过ip-netns命令"><a href="#1-2-通过ip-netns命令" class="headerlink" title="1.2 通过ip netns命令"></a>1.2 通过<code>ip netns</code>命令</h4><p>该命令仅会列出有名字的namespace，对于未命名的不能显示。</p>
<ul>
<li><code>ip netns identify $&#123;pid&#125;</code> 可以找到进程所属的网络命名空间</li>
<li><code>ip netns list</code>: 显示所有有名字的namespace</li>
</ul>
<h3 id="2-通过pid进入具体的network-namespace"><a href="#2-通过pid进入具体的network-namespace" class="headerlink" title="2. 通过pid进入具体的network namespace"></a>2. 通过pid进入具体的network namespace</h3><h4 id="2-1-通过nsenter命令"><a href="#2-1-通过nsenter命令" class="headerlink" title="2.1 通过nsenter命令"></a>2.1 通过nsenter命令</h4><p><code>nsenter --target $PID --net</code>可以进入到对应的命名空间</p>
<h4 id="2-2-docker-net参数"><a href="#2-2-docker-net参数" class="headerlink" title="2.2 docker --net参数"></a>2.2 docker <code>--net</code>参数</h4><p>docker提供了<code>--net</code>参数用于加入另一个容器的网络命名空间<code>docker run -it --net container:7835490487c1 busybox ifconfig</code>。</p>
<h4 id="2-3-setns系统调用"><a href="#2-3-setns系统调用" class="headerlink" title="2.3 setns系统调用"></a>2.3 setns系统调用</h4><p>一个进程可以通过setns()系统调用来进入到另外一个namespace中。</p>
<p>编写setns.c程序，该程序会进入到进程id所在的网络命令空间，并使用<code>gcc setns.c -o setns</code>进行编译，编译完成后执行<code>./setns /proc/4913/ns/net ifconfig</code>可以看到网卡的信息为容器中的网卡信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (setns(fd, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;setns&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  execvp(argv[<span class="number">2</span>], &amp;argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;execvp exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果执行<code>./setns /proc/4913/ns/net /bin/bash</code>，在宿主机上查看docker进程和&#x2F;bin&#x2F;bash进程的网络命名空间&#x2F;proc&#x2F;${pid}&#x2F;ns&#x2F;net，会发现都指向<code>lrwxrwxrwx 1 root root 0 Sep 14 14:42 net -&gt; net:[4026532133]</code>同一个位置。</p>
<h3 id="3-pid的获取方式"><a href="#3-pid的获取方式" class="headerlink" title="3. pid的获取方式"></a>3. pid的获取方式</h3><p>最简单的方式上文第1点中的PID列</p>
<h4 id="3-1-proc-pid-ns"><a href="#3-1-proc-pid-ns" class="headerlink" title="3.1 /proc/[pid]/ns"></a>3.1 <code>/proc/[pid]/ns</code></h4><p>可以使用如下命令查看当前容器在宿主机上的进程id。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect --format &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; a1bf0119d891</span><br></pre></td></tr></table></figure>

<p>每个进程在&#x2F;proc&#x2F;${pid}&#x2F;ns&#x2F;目录下都会创建其对应的虚拟文件，并链接到一个真实的namespace文件上，如果两个进程下的链接文件链接到同一个地方，说明两个进程同属于一个namespace。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost runc]# ls -l /proc/4913/ns/</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 Sep 11 00:21 ipc -&gt; ipc:[4026532130]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Sep 11 00:21 mnt -&gt; mnt:[4026532128]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Sep 11 00:18 net -&gt; net:[4026532133]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Sep 11 00:21 pid -&gt; pid:[4026532131]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Sep 11 00:21 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx 1 root root 0 Sep 11 00:21 uts -&gt; uts:[4026532129]</span><br></pre></td></tr></table></figure>

<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://coolshell.cn/articles/17029.html">DOCKER基础技术：LINUX NAMESPACE（下）</a></li>
<li>极客时间-深入剖析Kubernetes</li>
<li><a href="https://www.cnblogs.com/bakari/p/10443484.html">一文搞懂 Linux network namespace</a></li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础知识之user namespace</title>
    <url>/post/namespace_user/</url>
    <content><![CDATA[<p>user namespace是所有namespace中实现最复杂的一个，也是最晚引入的一个，是在linux2.6版本中才引入。因为涉及到权限机制，跟capability有着比较密切的关系。</p>
<h2 id="创建user-namespace"><a href="#创建user-namespace" class="headerlink" title="创建user namespace"></a>创建user namespace</h2><p>在clone或者unshare系统调用使用CLONE_NEWUSER参数后，在子进程中看到的uid和gid跟父进程中的不一样，子进程中找不到uid时，会显示最大的uid 65534（在&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;overflowuid中设置）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vagrant@ubuntu-xenial:/tmp$ id</span><br><span class="line">uid=1000(vagrant) gid=1000(vagrant) groups=1000(vagrant)</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ readlink /proc/$$/ns/user</span><br><span class="line">user:[4026531837]</span><br><span class="line"></span><br><span class="line"># 使用unshare命令创建新的user namespace</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ unshare --user /bin/bash</span><br><span class="line">nobody@ubuntu-xenial:/tmp$ readlink /proc/$$/ns/user</span><br><span class="line">user:[4026532145]</span><br><span class="line"># 新的user namespace没有映射关系，默认使用/proc/sys/kernel/overflowuid中定义的user id和/proc/sys/kernel/overflowgid中的group id</span><br><span class="line">nobody@ubuntu-xenial:/tmp$ id</span><br><span class="line">uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup)</span><br><span class="line"></span><br><span class="line">#--------------------------第二个shell窗口----------------------</span><br><span class="line"># 在父user namespace上创建文件夹，可以看到用户为vagrant</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ mkdir test</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ ll /tmp | grep test</span><br><span class="line">drwxrwxr-x  2 vagrant vagrant  4096 Sep 23 17:11 test/</span><br><span class="line"></span><br><span class="line">#--------------------------第一个shell窗口----------------------</span><br><span class="line"># 在新创建的user namespace下用户显示为nobody</span><br><span class="line">nobody@ubuntu-xenial:/tmp$ ll /tmp | grep test</span><br><span class="line">drwxrwxr-x  2 nobody nogroup  4096 Sep 23 17:11 test/</span><br></pre></td></tr></table></figure>

<h2 id="映射user-id和group-id到新的user-namespace"><a href="#映射user-id和group-id到新的user-namespace" class="headerlink" title="映射user id和group id到新的user namespace"></a>映射user id和group id到新的user namespace</h2><p>创建完新的user namespace后，通常会先映射user id和group id，方法为添加映射关系到&#x2F;proc&#x2F;${pid}&#x2F;uid_map和&#x2F;proc&#x2F;${pid}&#x2F;gid_map中。</p>
<p>user namespace被创建以后，第一个进程被赋予了该namespace的所有权限，但该进程并不拥有父namespace的任何权限。利用该机制可以做到一个用户在父user namespace中是普通用户，在子user namespace中是超级用户的功能。</p>
<p>为了将容器中的uid和父user namespace上的uid和gid进行 关联起来，可通过&#x2F;proc&#x2F;<pid>&#x2F;uid_map和&#x2F;proc&#x2F;<pid>&#x2F;gid_map来进行映射的。这两个文件的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ID-inside-ns ID-outside-ns length</span><br></pre></td></tr></table></figure>

<p>第一个字段ID-inside-ns表示在容器显示的UID或GID，<br>第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。<br>第三个字段表示映射的范围，一般填1，表示一一对应。</p>
<p><code>0 1000 256</code>这个配置的含义为父user namespace的1000-1256映射到新user namespace的0-256.</p>
<p>创建子进程在没有指定CLONE_NEWUSER时文件内容如下，子进程跟父进程的用户完全一致：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形</span><br><span class="line">[root@centos7 1325]# cat uid_map</span><br><span class="line">         0          0 4294967295</span><br></pre></td></tr></table></figure>

<p>要想实现以普通用户运行程序，在子进程中以root用户执行，仅需要将uid_map文件修改为普通用户映射到子进程中的0即可，因为uid为0表示root用户。</p>
<p>那么谁拥有写入该文件的权限呢？</p>
<p>&#x2F;proc&#x2F;${pid}&#x2F;[u|g]id的拥有者为创建新user namespace的用户，拥有map文件写入权限的仅有两个用户：和该用户在同一个user namespace中的root用户，创建新的user namespace的用户。创建新的user namespace有没有写入map文件的权限，还要取决于capability中的CAP_SETUID和CAP_SETGID两个权限。</p>
<p>为了方便写入&#x2F;proc&#x2F;${pid}&#x2F;uid_map和&#x2F;proc&#x2F;${pid}&#x2F;gid_map文件，可以使用newuidmap和newgidmap命令来完成。</p>
<p>继续上述例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#--------------------------第一个shell窗口----------------------</span><br><span class="line"># 在新user namespace中获取当前的进程号</span><br><span class="line">nobody@ubuntu-xenial:/tmp$ echo $$</span><br><span class="line">13226</span><br><span class="line"></span><br><span class="line">#--------------------------第二个shell窗口----------------------</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ ll /proc/13226/uid_map  /proc/13226/gid_map</span><br><span class="line">-rw-r--r-- 1 vagrant vagrant 0 Sep 23 17:31 /proc/13226/gid_map</span><br><span class="line">-rw-r--r-- 1 vagrant vagrant 0 Sep 23 17:31 /proc/13226/uid_map</span><br><span class="line"># 提示当前进程没有权限写入</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ echo &#x27;0 1000 100&#x27; &gt; /proc/13226/uid_map</span><br><span class="line">-bash: echo: write error: Operation not permitted</span><br><span class="line"></span><br><span class="line"># 查看当前bash没有任何capability</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ cat /proc/$$/status | egrep &#x27;Cap(Inh|Prm|Eff)&#x27;</span><br><span class="line">CapInh:	0000000000000000</span><br><span class="line">CapPrm:	0000000000000000</span><br><span class="line">CapEff:	0000000000000000</span><br><span class="line"></span><br><span class="line"># 使用root权限给/bin/bash可执行文件增加cap_setgid和cap_setuid</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ sudo setcap cap_setgid,cap_setuid+ep /bin/bash</span><br><span class="line"># 启动新的bash后capability会生效</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ bash</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ cat /proc/$$/status | egrep &#x27;Cap(Inh|Prm|Eff)&#x27;</span><br><span class="line">CapInh:	0000000000000000</span><br><span class="line">CapPrm:	00000000000000c0</span><br><span class="line">CapEff:	00000000000000c0</span><br><span class="line"></span><br><span class="line"># 重新写入</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ echo &#x27;0 1000 100&#x27; &gt; /proc/13226/uid_map</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ echo &#x27;0 1000 100&#x27; &gt; /proc/13226/gid_map</span><br><span class="line"></span><br><span class="line"># 第二次再写入会失败，仅允许写入一次</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ echo &#x27;0 1000 100&#x27; &gt; /proc/13226/uid_map</span><br><span class="line">bash: echo: write error: Operation not permitted</span><br><span class="line"></span><br><span class="line"># 将刚才设置的capability取消</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ sudo setcap cap_setgid,cap_setuid-ep /bin/bash</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ getcap /bin/bash</span><br><span class="line">/bin/bash =</span><br><span class="line">vagrant@ubuntu-xenial:/tmp$ exit</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">#--------------------------第一个shell窗口----------------------</span><br><span class="line"># 第一个窗口中userid已经变更为0了</span><br><span class="line">nobody@ubuntu-xenial:/tmp$ id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line"># 重新执行一个新的bash，会发现提示符已经变更为root了</span><br><span class="line">nobody@ubuntu-xenial:/tmp$ bash</span><br><span class="line">root@ubuntu-xenial:/tmp#</span><br><span class="line"></span><br><span class="line"># 可以看到新的bash已经拥有的所有的capability，但也仅限于当前的user namespace中</span><br><span class="line">root@ubuntu-xenial:/tmp# cat /proc/$$/status | egrep &#x27;Cap(Inh|Prm|Eff)&#x27;</span><br><span class="line">CapInh:	0000000000000000</span><br><span class="line">CapPrm:	0000003fffffffff</span><br><span class="line">CapEff:	0000003fffffffff</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>user namespace在linux3.8内核版本上才实现，存在一定的安全问题。在redhat和centos系统下，user namespace作为了一个实验feature，默认情况下未开启。</p>
<p>执行如下命令<code>sudo grubby --args=&quot;user_namespace.enable=1&quot; --update-kernel=&quot;$(grubby --default-kernel)&quot;</code>并重启系统后可以就可以打开user namespace feature了。执行<code>grubby --remove-args=&quot;user_namespace.enable=1&quot; --update-kernel=&quot;$(grubby --default-kernel)&quot;</code>可关闭user namespace feature。</p>
<p>经实验，上述操作未生效，后续待查该问题。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://rhelblog.redhat.com/2015/07/07/whats-next-for-containers-user-namespaces/#comment-6796">What’s Next for Containers? User Namespaces
</a></li>
<li><a href="https://segmentfault.com/a/1190000006913195">Linux Namespace系列（07）：user namespace (CLONE_NEWUSER) (第一部分)</a></li>
</ul>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>《南渡北归》读后感</title>
    <url>/post/nandubeigui/</url>
    <content><![CDATA[<p>自己断断续续花了几个月的时间，终于将《南渡北归》读完了。当我知道这本书的时候，迅速被这本书的内容给吸引住了。早高峰上班的地铁上基本全部花在了该书上，晚上躺在床上后临睡前也在刷该书，困的睁不开眼的时候再倒头就睡。</p>
<p>中学的历史课本上，在讲解中国近现代史的时候实际上带有了比较浓厚的党的特色，过分的强调了自我，而对于当时的国民政府的描述相对较少。受限于篇幅的限制，历史课本对于历史人物提的也比较少一些。知识分子在中国历史上乘井喷状爆发的有两个阶段春秋时期和民国时期，本书以民国时期我们耳熟能详的知识分子们为主角，比如胡适、陈寅恪、梅贻琦、闻一多，讲解了大师们在乱世中颠沛流离的经历，以及错综复杂的人物关系。</p>
<p>《南渡北归》实际分为了《南渡》、《北归》和《离别》三部曲，全书100多万字，四大名著字数最多的《水浒传》也不过才96万字，本书可以算得上一步巨著了。之所以有那么多字数，其中有一部分篇幅是大师们的一些书信资料，真正属于作者的有效字数应该跟《水浒传》不相上下。</p>
<p>《南渡》主要讲解了卢沟桥事变抗日战争爆发后，北平各学府的师生们纷纷南下，先是辗转到长沙成立了长沙临时联合大学。但不久长沙沦陷，又分几路辗转到云南昆明组建西南联合大学，像李政道、杨振宁在这里完成了部分学业。但在昆明好景不长，时常有敌机轰炸，师生们天天”跑警报“。后一部分又逃亡了四川宜宾长江边上的李庄镇，很多大师们在李庄镇度过了非常难忘的一段回忆。比如林徽因、梁思永，很多时候都是在病床上度过，又受限于当地的环境，无药可医。</p>
<p>《北归》发生在了抗日战争结束，国民政府开始组织知识分子纷纷回到北平的旧时学府，回到一别多年的故乡。可是好景不长，国共内战爆发，北平沦陷。紧接着一大批的知识分子们又开始了新一轮的逃亡，很大一部分逃亡了台湾岛，另外一部分留在了大陆。这一不同的选择，直接决定了不同的人生命运。</p>
<p>《离别》是读起来最为伤感的一部，大师们纷纷陨落。逃亡台湾的如傅斯年、胡适、梅贻琦等虽然过得并不富裕，谈不上悲惨，但也算在台湾开辟了一番事业，名扬千古。但逃亡台湾的知识分子，在大陆却成了千古罪人。如大陆掀起了一股非常大的反胡热潮，以至于连胡适的儿子胡思杜都登报公开批判远在海峡对岸的父亲。可惜的是，思想觉悟足够高的儿子仍然在被批斗至自杀身亡。留在大陆的知识分子的命运却大相径庭，政治觉悟高者如郭沫若风生水起。但大部分的知识分子在”三反“、”文革“运动中都遭到了残酷的迫害，被红卫兵逼迫自杀者也不在少数。当年的红卫兵如今也就其八十岁的样子，我特别想采访一番当时他们是在什么情况下怀着怎样的心情什么动力来做出如此伤天害理之事，而且自己还理直气壮。</p>
<p>寒门难出贵子。民国时期但凡叫上名字的大师们大都出生在名门望族，而且往往一家不止出一位大师级人物，甚至有很多家族是世交。随便举几个例子，如周树人、周作人兄弟，虽然后来两兄弟完全走上了不同的人生道路。曾国藩的后人至少五代以内都有各种英才，如在民国时期活跃的曾宝荪、曾约农、曾昭燏、曾昭抡等。梁启超的两个儿子梁思成和梁思永兄弟，分别在建筑学和考古学方向有非常高的建树。不过也正是因为出生在名门望族，因为家庭出身的问题，也往往在后来的迫害中是最惨烈的。 </p>
<p>傅斯年在书中简直被作者推崇之至，甚至可以说是崇拜。关于傅斯年，作者描绘最多的字眼是胖子、高血压蹭蹭往上窜、活跃于政学两界、学术大鳄、气场强大、胡适的打手、思维清晰、擅长处理棘手问题。傅斯年毕业于大学，曾经领导过五四运动，出国留学后曾经担任了多年的史语所所长一职，也曾代理过北京大学校长一职。国共内战爆发后，随史语所一起逃亡台湾，在台湾期间，担任台湾大学校长，1950年突发脑淤血去世，后葬于台湾大学的”傅园“内为后世铭记。</p>
<p>另外一个对外印象比较深刻的人物是陈寅恪。清末著名诗人陈三立之子，同梁启超、王国维、赵元任并称为”清华国学四大导师“。国共内战北平失手后，陈寅恪从北京辗转逃亡岭南大学，后岭南大学跟中山大学合并，任教于中山大学。书中罗列了陈寅恪的多首诗，诗文引经据典，读起来相当晦涩，没点文化底蕴根本无法领会其中奥妙，可见大师功底之深。晚年在双目失明的情况下，完成了80多万字的巨著《柳如是别传》，非常人能所及。</p>
<p>本书描述的这段历史，实际上也就发生了一百年的时间，但却有非常多的历史是无法考证的。读史书其实想了解一个真实的历史，但本书的作者却带有了比较浓厚的个人感情色彩，比如对傅斯年推崇之至，对闻一多的评价却非常差。另外，作者有一丝错误的政治倾向，此书能够在大陆出版也算是一个奇迹了。读此书本着了解历史真相的态度，但却不可全信。</p>
<p>民国时期的知识分子大都有记录日志的好习惯，日记确实是一种非常好的自我反省和自我成长的好方式，可惜这么好的成长方式在现代的社会中却在逐渐消失，更多的会出现在小学生的课后作业中。另一方面，日记作为了非常好的一种史学参考资料，日记不会说谎，是作者的最真实的内心流露。过去发生的事情可以被人遗忘，但文字永存。由于没有长途电话这么高科技的产品，朋友之间的往来很多都是以书信的形式，如林徽因跟美国好友费慰梅就有大量的书信往来，这些书信也成为了非常好的史学资料。书信在当代早已成为了过去时，取而代之的是更为便捷的聊天app，无论身处何地对方永远在线，想聊天几乎没有了任何代价。</p>
<p>如果你有时间，此书值得一读。另外，再推荐一个关于昆明西南联合大学的纪录片《九零后》，针对超过16位超过90岁高龄的专家学者的口述，有助于了解当时那段历史。</p>
]]></content>
  </entry>
  <entry>
    <title>牛客网内推笔试卷题目2015.3.12</title>
    <url>/post/nowcoder_2015.3.12/</url>
    <content><![CDATA[<p>前段时间参加了牛客网的答题活动，共两套试题，每套题目3个算法题，我只做了每套题的前两道。最近想查看之前做的题目的答案，却发现非常不方便，特此将我做过的4道题目记录一下，算法的思路就不再解释了。</p>
<h1 id="题目一-奇数位上都是奇数或者偶数位上都是偶数"><a href="#题目一-奇数位上都是奇数或者偶数位上都是偶数" class="headerlink" title="题目一 奇数位上都是奇数或者偶数位上都是偶数"></a>题目一 奇数位上都是奇数或者偶数位上都是偶数</h1><blockquote>
<p>给定一个长度不小于2的数组arr。 写一个函数调整arr，使arr中要么所有的偶数位上都是偶数，要么所有的奇数位上都是奇数上。 要求：如果数组长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1),下标0,2,4,6…算作偶数位,下标1,3,5,7…算作奇数位，例如[1,2,3,4]调整为[2,1,4,3]即可。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">oddInOddEvenInEven</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> odd = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> even = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (odd &lt; len &amp;&amp; even &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[odd] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (arr[even] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    even += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (even &lt; len)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> tmp = arr[even];</span><br><span class="line">                    arr[even] = arr[odd];</span><br><span class="line">                    arr[odd] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                odd += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="题目二-求正数数组的最小不可组成和"><a href="#题目二-求正数数组的最小不可组成和" class="headerlink" title="题目二 求正数数组的最小不可组成和"></a>题目二 求正数数组的最小不可组成和</h1><blockquote>
<p>给定一个全是正数的数组arr，定义一下arr的最小不可组成和的概念： 1，arr的所有非空子集中，把每个子集内的所有元素加起来会出现很多的值，其中最小的记为min，最大的记为max； 2，在区间[min,max]上，如果有一些正数不可以被arr某一个子集相加得到，那么这些正数中最小的那个，就是arr的最小不可组成和； 3，在区间[min,max]上，如果所有的数都可以被arr的某一个子集相加得到，那么max+1是arr的最小不可组成和； 举例： arr &#x3D; {3,2,5} arr的min为2，max为10，在区间[2,10]上，4是不能被任何一个子集相加得到的值中最小的，所以4是arr的最小不可组成和； arr &#x3D; {3,2,4} arr的min为2，max为9，在区间[2,9]上，8是不能被任何一个子集相加得到的值中最小的，所以8是arr的最小不可组成和； arr &#x3D; {3,1,2} arr的min为1，max为6，在区间[2,6]上，任何数都可以被某一个子集相加得到，所以7是arr的最小不可组成和； 请写函数返回arr的最小不可组成和。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getFirstUnFormedNum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            set&lt;<span class="type">int</span>&gt; tmp = res;</span><br><span class="line">            <span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator iter = res.<span class="built_in">begin</span>(); iter != res.<span class="built_in">end</span>(); iter++)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">insert</span>(*iter + arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res = tmp;</span><br><span class="line">            res.<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set&lt;<span class="type">int</span>&gt;::iterator iter = res.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> before = *iter;</span><br><span class="line">        iter++;</span><br><span class="line">        <span class="keyword">for</span> (; iter != res.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*iter - before &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> before + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            before = *iter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> before + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="题目三-最大的LeftMax与rightMax之差绝对值"><a href="#题目三-最大的LeftMax与rightMax之差绝对值" class="headerlink" title="题目三 最大的LeftMax与rightMax之差绝对值"></a>题目三 最大的LeftMax与rightMax之差绝对值</h1><blockquote>
<p>给定一个长度为N的整型数组arr，可以划分成左右两个部分： 左部分arr[0..K]，右部分arr[K+1..arr.length-1]，K可以取值的范围是[0,arr.length-2] 求这么多划分方案中，左部分中的最大值减去右部分最大值的绝对值，最大是多少？ 例如： [2,7,3,1,1] 当左部分为[2,7]，右部分为[3,1,1]时，左部分中的最大值减去右部分最大值的绝对值为4; 当左部分为[2,7,3]，右部分为[1,1]时，左部分中的最大值减去右部分最大值的绝对值为6; 最后返回的结果为6。 注意：如果数组的长度为N，请尽量做到时间复杂度O(N)，额外空间复杂度O(1)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxABSLeftAndRight</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vec, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find the max in array</span></span><br><span class="line">        <span class="type">int</span> max = vec[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;(<span class="type">int</span>)vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = vec[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare the head and tail in array</span></span><br><span class="line">        <span class="keyword">if</span> (vec[<span class="number">0</span>] &lt; vec[len - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> max - vec[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - vec[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="题目四-按照左右半区的方式重新组合单链表"><a href="#题目四-按照左右半区的方式重新组合单链表" class="headerlink" title="题目四 按照左右半区的方式重新组合单链表"></a>题目四 按照左右半区的方式重新组合单链表</h1><blockquote>
<p>给定一个单链表的头部节点head，链表长度为N。 如果N为偶数，那么前N&#x2F;2个节点算作左半区，后N&#x2F;2个节点算作右半区； 如果N为奇数，那么前N&#x2F;2个节点算作左半区，后N&#x2F;2+1个节点算作右半区； 左半区从左到右依次记为L1-&gt;L2-&gt;…，右半区从左到右依次记为R1-&gt;R2-&gt;…。请将单链表调整成L1-&gt;R1-&gt;L2-&gt;R2-&gt;…的样子。 例如： 1-&gt;2-&gt;3-&gt;4 调整后：1-&gt;3-&gt;2-&gt;4 1-&gt;2-&gt;3-&gt;4-&gt;5 调整后：1-&gt;3-&gt;2-&gt;4-&gt;5 要求：如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">relocateList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use one loop, find the right head</span></span><br><span class="line">        ListNode *right_head = head;</span><br><span class="line">        ListNode *node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                right_head = right_head-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right_head = right_head-&gt;next;</span><br><span class="line">            node = node-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *left_node = head;</span><br><span class="line">        ListNode *right_node = right_head;</span><br><span class="line">        <span class="keyword">while</span> (left_node-&gt;next != right_head)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = left_node-&gt;next;</span><br><span class="line">            left_node-&gt;next = right_node;</span><br><span class="line">            right_node = right_node-&gt;next;</span><br><span class="line">            left_node-&gt;next-&gt;next = tmp;</span><br><span class="line">            left_node = left_node-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left_node-&gt;next = right_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>nsenter的用法</title>
    <url>/post/nsenter/</url>
    <content><![CDATA[<p>nsenter是一个命令行工具，用来进入到进程的linux namespace中。</p>
<p>docker提供了exec命令可以进入到容器中，nsenter具有跟<code>docker exec</code>差不多的执行效果，但是更底层，特别是docker daemon进程异常的时候，nsenter的作用就显示出来了，因此可以用于排查线上的docker问题。</p>
<p>CentOS用户可以直接使用<code>yum install util-linux</code>来进行安装。</p>
<p>启动要进入的容器：<code>docker run -d ubuntu /bin/bash -c &quot;sleep 1000&quot;</code></p>
<p>获取容器的pid可以使用&#96;</p>
<p>要进入容器执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取容器的pid</span><br><span class="line">docker inspect 9f7f7a7f0f26 -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span><br><span class="line"># 进入pid对应的namespace</span><br><span class="line">sudo nsenter --target $PID --mount --uts --ipc --net --pid</span><br></pre></td></tr></table></figure>

<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="http://man7.org/linux/man-pages/man1/nsenter.1.html">nsenter man page</a></li>
<li><a href="https://github.com/jpetazzo/nsenter">nsenter GitHub</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>日常工作中经常用到的命令</title>
    <url>/post/often-command/</url>
    <content><![CDATA[<p>shell的命令千千万，工作中总有些命令是经常使用到的，本文记录一些常用到的命令，用于提高效率。</p>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>快速开启一个http server <code>python -m SimpleHTTPServer 8080</code>。</p>
<p>在python3环境下该命令变更为：<code>python3 -m http.server 8080</code></p>
<p>格式化 json: <code>cat 1.json | python -m json.tool</code></p>
<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>按照,打印出一每一列 <code>awk -F, &#39;&#123;for(i=1;i&lt;=NF;i++)&#123;print $i;&#125;&#125;&#39;</code></p>
<h2 id="docker-registry"><a href="#docker-registry" class="headerlink" title="docker registry"></a>docker registry</h2><ul>
<li>列出镜像：<code>curl http://127.0.0.1:5000/v2/_catalog?n=1000</code></li>
<li>查询镜像的tag: <code>curl http://127.0.0.1:5000/v2/nginx/tags/list</code>，如果遇到镜像名类似<code>aa/bb</code>的情况，需要转移一下 <code>curl http://127.0.0.1:5000/v2/aa\/bb/tags/list</code></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>浪潮之巅读书笔记</title>
    <url>/post/on_top_of_tides/</url>
    <content><![CDATA[<p>我的大部分读书时间都花在了技术类书籍上，对于扯淡类和鸡汤类的书籍不是我的最爱。本书受到了很多互联网从业人员的推荐，对于技术人员推荐的书籍感觉还是比较靠谱的，因此试着一读，读完之后果然收获颇多。吴军博士的很多观点都相当理性，很多对未来的预测也都在今天得以验证了。文章行为流畅，观点鲜明，能够窥见作者的写作功底。文中的一些观点非常值得记录和学习，本文主要是记录文中观点的摘要，并体现部分自己的理解。</p>
<h1 id="计算机行业发展规律"><a href="#计算机行业发展规律" class="headerlink" title="计算机行业发展规律"></a>计算机行业发展规律</h1><h2 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h2><blockquote>
<p>摩尔定律：每18个月，计算机等IT产品的性能会翻一番，或者说相同性能的计算机等IT产品，每18个月价钱会降一半。</p>
</blockquote>
<p>摩尔定律对行业发展的影响主要体现在以下几个方面：</p>
<ol>
<li>IT公司必须在比较短的时间内完成下一代产品的开发。天下武功唯快不破，在互联网行业特别合适。</li>
<li>由于有了强有力的硬件支持，以前都不敢想的应用会不断涌现。手机行业正在深受摩尔定律的影响。</li>
<li>各个公司现在的研发必须针对多年后的市场。不知道google是否在研究PC版的操作系统来取代Windows了，不知道苹果公司内部是否在研究iphone10了？</li>
</ol>
<h2 id="安迪-比尔定律"><a href="#安迪-比尔定律" class="headerlink" title="安迪-比尔定律"></a>安迪-比尔定律</h2><blockquote>
<p>安迪-比尔定律：即比尔要拿走安迪所给的。安迪是原英特尔公司 CEO 安迪·格鲁夫（Andy Grove），比尔就是微软的创始人比尔·盖茨。在过去的二十年里，英特尔处理器的速度每十八个月翻一番，计算机内存和硬盘的容量以更快的速度在增长。但是，微软的操作系统等应用软件越来越慢，也越做越大。所以，现在的计算机虽然比十年前快了一百倍，运行软件感觉上还是和以前差不多。而且，过去整个视窗操作系统不过十几兆大小，现在要几千兆，应用软件也是如此。虽然新的软件功能比以前的版本强了一些，但是，增加的功能绝对不是和它的大小成比例的。因此，一台十年前的计算机能装多少应用程序，现在的也不过装这么多，虽然硬盘的容量增加了一千倍。更糟糕的是，用户发现，如果不更新计算机，现在很多新的软件就用不了，连上网也是个问题。而十年前买得起的车却照样可以跑。</p>
</blockquote>
<p>安迪-比尔定律把原本属于耐用消费品的电脑、手机等商品变成了消费性商品，刺激着整个IT领域的发展。</p>
<h2 id="反摩尔定律"><a href="#反摩尔定律" class="headerlink" title="反摩尔定律"></a>反摩尔定律</h2><blockquote>
<p>反摩尔定律：Google的前CEO埃里克·施密特提出：如果你反过来看摩尔定律，一个IT公司如果今天和18个月前卖掉同样多的、同样的产品，它的营业额就要降一半。IT界把它称为反摩尔定律。反摩尔定理对于所有的IT 公司来讲，都是非常可悲的，因为一个IT<br>公司花了同样的劳动，却只得到以前一半的收入。反摩尔定理逼着所有的硬件设备公司必须赶上摩尔定理规定的更新速度。</p>
</blockquote>
<h1 id="信息产业的规律性"><a href="#信息产业的规律性" class="headerlink" title="信息产业的规律性"></a>信息产业的规律性</h1><h2 id="70-20-10定律"><a href="#70-20-10定律" class="headerlink" title="70-20-10定律"></a>70-20-10定律</h2><blockquote>
<p>当某个领域发展成熟后（而不是群雄争霸时期），一般在全球容不下三个以上的主要竞争者。这个行业一定有一个老大，斯库利把它比喻成一个猴王，它是这个行业的主导者。毫无疑问，它虽然想顺顺当当地统领好整个行业，就像猴王想让猴子们永远臣服一样，但是，它一定会遇到一两个主要的挑战者，也就是老二（也许还有一个老三）。剩下来的是一大群小商家，就像一大群猴子。老大是这个领域的主导者，不仅占据着超过一半，通常是百分之六七十的市场，并且制定了这个领域的游戏规则。老二有自己稳定的百分之二三十的市场份额，有时也会挑战老大并给老大一些颜色看看，但是总的来讲是受老大欺负的时间多。剩下的一群小猴子数量虽然多，但是却只能占到百分之十甚至更少的市场，它们基本上唯老大马首是瞻。老大总是密切注视着老二，并时不时地打压它，防止它做大。老大和老二通常都不会太在意剩下的小企业，这样就让这一群小的企业能有挣一些小钱的地方。</p>
</blockquote>
<h2 id="诺维格定律"><a href="#诺维格定律" class="headerlink" title="诺维格定律"></a>诺维格定律</h2><blockquote>
<p>谷歌研究院院长彼得.诺威格博士说，当一个公司的市场占有率超过50% 以后，就不要<br>再指望在市场占有率上翻番了。</p>
</blockquote>
<h2 id="基因决定定律"><a href="#基因决定定律" class="headerlink" title="基因决定定律"></a>基因决定定律</h2><blockquote>
<p>一个在某个领域特别成功的大公司一定已经被优化得非常适应这个市场，它的文化、做事方式、商业模式、市场定位等等已经非常适应，甚至过分适应自己传统的市场。这使得该公司获得成功的内在因素会渐渐地、深深地植入该公司，可以讲是这个公司的基因。</p>
</blockquote>
<p>基因对于一个公司非常的重要，会影响到公司的整个发展历程。济南的软件公司都是些传统行业的软件公司，在过去十年的时间中发展还算可以。因为行业软件是销售为王，只要销售搞的好，只要不是特别烂的技术都能混过去。现在随着互联网的兴起，很多企业开始转型搞互联网应用，却没有一家搞的起来，到现在济南都没有一家真正意义上的互联网公司，如果有请你告诉我。这些从本质上来说还是基因决定定律的影响。</p>
<h1 id="最佳商业模式"><a href="#最佳商业模式" class="headerlink" title="最佳商业模式"></a>最佳商业模式</h1><h2 id="Google的广告系统"><a href="#Google的广告系统" class="headerlink" title="Google的广告系统"></a>Google的广告系统</h2><blockquote>
<p>在这台印钞机里，运营的成本就是数据中心的费用和带宽的费用，而间接的成本则是打<br>造和改进这个印钞机的研发费用。在这台印钞机中，自动化程度必须到达一个阈值，它才能自动运转起来。而当它的自动化越高，成本就越低。</p>
</blockquote>
<h2 id="Ebay-和亚马逊的在线市场"><a href="#Ebay-和亚马逊的在线市场" class="headerlink" title="Ebay 和亚马逊的在线市场"></a>Ebay 和亚马逊的在线市场</h2><p>提供在线交易和支付平台，买卖双方自由交易，赚取手续费用和少量提成。中国的淘宝也基本属于这种模式。</p>
<h2 id="戴尔的虚拟工厂"><a href="#戴尔的虚拟工厂" class="headerlink" title="戴尔的虚拟工厂"></a>戴尔的虚拟工厂</h2><blockquote>
<p>一个传统的制造业需要通过产品设计、原料采购、仓储运输、加工制造、订单处理、批<br>发经营和零售七个环节才能收回投资、获得利润。戴尔将上述七个环节减少到两个，仅留订单处理和零售。</p>
</blockquote>
<h2 id="腾讯的虚拟物品和服务"><a href="#腾讯的虚拟物品和服务" class="headerlink" title="腾讯的虚拟物品和服务"></a>腾讯的虚拟物品和服务</h2><p>销售虚拟商品商业模式必须解决好两个问题：虚拟商品的使用价值和虚拟社交网站中的用户不但是虚拟商品的消费者，还是它们的创造者。解决好上述两个问题，只要累计起足够多的用户基数，虚拟商品就成了社交网站的印钞机。</p>
<h1 id="下一个Google"><a href="#下一个Google" class="headerlink" title="下一个Google"></a>下一个Google</h1><p>微软是一家软件公司，百度是一家区域性的互联网公司，而Google更多地是一家科技公司。</p>
<p>下一个Google不可能是搜索公司，而且不太可能是现在意义上依靠广告挣钱的互联网公司，因为这个互联网广告产业不够养活一个像Google这么大的公司。</p>
<p>替代能源和电池在近期很难诞生一个Google这样的公司。</p>
<p>生物和医疗技术有全社会的需求，但是创新周期特别长，加上法律上的风险，不可能在短期内核诞生下一个Google。</p>
<p>在中国和一些亚洲国家，电子商务的潜力可以早就出Google这样的大型新型公司。</p>
<p>如果通过云计算诞生一两个千亿美元的公司，首先会是Google自己，其次是控制开发平台的Facebook，而不会是新面孔。</p>
<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a href="http://www.weibo.com/1465282224/B1kXiACNq">非常精美的读书笔记PPT</a></p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>从项目管理的角度分析一个失败的软件项目</title>
    <url>/post/one_failed_project_in_pm/</url>
    <content><![CDATA[<p>前段时间公司领导安排我完成一个android的小项目，功能为完成手机短信的分类功能。由于考虑到可能会和某运营商合作，项目需求多变，项目名到项目死掉的那一刻也没有想好，暂定叫短信管家。前段时间参加了今年软考中的高级项目管理师考试，对项目管理有一定的了解，由于在实际的工作中没有参与项目经理的角色，对项目管理的知识理论和实际结合还有一定差距。我一向是喜欢挑人毛病的，本文也不例外，将结合项目管理的知识领域来分析项目中存在的问题，并给出纠正的措施。本文并不想按照项目管理的44个过程组来写，不想受项目管理理论知识条条框框的约束。</p>
<h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>在2013年元旦后上班第一天，经过领导简单介绍项目后，项目正式开始启动。项目参与人员包括我和一名美工。由于公司没有做android项目的经验，我是公司唯一懂点android项目的技术人员，我之前也仅仅是自学过一点。经过两个星期的学习之后开始了android项目的开发，春节前领导希望看到一个版本出来。离春节放假还有三天，美工搞出一个首界面来，我仿照首界面基本搞定。后来领导一看不符合需求，其实领导之前就看过首界面效果图，只是没有仔细看。当然领导也不知道要做出个什么样的东西，估计心想着技术人员弄出个什么样的东西来再修改。<br>年后，对需求开会进行了重新整理，通过思维导图的方式跟领导确定需求，就需求中存在的疑问进行确认。不过后来事实证明经过领导确认的需求也是在不断变更。这次的需求要远比上次复杂，将原来的短信分类从一级短信分类更改为了二级短信分类。公司没有互联网行业产品的经验，美工给出的效果图也仅是从桌面端来考虑移动产品的设计。我最终决定自己开始重新设计软件的界面，参考了众多同类软件，花费的时间比较多。大约到2013年4月底产品已经基本可用，经过我自己的测试和领导的使用效果还算可以。后来发现不支持彩信，经过我的一番研究后发现现有的产品功能要对彩信支持需要耗费非常大的工作量，因为软件本身的功能打破了android系统短信的设计，也难怪了android的应用中没有功能相似的产品出现。这也成为了该项目失败的直接原因。</p>
<h1 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h1><h3 id="技术可行性"><a href="#技术可行性" class="headerlink" title="技术可行性"></a>技术可行性</h3><p>项目的起源来自领导的短信泛滥，领导想着能够搞一个拦截垃圾短信并对短信进行管理的软件将是酷的一件事情。领导接触过一些android，片面的认为这种方案在技术上可行。我也做了一个调研，发现现有的android软件项目中没有此功能的产品。</p>
<h3 id="经济可行性"><a href="#经济可行性" class="headerlink" title="经济可行性"></a>经济可行性</h3><p>支出分析：由于项目主要参与人员仅有我一人，支出的成本较小。收益分析：现在的互联网产品都是先圈用户再考虑盈利，我们这个软件产品也不例外。</p>
<h3 id="运行环境可行性"><a href="#运行环境可行性" class="headerlink" title="运行环境可行性"></a>运行环境可行性</h3><p>对于产品的运营存在两种方式：1、跟某地方运营商合作；2、自己单独发布。</p>
<p>总体而言，由于项目较小，对可行性研究基本忽略，没有科学、可观、公证的对项目进行可行性分析。</p>
<h1 id="范围管理"><a href="#范围管理" class="headerlink" title="范围管理"></a>范围管理</h1><p>在项目立项的时候仅有一个产品的大致方向，做一款android系统中的短信分类管理类应用。从始至终领导对于产品的理解在不断变化，每次变化都需要修改很多代码，跟领导对于导致产品研发过程做了很多无用功。<br>在项目进行到一个月后，我认识到了项目这样下去反复修改不可能有好的结果，因此跟领导召开了需求定义的会议，就产品的需求用思维导图的方式就项目的范围进行了定义，会后就需求中没有考虑到的问题跟领导进行了沟通确认。此次会议之后项目的需求基本敲定，虽然之后领导有需求变更的情况，但是相对较少。</p>
<h1 id="进度管理"><a href="#进度管理" class="headerlink" title="进度管理"></a>进度管理</h1><p>由于公司初次开展android类项目，对项目的进度很难掌控。项目开始时负责市场部的领导给出了一个月之内完成的计划，我心想我自己加把劲应该能搞定吧，因为最初的项目需求还比较简单。我用了两个星期的时间来学习android知识，用两个星期的时间来开发，结果到最后我才刚根据美工提供的效果图完成了首页，我总是不能很好的估算自己的工作进度。这篇《为什么程序员总是不能准确预估工作量》的文章或许能替我解释些什么。<br>在项目范围确定之后我对自己工作的进度管理也不够好，第一次尝试做android项目，未知因素太多，编码中总能遇到这样那样的问题。</p>
<h1 id="成本管理"><a href="#成本管理" class="headerlink" title="成本管理"></a>成本管理</h1><p>项目的整个成本应该我的人力成本占了绝大部分，本来软件项目中的人力成本就是占的比重较多的，何况主要是我一个人参与的项目，自然我那微薄的人力占了项目成本的大部分。至于后期项目的盈利并没有过多考虑，现在的互联网行业本来就是先圈用户后盈利。</p>
<h1 id="质量管理"><a href="#质量管理" class="headerlink" title="质量管理"></a>质量管理</h1><p>我在项目的编码过程中，一般一个小功能完成之后都会进行详尽的功能测试。由于功能不负责，产品的质量只要多测试一般问题就不大了。</p>
<h1 id="人力资源管理"><a href="#人力资源管理" class="headerlink" title="人力资源管理"></a>人力资源管理</h1><p>项目的初期我就感觉项目不可能成功，但是领导坚持要做，而且我一个做C++的程序员来写android的代码，我当时居然仅有听从领导的意识，没有适当的表达自己的想法。当时怀着一己之心认为可能一个月项目就完成了，完成之后工作依旧，还可以熟练熟练android的开发，谁知一练手就是做了五个月，而到最后项目仍然没有成型。<br>由于一直对项目持悲观态度，始终认为我自己开发出来的产品我都不想去用，用户怎么可能去用。长期自己独自做，兼任了产品经理、美工、码农的工作，做的过程中还要担心着需求的变更，在项目进行到中后期的时候， 缺少激励因素，对工作激情不够，这也影响了项目的进度。</p>
<h1 id="沟通管理"><a href="#沟通管理" class="headerlink" title="沟通管理"></a>沟通管理</h1><p>在项目的开发过程中基本能保持没完成一个关键功能跟领导汇报一次项目进展。在项目中沟通方面存在不少的问题，尤其以前期严重。前期由于跟领导的需求不一致，导致做了很多的重复性劳动。领导对项目的需求本来就不够明确，一旦有好的想法就加到项目中，这也导致了跟领导的沟通困难，因为这样的沟通效率太低。</p>
<h1 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h1><p>项目可研阶段对技术可行性分析研究不够，导致了后期在对彩信进行分类处理的时候遇到了技术上的难题。当然前期的可研阶段做充分的技术可行性研究也是不太现实了，因为本来技术对公司而言就是未知的。最好的办法就是对自己不熟悉而且短期内不能实现盈利的项目不参与。</p>
<h1 id="文档管理"><a href="#文档管理" class="headerlink" title="文档管理"></a>文档管理</h1><p>由于项目管理中要求每个阶段都有输出的文档，这么繁琐的文档我相信中国找不出几家软件公司能够办到，能办到的估计都已经死掉了。此项目中仅有范围定义的思维导图、我在编写某个具体的功能代码前绘制的流程图，应该说文档及其少。但我目前不认为这有什么不对，我还是坚信某些情况下看代码比看文档要来的更快，特别是看我这种android菜鸟写的代码。更何况此项目的需求在不断随着领导的想法而变化，文档都没法写，写文档的成本太高。</p>
<h1 id="我的一些反思："><a href="#我的一些反思：" class="headerlink" title="我的一些反思："></a>我的一些反思：</h1><p>在项目中我也存在不少问题。</p>
<ol>
<li>项目开始阶段应该向领导表达清楚自己的想法，阐明自己对项目的看法。</li>
<li>对项目的进度没有很好的把握。</li>
<li>对技术较为熟悉之后可以适当的学习后期开发功能需要技术，比如一直没有研究彩信的技术实现，导致后期在开发彩信功能时遇到技术问题。如果能够提前学习相关技术就能够提前预支项目的风险。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>理解OverlayFS</title>
    <url>/post/overlayfs/</url>
    <content><![CDATA[<h2 id="docker-image结构"><a href="#docker-image结构" class="headerlink" title="docker image结构"></a>docker image结构</h2><p>docker可以通过命令<code>docker image inspect $&#123;image&#125;</code>来查看image的详细信息，其中包含了所使用的底层文件系统及各层的信息。</p>
<p>docker container的存储结构分为了只读层、init层和可读写层。</p>
<p>只读层跟docker image的层次结构恰好对应，主要包含操作系统的文件、配置、目录等信息，不包含操作系统镜像。</p>
<p>init层在只读层和读写层中间，用来专门存放&#x2F;etc&#x2F;hosts &#x2F;etc&#x2F;resolv.conf等信息，这些文件往往需要在启动的时候写入一些指定值，但不期望<code>docker commit</code>命令对其进行提交。</p>
<p>可读写层为容器在运行中可以进行写入的层。</p>
<h2 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h2><p><img src="https://arkingc.github.io/img/in-post/post-docker-filesystem/overlay_constructs.jpg" alt="image"></p>
<p>采用了两层结构，lowerdir为镜像层，只读。upperdir为容器层。</p>
<p>每层都会在&#x2F;var&#x2F;run&#x2F;docker&#x2F;overlay创建一个文件夹，文件夹中为实际层的内容，文件采用硬链接的方式链接到真实层中的文件，每一层都包含该层该拥有的所有文件，而该文件的真实存储可能是采用硬链接的方式链接到上层中的真实文件，因此比较耗费inode。</p>
<p>创建一个容器时，会新增两个目录，一个为读写层，一个为初始层。初始层中保存了容器初始化时的环境信息，如hostname、hosts文件等。读写层用于记录容器的所有改动。</p>
<h2 id="overlay2"><a href="#overlay2" class="headerlink" title="overlay2"></a>overlay2</h2><p>为了规避overlay消耗inode节点过多的问题，overlay2采用在每层中增加lower文件的方式来记录所有底层的信息，类似于链表的形式。</p>
<p><code>docker pull ubuntu</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost runc]# docker pull ubuntu</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">c64513b74145: Pull complete</span><br><span class="line">01b8b12bad90: Pull complete</span><br><span class="line">c5d85cf7a05f: Pull complete</span><br><span class="line">b6b268720157: Pull complete</span><br><span class="line">e12192999ff1: Pull complete</span><br><span class="line">Digest: sha256:3f119dc0737f57f704ebecac8a6d8477b0f6ca1ca0332c7ee1395ed2c6a82be7</span><br><span class="line">Status: Downloaded newer image for ubuntu:latest</span><br></pre></td></tr></table></figure>

<p>会在&#x2F;var&#x2F;run&#x2F;docker&#x2F;overlay2目录下创建如下文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost overlay2]# tree -L 2</span><br><span class="line">.</span><br><span class="line">|-- 664ae13f1c21402385076025d68476eb8d1cc4be6c6a218b24bd55217ac62672    // 第0层</span><br><span class="line">|   |-- diff</span><br><span class="line">|   `-- link    // MZUEUOFHBNVTRCJYJEG7QY4VWT</span><br><span class="line">|-- 783ad02709b67ac47b55198e9659c4592f0972334987ab97f42fd10f1784cbba    // 第2层</span><br><span class="line">|   |-- diff</span><br><span class="line">|   |-- link    // HXATFASQ4E2JBG434DUEN54EZZ</span><br><span class="line">|   |-- lower   // l/WUZC5WSTQTPJUJ4KFAYCUT5IPD:l/MZUEUOFHBNVTRCJYJEG7QY4VWT</span><br><span class="line">|   |-- merged</span><br><span class="line">|   `-- work</span><br><span class="line">|-- 89f7a20dda3d868840e20d9e8f1bfe20c5cca51c27b07825f100da0f474672f6    // 第3层</span><br><span class="line">|   |-- diff</span><br><span class="line">|   |-- link    // 5PHT7S3MCZTTQOXVPA4CKJRRFD</span><br><span class="line">|   |-- lower   // l/HXATFASQ4E2JBG434DUEN54EZZ:l/WUZC5WSTQTPJUJ4KFAYCUT5IPD:l/MZUEUOFHBNVTRCJYJEG7QY4VWT</span><br><span class="line">|   |-- merged</span><br><span class="line">|   `-- work</span><br><span class="line">|-- backingFsBlockDev</span><br><span class="line">|-- bad073a2d1f79a03af6caa0b3f51a22e6762cebbc0c30e45458fe6c1ff266f68    // 第4层</span><br><span class="line">|   |-- diff</span><br><span class="line">|   |-- link    // QMKHIPSDT4JTPE4FLT7QGJ33ND</span><br><span class="line">|   |-- lower   // l/5PHT7S3MCZTTQOXVPA4CKJRRFD:l/HXATFASQ4E2JBG434DUEN54EZZ:l/WUZC5WSTQTPJUJ4KFAYCUT5IPD:l/MZUEUOFHBNVTRCJYJEG7QY4VWT</span><br><span class="line">|   |-- merged</span><br><span class="line">|   `-- work</span><br><span class="line">|-- cb40b5b47c699050305676b35b1cea1ce08b38604dd68243c4be48934125b1a3    // 第1层</span><br><span class="line">|   |-- diff</span><br><span class="line">|   |-- link    // WUZC5WSTQTPJUJ4KFAYCUT5IPD</span><br><span class="line">|   |-- lower   // l/MZUEUOFHBNVTRCJYJEG7QY4VWT</span><br><span class="line">|   |-- merged</span><br><span class="line">|   `-- work</span><br><span class="line">`-- l</span><br><span class="line">    |-- 5PHT7S3MCZTTQOXVPA4CKJRRFD -&gt; ../89f7a20dda3d868840e20d9e8f1bfe20c5cca51c27b07825f100da0f474672f6/diff</span><br><span class="line">    |-- HXATFASQ4E2JBG434DUEN54EZZ -&gt; ../783ad02709b67ac47b55198e9659c4592f0972334987ab97f42fd10f1784cbba/diff</span><br><span class="line">    |-- MZUEUOFHBNVTRCJYJEG7QY4VWT -&gt; ../664ae13f1c21402385076025d68476eb8d1cc4be6c6a218b24bd55217ac62672/diff</span><br><span class="line">    |-- QMKHIPSDT4JTPE4FLT7QGJ33ND -&gt; ../bad073a2d1f79a03af6caa0b3f51a22e6762cebbc0c30e45458fe6c1ff266f68/diff</span><br><span class="line">    `-- WUZC5WSTQTPJUJ4KFAYCUT5IPD -&gt; ../cb40b5b47c699050305676b35b1cea1ce08b38604dd68243c4be48934125b1a3/diff</span><br></pre></td></tr></table></figure>

<p>l目录下为超链接，缩短后的目录，为了避免mount时超出页大小限制。</p>
<p>每一层中的diff文件夹包含实际内容。</p>
<p>每一层中都有一个link文件，内容为l目录中的超链接，超链接实际指向当前层目录中的diff文件夹。</p>
<p>除去最底层的目录外，其余每一层中包含一个lower文件，包含了该层的所有更底层名称和顺序，可以根据该文件构建出整个镜像的层次结构。</p>
<p>work目录用于OverlayFS内部使用。</p>
<p>最底层只有link文件，无lower文件，因此664ae13f1c21402385076025d68476eb8d1cc4be6c6a218b24bd55217ac62672为最底层。</p>
<p>以上五层为lower，只读。</p>
<p>当使用<code>docker run -it ubuntu:latest /bin/bash</code>启动一个容器后，在overlay2目录下会多出两个文件夹。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost overlay2]# tree -L 1 0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08-init 0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08 l</span><br><span class="line">0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08-init</span><br><span class="line">|-- diff</span><br><span class="line">|-- link    // ZJVMGTB2IOJ6QF57TYM5O7EWXW</span><br><span class="line">|-- lower   // l/QMKHIPSDT4JTPE4FLT7QGJ33ND:l/5PHT7S3MCZTTQOXVPA4CKJRRFD:l/HXATFASQ4E2JBG434DUEN54EZZ:l/WUZC5WSTQTPJUJ4KFAYCUT5IPD:l/MZUEUOFHBNVTRCJYJEG7QY4VWT</span><br><span class="line">|-- merged</span><br><span class="line">`-- work</span><br><span class="line">0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08</span><br><span class="line">|-- diff</span><br><span class="line">|-- link</span><br><span class="line">|-- lower   // l/ZJVMGTB2IOJ6QF57TYM5O7EWXW:l/QMKHIPSDT4JTPE4FLT7QGJ33ND:l/5PHT7S3MCZTTQOXVPA4CKJRRFD:l/HXATFASQ4E2JBG434DUEN54EZZ:l/WUZC5WSTQTPJUJ4KFAYCUT5IPD:l/MZUEUOFHBNVTRCJYJEG7QY4VWT</span><br><span class="line">|-- merged</span><br><span class="line">`-- work</span><br><span class="line">l</span><br><span class="line">|-- 5PHT7S3MCZTTQOXVPA4CKJRRFD -&gt; ../89f7a20dda3d868840e20d9e8f1bfe20c5cca51c27b07825f100da0f474672f6/diff</span><br><span class="line">|-- AOLYGFOHIAHWU5CBAJFULNAXI7 -&gt; ../0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08/diff</span><br><span class="line">|-- HXATFASQ4E2JBG434DUEN54EZZ -&gt; ../783ad02709b67ac47b55198e9659c4592f0972334987ab97f42fd10f1784cbba/diff</span><br><span class="line">|-- MZUEUOFHBNVTRCJYJEG7QY4VWT -&gt; ../664ae13f1c21402385076025d68476eb8d1cc4be6c6a218b24bd55217ac62672/diff</span><br><span class="line">|-- QMKHIPSDT4JTPE4FLT7QGJ33ND -&gt; ../bad073a2d1f79a03af6caa0b3f51a22e6762cebbc0c30e45458fe6c1ff266f68/diff</span><br><span class="line">|-- WUZC5WSTQTPJUJ4KFAYCUT5IPD -&gt; ../cb40b5b47c699050305676b35b1cea1ce08b38604dd68243c4be48934125b1a3/diff</span><br><span class="line">`-- ZJVMGTB2IOJ6QF57TYM5O7EWXW -&gt; ../0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08-init/diff</span><br></pre></td></tr></table></figure>

<p><code>0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08-init</code>用于存放容器初始化时的信息，通过下面查看更直观。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost overlay2]# tree 0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08-init</span><br><span class="line">0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08-init</span><br><span class="line">|-- diff</span><br><span class="line">|   |-- dev</span><br><span class="line">|   |   `-- console</span><br><span class="line">|   `-- etc</span><br><span class="line">|       |-- hostname</span><br><span class="line">|       |-- hosts</span><br><span class="line">|       |-- mtab -&gt; /proc/mounts</span><br><span class="line">|       `-- resolv.conf</span><br><span class="line">|-- link</span><br><span class="line">|-- lower</span><br><span class="line">|-- merged</span><br><span class="line">`-- work</span><br><span class="line">    `-- work</span><br></pre></td></tr></table></figure>

<p><code>0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08</code>的直接底层为init层，更详细的目录结构如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost overlay2]# tree -L 2  0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08</span><br><span class="line">0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08</span><br><span class="line">|-- diff</span><br><span class="line">|-- link</span><br><span class="line">|-- lower</span><br><span class="line">|-- merged</span><br><span class="line">|   |-- bin</span><br><span class="line">|   |-- boot</span><br><span class="line">|   |-- dev</span><br><span class="line">|   |-- etc</span><br><span class="line">|   |-- home</span><br><span class="line">|   |-- lib</span><br><span class="line">|   |-- lib64</span><br><span class="line">|   |-- media</span><br><span class="line">|   |-- mnt</span><br><span class="line">|   |-- opt</span><br><span class="line">|   |-- proc</span><br><span class="line">|   |-- root</span><br><span class="line">|   |-- run</span><br><span class="line">|   |-- sbin</span><br><span class="line">|   |-- srv</span><br><span class="line">|   |-- sys</span><br><span class="line">|   |-- tmp</span><br><span class="line">|   |-- usr</span><br><span class="line">|   `-- var</span><br><span class="line">`-- work</span><br><span class="line">    `-- work</span><br></pre></td></tr></table></figure>

<p>merged文件夹中内容较多，为overlay2的直接挂载点，对容器的修改会反应到该目录中。例如在容器中增加&#x2F;root&#x2F;hello.txt文件，在merged目录下会增加root&#x2F;hello.txt文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost overlay2]# mount  | grep overlay2</span><br><span class="line">/dev/mapper/centos-root on /var/lib/docker/overlay2 type xfs (rw,relatime,attr2,inode64,noquota)</span><br><span class="line">overlay on /var/lib/docker/overlay2/0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08/merged type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/ZJVMGTB2IOJ6QF57TYM5O7EWXW:/var/lib/docker/overlay2/l/QMKHIPSDT4JTPE4FLT7QGJ33ND:/var/lib/docker/overlay2/l/5PHT7S3MCZTTQOXVPA4CKJRRFD:/var/lib/docker/overlay2/l/HXATFASQ4E2JBG434DUEN54EZZ:/var/lib/docker/overlay2/l/WUZC5WSTQTPJUJ4KFAYCUT5IPD:/var/lib/docker/overlay2/l/MZUEUOFHBNVTRCJYJEG7QY4VWT,upperdir=/var/lib/docker/overlay2/0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08/diff,workdir=/var/lib/docker/overlay2/0326c1da0af912a6ea5efda77b65b04e796993e0f111ed8f262c55b2716f1c08/work)</span><br></pre></td></tr></table></figure>

<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">Use the OverlayFS storage driver</a></li>
<li><a href="https://arkingc.github.io/2017/05/05/docker-filesystem-overlay/">Docker存储驱动—Overlay&#x2F;Overlay2「译」</a></li>
</ul>
]]></content>
      <tags>
        <tag>overlay overlay2</tag>
      </tags>
  </entry>
  <entry>
    <title>ovs入门</title>
    <url>/post/ovs/</url>
    <content><![CDATA[<p>控制器向上提供接口，用来供应用程序调用，此接口成为北向接口；控制器向下调用接口，控制网络设备，此接口成为南向接口。</p>
<p>OpenFlow是控制器和网络设备之间互通的南向协议，OpenvSwitch 用于创建软件的虚拟交换机。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/ovs.jpg" alt="https://static001.geekbang.org/resource/image/d8/14/d870e5bfcad8ec45d146c3226cdccb14.jpg"></p>
<p>用户态进程</p>
<ul>
<li>ovsdb：本地数据库，存储ovs的配置信息</li>
<li>vswitchd：ovs-ofctl用来跟该命令通讯，下发流表规则</li>
</ul>
<h2 id="install-OpenvSwitch-on-CentOS-7"><a href="#install-OpenvSwitch-on-CentOS-7" class="headerlink" title="install OpenvSwitch on CentOS 7"></a>install OpenvSwitch on CentOS 7</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装依赖</span><br><span class="line">yum install openssl-devel  python-sphinx gcc make python-devel openssl-devel kernel-devel graphviz kernel-debug-devel autoconf automake rpm-build redhat-rpm-config libtool python-twisted-core python-zope-interface PyQt4 desktop-file-utils libcap-ng-devel groff checkpolicy selinux-policy-devel gcc-c++ python-six unbound unbound-devel -y</span><br><span class="line"></span><br><span class="line">mkdir -p ~/rpmbuild/SOURCES &amp;&amp; cd ~/rpmbuild/SOURCES</span><br><span class="line"># 下载ovs源码</span><br><span class="line">wget https://www.openvswitch.org/releases/openvswitch-2.12.0.tar.gz</span><br><span class="line"></span><br><span class="line">tar zvxf openvswitch-2.12.0.tar.gz</span><br><span class="line"># 构建rpm包</span><br><span class="line">rpmbuild -bb --nocheck openvswitch-2.12.0/rhel/openvswitch-fedora.spec</span><br><span class="line"></span><br><span class="line"># 安装rpm包</span><br><span class="line">yum localinstall /root/rpmbuild/RPMS/x86_64/openvswitch-2.12.0-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">systemctl start openvswitch.service</span><br></pre></td></tr></table></figure>

<p>在编译的时候有如下报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  File &quot;/usr/lib64/python2.7/site-packages/jinja2/sandbox.py&quot;, line 22, in &lt;module&gt;</span><br><span class="line">    from markupsafe import EscapeFormatter</span><br><span class="line">ImportError: cannot import name EscapeFormatter</span><br></pre></td></tr></table></figure>

<p>是因为markupsafe的版本不对导致的，解决方法为安装合适的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip uninstall markupsafe</span><br><span class="line">pip install markupsafe==0.23</span><br></pre></td></tr></table></figure>

<h2 id="vlan实验"><a href="#vlan实验" class="headerlink" title="vlan实验"></a>vlan实验</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建虚拟交换机ovs_br</span><br><span class="line">ovs-vsctl add-br ovs_br</span><br><span class="line">ovs-vsctl add-port ovs_br first_port</span><br></pre></td></tr></table></figure>

<h2 id="flow-table试验-1"><a href="#flow-table试验-1" class="headerlink" title="flow table试验 1"></a>flow table试验 1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建namespace</span><br><span class="line">ip netns add ns1</span><br><span class="line">ip netns add ns2</span><br><span class="line"></span><br><span class="line"># 创建veth pair设备</span><br><span class="line">ip link add veth1 type veth peer name veth1_br</span><br><span class="line">ip link add veth2 type veth peer name veth2_br</span><br><span class="line"></span><br><span class="line"># 设置veth pair设备的namespace</span><br><span class="line">ip link set veth1 netns ns1</span><br><span class="line">ip link set veth2 netns ns2</span><br><span class="line"></span><br><span class="line"># 创建OVS网桥</span><br><span class="line">ovs-vsctl add-br ovs1</span><br><span class="line"></span><br><span class="line"># 将veth pair设备另一端绑到网桥ovs1</span><br><span class="line">ovs-vsctl add-port ovs1 veth1_br</span><br><span class="line">ovs-vsctl add-port ovs1 veth2_br</span><br><span class="line"></span><br><span class="line"># 启动veth pair</span><br><span class="line">ip netns exec ns1 ip link set veth1 up</span><br><span class="line">ip netns exec ns2 ip link set veth2 up</span><br><span class="line">ip link set veth1_br up</span><br><span class="line">ip link set veth2_br up</span><br><span class="line"></span><br><span class="line"># 设置veth1和veth2的ip地址</span><br><span class="line">ip netns exec ns1 ip addr add 192.168.1.100 dev veth1</span><br><span class="line">ip netns exec ns2 ip addr add 192.168.1.200 dev veth2</span><br><span class="line"></span><br><span class="line"># 配置路由</span><br><span class="line">ip netns exec ns1 route add -net 192.168.1.0 netmask 255.255.255.0 dev veth1</span><br><span class="line">ip netns exec ns2 route add -net 192.168.1.0 netmask 255.255.255.0 dev veth2</span><br></pre></td></tr></table></figure>

<p>可以使用如下命令来查看刚才的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可以看到刚才创建的网桥</span><br><span class="line">$ ovs-vsctl list-br</span><br><span class="line">ovs1</span><br><span class="line"></span><br><span class="line"># 查看网桥的端口</span><br><span class="line">$ ovs-vsctl list-ports ovs1</span><br><span class="line">veth1_br</span><br><span class="line">veth2_br</span><br><span class="line"></span><br><span class="line"># 查看网桥的状态</span><br><span class="line">$ ovs-vsctl show</span><br><span class="line">4ec35070-a763-4748-878a-c3784b5938a4</span><br><span class="line">    Bridge &quot;ovs1&quot;</span><br><span class="line">        Port &quot;veth1_br&quot;</span><br><span class="line">            Interface &quot;veth1_br&quot;</span><br><span class="line">        Port &quot;ovs1&quot;</span><br><span class="line">            Interface &quot;ovs1&quot;</span><br><span class="line">                type: internal</span><br><span class="line">        Port &quot;veth2_br&quot;</span><br><span class="line">            Interface &quot;veth2_br&quot;</span><br><span class="line">    ovs_version: &quot;2.12.0&quot;</span><br><span class="line"></span><br><span class="line"># 查看interface的状态，跟port是一一对应的</span><br><span class="line">$ ovs-vsctl list interface veth1_br</span><br><span class="line">...</span><br><span class="line">mac                 : []</span><br><span class="line">mac_in_use          : &quot;32:13:6b:99:91:2b&quot;</span><br><span class="line">mtu                 : 1500</span><br><span class="line">mtu_request         : []</span><br><span class="line">name                : &quot;veth1_br&quot;</span><br><span class="line">ofport              : 1 # ovs port编号</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接下来测试一下网络的连通性是没问题的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip netns exec ns1 ping 192.168.1.200</span><br></pre></td></tr></table></figure>

<p>查看当前流表，可以看到有一条默认的规则，该条规则用来实现交换机的基本动作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ovs-ofctl dump-flows ovs1</span><br><span class="line"> cookie=0x0, duration=1428.955s, table=0, n_packets=22, n_bytes=1676, priority=0 actions=NORMAL</span><br></pre></td></tr></table></figure>

<p>将上述规则删除，再执行ping命令发现已经不通。说明该默认规则会将流量在端口之间进行转发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ovs-ofctl del-flows ovs1</span><br></pre></td></tr></table></figure>

<p>新增加如下两条规则，用来表示将port 1的流量转发到port 3，将port 3的流量转发到port 1。其中的1和3分别为port编号，使用<code>ovs-vsctl list interface veth1_br</code>命令中的ofport可以看到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ovs-ofctl add-flow ovs1 &quot;priority=1,in_port=1,actions=output:3&quot;</span><br><span class="line">ovs-ofctl add-flow ovs1 &quot;priority=2,in_port=3,actions=output:1&quot;</span><br><span class="line"></span><br><span class="line">$ ovs-ofctl dump-flows ovs1</span><br><span class="line"> cookie=0x0, duration=69.378s, table=0, n_packets=4, n_bytes=280, priority=1,in_port=&quot;veth1_br&quot; actions=output:&quot;veth2_br&quot;</span><br><span class="line"> cookie=0x0, duration=69.063s, table=0, n_packets=4, n_bytes=280, priority=2,in_port=&quot;veth2_br&quot; actions=output:&quot;veth1_br&quot;</span><br></pre></td></tr></table></figure>

<p>再执行ping命令，发现可以ping通了。</p>
<p>重新增加一条优先级更高的规则，将port 1的数据drop掉。此时再ping发现已经不通了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ovs-ofctl add-flow ovs1 &quot;priority=3,in_port=1,actions=drop&quot;</span><br></pre></td></tr></table></figure>

<h3 id="多table"><a href="#多table" class="headerlink" title="多table"></a>多table</h3><p>接下来清理掉规则，并将规则重新写入到table1中，默认规则是写入到table0中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ovs-ofctl del-flows ovs1</span><br><span class="line">ovs-ofctl add-flow ovs1 &quot;table=1,priority=1,in_port=1,actions=output:3&quot;</span><br><span class="line">ovs-ofctl add-flow ovs1 &quot;table=1,priority=2,in_port=3,actions=output:1&quot;</span><br></pre></td></tr></table></figure>

<p>此时再执行ping命令，发现网络是不通的。因为table0中没有匹配成功，包被drop掉了。</p>
<p>再增加如下规则，即将table 0的规则发送到table 1处理，此时可以ping通。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ovs-ofctl add-flow ovs1 &quot;table=0,actions=goto_table=1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="group-table"><a href="#group-table" class="headerlink" title="group table"></a>group table</h3><p>执行<code>ovs-ofctl del-flows ovs1</code>重新清理掉规则，执行下面命令查看group table内容，可以看到内容为空。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ovs-ofctl -O OpenFlow13 dump-groups ovs1</span><br><span class="line">OFPST_GROUP_DESC reply (OF1.3) (xid=0x2):</span><br></pre></td></tr></table></figure>

<p>执行如下命令，完成数据包从table0 -&gt; group table -&gt; table1的过程，真正数据处理在table1中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个group table，其作用为将数据包发送到table 1</span><br><span class="line">ovs-ofctl add-group ovs1 &quot;group_id=1,type=select,bucket=resubmit(,1)&quot;</span><br><span class="line"></span><br><span class="line"># 将port 1和3 的数据发往group table 1</span><br><span class="line">ovs-ofctl add-flow ovs1 &quot;table=0,in_port=1,actions=group:1&quot;</span><br><span class="line">ovs-ofctl add-flow ovs1 &quot;table=0,in_port=3,actions=group:1&quot;</span><br><span class="line"></span><br><span class="line"># table 1为真正要处理数据的逻辑</span><br><span class="line">ovs-ofctl add-flow ovs1 &quot;table=1,priority=1,in_port=1,actions=output:3&quot;</span><br><span class="line">ovs-ofctl add-flow ovs1 &quot;table=1,priority=2,in_port=3,actions=output:1&quot;</span><br></pre></td></tr></table></figure>

<p>此时再执行ping命令，发现是可以ping通的。</p>
<h3 id="清理操作"><a href="#清理操作" class="headerlink" title="清理操作"></a>清理操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除网桥</span><br><span class="line">ovs-vsctl del-br ovs1</span><br><span class="line">ip link delete veth1_br</span><br><span class="line">ip link delete veth2_br</span><br><span class="line">ip netns del ns1</span><br><span class="line">ip netns del ns2</span><br></pre></td></tr></table></figure>

<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul>
<li><code>ovs-appctl fdb/show ovs1</code>: 查看mac地址表</li>
<li><code>ovs-ofctl show ovs1</code>: 可以查看网桥的端口号</li>
<li><code>ovs-vsctl set bridge ovs1 stp_enable=false</code>: 开启网桥的生成树协议</li>
<li><code>ovs-appctl ofproto/trace ovs1 in_port=1,dl_dst=7a:42:0a:ca:04:65</code>: 可用来验证一个包到达网桥后的处理流程</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/63114462">CentOS 7 安装 Open vSwitch</a></li>
<li><a href="https://zpzhou.com/archives/ovs_flow.html">OpenvSwitch初探 - FLOW篇</a></li>
<li><a href="https://kb.juniper.net/InfoCenter/index?page=content&id=KB32283&actp=METADATA">Open vSwitch (OVS) commands for troubleshooting</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>两个通过http获取指定网页内容并解析的简单程序</title>
    <url>/post/parse_http/</url>
    <content><![CDATA[<p>近段时间写了两个通过http协议来获取指定网页的内容并将内容解析出来的程序。程序一可以解析出目前本博客的内容页面的内容、时间、访问次数参数，采用Qt类库实现；程序二可以解析出新浪博客页面的内容、时间等参数，采用Linux下的tcp相关API实现。均采用C++语言实现。</p>
<h1 id="程序一"><a href="#程序一" class="headerlink" title="程序一"></a>程序一</h1><p>该程序采用Qt类库实现，其中Http协议的发送和接收采用Qt类库封装的类，网页内容的解析采用Qt封装的解析XML的相关类。<br>该程序仅能解析标准的Html语言，对于网页中的所有”&lt;&gt;”标签必须有结尾才行。例如本页面源码中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>必须是闭合的。如果是下面这样则无法正确解析网页内容，这是由于采用的Qt类库决定的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;</span><br></pre></td></tr></table></figure>

<h1 id="程序二"><a href="#程序二" class="headerlink" title="程序二"></a>程序二</h1><p>该程序的Http协议部分采用Linux的tcp协议api实现，解析网页直接采用搜索字符串的方式实现，较上一种方式要底层，仅能运行在Linux系统下运行。</p>
<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a href="http://pan.baidu.com/share/link?shareid=1578018382&uk=3506813023">程序一和二的下载链接</a></p>
]]></content>
  </entry>
  <entry>
    <title>我要看电视 - 将树莓派 5 打造成 Android TV 电视盒子折腾记（1）</title>
    <url>/post/pi5-1/</url>
    <content><![CDATA[<p>在上一篇文章 《<a href="/post/watch-tv/">我要看电视 - 投影仪和电视盒子选型</a>》中，提到了用树莓派 5 来作为电视盒子，需要刷 Android TV 系统，本文将详细介绍折腾经历。<br>在这之前我并没有接触过树莓派，Android 系统倒是曾经刷过机，但也了解不深。文中如有不正确的地方，欢迎指正。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>要想折腾树莓派，还是需要一点点设备，我使用到的设备清单如下：</p>
<ol>
<li>一台 Mac 笔记本电脑：用来下载镜像、烧录景象、远程连接电视盒子等。其他操作系统的电脑均可。</li>
<li>一个 32G SD 卡：用来作为树莓派的存储系统 RAM。</li>
<li>一个 SD 读卡器：用来读取 SD 卡，供电脑烧录系统使用。</li>
<li>一个 U 盘：该 U 盘并非树莓派的 SD 卡，而是作为树莓派的额外存储，用来向树莓派中复制文件。</li>
<li>一台显示器：用来显示树莓派的内容，也可以是电视或者投影仪等设备。</li>
<li>一个 USB 键盘：用来连接树莓派进行操作。</li>
<li>一个 USB 鼠标：用来连接树莓派进行操作。</li>
<li>一个蓝牙遥控器：用来连接树莓派的 Android TV 系统。我直接使用了家里办宽带送的移动电视盒子的遥控器。</li>
<li>一根 HDMI 数据线：其中一头为 Micro HDMI，用来连接树莓派，另外一头为标准 HDMI 口，用来连接显示器。</li>
</ol>
<p>另外：</p>
<ol>
<li>网络需要能够访问 Google 等网站。</li>
</ol>
<h1 id="寻找-Android-TV-系统"><a href="#寻找-Android-TV-系统" class="headerlink" title="寻找 Android TV 系统"></a>寻找 Android TV 系统</h1><p>找到树莓派对应的 Android TV 镜像是非常重要的前提，找到合适的 ROM 永远是 Android 系统刷机中非常重要的一环，一般每个设备总有那么几个大神在提供各类 ROM。<br>查找一个设备的资源最快的方式就是去 github.com 上查找 awesome，树莓派的项目地址为：<a href="https://github.com/thibmaek/awesome-raspberry-pi">awesome-raspberry-pi</a>。在 OS Images 章节中包含了支持树莓派的多种 OS，单纯搜索 Android TV 并不能找到对应的 OS，但实际上 <a href="https://konstakang.com/devices/rpi4/">KonstaKANG</a> 对应就是 Android 镜像，这是文档不好的地方，并没有将简介写清楚。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/konstakang-1.png" alt="image.png"></p>
<p><a href="https://konstakang.com/devices/rpi4/">KonstaKANG</a> 并非一个系统，而是一个网站，包含了多种设备的 OS 镜像。对应的 <a href="https://konstakang.com/devices/rpi5/">Raspberry 5</a> 的页面包含了 AOSP 和 LineageOS 两种 OS 镜像，AOSP 和 LineageOS 均为 android 的发型版。但只提供了 LineageOS 20 一个 Android TV 的版本，剩下的两个为 Android 版本。Android TV 和 Android 并非同一个系统，Android TV 是针对电视使用的系统，而 Android 是针对智能手机和平板使用的系统，用户体验上还是有较大区别。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/konstakang-2.png" alt="image.png"><br>因此，<a href="https://konstakang.com/devices/rpi5/LineageOS20-ATV/">LineageOS 20 Android TV (Android 13) </a>即变为了目前唯一一个可以在树莓派 5 上使用 Android TV 系统，除此之外，别无他选。无论该系统是否完善，这就是目前的唯一选择了。在文章中介绍了非常多的系统方面的支持，建议精读一遍，包括文章后面的评论。<br>文中的两个镜像，一个是原始镜像，另外一个是 ota 补丁包，两个均需要安装。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/konstakang-3.png" alt="image.png"></p>
<h1 id="用到的文件"><a href="#用到的文件" class="headerlink" title="用到的文件"></a>用到的文件</h1><p>由于在国内下载非常不稳定，通常需要魔法下载，我将需要用到的文件上传到云盘供下载使用。我对部分软件的用途一知半解，但我知道安装了应该没有坏处，选择全部安装。</p>
<ul>
<li><a href="https://pan.baidu.com/s/1pgGB_h2bUhq9iUXHrosW9w?pwd=rgad">lineage-20.0-20240112-UNOFFICIAL-KonstaKANG-rpi5-atv.zip</a> 提取码：rgad</li>
<li><a href="https://pan.baidu.com/s/15RAKHM2q6pOGSt0a8jfJUg?pwd=3t4m">lineage-20.0-20240112-UNOFFICIAL-KonstaKANG-rpi5-atv-ota.zip</a> 提取码: 3t4m</li>
<li><a href="https://pan.baidu.com/s/1HWv0P22uAH2eavIycuaf1A?pwd=33wj">MindTheGapps-13.0.0-arm64-ATV-full-20240104_210039.zip</a> 提取码：33wj</li>
<li><a href="https://pan.baidu.com/s/1z0NcAlssVKPwav7RZTIUNg?pwd=c6ja">lineage-20.0-rpi-resize.zip</a> 提取码：c6ja</li>
<li><a href="https://androidfilehost.com/?fid=14871746926876846664#google_vignette">lineage-20.0-rpi-magisk-v25.2.zip</a></li>
<li><a href="https://androidfilehost.com/?fid=11701882489785033173">lineage-20.0-rpi-widevine.zip</a></li>
<li><a href="https://github.com/topjohnwu/Magisk/releases/tag/v25.2">Magisk-v25.2.apk</a></li>
<li><a href="https://androidfilehost.com/?fid=11701882489785033172">lineage-20.0-rpi-gsfaid.zip</a></li>
</ul>
<h1 id="刷-LineageOS-到树莓派"><a href="#刷-LineageOS-到树莓派" class="headerlink" title="刷 LineageOS 到树莓派"></a>刷 LineageOS 到树莓派</h1><p>树莓派官方提供了镜像烧录工具 <a href="https://www.raspberrypi.com/software/">Imager</a>，支持 Windows、Ubuntu、Mac，刷机非常方便。<img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/imager.png" alt="image.png"><br>将树莓派的 SD 插入到电脑，在 <code>Raspberry Pi Device</code> 中选择 <code>RASPBERRY PI 5</code>，在<code>请选择需要写入的操作系统</code>中使用 <code>Use custom</code> 选项选择已经下载好的文件 lineage-20.0-20240112-UNOFFICIAL-KonstaKANG-rpi5-atv.zip，选择对应的 SD 卡，再点击 <code>Next</code> 即可开始将镜像写入到SD 卡中。<br>值得一提的是，对于树莓派其他的系统，都不需要事先下载，选择系统后，该工具可以自动下载最新版本，这个功能还是非常值得👍。</p>
<h1 id="LineageOS-初步体验及初步设置"><a href="#LineageOS-初步体验及初步设置" class="headerlink" title="LineageOS 初步体验及初步设置"></a>LineageOS 初步体验及初步设置</h1><p>在将系统刷入 SD 卡后，即可将 SD 卡放到树莓派 5 中，在树莓派中连接好键盘和鼠标。<br>下面步骤中可能会用到键盘的一些快捷键：F1 &#x3D; Home, F2 &#x3D; Back, F3 &#x3D; Multi-tasking, F4 &#x3D; Menu, F5 &#x3D; Power, F11 &#x3D; Volume down, and F12 &#x3D; Volume up<br>开机后即可看到 LineageOS 的开机动画。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-1.png" alt="image.png"></p>
<p>接下来就会看到查找蓝牙设备的界面，这里可以选择等待一会后自动跳过。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-2.png" alt="image.png"></p>
<p>接下来就来到了 Welcome 的界面，点击 <code>Start</code>。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-3.png" alt="image.png"></p>
<p>接下来会进入到选择语言、连接 WIFI 等操作，完成后即可进入到操作系统界面。操作系统界面可谓简洁到不能再精简，只有一个文件的应用。左上角的语音和搜索功能均不能使用。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-4.png" alt="image.png"></p>
<p>但设置功能作为 Android 系统的核心，这部分功能一点都不会少。在设置中连接  Wifi 后发现会持续断开，不知道是否为系统的问题。</p>
<p>打开 Recovery 模式：设置 -&gt; 系统 -&gt; Buttons，打开右侧的 Advanced restart。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-5.png" alt="image.png"></p>
<p>打开开发者模式：设置 -&gt; 系统 -&gt; 关于 -&gt; Android TV 操作系统版本，连续点击键盘的回车键，会提示开发者模式已打开。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-6.png" alt="image.png"></p>
<p>打开 Rooted debug：设置 -&gt; 系统 -&gt; 开发者选项 -&gt; 打开 <code>USB 调试</code>、<code>Rooted debugging</code>、<code>ADB over network</code> 三个选项。</p>
<p>打开树莓派的 SSH 服务：设置 -&gt; 系统 -&gt; Raspberry Pi Settings 中将 SSH 服务打开。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-7.png" alt="image.png"></p>
<h1 id="刷入-ota-包"><a href="#刷入-ota-包" class="headerlink" title="刷入 ota 包"></a>刷入 ota 包</h1><p>接下来选择刷入 OTA 包 <a href="https://pan.baidu.com/s/15RAKHM2q6pOGSt0a8jfJUg?pwd=3t4m">lineage-20.0-20240112-UNOFFICIAL-KonstaKANG-rpi5-atv-ota.zip</a>，ota 包不会用到树莓派镜像烧录器，而是要通过Android Recovery 模式刷入。需要事先准备好 OTA 包，并将其复制到 U 盘中，并将 U 盘插入到树莓派中。</p>
<p>在 Android 系统设置 -&gt; 系统 -&gt; 重新启动中选择 Recovery，此时系统会重启进入到 Recovery 模式。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/ota-1.png" alt="image.png"></p>
<p>点击 <code>Install</code>，并选择右下角的 <code>Select Storage</code> 按钮，选择 USB 存储，即刚插入的 U 盘。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/ota-2.png" alt="image.png"></p>
<p>在 U 盘中选择要刷入的 ota 补丁，取消 <code>Zip signature verification</code>。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/ota-3.png" alt="image.png"></p>
<p>在 <code>Swipe to confirm Flash</code>处向右滑动鼠标，即可进入到安装 ota 补丁的界面。ota 补丁安装完成后，即可自动重启进入到 Android TV 系统中。重新进入系统后，发现系统的界面没有任何变化，不知道该 ota 补丁的具体影响功能。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/ota-4.png" alt="image.png"></p>
<h1 id="系统存储空间设置"><a href="#系统存储空间设置" class="headerlink" title="系统存储空间设置"></a>系统存储空间设置</h1><p>在默认的情况下，打开设置 -&gt; 存储空间，可以看到内部共享存储空间仅为 4.7 GB，这里的存储空间为 &#x2F;data 目录挂载的设备，并没有将 U 盘的空间全部使用起来，U 盘剩余的磁盘空间处于未分配状态。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-8.png" alt="image.png"></p>
<p>这里使用 <a href="https://pan.baidu.com/s/1z0NcAlssVKPwav7RZTIUNg?pwd=c6ja">lineage-20.0-rpi-resize.zip</a> 工具来修改存储空间，按照刷入 ota 包相同的方式，进入 Recovery 模式下刷入该包，重新进入系统后即发现存储空间已经变大。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-9.png" alt="image.png"></p>
<h1 id="安装-adb-工具"><a href="#安装-adb-工具" class="headerlink" title="安装 adb 工具"></a>安装 adb 工具</h1><p>前置条件：开发者选项中的 ADB over network 必须为开启状态。</p>
<p>adb 命令需要安装到电脑上，在 mac 下使用 <code>brew install android-platform-tools</code>即可安装完成。</p>
<p>在 android tv 上查看当前的 ip 地址，我这里为 192.168.31.167。执行 <code>adb connect 192.168.31.167</code> 后即可获取到 USB 调试信息，并选中<code>一律允许使用这台计算机进行调试处</code>后点击允许。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-10.png" alt="image.png"><br>此时在终端中即可显示出连接成功的信息：<code>already connected to 192.168.31.167:5555</code>。</p>
<p>在安装完 adb 工具后，即可以通过 adb 命令来远程访问 Android TV 系统了。例如：</p>
<ul>
<li><code>adb install</code> 可以安装 apk 包。</li>
<li><code>adb shell settings list global</code> 命令来查看 Android 系统的所有global 配置。</li>
<li><code>adb logcat</code> 查看 android 的日志。</li>
</ul>
<h1 id="安装-Google-Apps"><a href="#安装-Google-Apps" class="headerlink" title="安装 Google Apps"></a>安装 Google Apps</h1><blockquote>
<p>注意：此处要求网络具备魔法，可以访问 Google</p>
</blockquote>
<h2 id="刷入-Google-Apps-包"><a href="#刷入-Google-Apps-包" class="headerlink" title="刷入 Google Apps 包"></a>刷入 Google Apps 包</h2><p>Google Apps 包为必须用到的包，通过 Recovery 模式刷入包 <code>MindTheGapps-13.0.0-arm64-ATV-full-20240104_210039.zip</code>。包安装完成后，重新进入系统发现界面发生了变化，多出了应用 Google Play Store，左上角的语音和搜索功能虽然不可以用，但是点击后提示信息已经发生了变化。</p>
<blockquote>
<p>原来的文件应用在这里消失不见了，实际上在所有应用中还可以找到。</p>
</blockquote>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-11.png" alt="image.png"><br>在系统中使用 Google 账号登录 Google Play Store，即使在可以访问 Google 的网络下，发现也一直会失败。</p>
<h2 id="查询并注册-Android-ID"><a href="#查询并注册-Android-ID" class="headerlink" title="查询并注册 Android ID"></a>查询并注册 Android ID</h2><p>因为该 Android TV 设备并不被信任，需要将 Android ID 在 Android 网站注册。如果不注册，那么 Google 账号登录不成功。<br>将树莓派的 SD 卡插入到笔记本，查看 SD 卡中的文件 gsf-android_id.txt，该文件对应的内容即为 Android ID。<br>还有另外一种办法可以获取到 Android ID，在笔记本上通过 adb 命令查询到当前设备的 Android ID。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line"># 找到 google service 的 sqlite3 数据库文件</span><br><span class="line">adb shell &#x27;find /data -name &quot;gservices.db&quot;&#x27;</span><br><span class="line"></span><br><span class="line"># 通过数据库查询到 android id</span><br><span class="line"># 其中 sqlite3 命令后的为上面步骤查询出的文件路径，如果查询出多个，可以任选一个</span><br><span class="line">adb shell &#x27;sqlite3 /data/data/com.google.android.gsf/databases/gservices.db &quot;select * from main where name = \&quot;android_id\&quot;;&quot;&#x27;</span><br></pre></td></tr></table></figure>

<p>将上述 Android ID 在网站进行注册，网址：<a href="https://www.google.com/android/uncertified/">https://www.google.com/android/uncertified/</a><br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-12.png" alt="image.png"></p>
<h2 id="使用-Google-账号登录"><a href="#使用-Google-账号登录" class="headerlink" title="使用 Google 账号登录"></a>使用 Google 账号登录</h2><p>重新进入 Recovery 模式，点击 Wipe -&gt; Factory reset，此时机器会进行重启。该操作会清空系统中的 &#x2F;data&#x2F;media 下的内容。(还不太清楚该步骤是否为必须操作)<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-13.png" alt="image.png"></p>
<p>机器重新后会重新进入一遍系统的初始化，但现在的初始化界面跟最初的 LineageOS 的初始化有所不同，进入到了 GMS 的开机引导，该步骤中必须要登录到 Google 账号，而且无法跳过。如果 Android ID 没有注册，此时登录 Google 账号一直会失败，导致无法进入到系统中。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-14.png" alt="image.png"></p>
<p>登录完成后在首页可以看到了更多的一些信息：<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-15.png" alt="image.png"></p>
<h1 id="通过-Recovery-刷入其他包"><a href="#通过-Recovery-刷入其他包" class="headerlink" title="通过 Recovery 刷入其他包"></a>通过 Recovery 刷入其他包</h1><p>widevine 是在 Android 生态下跟数字版权相关的包，通过 Recovery 模式刷入包 lineage-20.0-rpi-widevine.zip。</p>
<p>通过 Recovery 模式刷入包 lineage-20.0-rpi-magisk-v25.2.zip，进入到 Android TV 系统后通过文件工具安装包 Magisk-v25.2.apk。</p>
<h1 id="解决网络连接受限"><a href="#解决网络连接受限" class="headerlink" title="解决网络连接受限"></a>解决网络连接受限</h1><p>如果本地的网络无法访问 Google，默认情况下，网络会提示<code>网络连接受限</code>，原因主要还是跟访问不了 Google 的域名有关，以至于 Android TV 系统不能识别出可以连接互联网。<br><img src="https://kuring.oss-cn-beijing.aliyuncs.com/raspberry/lineage-16.png" alt="image.png"></p>
<p>网络连接受限状态的 WIFI，经测试机器重启后无法自动连接，需要每次都手工连接 WIFI。</p>
<p>执行如下的命令来系统进行设置：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">adb connect <span class="number">192.168</span>.<span class="number">31.166</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置时间服务器</span></span><br><span class="line">adb shell settings put global ntp_server ntp1.aliyun.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该值默认为 0</span></span><br><span class="line">adb shell settings put global captive_portal_detection_enabled <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认没有这两个值</span></span><br><span class="line">adb shell settings put global captive_portal_https_url https://connect.rom.miui.com/generate_204</span><br></pre></td></tr></table></figure>
<p>设置完成后重启系统，即可看到网络的连接受限已经消除，并且 WIFI 已经可以自动连接了。</p>
<h1 id="常用-apk-软件安装"><a href="#常用-apk-软件安装" class="headerlink" title="常用 apk 软件安装"></a>常用 apk 软件安装</h1><p>我这里使用了 <a href="https://kxsw.gitbook.io/tv/">https://kxsw.gitbook.io/tv/</a> 中的方法安装了 File Commands 和 Clash 软件。File Commands  可以用来管理本地的文件，甚至可以提供 HTTP Server，供远程来下载或者上传文件。<br>国内的常见应用在 Google Play Store 中并不存在，而且通过 Google Play Store 直接安装应用很可能会失败，跟使用的网络有很大关系。国内的应用我直接使用了当贝市场来安装电视应用即可。</p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="听不到声音"><a href="#听不到声音" class="headerlink" title="听不到声音"></a>听不到声音</h2><p>在播放视频时发现听不到声音，原因是因为默认情况下使用了 hdmi0 接口来输入声音，通过 hdmi1 只能输出视频信号，没有声音。将 hdmi 线切换到 hdmi0 口后并重启系统后，声音即正常。</p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>到目前为止，树莓派已经具备了完整的 Android TV 系统的功能，而且使用起来还比较稳定，这一点超出了我的预期，毕竟树莓派 5 比较新，该系统出来的时间比较短。<br>后面我计划使用新的文章来记录使用体验，以及新的折腾经历，比如：如何通过遥控器实现正常的开关机。<br>敬请期待。。。</p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ul>
<li><a href="https://blog.csdn.net/u013120422/article/details/132107317">https://blog.csdn.net/u013120422/article/details/132107317</a></li>
<li><a href="https://konstakang.com/devices/rpi5/LineageOS20-ATV/">https://konstakang.com/devices/rpi5/LineageOS20-ATV/</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>内存使用分析</title>
    <url>/post/pod-memory-stats/</url>
    <content><![CDATA[<h2 id="操作系统级别"><a href="#操作系统级别" class="headerlink" title="操作系统级别"></a>操作系统级别</h2><h3 id="x2F-proc-x2F-meminfo"><a href="#x2F-proc-x2F-meminfo" class="headerlink" title="&#x2F;proc&#x2F;meminfo"></a>&#x2F;proc&#x2F;meminfo</h3><p>其中的Buffers和Cached的迷惑性非常大，非常难理解。Buffers是指的磁盘数据的缓存，Cached是指对文件数据的缓存.</p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>该命令实际上是通过读取&#x2F;proc&#x2F;meminfo文件得到的如下输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            30G         22G        412M         47M        7.6G        7.3G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure>

<p>具体列含义：</p>
<ul>
<li>total: 总内存大小</li>
<li>used：已经使用的内存大小，包含共享内存</li>
<li>free：未使用的内存大小</li>
<li>shared：共享内存大小</li>
<li>buff&#x2F;cache：缓存和缓冲区的大小</li>
<li>available：新进程可用的内存大小</li>
</ul>
<h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vmstat 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 4  0      0 1091484 1142360 34545436    0    0   146   265    0    0  8  5 86  1  0</span><br></pre></td></tr></table></figure>

<h2 id="容器级别"><a href="#容器级别" class="headerlink" title="容器级别"></a>容器级别</h2><h3 id="通过kubectl命令来查看内存使用"><a href="#通过kubectl命令来查看内存使用" class="headerlink" title="通过kubectl命令来查看内存使用"></a>通过kubectl命令来查看内存使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl top pod nginx-ingress-controller-85cd6c7b5d-md6vc</span><br><span class="line">NAME                                        CPU(cores)   MEMORY(bytes)</span><br><span class="line">nginx-ingress-controller-85cd6c7b5d-md6vc   22m          502Mi</span><br></pre></td></tr></table></figure>

<h3 id="通过docker-stats命令来查看容器"><a href="#通过docker-stats命令来查看容器" class="headerlink" title="通过docker stats命令来查看容器"></a>通过docker stats命令来查看容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker stats $container_id</span><br><span class="line">CONTAINER ID  NAME                CPU %   MEM USAGE / LIMIT   MEM %  NET I/O   BLOCK I/O           PIDS</span><br><span class="line">97d8bff3f89f  k8s_nginx-ingress   6.33%   180.3MiB / 512MiB   35.21% 0B / 0B   0B / 0B             119</span><br></pre></td></tr></table></figure>

<p>docker通过cgroup的统计数据来获取的内存值</p>
<p>参考文档：<a href="https://docs.docker.com/engine/reference/commandline/stats/">https://docs.docker.com/engine/reference/commandline/stats/</a></p>
<h2 id="进程级别"><a href="#进程级别" class="headerlink" title="进程级别"></a>进程级别</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/vm-1.png"></p>
<p>具体的含义可以通过下文的&#x2F;proc&#x2F;$pid&#x2F;status来查看，其他进程的内存含义</p>
<h3 id="cat-x2F-proc-x2F-pid-x2F-status"><a href="#cat-x2F-proc-x2F-pid-x2F-status" class="headerlink" title="cat &#x2F;proc&#x2F;$pid&#x2F;status"></a>cat &#x2F;proc&#x2F;$pid&#x2F;status</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat status</span><br><span class="line">Name:   nginx</span><br><span class="line">Umask:  0022</span><br><span class="line">State:  S (sleeping)</span><br><span class="line">Tgid:   46787</span><br><span class="line">Ngid:   0</span><br><span class="line">Pid:    46787</span><br><span class="line">PPid:   33</span><br><span class="line">TracerPid:      0</span><br><span class="line">Uid:    1000    1000    1000    1000</span><br><span class="line">Gid:    19062   19062   19062   19062</span><br><span class="line">FDSize: 128</span><br><span class="line">Groups:</span><br><span class="line">VmPeak:   559768 kB</span><br><span class="line">VmSize:   559120 kB</span><br><span class="line">VmLck:         0 kB</span><br><span class="line">VmPin:         0 kB</span><br><span class="line">VmHWM:    285240 kB</span><br><span class="line">VmRSS:    284752 kB</span><br><span class="line">RssAnon:          279016 kB</span><br><span class="line">RssFile:            3420 kB</span><br><span class="line">RssShmem:           2316 kB</span><br><span class="line">VmData:   371784 kB</span><br><span class="line">VmStk:       136 kB</span><br><span class="line">VmExe:      4716 kB</span><br><span class="line">VmLib:      6828 kB</span><br><span class="line">VmPTE:       900 kB</span><br><span class="line">VmSwap:        0 kB</span><br><span class="line">Threads:        33</span><br><span class="line">SigQ:   1/123857</span><br><span class="line">SigPnd: 0000000000000000</span><br><span class="line">ShdPnd: 0000000000000000</span><br><span class="line">SigBlk: 0000000000000000</span><br><span class="line">SigIgn: 0000000040001000</span><br><span class="line">SigCgt: 0000000198016eef</span><br><span class="line">CapInh: 0000001fffffffff</span><br><span class="line">CapPrm: 0000000000000400</span><br><span class="line">CapEff: 0000000000000400</span><br><span class="line">CapBnd: 0000001fffffffff</span><br><span class="line">CapAmb: 0000000000000000</span><br><span class="line">NoNewPrivs:     0</span><br><span class="line">Seccomp:        0</span><br><span class="line">Speculation_Store_Bypass:       vulnerable</span><br><span class="line">Cpus_allowed:   0001</span><br><span class="line">Cpus_allowed_list:      0</span><br><span class="line">Mems_allowed:   00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000001</span><br><span class="line">Mems_allowed_list:      0</span><br><span class="line">voluntary_ctxt_switches:        343464</span><br><span class="line">nonvoluntary_ctxt_switches:     35061</span><br></pre></td></tr></table></figure>

<p>具体字段含义可以查看man文档：<a href="https://man7.org/linux/man-pages/man5/proc.5.html%EF%BC%8C%E8%B7%9F%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E7%9A%84%E5%AD%97%E6%AE%B5%E5%A6%82%E4%B8%8B%EF%BC%9A">https://man7.org/linux/man-pages/man5/proc.5.html，跟内存相关的字段如下：</a></p>
<ul>
<li>VmRSS：虚拟内存驻留在物理内存中的部分大小</li>
<li>VmHWM：使用物理内存的峰值</li>
<li>VmData：进程占用的数据段大小</li>
</ul>
<h3 id="top命令查看"><a href="#top命令查看" class="headerlink" title="top命令查看"></a>top命令查看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ top -p $pid</span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">  46787 www-data  20   0  559120 286544   5740 S   1.3  0.9   2:43.64 nginx</span><br></pre></td></tr></table></figure>

<p>具体列含义如下：</p>
<ul>
<li>VIRT：进程使用虚拟内存总大小，即使没有占用物理内存，包括了进程代码段、数据段、共享内存、已经申请的堆内存和已经换到swap空间的内存等</li>
<li>RES: 进程实际使用的物理内存大小，不包括swap和共享内存</li>
<li>SHR：与其他进程的共享内存、加载的动态链接库、程序代码段的大小</li>
<li>MEM：进程使用的物理内存占系统总内存的百分比</li>
</ul>
<h3 id="ps命令查看"><a href="#ps命令查看" class="headerlink" title="ps命令查看"></a>ps命令查看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ps aux</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">www-data       1  0.0  0.0    212     8 ?        Ss   Apr09   0:00 /usr/bin/dumb-init -- /nginx-ingress-controller</span><br><span class="line">www-data       6  0.9  0.3 813500 99644 ?        Ssl  Apr09  67:32 /nginx-ingress-controller</span><br><span class="line">www-data      33  0.0  0.7 458064 242252 ?       S    Apr09   0:53 nginx: master process /usr/local/nginx/sbin/nginx -c /etc/nginx/nginx.conf</span><br><span class="line">www-data   46786  0.0  0.7 459976 239996 ?       S    17:57   0:00 rollback logs/eagleeye.log interval=60 adjust=600</span><br><span class="line">www-data   46787  1.3  0.8 559120 284452 ?       Sl   17:57   2:22 nginx: worker process</span><br><span class="line">www-data   46788  1.0  0.8 558992 285168 ?       Sl   17:57   1:51 nginx: worker process</span><br><span class="line">www-data   46789  0.0  0.7 452012 237152 ?       S    17:57   0:01 nginx: cache manager process</span><br><span class="line">www-data   46790  0.0  0.8 490832 267600 ?       S    17:57   0:00 nginx: x</span><br><span class="line">www-data   47533  0.0  0.0  60052  1832 pts/2    R+   20:50   0:00 ps aux</span><br></pre></td></tr></table></figure>

<ul>
<li>RSS：虚拟内存中的常驻内存，即实际占用的物理内存，包括所有已经分配的堆内存、栈内存、共享内存，由于共享内存非独占，实际上进程独占的物理内存要少于RSS</li>
</ul>
<h3 id="pmap"><a href="#pmap" class="headerlink" title="pmap"></a>pmap</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># pmap -x 452021</span><br><span class="line">452021:   nginx: worker process</span><br><span class="line">Address           Kbytes     RSS   Dirty Mode  Mapping</span><br><span class="line">0000000000400000    4716    1540       0 r-x-- tengine</span><br><span class="line">0000000000a9a000      20      16       4 r---- tengine</span><br><span class="line">0000000000a9f000     212     196     176 rw--- tengine</span><br><span class="line">0000000000ad4000     248      60      60 rw---   [ anon ]</span><br><span class="line">00002b0da6cb0000     136       4       0 r-x-- ld-2.17.so</span><br><span class="line">00002b0da6cd2000       4       4       4 rw---   [ anon ]</span><br><span class="line">00002b0da6cd3000       4       4       4 rw-s- zero (deleted)</span><br><span class="line">00002b0da6cd7000      28      24      24 rw---   [ anon ]</span><br><span class="line">00002b0da6cde000      64       8       8 rwx--   [ anon ]</span><br><span class="line">00002b0da6ed1000       4       4       4 r---- ld-2.17.so</span><br><span class="line">00002b0da6ed2000       4       4       4 rw--- ld-2.17.so</span><br><span class="line">00002b0da6ed3000       4       4       4 rw---   [ anon ]</span><br><span class="line">00002b0da6ed4000       8       0       0 r-x-- libdl-2.17.so</span><br><span class="line">00002b0da70d8000      92      32       0 r-x-- libpthread-2.17.so</span><br><span class="line">00002b0da72f0000      16       4       4 rw---   [ anon ]</span><br><span class="line">00002b0da72f4000      32       0       0 r-x-- libcrypt-2.17.so</span><br><span class="line">00002b0da72fc000    2044       0       0 ----- libcrypt-2.17.so</span><br><span class="line">00002b0da74fb000       4       4       4 r---- libcrypt-2.17.so</span><br><span class="line">00002b0da74fc000       4       4       4 rw--- libcrypt-2.17.so</span><br><span class="line">00002b0da74fd000     184       0       0 rw---   [ anon ]</span><br><span class="line">00002b0da752b000    1028       8       0 r-x-- libm-2.17.so</span><br><span class="line">00002b0da7a35000     760     372       0 r-x-- libssl.so.1.1</span><br><span class="line">00002b0da7d03000    2812    1124       0 r-x-- libcrypto.so.1.1</span><br><span class="line">00002b0da7fc2000    2044       0       0 ----- libcrypto.so.1.1</span><br><span class="line">00002b0da81c1000     172     172     172 r---- libcrypto.so.1.1</span><br><span class="line">00002b0da81ec000      12      12      12 rw--- libcrypto.so.1.1</span><br><span class="line">00002b0da81ef000      16       8       8 rw---   [ anon ]</span><br><span class="line">00002b0da81f3000      84      40       0 r-x-- libgcc_s-4.8.5-20150702.so.1</span><br><span class="line">00002b0da8409000    1808     316       0 r-x-- libc-2.17.so</span><br><span class="line">00002b0da85cd000    2044       0       0 ----- libc-2.17.so</span><br><span class="line">00002b0da87cc000      16      16      16 r---- libc-2.17.so</span><br><span class="line">00002b0da87d0000       8       8       8 rw--- libc-2.17.so</span><br><span class="line">00002b0da87d2000      20      12      12 rw---   [ anon ]</span><br><span class="line">00002b0da87d7000       8       0       0 r-x-- libfreebl3.so</span><br><span class="line">00002b0da87d9000    2044       0       0 ----- libfreebl3.so</span><br><span class="line">00002b0da89d8000       4       4       4 r---- libfreebl3.so</span><br><span class="line">00002b0da89d9000       4       4       4 rw--- libfreebl3.so</span><br><span class="line">00002b0da8a00000   24576   21936   21936 rw---   [ anon ]</span><br><span class="line">00002b0daa200000    8192    8180    8180 rw---   [ anon ]</span><br><span class="line">00002b0daaa00000    8192    8192    8192 rw---   [ anon ]</span><br><span class="line">00002b0dab200000    8192    8192    8192 rw---   [ anon ]</span><br><span class="line">00002b0daba00000    8192    8172    8172 rw---   [ anon ]</span><br><span class="line">00002b0dac200000    4096    4096    4096 rw---   [ anon ]</span><br><span class="line">00002b0dac600000    4096    4096    4096 rw---   [ anon ]</span><br><span class="line">00002b0daca00000    4096      12      12 rw-s- zero (deleted)</span><br><span class="line">00002b0dace00000    1024       0       0 rw-s- zero (deleted)</span><br><span class="line">00002b0dacf00000    1024       0       0 rw-s- zero (deleted)</span><br><span class="line">00002b0dad000000   16384   16384   16384 rw---   [ anon ]</span><br><span class="line">00002b0dae000000   10240       0       0 rw-s- zero (deleted)</span><br><span class="line">00002b0db3f00000      24      16       0 r-x-- cjson.so</span><br><span class="line">00002b0db3f06000    2048       0       0 ----- cjson.so</span><br><span class="line">00002b0db4106000       4       4       4 r---- cjson.so</span><br><span class="line">00002b0db4107000       4       4       4 rw--- cjson.so</span><br><span class="line">00002b0db4108000       8       0       0 r-x-- librestychash.so</span><br><span class="line">00002b0db410a000    2044       0       0 ----- librestychash.so</span><br><span class="line">00002b0db4309000       4       4       4 r---- librestychash.so</span><br><span class="line">00002b0db430a000       4       4       4 rw--- librestychash.so</span><br><span class="line">00002b0db430b000   10240    1784    1784 rw-s- zero (deleted)</span><br><span class="line">00002b0db4d0b000   10240       0       0 rw-s- zero (deleted)</span><br><span class="line">00002b0db5800000    6144    6144    6144 rw---   [ anon ]</span><br><span class="line">00002b0db5e00000    6144    6144    6144 rw---   [ anon ]</span><br><span class="line">00002b0db6400000    8192    8192    8192 rw---   [ anon ]</span><br><span class="line">00002b0db6c0b000    5120       8       8 rw-s- zero (deleted)</span><br><span class="line">00002b0db7200000    8192    8192    8192 rw---   [ anon ]</span><br><span class="line">00002b0dc2800000    1024       0       0 rw-s- zero (deleted)</span><br><span class="line">00002b0dc2900000   10240       0       0 rw-s- zero (deleted)</span><br><span class="line">00002b0dc3300000   10240       0       0 rw-s- zero (deleted)</span><br><span class="line">00002b0dc861f000    2048       8       8 rw---   [ anon ]</span><br><span class="line">00002b0dc881f000       4       0       0 -----   [ anon ]</span><br><span class="line">00002b0dc8820000    2048       8       8 rw---   [ anon ]</span><br><span class="line">00007fff60f6c000     136      44      44 rw---   [ stack ]</span><br><span class="line">00007fff60fdd000       8       4       0 r-x--   [ anon ]</span><br><span class="line">ffffffffff600000       4       0       0 r-x--   [ anon ]</span><br><span class="line">---------------- ------- ------- -------</span><br><span class="line">total kB          558996  289376  285888</span><br></pre></td></tr></table></figure>

<ul>
<li>Mapping: 支持如下值<ul>
<li>[anon]：分配的内存</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>编程珠玑读书笔记第1章开篇</title>
    <url>/post/programming_pearls_1/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>一个最多包含n个正整数的文件，每个数小于n，其中n为10000000。要求升序排列整数列表，最多使用1MB的内存，运行时间尽可能短。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="c++">#include &lt;stdio.h&gt;                                                                                                                                                              
#include &lt;stdlib.h&gt;

#define BITSPERWORD 32
#define SHIFT 5
#define MASK 0x1F
#define N 10000000

int a[1 + N/BITSPERWORD] = &#123;0&#125;;

/**
 * i&gt;&gt;SHIFT相当于i/32，用于确定i在第几个int数组中
 * 其中i&amp;MASK含义为i%32，用于确定在int中的第几位
 */
void set(int i)
&#123;
    a[i &gt;&gt; SHIFT] |= (1 &lt;&lt; (i &amp; MASK));
&#125;

void clr(int i)
&#123;
    a[i &gt;&gt; SHIFT] &amp;= (0 &lt;&lt; (i &amp; MASK));
&#125;

int test(int i)
&#123;
    return a[i &gt;&gt; SHIFT] &amp; (1 &lt;&lt; (i &amp; MASK));
&#125;

int main(void)
&#123;
    int i;
    while (scanf(&quot;%d&quot;, &amp;i) != EOF)
    &#123;
        set(i);
    &#125;
    for (i=0; i&lt;N; i++)
    &#123;
        if (test(i))
        &#123;
            printf(&quot;%d\n&quot;, i);
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>
<h1 id="习题5"><a href="#习题5" class="headerlink" title="习题5"></a>习题5</h1><p>通过shell命令<code>echo &quot;scale=2; 10000000 / 1024 / 8 / 1024.0&quot; | bc</code>计算该程序运行时至少需要的存储空间为1.19MB，如果仅提供了1MB的存储空间，则需要更改上述程序的处理方式。</p>
<p>可采用多趟算法，多趟读入输入数据，每次完成一步。针对该题，可采用2步来完成，int数组的大小变更为5000000&#x2F;8，比之前小了一半。第一步处理0-4999999之间的数据，第二步处理5000000-999999之间的数据。</p>
<h1 id="习题6"><a href="#习题6" class="headerlink" title="习题6"></a>习题6</h1><p>如果是每个整数至少出现10次，而不是原先的一次。可以使用4bit来统计出现的次数，申请的数组大小变为了10000000&#x2F;2。只要是每个整数有出现的最多次数上限该种处理方式就合适，当然整数出现的上限不能太大，否则该算法就没有了任何优势。</p>
<h1 id="习题9"><a href="#习题9" class="headerlink" title="习题9"></a>习题9</h1><p>对一个大的数组的初始化操作需要耗费一些时间，为了消除数组的初始化，可以通过两个额外的数组来解决，这是典型的用空间换时间的方法。</p>
<pre style="font-family: Courier, monospace;">
      +---+---+---+---+---+---+---+----+
data  |   |   | 3 |   | 2 |   | 8 |    |
      +---+---+---+---+---+---+---+----+
                                        
      +---+---+---+---+---+---+---+----+
from  |   |   | 0 |   | 2 |   | 1 |    |
      +---+---+---+---+---+---+---+----+
                                        
      +---+---+---+---+---+---+---+----+
to    | 1 | 5 | 3 |   |   |   |   |    |
      +---+---+---+---+---+---+---+----+
                                        
                    ^                   
                    +                   
                   top                  
</pre>

<p>上图中data为要初始化的数组，from和to为辅助数组。如果data[i]已经初始化，则from[i]&lt;top，to[from[i]]&#x3D;i。from是一个简单的标识，to和top确保了from中不会写入内存中的随机内容。</p>
<h1 id="习题11"><a href="#习题11" class="headerlink" title="习题11"></a>习题11</h1><p>该题的答案太他妈逗了，为了能够解决两地之间的数据传输瓶颈，作者给出的答案居然是用信鸽传输图片的底片后再将底片放大的方式来代替原先的用汽车运输的方式，这就是中国古代的飞鸽传书啊。</p>
<h1 id="习题12"><a href="#习题12" class="headerlink" title="习题12"></a>习题12</h1><p>该题在《三傻大闹宝莱坞》中见过，这跟编程毛线关系也没有啊。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>正向代理</title>
    <url>/post/proxy-server/</url>
    <content><![CDATA[<p>正向代理通常用在远程访问某个环境中的。常见的正向代理工具包括squid、nginx、3proxy。</p>
<h2 id="squid"><a href="#squid" class="headerlink" title="squid"></a>squid</h2><p>老牌的正向代理工具。</p>
<p>安装：yum install squid &amp;&amp; systemctl start squid</p>
<p>squid默认会监听在3128端口号。</p>
<p>缺点：如果修改了本地的&#x2F;etc&#x2F;hosts文件，则需要重启squid后才可以更新。</p>
<h2 id="3proxy"><a href="#3proxy" class="headerlink" title="3proxy"></a>3proxy</h2><p>官方并没有提供yum的安装方式，比较简单的运行方式是以docker的形式。</p>
<p>执行如下的命令，即可开启3128端口作为http代理，3129端口作为sock5代理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /etc/3proxy</span><br><span class="line">cat &gt; /etc/3proxy/3proxy.cfg &lt;&lt;EOF</span><br><span class="line">log /var/log/3proxy.log D</span><br><span class="line">logformat &quot;- +_L%t.%. %N.%p %E %U %C:%c %R:%r %O %I %h %T&quot;</span><br><span class="line">rotate 7</span><br><span class="line">auth none</span><br><span class="line">flush</span><br><span class="line">allow somepu</span><br><span class="line">maxconn 200</span><br><span class="line"></span><br><span class="line"># starting HTTP proxy with disabled NTLM auth ( -n )</span><br><span class="line">proxy -p3128 -n</span><br><span class="line"></span><br><span class="line"># starting SOCKS proxy</span><br><span class="line">socks -p3129 -n</span><br><span class="line">EOF</span><br><span class="line">docker run -d --restart=always -p 3128:3128 -p 3129:3129 --net=host -v /var/log:/var/log -v /etc/3proxy/3proxy.cfg:/etc/3proxy/3proxy.cfg --name 3proxy 3proxy/3proxy</span><br></pre></td></tr></table></figure>

<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><h3 id="终端设置代理"><a href="#终端设置代理" class="headerlink" title="终端设置代理"></a>终端设置代理</h3><p>shell支持如下的代理环境变量:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export http_proxy=http://localhost:1080</span><br><span class="line">export https_proxy=http://localhost:1080</span><br></pre></td></tr></table></figure>

<p>如果是 socks5 代理同样可以使用上述两个环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export http_proxy=socks5://localhost:1080</span><br><span class="line">export https_proxy=socks5://localhost:1080</span><br></pre></td></tr></table></figure>

<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://github.com/3proxy/3proxy">https://github.com/3proxy/3proxy</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>pushd和popd命令的用法</title>
    <url>/post/pushd-popd/</url>
    <content><![CDATA[<h1 id="pushd和popd命令的用法"><a href="#pushd和popd命令的用法" class="headerlink" title="pushd和popd命令的用法"></a>pushd和popd命令的用法</h1><p>在编写shell的时候，经常会在目录之间进行切换，如果使用cd命令经常会切换错误，pushd和popd使用栈的方式来管理目录。</p>
<h2 id="dirs"><a href="#dirs" class="headerlink" title="dirs"></a>dirs</h2><p>用于显示当前目录栈中的所有记录。</p>
<h2 id="pushd"><a href="#pushd" class="headerlink" title="pushd"></a>pushd</h2><p>将目录加入到栈顶部，并将当前目录切换到该目录。若不加任何参数，该命令用于将栈顶的两个目录进行对调。</p>
<h2 id="popd"><a href="#popd" class="headerlink" title="popd"></a>popd</h2><p>删除目录栈中的目录。若不加任何参数，则会首先删除目录栈顶的目录，并将当前目录切换到栈顶下面的目录。</p>
<p>命令格式：<code>pushd  [-N | +N]   [-n]</code></p>
<ul>
<li><code>+N</code> 将第N个目录删除（从左边数起，数字从0开始）</li>
<li><code>-N</code> 将第N个目录删除（从右边数起，数字从0开始）</li>
<li><code>-n</code> 将目录出栈时，不切换目录</li>
</ul>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# mkdir /tmp/dir&#123;1,2,3,4&#125;</span><br><span class="line">[root@localhost tmp]# pushd /tmp/dir1</span><br><span class="line">/tmp/dir1 /tmp</span><br><span class="line">[root@localhost dir1]# pushd /tmp/dir2</span><br><span class="line">/tmp/dir2 /tmp/dir1 /tmp</span><br><span class="line">[root@localhost dir2]# pushd /tmp/dir3</span><br><span class="line">/tmp/dir3 /tmp/dir2 /tmp/dir1 /tmp</span><br><span class="line">[root@localhost dir3]# pushd /tmp/dir4</span><br><span class="line">/tmp/dir4 /tmp/dir3 /tmp/dir2 /tmp/dir1 /tmp</span><br><span class="line"># dirs的显示内容跟pushd完成后的输出一致</span><br><span class="line">[root@localhost dir4]# dirs</span><br><span class="line">/tmp/dir4 /tmp/dir3 /tmp/dir2 /tmp/dir1 /tmp</span><br><span class="line"></span><br><span class="line">[root@localhost dir4]# popd</span><br><span class="line">/tmp/dir3 /tmp/dir2 /tmp/dir1 /tmp</span><br><span class="line"></span><br><span class="line"># 带有数字比较容易出错</span><br><span class="line">[root@localhost dir3]# popd +1</span><br><span class="line">/tmp/dir3 /tmp/dir1 /tmp</span><br><span class="line"></span><br><span class="line"># 清除目录栈</span><br><span class="line">[root@localhost dir3]# dirs -c</span><br><span class="line">[root@localhost dir3]# dirs</span><br><span class="line">/tmp/dir3</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP TIME_WAIT</title>
    <url>/post/time-wait/</url>
    <content><![CDATA[<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/tcp_state.png"></p>
<h2 id="time-wait状态"><a href="#time-wait状态" class="headerlink" title="time_wait状态"></a>time_wait状态</h2><p>客户端在收到服务器端发送的FIN报文后发送ACK报文，并进入TIME_WAIT状态，等待2MSL（最大报文生存时间）后才断开连接，MSL在Linux中值为30s。</p>
<p>之所以设计time_wait主要用来解决以下异常场景：</p>
<ol>
<li>确保对端处于关闭状态。主动断开连接一段发送最后一个ack报文，如果丢失，被动断开连接一端会重新发送fin报文。如果主动断开连接一方直接关闭，被动方会一直处于last-ack状态。</li>
<li>防止上一个连接中的包影响新的连接，上一个连接中的包在2MSL中一定可以到达对端。</li>
</ol>
<p>过多的危害：在客户端占用过多的端口号</p>
<h2 id="time-wait过多的解决思路"><a href="#time-wait过多的解决思路" class="headerlink" title="time_wait过多的解决思路"></a>time_wait过多的解决思路</h2><ol>
<li>将<code>net.ipv4.tcp_max_tw_buckets</code>值调小，当TIME_WAIT的数量到达该值后，TIME_WAIT状态会被清除，相当于没有遵守tcp协议</li>
<li>修改TCP_TIMEWAIT_LEN的值，但需要重新编译内核，非常不建议修改</li>
<li>打开tcp_tw_recycle和tcp_timestamps</li>
<li>打开tcp_tw_reuse和tcp_timestamps</li>
<li>采用长连接</li>
</ol>
<p>tcp有个tcp时间戳选项，第一个是发送方的当前时钟时间戳（4个字节），第二个4字节为从远程主机接收到的最新时间戳</p>
<h2 id="相关内核参数"><a href="#相关内核参数" class="headerlink" title="相关内核参数"></a>相关内核参数</h2><h3 id="net-ipv4-tcp-max-tw-buckets"><a href="#net-ipv4-tcp-max-tw-buckets" class="headerlink" title="net.ipv4.tcp_max_tw_buckets"></a><code>net.ipv4.tcp_max_tw_buckets</code></h3><blockquote>
<p>(integer; default: see below; since Linux 2.4) The maximum number of sockets in TIME_WAIT state allowed in the system.  This limit exists only to prevent simple denial-of-service attacks.  The default value of NR_FILE*2 is adjusted depending on the memory in the system.  If this number is exceeded, the socket is closed and a warning is printed.</p>
</blockquote>
<p>系统中允许的 time_wait 数量的最大值，当达到最大值后，新的连接会被拒绝。</p>
<h3 id="net-ipv4-tcp-tw-timeout"><a href="#net-ipv4-tcp-tw-timeout" class="headerlink" title="net.ipv4.tcp_tw_timeout"></a><code>net.ipv4.tcp_tw_timeout</code></h3><p>time_wait 的超时时间，默认为 2MSL，即 60s，在大部分的 linux 系统下该值没法修改，仅在某些 OS 系统下可用。比如：<a href="https://help.aliyun.com/zh/ecs/user-guide/change-the-tcp-time-wait-timeout-period">Alibaba Cloud Linux 修改TCP TIME-WAIT超时时间</a>。</p>
<h3 id="tcp-timestamp"><a href="#tcp-timestamp" class="headerlink" title="tcp_timestamp"></a>tcp_timestamp</h3><p>用来控制tcp option字段，发送方在发送报文时会将当前时钟的时间值放入到时间戳字段。</p>
<h3 id="net-ipv4-tcp-tw-reuse"><a href="#net-ipv4-tcp-tw-reuse" class="headerlink" title="net.ipv4.tcp_tw_reuse"></a><code>net.ipv4.tcp_tw_reuse</code></h3><blockquote>
<p>(Boolean; default: disabled; since Linux 2.4.19&#x2F;2.6) Allow to reuse TIME_WAIT sockets for new connections when it is safe from protocol viewpoint.  It should not be changed without advice&#x2F;request of technical experts.</p>
</blockquote>
<p>tcp_tw_reuse意思为主动关闭连接的一方可以复用之前的time_wait状态的连接。</p>
<p>复用连接后，这条连接的时间更改为当前时间，延迟数据到达时，延迟数据时间小于新连接时间。</p>
<p>需要连接双方都打开timestamp选项。</p>
<p>该选项适用的范围为作为客户端主动断开连接，复用客户端的time_wait的状态，对服务端无影响。</p>
<h3 id="net-ipv4-tcp-tw-recycle"><a href="#net-ipv4-tcp-tw-recycle" class="headerlink" title="net.ipv4.tcp_tw_recycle"></a><code>net.ipv4.tcp_tw_recycle</code></h3><p>内核会在一个RTO的时间内快速销毁掉time_wait状态，RTO时间为数据包重传的超时时间，该时间通过RTT动态计算，远小于2MSL。</p>
<p>需要连接双方都打开timestamp选项。</p>
<p>适用场景为服务端主动断开连接，time_wait状态位于服务端，服务端适用该选项快速回收time_wait状态的连接。</p>
<p><em>弊端</em>：如果客户端在NAT网络中，如果配置了tcp_tw_recycle，可能会出现在一个RTO的时间内，只有一个客户端和自己连接成功的情况。</p>
<p>4.10之后，Linux内核修改了时间戳生成机制，该选项已经抛弃。</p>
<h2 id="In-Action"><a href="#In-Action" class="headerlink" title="In Action"></a>In Action</h2><p>解决time_wait状态过多的比较好的思路为采用http的keepalive功能。</p>
<h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>nginx对于upstream，默认是使用http1.0协议的，要想启用keepalive，需要在location中增加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_http_version 1.1;</span><br><span class="line">proxy_set_header Connection &quot;&quot;;</span><br></pre></td></tr></table></figure>

<p>在upstream中增加keepalive参数，这里的参数含义为每个nginx worker连接所有后端的最大连接数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keepalive 200;</span><br></pre></td></tr></table></figure>

<p>如果keepalive连接过少，此时由于使用的是http1.1的协议，upstream端不会主动断开连接，nginx会主动断开连接，此时nginx端的time_wait就会过多，会占用端口号，导致nginx端没有端口号可以使用。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="https://www.nosa.me/2014/12/18/%E5%85%B3%E4%BA%8E-nginx-upstream-keepalive-%E7%9A%84%E8%AF%B4%E6%98%8E/">关于 Nginx upstream keepalive 的说明
</a></li>
<li><a href="http://www.haproxy.com/blog/haproxy-and-http-errors-408-in-chrome/">HAProxy and HTTP errors 408 in Chrome</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMDQxMDMyNg==&mid=2247484841&idx=1&sn=7e0923ea9204e126003e263dc8414261&chksm=f9022e90ce75a7865a985ddfb02016949b0c36a02f8fb805c957699ba64144682b9b40d58a1c&mpshare=1&scene=1&srcid=1212u1NkZyHItSo6HpPq7eer%23rd">被抛弃的tcp_recycle</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>图的存储和遍历</title>
    <url>/post/traverse_graph/</url>
    <content><![CDATA[<h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><p>在leetcode中图的存储形式如下，这种形式的图只能适合用来存储是连通图的情况，且根据leetcode提供的_{0,1,2#1,2#2,2}_格式的字符串通过程序来自动构造图比较麻烦，预知字符串的含义请移步到<a href="https://oj.leetcode.com/problems/clone-graph/">leetcode的解释</a>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for undirected graph.</span></span><br><span class="line"><span class="comment"> * struct UndirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     vector&lt;UndirectedGraphNode *&gt; neighbors;</span></span><br><span class="line"><span class="comment"> *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br></pre></td></tr></table></figure>

<p>本文为了能够用字符串表示所有图，并且便于程序的构造，使用了邻接表的形式来对图进行存储，即可以用来存储有向图，有可以存储无向图。图一个节点的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图节点的邻接表表示形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> label;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;GraphNode *&gt; neighbors;</span><br><span class="line">    <span class="type">bool</span> visited;			<span class="comment">// 深度优先搜索和广度优先搜索的遍历都需要visited数组，为了简化程序，直接在节点的存储结构中设置visited变量</span></span><br><span class="line">    GraphNode(<span class="built_in">std</span>::<span class="built_in">string</span> x) : label(x), visited(<span class="literal">false</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>图的创建方面为了简化算法实现，对程序的效率没做太多关注，算法复杂度稍高。本算法的难点在于对字符串的拆解，并根据字符串找到对应的节点指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图节点的邻接表表示形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GraphNode</span> &#123;</span><br><span class="line">    std::string label;</span><br><span class="line">    std::vector&lt;GraphNode *&gt; neighbors;</span><br><span class="line">    <span class="type">bool</span> visited;</span><br><span class="line">    <span class="built_in">GraphNode</span>(std::string x) : <span class="built_in">label</span>(x), <span class="built_in">visited</span>(<span class="literal">false</span>) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过字符串的值，找到该字符串对应的图节点</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function">GraphNode *<span class="title">get_one_node</span><span class="params">(<span class="type">const</span> std::vector&lt;GraphNode *&gt; &amp;node_vector, std::string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;GraphNode *&gt;::const_iterator iter = node_vector.<span class="built_in">begin</span>(); iter != node_vector.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*iter)-&gt;label == str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间复杂度高,对图的构建一般效率要求较低</span></span><br><span class="line"><span class="comment"> * 对于查找某个节点的邻接点的指针操作可以使用map来提高查询效率</span></span><br><span class="line"><span class="comment"> * 或者可以通过不需要初始化所有节点的方式来构造图，而是采用需要哪个节点构造哪个节点的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::vector&lt;GraphNode *&gt; <span class="title">create_graph</span><span class="params">(std::string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;GraphNode *&gt; node_vector;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// init all nodes</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> pos = <span class="number">0</span>; pos &lt; str.<span class="built_in">length</span>() - <span class="number">1</span>;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> end = str.<span class="built_in">find</span>(<span class="string">&#x27;,&#x27;</span>, pos);</span><br><span class="line">        <span class="keyword">if</span> (end != std::string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            GraphNode *node = <span class="keyword">new</span> <span class="built_in">GraphNode</span>(str.<span class="built_in">substr</span>(pos, end - pos));</span><br><span class="line">            node_vector.<span class="built_in">push_back</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos = str.<span class="built_in">find</span>(<span class="string">&#x27;#&#x27;</span>, pos);</span><br><span class="line">        <span class="keyword">if</span> (pos == std::string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add neighbors in every node</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> pos = <span class="number">0</span>; pos &lt; str.<span class="built_in">length</span>() - <span class="number">1</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        GraphNode *current_node = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">size_t</span> current_end = str.<span class="built_in">find</span>(<span class="string">&#x27;,&#x27;</span>, pos);</span><br><span class="line">        <span class="keyword">if</span> (current_end != std::string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            current_node = <span class="built_in">get_one_node</span>(node_vector, str.<span class="built_in">substr</span>(pos, current_end - pos));</span><br><span class="line">            pos = current_end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> node_end = str.<span class="built_in">find</span>(<span class="string">&#x27;#&#x27;</span>, pos);   <span class="comment">// 当前节点的字符串的结束位置</span></span><br><span class="line">        <span class="keyword">if</span> (node_end == std::string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            node_end = str.<span class="built_in">length</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node_end--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( ; ; )</span><br><span class="line">        &#123;</span><br><span class="line">            current_end = str.<span class="built_in">find</span>(<span class="string">&#x27;,&#x27;</span>, pos);</span><br><span class="line">            <span class="keyword">if</span> (current_end &gt; node_end || current_end == std::string::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 一个节点的最后一个邻接点</span></span><br><span class="line">                current_end = node_end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                current_end--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            GraphNode *node = <span class="built_in">get_one_node</span>(node_vector, str.<span class="built_in">substr</span>(pos, current_end - pos + <span class="number">1</span>)); </span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                current_node-&gt;neighbors.<span class="built_in">push_back</span>(node);</span><br><span class="line">                std::cout &lt;&lt; current_node-&gt;label &lt;&lt; <span class="string">&quot; add &quot;</span> &lt;&lt; node-&gt;label &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current_end == node_end)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 一个节点的最后一个邻接点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pos = current_end + <span class="number">2</span>;  <span class="comment">// 该节点之后还有其他邻接点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = node_end + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node_vector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><p>深度优先搜索遵循贪心算法的原理，如果孩子节点不为空，则一直遍历下去。</p>
<h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_traverse_recursion</span><span class="params">(GraphNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;visited)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; node-&gt;label &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">        node-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;GraphNode *&gt;::iterator iter = node-&gt;neighbors.<span class="built_in">begin</span>(); iter != node-&gt;neighbors.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(*iter)-&gt;visited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DFS_traverse_recursion</span>(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图的深度优先搜索的递归形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_traverse_recursion</span><span class="params">(std::vector&lt;GraphNode *&gt; &amp;graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;GraphNode *&gt;::iterator iter = graph.<span class="built_in">begin</span>(); iter != graph.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*iter)-&gt;visited = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;GraphNode *&gt;::iterator iter = graph.<span class="built_in">begin</span>(); iter != graph.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(*iter)-&gt;visited)</span><br><span class="line">            <span class="built_in">DFS_traverse_recursion</span>(*iter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h2><p>使用栈来实现非递归。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图的深度优先搜索的非递归形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_traverse_not_recursion</span><span class="params">(std::vector&lt;GraphNode *&gt; &amp;graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;GraphNode *&gt;::iterator iter = graph.<span class="built_in">begin</span>(); iter != graph.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*iter)-&gt;visited = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;GraphNode *&gt;::iterator iter = graph.<span class="built_in">begin</span>(); iter != graph.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::stack&lt;GraphNode *&gt; node_stack;</span><br><span class="line">        <span class="keyword">if</span> ((*iter)-&gt;visited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node_stack.<span class="built_in">push</span>(*iter);</span><br><span class="line">        <span class="keyword">while</span> (!node_stack.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            GraphNode *node = node_stack.<span class="built_in">top</span>();</span><br><span class="line">            node_stack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;visited)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            std::cout &lt;&lt; node-&gt;label &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">            node-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">/* 使用反向迭代器遍历后将节点加入到栈中 */</span></span><br><span class="line">            <span class="keyword">for</span> (std::vector&lt;GraphNode *&gt;::reverse_iterator iter2 = node-&gt;neighbors.<span class="built_in">rbegin</span>(); iter2 != node-&gt;neighbors.<span class="built_in">rend</span>(); iter2++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(*iter2)-&gt;visited)</span><br><span class="line">                &#123;</span><br><span class="line">                    node_stack.<span class="built_in">push</span>(*iter2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>该算法不存在递归算法，仅有非递归版本。需要利用队列来保存需要遍历的节点，占用的存储空间稍多。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图的广度优先搜索的非递归形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS_traverse_not_recursion</span><span class="params">(std::vector&lt;GraphNode *&gt; &amp;graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;GraphNode *&gt;::iterator iter = graph.<span class="built_in">begin</span>(); iter != graph.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        (*iter)-&gt;visited = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;GraphNode *&gt;::iterator iter = graph.<span class="built_in">begin</span>(); iter != graph.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::queue&lt;GraphNode *&gt; node_queue;</span><br><span class="line">        <span class="keyword">if</span> ((*iter)-&gt;visited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node_queue.<span class="built_in">push</span>(*iter);</span><br><span class="line">        <span class="keyword">while</span> (!node_queue.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            GraphNode *node = node_queue.<span class="built_in">front</span>();</span><br><span class="line">            node_queue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;visited)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            std::cout &lt;&lt; node-&gt;label &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">            node-&gt;visited = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (std::vector&lt;GraphNode *&gt;::iterator iter2 = node-&gt;neighbors.<span class="built_in">begin</span>(); iter2 != node-&gt;neighbors.<span class="built_in">end</span>(); iter2++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(*iter2)-&gt;visited)</span><br><span class="line">                &#123;</span><br><span class="line">                    node_queue.<span class="built_in">push</span>(*iter2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a href="http://pan.baidu.com/s/1i3GIj9V">本文相关源码</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/post/traverse_tree/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>近期准备复习数据结构和算法的知识，参照了网络上各路大神的学习攻略，大部分算法学习的思路为参照一些经典书籍（如算法导论）并结合一些代码的实践来完成，并未找到一条适合我的算法学习之路。经过思考后决定采用代码编写曾经的教科书中代码实例的方式来学习，曾经接触的算法教科书包括《数据结构（C语言版）》和《计算机算法基础》。一来这些算法已经基本熟悉，只是时间久远有些已经忘记；二来，通过思考后编写代码增强自己的记忆。</p>
<p>同时我编写的这些实例可以作为leetcode上的很多题目的基础，为下一个阶段刷leetcode上的题目打好基础。</p>
<p>树的存储形式包括了顺序存储（采用数组形式）和链式存储，其中链式存储更为灵活，可以表示任意形式的树，本文中的代码将采用树的链式存储方式。</p>
<h1 id="树的构建"><a href="#树的构建" class="headerlink" title="树的构建"></a>树的构建</h1><p>树的构建有多种方式，本文使用字符串采用了自顶向下、自左到右的顺序构建树，跟leetcode的形式一致。其中’#’表示该节点为空，如果该节点为空节点，其左右子孩子节点也要用’#’表示，而不能不用任何字符表示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树的链式存储结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">char</span> data) : <span class="built_in">data</span>(data), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造二叉树，要构造的字符串采用了自顶向下、自左到右的顺序，跟leetcode的形式一致</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">create_binary_tree</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str || <span class="built_in">strlen</span>(str) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个节点分配存储空间</span></span><br><span class="line">    <span class="type">int</span> node_size = <span class="built_in">strlen</span>(str);</span><br><span class="line">    TreeNode **tree = <span class="keyword">new</span> TreeNode*[node_size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;node_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[i] = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;node_size &amp;&amp; j&lt;node_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[i] != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((j + <span class="number">1</span>) &lt; node_size)</span><br><span class="line">            &#123;</span><br><span class="line">                tree[i]-&gt;left = tree[++j];</span><br><span class="line">                tree[i]-&gt;right = tree[++j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的先序遍历"><a href="#二叉树的先序遍历" class="headerlink" title="二叉树的先序遍历"></a>二叉树的先序遍历</h1><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 先序遍历二叉树的递归形式</span><br><span class="line"> */</span><br><span class="line">void preorder_traverse_recursion(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    if (!root)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%c\t&quot;, root-&gt;data);</span><br><span class="line">    </span><br><span class="line">    preorder_traverse_recursion(root-&gt;left);</span><br><span class="line"></span><br><span class="line">    preorder_traverse_recursion(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先序遍历的非递归形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder_traverse_not_recursion</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    std::stack&lt;TreeNode *&gt; tree_stack;</span><br><span class="line">    tree_stack.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (tree_stack.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *node = tree_stack.<span class="built_in">top</span>();</span><br><span class="line">        tree_stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, node-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tree_stack.<span class="built_in">push</span>(node-&gt;right);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tree_stack.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><h2 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历二叉树的递归形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder_traverse_recursion</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">inorder_traverse_recursion</span>(root-&gt;left);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, root-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inorder_traverse_recursion</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非递归实现-1"><a href="#非递归实现-1" class="headerlink" title="非递归实现"></a>非递归实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历二叉树的非递归形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder_traverse_not_recursion</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    std::stack&lt;TreeNode *&gt; tree_stack;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || tree_stack.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历到左子树的叶子节点</span></span><br><span class="line">        <span class="keyword">while</span> (root)</span><br><span class="line">        &#123;</span><br><span class="line">            tree_stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历栈顶节点</span></span><br><span class="line">        root = tree_stack.<span class="built_in">top</span>();</span><br><span class="line">        tree_stack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, root-&gt;data);</span><br><span class="line"></span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h1><h2 id="递归实现-2"><a href="#递归实现-2" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历二叉树的递归形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder_traverse_recursion</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">postorder_traverse_recursion</span>(root-&gt;left);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">postorder_traverse_recursion</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, root-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非递归实现-2"><a href="#非递归实现-2" class="headerlink" title="非递归实现"></a>非递归实现</h2><p>仅用一个栈不能够实现后序遍历非递归算法，需要保存一个上次访问过节点的变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历二叉树的非递归形式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder_traverse_not_recursion</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    std::stack&lt;TreeNode *&gt; tree_stack;</span><br><span class="line">    TreeNode *visited = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || tree_stack.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 遍历到左子树的叶子节点</span></span><br><span class="line">        <span class="keyword">while</span> (root)</span><br><span class="line">        &#123;</span><br><span class="line">            tree_stack.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root = tree_stack.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span> || root-&gt;right == visited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果没有右孩子，或者右孩子刚刚访问过，则访问当前节点</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, root-&gt;data);</span><br><span class="line">            tree_stack.<span class="built_in">pop</span>();</span><br><span class="line">            visited = root;</span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>二叉树遍历的递归形式程序结构类似，编写相对简单。但是递归方法在C语言中存在执行效率差（需要维护函数栈），容易出现栈溢出的异常的问题。任何递归问题问题都可以转化为非递归问题，转化的思路包括了直接转化法和间接转化法。直接转化法可以通过循环来解决，间接转化法需要借助栈加循环来解决。</p>
<p>二叉树遍历的非递归形式相对复杂，二叉树的先序遍历的非递归形式容易理解，二叉树的中序遍历稍微困难，后序遍历的非递归形式最复杂。</p>
<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a href="http://pan.baidu.com/s/1eQmweSM">程序源代码</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>在ubuntu中更改mac地址的方法</title>
    <url>/post/ubuntu_change_mac/</url>
    <content><![CDATA[<p>本文提供简易shell脚本来更改mac地址，在其他linux发行版中去掉sudo即可。脚本内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">sudo ifconfig eth0 down</span><br><span class="line">sudo ifconfig eth0 hw ether 08:00:27:DF:B3:7B</span><br><span class="line">sudo ifconfig eth0 up</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>手动更新Custom Resource中的status部分</title>
    <url>/post/update-cr-status/</url>
    <content><![CDATA[<p>在k8s中的内置资源很多都有status部分，比如deployment，用来标识当前资源的状态信息。同样在CRD的体系中，也都有status部分。这些status部分信息，是由operator来负责维护的。</p>
<p>如果直接采用kubectl edit的方式来修改status部分信息，会发现是无法直接修改status部分的，因为status是无法修改成功的，因为status部分是CR的一个子资源。</p>
<p>可以通过如下的方式来完成修改</p>
<ol>
<li>首先要准备一个完整的yaml文件，包含了status部分信息</li>
</ol>
<p>这个的格式必须为json</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;apiVersion&quot;: &quot;kuring.me/v1alpha1&quot;,</span><br><span class="line">  &quot;kind&quot;: &quot;Certificate&quot;,</span><br><span class="line">  &quot;metadata&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;test&quot;,</span><br><span class="line">    &quot;namespace&quot;: &quot;default&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;spec&quot;: &#123;</span><br><span class="line">    &quot;secretName&quot;: &quot;test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot;: &#123;</span><br><span class="line">    &quot;phase&quot;: &quot;pending&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取系统的TOKEN信息</li>
</ol>
<p>通常在kube-system下会有admin的ServiceAccount，会有一个对应的Secret来存放该ServiceAccount的token信息。执行<code>kubectl get secret -n kube-system admin-token-r2bvt   -o yaml</code>获取到token信息，并其中的token部分进行base64解码。</p>
<ol start="3">
<li>执行如下的脚本</li>
</ol>
<p>需要将其中的变量信息修改一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">obj_file=$1</span><br><span class="line">kind=certificates</span><br><span class="line">APISERVER=https://10.0.0.100:6443</span><br><span class="line">namespace=default</span><br><span class="line">TOKEN=eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi10b2tlbi1yMmJ2dCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJhZG1pbiIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImRiY2IyNzUzLWE5OGMtMTFlYS04NGVjLTAwMTYzZTAwOGU3MCIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlLXN5c3RlbTphZG1pbiJ9.tX3jyNh-GEuZQg-hmy7igqh9vpTAz8Jh9uEv-diZ5XWjX9JYhxwD9nxTQvCcvzY7iPIbvxQfW2GHDZISPoopX0vQy9mQ7npVitrOvFovk06plefI5Gxjdft6vdpt-ArsGTpm7-s9G-3aBg5x41h3Cdgyv-W-ypFlCr9dKu9K7BcRIXSq_GQlq5TBmd-LKFXoer4QGwkn7geq5-ziMk_lY21jIGVdIkq9IRiH8NWuCl7l8i6nQESQDUUpMyKDCqkJqUFV8UkrQL7TfqurFP36_TUAQTh2ZAE8nFnrKRoa09BnjT-FoPO6Jnq6COQjk3PGDHV8LKNDAjCCrs0A53IYGw</span><br><span class="line">obj=nginx-test</span><br><span class="line"></span><br><span class="line">echo &quot;begin to patch $obj the file &quot;$&#123;obj_file&#125;</span><br><span class="line">curl -XPATCH -H &quot;Accept: application/json&quot; -H  &quot;Content-Type: application/merge-patch+json&quot; --header &quot;Authorization: Bearer $TOKEN&quot; --insecure -d  @$&#123;obj_file&#125; $APISERVER/apis/kuring.me/v1alpha1/namespaces/$&#123;namespace&#125;/$&#123;kind&#125;/$obj/status</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>k8s virtual cluster 方案 - vCluster</title>
    <url>/post/vcluster/</url>
    <content><![CDATA[<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><ul>
<li>host cluster：virtual cluster 中的宿主 k8s 集群，承载了所有的计算资源。也会被叫做 super cluster。</li>
<li>virtual cluster：virtual cluster 中的租户 k8s 集群，通常简写 vc。也会被叫做 tenant cluster。</li>
<li>vCluster：k8s virtual cluster 的实现之一，即本文中要介绍的方案。</li>
</ul>
<h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><h2 id="k8s-的多租功能"><a href="#k8s-的多租功能" class="headerlink" title="k8s 的多租功能"></a>k8s 的多租功能</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/vcluster-compare.png" alt="image.png"><br>k8s 自身在多租的能力上支持较差，提供了 namespace 级别的隔离，不同的租户使用不同的 namespace，但该隔离功能较弱。很多组件部署在同一个 workload 会存在诸多问题：</p>
<ol>
<li>使用全局对象存在冲突，比如 CRD。</li>
<li>存在诸多安全性问题，比如多个租户之间的 pod 完全可以互访，没有任何隔离机制。</li>
<li>不同组件对于 k8s 的版本不统一。</li>
</ol>
<p>为了解决多租的问题，最简单的思路就是使用多 k8s 集群，业界的 KubeFed v2、karmada、clusternet、OCM 等均为多 k8s 集群的实现。但多 k8s 集群因为存在独立的控制面和计算资源，存在资源消耗过多的问题。</p>
<p>还有一个中间思路为仅做 k8s 的控制面隔离，计算资源仍然共享，即 pod 也可以解决很多的多租隔离问题。k8s 的控制面隔离又存在两个主要方案：</p>
<ol>
<li>独立的 kube-apiserver 和 etcd、kube-controller-manager， kube-scheduler 共享 host cluster。该方案中有独立的 kube-apiserver 组件，这里的 etcd 可以被 sqllite、mysql 等存储取代。该方案统称为 virtual cluster，简称为 vc。</li>
<li>独立的 proxy apiserver，kube-apiserver、kube-controller-manager、kube-scheduler 共享 host cluster。访问 k8s 的请求先到 proxy apiserver，proxy apiserver 转发到 host cluster 的 kube-apiserver。可以在 proxy apiserver 中提供独立的 RBAC 机制，实现一定程度的隔离。该方案在开源中未看到具体的实现。</li>
</ol>
<h2 id="vCluster-介绍"><a href="#vCluster-介绍" class="headerlink" title="vCluster 介绍"></a>vCluster 介绍</h2><p><a href="https://github.com/loft-sh/vcluster">vCluster</a> 为 virtual cluster 的开源实现之一，由 Loft Labs 提供，Github Star 3.7K，代码行数 4 万行。除了开源版本外，还提供了商业版本 vCluster PRO。</p>
<p>vCluster 设计原则：</p>
<ol>
<li>最小化资源占用。在实现上使用了单 pod 的 k3s 作为 k8s 的控制面。</li>
<li>复用 host cluster 的计算、存储和网络资源。</li>
<li>降低对 host cluster 的请求。</li>
<li>简单灵活。</li>
<li>不需要 host cluster 的管理员权限。</li>
<li>vCluster 多个 namespace 下的对象映射到 host cluster 的同一个 namespace 下。同时也可以支持 vCluster 的一个 namespace 对应 host cluster 的一个 namespace。</li>
<li>易清理。</li>
</ol>
<h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><h2 id="k8s-集群准备"><a href="#k8s-集群准备" class="headerlink" title="k8s 集群准备"></a>k8s 集群准备</h2><p>k8s 集群这里使用了 kind 方案，kind 配置 kind.conf 如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Cluster</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kind.x-k8s.io/v1alpha4</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">vcluster</span></span><br><span class="line"><span class="attr">nodes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">role:</span> <span class="string">control-plane</span></span><br><span class="line">  <span class="comment"># 如果需要 ingress，则需要指定该参数</span></span><br><span class="line">  <span class="attr">kubeadmConfigPatches:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">    kind: InitConfiguration</span></span><br><span class="line"><span class="string">    nodeRegistration:</span></span><br><span class="line"><span class="string">      kubeletExtraArgs:</span></span><br><span class="line"><span class="string">        node-labels: &quot;ingress-ready=true&quot;</span></span><br><span class="line"><span class="string"></span>  <span class="attr">extraPortMappings:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">hostPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">hostPort:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="comment"># 指定 k8s 版本，默认不指定</span></span><br><span class="line">  <span class="comment"># image: kindest/node:v1.23.17</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">role:</span> <span class="string">worker</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">role:</span> <span class="string">worker</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">role:</span> <span class="string">worker</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">apiServerPort:</span> <span class="number">6443</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>kind create cluster --config kind.conf</code> 即可创建 k8s 集群，包含了一个 control-plane 节点，三个 worker 节点。</p>
<h2 id="安装-vcluster"><a href="#安装-vcluster" class="headerlink" title="安装 vcluster"></a>安装 vcluster</h2><p>vCluster 提供了使用 vcluster cli、helm 和 kubectl 三种安装方式，使用 vcluster cli 最为简单，其底层同样采用 helm chart 的方式部署，下面采用 vcluster cli 的方式进行安装。<br>安装 vcluster cli 工具：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">curl</span> <span class="string">-L</span> <span class="string">-o</span> <span class="string">vcluster</span> <span class="string">&quot;https://github.com/loft-sh/vcluster/releases/latest/download/vcluster-darwin-arm64&quot;</span> <span class="string">&amp;&amp;</span> <span class="string">sudo</span> <span class="string">install</span> <span class="string">-c</span> <span class="string">-m</span> <span class="number">0755 </span><span class="string">vcluster</span> <span class="string">/usr/local/bin</span> <span class="string">&amp;&amp;</span> <span class="string">rm</span> <span class="string">-f</span> <span class="string">vcluster</span></span><br></pre></td></tr></table></figure>
<p>或者执行 <code>brew install vcluster</code>安装 vcluster 命令行工具。</p>
<p>执行命令 <code>vcluster create my-vcluster</code> 创建 virtual cluster。会在 host cluster 上创建 namespace <code>vcluster-my-vcluster</code>，该 namespace 下创建如下对象：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">all</span> <span class="string">-n</span> <span class="string">vcluster-my-vcluster</span></span><br><span class="line"><span class="string">NAME</span>                                                       <span class="string">READY</span>   <span class="string">STATUS</span>    <span class="string">RESTARTS</span>        <span class="string">AGE</span></span><br><span class="line"><span class="string">pod/coredns-68559449b6-l5whx-x-kube-system-x-my-vcluster</span>   <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">2</span> <span class="string">(5m45s</span> <span class="string">ago)</span>   <span class="string">3d</span></span><br><span class="line"><span class="string">pod/my-vcluster-0</span>                                          <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">2</span> <span class="string">(5m45s</span> <span class="string">ago)</span>   <span class="string">3d</span></span><br><span class="line"></span><br><span class="line"><span class="string">NAME</span>                                              <span class="string">TYPE</span>        <span class="string">CLUSTER-IP</span>     <span class="string">EXTERNAL-IP</span>   <span class="string">PORT(S)</span>                         <span class="string">AGE</span></span><br><span class="line"><span class="string">service/kube-dns-x-kube-system-x-my-vcluster</span>      <span class="string">ClusterIP</span>   <span class="number">10.96</span><span class="number">.67</span><span class="number">.119</span>   <span class="string">&lt;none&gt;</span>        <span class="number">53</span><span class="string">/UDP,53/TCP,9153/TCP</span>          <span class="string">3d</span></span><br><span class="line"><span class="string">service/my-vcluster</span>                               <span class="string">NodePort</span>    <span class="number">10.96</span><span class="number">.214</span><span class="number">.58</span>   <span class="string">&lt;none&gt;</span>        <span class="number">443</span><span class="string">:30540/TCP,10250:31621/TCP</span>   <span class="string">3d</span></span><br><span class="line"><span class="string">service/my-vcluster-headless</span>                      <span class="string">ClusterIP</span>   <span class="string">None</span>           <span class="string">&lt;none&gt;</span>        <span class="number">443</span><span class="string">/TCP</span>                         <span class="string">3d</span></span><br><span class="line"><span class="string">service/my-vcluster-node-vcluster-control-plane</span>   <span class="string">ClusterIP</span>   <span class="number">10.96</span><span class="number">.69</span><span class="number">.115</span>   <span class="string">&lt;none&gt;</span>        <span class="number">10250</span><span class="string">/TCP</span>                       <span class="string">3d</span></span><br><span class="line"></span><br><span class="line"><span class="string">NAME</span>                           <span class="string">READY</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">statefulset.apps/my-vcluster</span>   <span class="number">1</span><span class="string">/1</span>     <span class="string">3d</span></span><br></pre></td></tr></table></figure>
<p>可以看到在该 namespace 下创建了 coredns 和 StatefulSet my-vcluster。每个租户有独立的 coredns 组件，用来做域名解析。my-vcluster 为 vCluster 的管控面组件，包括了 k8s controller plane 和 syncer 组件。</p>
<p>执行  <code>vcluster connect my-vcluster</code> 后会在本地启动代理，并自动切换本地的 kubeconfig context，将 context 切换到 virtual cluster。执行 kubectl 命令即可连接到对应的 k8s 集群。virtual cluster 集群中的信息如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">all</span> <span class="string">-A</span></span><br><span class="line"><span class="string">NAMESPACE</span>     <span class="string">NAME</span>                           <span class="string">READY</span>   <span class="string">STATUS</span>    <span class="string">RESTARTS</span>      <span class="string">AGE</span></span><br><span class="line"><span class="string">kube-system</span>   <span class="string">pod/coredns-68559449b6-jg2bs</span>   <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">1</span> <span class="string">(20m</span> <span class="string">ago)</span>   <span class="string">51m</span></span><br><span class="line"></span><br><span class="line"><span class="string">NAMESPACE</span>     <span class="string">NAME</span>                 <span class="string">TYPE</span>        <span class="string">CLUSTER-IP</span>     <span class="string">EXTERNAL-IP</span>   <span class="string">PORT(S)</span>                  <span class="string">AGE</span></span><br><span class="line"><span class="string">kube-system</span>   <span class="string">service/kube-dns</span>     <span class="string">ClusterIP</span>   <span class="number">10.96</span><span class="number">.120</span><span class="number">.59</span>   <span class="string">&lt;none&gt;</span>        <span class="number">53</span><span class="string">/UDP,53/TCP,9153/TCP</span>   <span class="string">51m</span></span><br><span class="line"><span class="string">default</span>       <span class="string">service/kubernetes</span>   <span class="string">ClusterIP</span>   <span class="number">10.96</span><span class="number">.35</span><span class="number">.53</span>    <span class="string">&lt;none&gt;</span>        <span class="number">443</span><span class="string">/TCP</span>                  <span class="string">51m</span></span><br><span class="line"></span><br><span class="line"><span class="string">NAMESPACE</span>     <span class="string">NAME</span>                      <span class="string">READY</span>   <span class="string">UP-TO-DATE</span>   <span class="string">AVAILABLE</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">kube-system</span>   <span class="string">deployment.apps/coredns</span>   <span class="number">1</span><span class="string">/1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="string">51m</span></span><br><span class="line"></span><br><span class="line"><span class="string">NAMESPACE</span>     <span class="string">NAME</span>                                 <span class="string">DESIRED</span>   <span class="string">CURRENT</span>   <span class="string">READY</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">kube-system</span>   <span class="string">replicaset.apps/coredns-68559449b6</span>   <span class="number">1</span>         <span class="number">1</span>         <span class="number">1</span>       <span class="string">51m</span></span><br></pre></td></tr></table></figure>
<p>在 virtual cluster 可以看到仅包含了 coredns 组件。</p>
<p>在 virtual cluster 和在 host cluster 中的 node 信息：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">node</span> <span class="string">-o</span> <span class="string">wide</span></span><br><span class="line"><span class="string">NAME</span>               <span class="string">STATUS</span>   <span class="string">ROLES</span>    <span class="string">AGE</span>   <span class="string">VERSION</span>   <span class="string">INTERNAL-IP</span>     <span class="string">EXTERNAL-IP</span>   <span class="string">OS-IMAGE</span>                         <span class="string">KERNEL-VERSION</span>     <span class="string">CONTAINER-RUNTIME</span></span><br><span class="line"><span class="string">vcluster-worker3</span>   <span class="string">Ready</span>    <span class="string">&lt;none&gt;</span>   <span class="string">51m</span>   <span class="string">v1.27.3</span>   <span class="number">10.96</span><span class="number">.118</span><span class="number">.228</span>   <span class="string">&lt;none&gt;</span>        <span class="string">Debian</span> <span class="string">GNU/Linux</span> <span class="number">11</span> <span class="string">(bullseye)</span>   <span class="number">5.10</span><span class="number">.76</span><span class="string">-linuxkit</span>   <span class="string">containerd://1.7.1</span></span><br><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">node</span> <span class="string">-o</span> <span class="string">wide</span> <span class="string">--context</span> <span class="string">kind-vcluster</span></span><br><span class="line"><span class="string">NAME</span>                     <span class="string">STATUS</span>   <span class="string">ROLES</span>           <span class="string">AGE</span>   <span class="string">VERSION</span>   <span class="string">INTERNAL-IP</span>   <span class="string">EXTERNAL-IP</span>   <span class="string">OS-IMAGE</span>                         <span class="string">KERNEL-VERSION</span>     <span class="string">CONTAINER-RUNTIME</span></span><br><span class="line"><span class="string">vcluster-control-plane</span>   <span class="string">Ready</span>    <span class="string">control-plane</span>   <span class="string">86m</span>   <span class="string">v1.27.3</span>   <span class="number">172.19</span><span class="number">.0</span><span class="number">.3</span>    <span class="string">&lt;none&gt;</span>        <span class="string">Debian</span> <span class="string">GNU/Linux</span> <span class="number">11</span> <span class="string">(bullseye)</span>   <span class="number">5.10</span><span class="number">.76</span><span class="string">-linuxkit</span>   <span class="string">containerd://1.7.1</span></span><br><span class="line"><span class="string">vcluster-worker</span>          <span class="string">Ready</span>    <span class="string">&lt;none&gt;</span>          <span class="string">85m</span>   <span class="string">v1.27.3</span>   <span class="number">172.19</span><span class="number">.0</span><span class="number">.2</span>    <span class="string">&lt;none&gt;</span>        <span class="string">Debian</span> <span class="string">GNU/Linux</span> <span class="number">11</span> <span class="string">(bullseye)</span>   <span class="number">5.10</span><span class="number">.76</span><span class="string">-linuxkit</span>   <span class="string">containerd://1.7.1</span></span><br><span class="line"><span class="string">vcluster-worker2</span>         <span class="string">Ready</span>    <span class="string">&lt;none&gt;</span>          <span class="string">85m</span>   <span class="string">v1.27.3</span>   <span class="number">172.19</span><span class="number">.0</span><span class="number">.5</span>    <span class="string">&lt;none&gt;</span>        <span class="string">Debian</span> <span class="string">GNU/Linux</span> <span class="number">11</span> <span class="string">(bullseye)</span>   <span class="number">5.10</span><span class="number">.76</span><span class="string">-linuxkit</span>   <span class="string">containerd://1.7.1</span></span><br><span class="line"><span class="string">vcluster-worker3</span>         <span class="string">Ready</span>    <span class="string">&lt;none&gt;</span>          <span class="string">85m</span>   <span class="string">v1.27.3</span>   <span class="number">172.19</span><span class="number">.0</span><span class="number">.4</span>    <span class="string">&lt;none&gt;</span>        <span class="string">Debian</span> <span class="string">GNU/Linux</span> <span class="number">11</span> <span class="string">(bullseye)</span>   <span class="number">5.10</span><span class="number">.76</span><span class="string">-linuxkit</span>   <span class="string">containerd://1.7.1</span></span><br></pre></td></tr></table></figure>
<p>可以看到在 virtual cluster 和 host cluster 中的 node 名字相同，这是因为 node 在 vCluster 中并没有做隔离，而是从 host cluster 中做了同步。但 virtual cluster 中的 node 节点仅包含 pod 在 host cluster 中已经使用的 node 节点，未使用的节点并不会在 virtual cluster 上。<br>同时可以看到 vc 和 host cluster 中的 node ip 地址并不相同，vc 中的 node ip 地址跟 host cluster 中的对应 service clusterip 相同，在 host cluster 中的对应 service 名字为 <code>$vClusterName-node-$hostClusterNodeName</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">svc</span> <span class="string">--context</span> <span class="string">kind-vcluster</span> <span class="string">-n</span> <span class="string">vcluster-my-vcluster</span> <span class="string">my-vcluster-node-vcluster-worker3</span></span><br><span class="line"><span class="string">NAME</span>                                <span class="string">TYPE</span>        <span class="string">CLUSTER-IP</span>      <span class="string">EXTERNAL-IP</span>   <span class="string">PORT(S)</span>     <span class="string">AGE</span></span><br><span class="line"><span class="string">my-vcluster-node-vcluster-worker3</span>   <span class="string">ClusterIP</span>   <span class="number">10.96</span><span class="number">.118</span><span class="number">.228</span>   <span class="string">&lt;none&gt;</span>        <span class="number">10250</span><span class="string">/TCP</span>   <span class="string">3h54m</span></span><br></pre></td></tr></table></figure>

<p>在 virtual cluster 中创建 k8s 对象：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 virtual cluster 创建 namespace</span></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">create</span> <span class="string">ns</span> <span class="string">demo-nginx</span></span><br><span class="line"><span class="string">namespace/demo-nginx</span> <span class="string">created</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Deployment</span></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">create</span> <span class="string">deployment</span> <span class="string">nginx-deployment</span> <span class="string">-n</span> <span class="string">demo-nginx</span> <span class="string">--image=nginx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 virtual cluster 上创建出了 pod</span></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">pod</span> <span class="string">-n</span> <span class="string">demo-nginx</span> <span class="string">-o</span> <span class="string">wide</span></span><br><span class="line"><span class="string">NAME</span>                                <span class="string">READY</span>   <span class="string">STATUS</span>    <span class="string">RESTARTS</span>   <span class="string">AGE</span>   <span class="string">IP</span>           <span class="string">NODE</span>                     <span class="string">NOMINATED</span> <span class="string">NODE</span>   <span class="string">READINESS</span> <span class="string">GATES</span></span><br><span class="line"><span class="string">nginx-deployment-66fb7f764c-dn59g</span>   <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>          <span class="string">11m</span>   <span class="number">10.244</span><span class="number">.0</span><span class="number">.7</span>   <span class="string">vcluster-control-plane</span>   <span class="string">&lt;none&gt;</span>           <span class="string">&lt;none&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于 pod 调度了 host cluster 新节点，在 virtual cluster 中可以看到新的 k8s node，k8s node 为刚刚创建</span></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">node</span></span><br><span class="line"><span class="string">NAME</span>               <span class="string">STATUS</span>   <span class="string">ROLES</span>    <span class="string">AGE</span>     <span class="string">VERSION</span></span><br><span class="line"><span class="string">vcluster-worker2</span>   <span class="string">Ready</span>    <span class="string">&lt;none&gt;</span>   <span class="string">2m45s</span>   <span class="string">v1.27.3</span></span><br><span class="line"><span class="string">vcluster-worker3</span>   <span class="string">Ready</span>    <span class="string">&lt;none&gt;</span>   <span class="string">57m</span>     <span class="string">v1.27.3</span></span><br></pre></td></tr></table></figure>
<p>在 host cluster 中看到如下对象：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 host cluster 上并没有对应的 namespace demo-nginx</span></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">ns</span> <span class="string">--context</span> <span class="string">kind-vcluster</span> <span class="string">demo-nginx</span></span><br><span class="line"><span class="string">Error</span> <span class="string">from</span> <span class="string">server</span> <span class="string">(NotFound):</span> <span class="string">namespaces</span> <span class="string">&quot;demo-nginx&quot;</span> <span class="string">not</span> <span class="string">found</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 host cluster 上并没有对应的 deployment nginx-deployment</span></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">deploy</span> <span class="string">-A</span> <span class="string">--context</span> <span class="string">kind-vcluster</span></span><br><span class="line"><span class="string">NAMESPACE</span>            <span class="string">NAME</span>                       <span class="string">READY</span>   <span class="string">UP-TO-DATE</span>   <span class="string">AVAILABLE</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">ingress-nginx</span>        <span class="string">ingress-nginx-controller</span>   <span class="number">1</span><span class="string">/1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="string">90m</span></span><br><span class="line"><span class="string">kube-system</span>          <span class="string">coredns</span>                    <span class="number">2</span><span class="string">/2</span>     <span class="number">2</span>            <span class="number">2</span>           <span class="string">91m</span></span><br><span class="line"><span class="string">local-path-storage</span>   <span class="string">local-path-provisioner</span>     <span class="number">1</span><span class="string">/1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="string">91m</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但在 host cluster 上却看到了对应的 pod，位于 vcluster 统一的 namespace vcluster-my-vcluster 之下</span></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">pod</span> <span class="string">-n</span> <span class="string">vcluster-my-vcluster</span> <span class="string">--context</span> <span class="string">kind-vcluster</span></span><br><span class="line"><span class="string">NAME</span>                                                           <span class="string">READY</span>   <span class="string">STATUS</span>    <span class="string">RESTARTS</span>      <span class="string">AGE</span></span><br><span class="line"><span class="string">coredns-68559449b6-jg2bs-x-kube-system-x-my-vcluster</span>           <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">1</span> <span class="string">(26m</span> <span class="string">ago)</span>   <span class="string">57m</span></span><br><span class="line"><span class="string">my-vcluster-0</span>                                                  <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">1</span> <span class="string">(26m</span> <span class="string">ago)</span>   <span class="string">86m</span></span><br><span class="line"><span class="string">nginx-deployment-66fb7f764c-sffqt-x-demo-nginx-x-my-vcluster</span>   <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>             <span class="string">2m22s</span></span><br></pre></td></tr></table></figure>
<p>可以看到仅 pod 在 host cluster 中同步存在，而 namespace、deployment 这些对象仅存在于 virtual cluster 中。在 virtual cluster 中创建的多个不同 namespace pod 仅会存在于 host cluster 的同一个 namespace 下。</p>
<h2 id="验证-service"><a href="#验证-service" class="headerlink" title="验证 service"></a>验证 service</h2><p>在 virtual cluster 中创建 service 对象：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">kubernetes.io/cluster-service:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">demo-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ipFamilies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">IPv4</span></span><br><span class="line">  <span class="attr">ipFamilyPolicy:</span> <span class="string">SingleStack</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure>
<p>在 virtual cluster 中包含如下的 Service 对象：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">svc</span> <span class="string">-n</span> <span class="string">demo-nginx</span></span><br><span class="line"><span class="string">NAME</span>    <span class="string">TYPE</span>        <span class="string">CLUSTER-IP</span>     <span class="string">EXTERNAL-IP</span>   <span class="string">PORT(S)</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">nginx</span>   <span class="string">ClusterIP</span>   <span class="number">10.96</span><span class="number">.239</span><span class="number">.53</span>   <span class="string">&lt;none&gt;</span>        <span class="number">80</span><span class="string">/TCP</span>    <span class="string">2m11s</span></span><br></pre></td></tr></table></figure>
<p>在 host cluster 中会同步创建如下的 Service 对象，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/object-name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/object-namespace:</span> <span class="string">demo-nginx</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/object-uid:</span> <span class="string">5ab7aa9c-90b6-46f9-a162-9ea9ca9826f3</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2023-11-28T09:32:22Z&quot;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/label-my-vcluster-x-a172cedcae:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/label-my-vcluster-x-d9125f8911:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/managed-by:</span> <span class="string">my-vcluster</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/namespace:</span> <span class="string">demo-nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-x-demo-nginx-x-my-vcluster</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">vcluster-my-vcluster</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-vcluster</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">463a503e-d889-49a7-94e0-0cba5299dd47</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;12344&quot;</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">fc9ea383-996e-471c-9c27-ee1c22fec7a3</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.96</span><span class="number">.239</span><span class="number">.53</span></span><br><span class="line">  <span class="attr">clusterIPs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">10.96</span><span class="number">.239</span><span class="number">.53</span></span><br><span class="line">  <span class="attr">internalTrafficPolicy:</span> <span class="string">Cluster</span></span><br><span class="line">  <span class="attr">ipFamilies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IPv4</span></span><br><span class="line">  <span class="attr">ipFamilyPolicy:</span> <span class="string">SingleStack</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/label-my-vcluster-x-a172cedcae:</span> <span class="string">nginx-deployment</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/managed-by:</span> <span class="string">my-vcluster</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/namespace:</span> <span class="string">demo-nginx</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 host cluster 中的 service 的 ClusterIP 跟 virutal cluster 一致，但 spec.selector 字段已经被 syncer 修改，以便可以匹配到正确的 pod。</p>
<h2 id="验证-Ingress"><a href="#验证-Ingress" class="headerlink" title="验证 Ingress"></a>验证 Ingress</h2><p>默认情况下 Ingress 不会同步到 host cluster，需要通过开关的方式启动。创建文件 values.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sync:</span></span><br><span class="line">  <span class="attr">ingresses:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>执行 <code>vcluster create my-vcluster --upgrade -f values.yaml</code> 即可修改现在 vcluster 集群配置。</p>
<p>在 virtual cluster 中创建如下的 Ingress 对象：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">demo-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.aa.com</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">ImplementationSpecific</span></span><br></pre></td></tr></table></figure>
<p>查看 host cluster 中的 Ingress 信息如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">ingress</span> <span class="string">--context</span> <span class="string">kind-vcluster</span> <span class="string">-n</span> <span class="string">vcluster-my-vcluster</span> <span class="string">-o</span> <span class="string">yaml</span> <span class="string">nginx-x-demo-nginx-x-my-vcluster</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/object-name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/object-namespace:</span> <span class="string">demo-nginx</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/object-uid:</span> <span class="string">4b8034a6-1513-4ccd-b80a-66807d862b4e</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2023-11-28T10:07:52Z&quot;</span></span><br><span class="line">  <span class="attr">generation:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/label-my-vcluster-x-a172cedcae:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/managed-by:</span> <span class="string">my-vcluster</span></span><br><span class="line">    <span class="attr">vcluster.loft.sh/namespace:</span> <span class="string">demo-nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-x-demo-nginx-x-my-vcluster</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">vcluster-my-vcluster</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-vcluster</span></span><br><span class="line">    <span class="attr">uid:</span> <span class="string">463a503e-d889-49a7-94e0-0cba5299dd47</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;16292&quot;</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">1d0de02b-5aad-4858-a8cf-2caa345ca85b</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.aa.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">nginx-x-demo-nginx-x-my-vcluster</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">ImplementationSpecific</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span></span><br><span class="line">    <span class="attr">ingress:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hostname:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure>
<p>可以看到 Ingress 中对应的 Service 名字已经修改了 host cluster 中对应的 Service 名字。</p>
<h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><p>在使用完成后执行如下命令即可销毁 virtual cluster：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换本地的 context</span></span><br><span class="line">vcluster disconnect</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除 vcluster</span></span><br><span class="line">vcluster delete my-vcluster</span><br></pre></td></tr></table></figure>

<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/vcluster-arch.png" alt="image.png"></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>整个架构中，有两大核心组件：k8s Control Plane 和 syncer。其中 StatefulSet my-vcluster 中容器 syncer，默认情况下在该容器中同时启动了 k3s 容器作为 vCluster 控制平面和 vCluster 的 syncer 进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">exec</span> -it --context kind-vcluster -n vcluster-my-vcluster my-vcluster-0 -- ps -ef</span></span><br><span class="line">Defaulted container &quot;syncer&quot; out of: syncer, vcluster (init)</span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      2:57 /vcluster start --name=my-vcluster --kube-config=/data/k3s</span><br><span class="line">   17 root     18:35 /k3s-binary/k3s server</span><br><span class="line">   46 root      0:00 ps -ef</span><br></pre></td></tr></table></figure>

<h3 id="controller-plane"><a href="#controller-plane" class="headerlink" title="controller plane"></a>controller plane</h3><p>控制平面默认使用 k3s，存储使用 sqllite，也可以使用 etcd、mysql、postgresql。k8s 发行版也可以使用 k0s、Vanilla（标准 k8s）、第三方镜像等。控制平面由如下几个组件组成：</p>
<ol>
<li>k8s apiserver。</li>
<li>数据存储，比如 sqllite、etcd 等。</li>
<li>kube-controller-manager</li>
<li>kube-scheduler：可选组件，默认使用 host cluster 调度器。</li>
</ol>
<blockquote>
<p>在 Pro 版本中，允许控制面跟 pod 部署在不同的 host cluster。</p>
</blockquote>
<h3 id="syncer"><a href="#syncer" class="headerlink" title="syncer"></a>syncer</h3><p>virtual cluster 中并不包含实际的计算、存储和网络资源，syncer 的职责为将对象从 virtual cluster 同步到 host cluster，也有少部分对象需要从 host cluster 同步到 virtual cluster。<br>vCluster 将 k8s 对象划分为 low level 和 high level，其中 high level 的对象仅存在于 virtual cluster 中，比如 Deployment、CRD 等对象。low level 的对象会通过 syncer 模块同步到 host cluster 上，包括 Pod、ConfigMap、Secret 等。low level 的对象在 virutal cluster 为多个 namespace，但均会映射到 host cluster 的一个 namespace 下。另外，vCluster 也支持将 virtual cluster 的多个 namespace 映射到 host cluster 的多个 namespace，该特性目前处于 alpha 状态。<br>vCluster 可以通过<a href="https://www.vcluster.com/docs/syncer/other_resources/config_syntax">配置的方式</a>来定制资源的同步，更复杂的同步规则提供了<a href="https://www.vcluster.com/docs/advanced-topics/plugins-overview">插件机制</a>实现。<br>vCluster 默认支持的同步资源列表：<a href="https://www.vcluster.com/docs/syncer/core_resources">https://www.vcluster.com/docs/syncer/core_resources</a>。</p>
<p>已经创建完成的 syncer 配置，可以通过 <code>vcluster create my-vcluster --upgrade -f values.yaml</code> 的方式修改，该命令会调用 helm update，helm update 命令最终会修改 StatefulSet syncer 的配置，并触发 pod 的重启。</p>
<h4 id="k8s-node-同步"><a href="#k8s-node-同步" class="headerlink" title="k8s node 同步"></a>k8s node 同步</h4><p>支持多种 node 的同步行为，通过修改 syncer 的启动参数：</p>
<ol>
<li>Fake Node：默认行为。根据 pod 中的 spec.nodeName 创建 Fake Node。Fake Node 为 syncer 服务自动创建。如果没有 pod 调度到 Fake Node 上，则 Fake Node 会自动删除。</li>
<li>Real Node：根据 pod 中的 spec.nodeName 创建 Real Node，Real Node 的信息从 host cluster 同步。如果没有 pod 调度到 Real Node 上，则 Real Node 会自动删除。</li>
<li>Real Node All：同步 host cluster 的所有 node 到 virtual cluster。如果要使用 DaemonSet，需要使用该模式。</li>
<li>Real Nodes Label Selector：仅同步 label selector 匹配的 host node 到 virtual cluster 中。</li>
<li>Real Nodes + Label Selector：仅同步包含在 pod spec.nodeName 且 Label selector 可以选中的 host cluster node 到 virtual cluster 中。</li>
</ol>
<h2 id="pod-调度"><a href="#pod-调度" class="headerlink" title="pod 调度"></a>pod 调度</h2><p>默认情况下，virtual cluster 中的 pod 调度会使用 host cluster 的调度，但存在如下的问题：</p>
<ol>
<li>在 virtual cluster node 上的 label 对于 pod 调度不会生效。</li>
<li>drait、trait 命令对于 virtual cluster 上的 pod 没有影响。</li>
<li>virtual cluster 中使用自定义调度器不生效。</li>
</ol>
<p>基于上述限制，vCluster 支持如下两种方案：</p>
<ol>
<li>支持在 virtual cluster 中使用独立的调度器。可以给 virtual cluster 上的 node 增加标签、污点等信息，pod 的调度在 virtual cluster 中的调度器实现，syncer 组件仅将已经调度完成的 pod 同步到 host cluster。</li>
<li>仍然复用 host cluster 调度器，但做了部分功能的增强：在 syncer 服务中指定仅同步部分 host node 到 virtual cluster 中，这样 pod 就仅会调度到 host cluster 的特定 node 上。</li>
</ol>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>virutal cluster 中无独立的 pod 网络和 service 网络，完全复用 host cluster 的网络。</p>
<h3 id="Service-网络"><a href="#Service-网络" class="headerlink" title="Service 网络"></a>Service 网络</h3><ol>
<li>会从 virtual cluster 同步到 host cluster，两者的 clusterip 一致。</li>
<li>允许将一些 host cluster 中的 service 同步到 virtual cluster 中，同时指定service 的名字。</li>
<li>允许将 virtual cluster 中的 service 同步到 host cluster 中，同时指定service 的名字。</li>
</ol>
<h3 id="Ingress-网络"><a href="#Ingress-网络" class="headerlink" title="Ingress 网络"></a>Ingress 网络</h3><p>允许将 virtual cluster 中的 Ingress 同步到 host cluster，以便复用 host cluster 中的 Ingress Controller。</p>
<h3 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h3><p>在 virtual cluster 中部署了单独的 coredns 组件，默认情况下，在 vritual cluster 中的域名仅能解析内部的域名，不能解析 host cluster 上的域名。可以通过开关的方式，将 virtual cluster 中的域名解析转发到 host cluster 的 coredns。</p>
<blockquote>
<p>在 PRO 版本中，coredns 组件可以集成到 syncer 组件内部，以便节省资源。</p>
</blockquote>
<h3 id="NetworkPolicy"><a href="#NetworkPolicy" class="headerlink" title="NetworkPolicy"></a>NetworkPolicy</h3><p>默认情况下，vcluster 中会忽略 virtual cluster 中的 NetworkPolicy 资源。可以通过开关的方式打开该配置，即可将 NetworkPolicy 规则同步到 host cluster。</p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/vcluster-pv.png" alt="image.png"><br>默认情况下，host StorageClass 不会同步到 vc，可以通过开关的方式打开同步。<br>默认情况下，pv 不会从 vc 同步到 host cluster，可以通过开关的方式打开。</p>
<h2 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h2><h3 id="monitoring"><a href="#monitoring" class="headerlink" title="monitoring"></a>monitoring</h3><p>metrics-server 用来监控 k8s 的 Deployment、StatefulSet 等对象，metrics-server 可以复用 host cluster 中的，但需要启用 metrics server proxy 功能。也可以在 vc 中单独部署一套 metrics server。<br>在 vc 集群中，由于每个 k8s node 的 ip 地址为 host cluster 中的 service clusterip，在 vc 中网络是可达的，可以获取到对应的监控信息。</p>
<h3 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h3><p>需要用到Hostpath Mapper组件，该组件为 DaemonSet 的形式。后续即可以部署 loki 等组件。</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="隔离模式"><a href="#隔离模式" class="headerlink" title="隔离模式"></a>隔离模式</h3><p>在启动的时候指定<code>--isolate</code>，在该模式下对 workload 做了多种限制。</p>
<ol>
<li>对 vcluster pod 的 Pod Security 做限制，不符合规范的 pod 不会同步到 host cluster。</li>
<li>可以对 vc 中 pod 的总资源量做限制。</li>
<li>在 host cluster 上通过 NetworkPolicy 做隔离。</li>
</ol>
<h2 id="virtual-cluster-集群的创建"><a href="#virtual-cluster-集群的创建" class="headerlink" title="virtual cluster 集群的创建"></a>virtual cluster 集群的创建</h2><p>目前仅能通过 vcluster cli、helm 的方式来创建，底层均为 helm chart 的方式来管理，缺少服务化功能。</p>
<h2 id="virtual-cluster-集群对外暴露方法"><a href="#virtual-cluster-集群对外暴露方法" class="headerlink" title="virtual cluster 集群对外暴露方法"></a>virtual cluster 集群对外暴露方法</h2><h3 id="获取-kubeconfig"><a href="#获取-kubeconfig" class="headerlink" title="获取 kubeconfig"></a>获取 kubeconfig</h3><h4 id="vcluster-connect-命令"><a href="#vcluster-connect-命令" class="headerlink" title="vcluster connect 命令"></a>vcluster connect 命令</h4><p>该命令可以修改本地的 kubeconfig 文件，并将 context 切换为 virtual cluster context。默认为 virutual cluster 的管理员权限，可以指定使用特定的 ServiceAccount。</p>
<h4 id="host-cluster-secret-中获取到-kubeconfig"><a href="#host-cluster-secret-中获取到-kubeconfig" class="headerlink" title="host cluster secret 中获取到 kubeconfig"></a>host cluster secret 中获取到 kubeconfig</h4><p>在 host cluster 中，在 vc 的 namespace 下，存在一个以 <code>vc-</code> 开头的 Secret，该 Secret 中保存了 kubeconfig 完整信息。</p>
<h3 id="vc-集群中的-apiserver-的暴露地址"><a href="#vc-集群中的-apiserver-的暴露地址" class="headerlink" title="vc 集群中的 apiserver 的暴露地址"></a>vc 集群中的 apiserver 的暴露地址</h3><p>可以在 syncer 启动的时候指定获取的 kubeconfig 中的 endpoint 地址。endpoint 地址即为 vc 集群中的 kube-apiserver 的地址，该 kube-apiserver 的地址可以通过 host cluster 中的 Ingress、LoadBalancer Service、NodePort Service 等方式对外暴露。</p>
<h2 id="高可用设计"><a href="#高可用设计" class="headerlink" title="高可用设计"></a>高可用设计</h2><h3 id="control-plane-高可用"><a href="#control-plane-高可用" class="headerlink" title="control plane 高可用"></a>control plane 高可用</h3><p>k3s 可以支持高可用架构，在创建 vc 的时候通过指定的副本的方式来设置高可用。其他的 k8s 发行版同样类似的实现。</p>
<h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><p>vCluster 本身并没有提供对于 vc 集群的数据备份与恢复功能，可以通过通用的 velero 方式实现备份与恢复功能。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>未做网络隔离，容器网络和 service 网络仍然在同一个平面，要想相互隔离，必须使用 NetworkPolicy。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li>获取 helm chart 到本地</li>
</ol>
<pre><code class="shell">helm repo add lofts https://charts.loft.sh/
helm fetch lofts/vcluster
``
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Linux中的veth pair设备</title>
    <url>/post/veth-pair/</url>
    <content><![CDATA[<p>veth pair是一对虚拟的网络设备，两个网络设备彼此连接。常用于两个network namespace之间的连接，如果在同一个命名空间下有很多的限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌──────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                                                                              │</span><br><span class="line">│                                                                              │</span><br><span class="line">│                               network protocol                               │</span><br><span class="line">│                                                                              │</span><br><span class="line">│                                                                              │</span><br><span class="line">└────────────────────▲─────────────────────────▲──────────────────────▲────────┘</span><br><span class="line">                     │                         │                      │</span><br><span class="line">                     │                         │                      │</span><br><span class="line">                     │                         │                      │</span><br><span class="line">                     │                         │                      │</span><br><span class="line">                     │                         │                      │</span><br><span class="line">               ┌─────▼────┐              ┌─────▼────┐           ┌─────▼────┐</span><br><span class="line">               │          │              │          │           │          │</span><br><span class="line">               │   eth0   │              │  veth0   ◀───────────▶  veth1   │</span><br><span class="line">               │          │              │          │           │          │</span><br><span class="line">               └─────▲────┘              └──────────┘           └──────────┘</span><br><span class="line">                     │</span><br><span class="line">                     │</span><br><span class="line">                     │</span><br><span class="line">                     │</span><br><span class="line">                     │</span><br><span class="line">                     ▼</span><br><span class="line"></span><br><span class="line">             physical network</span><br></pre></td></tr></table></figure>

<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="veth设备的ping测试"><a href="#veth设备的ping测试" class="headerlink" title="veth设备的ping测试"></a>veth设备的ping测试</h3><h3 id="1-只给一个veth设备配置ip的情况测试"><a href="#1-只给一个veth设备配置ip的情况测试" class="headerlink" title="1. 只给一个veth设备配置ip的情况测试"></a>1. 只给一个veth设备配置ip的情况测试</h3><p>给veth0配置ip 192.168.100.10，可以看到主机的路由表中增加了目的地为192.168.100.0的记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost vagrant]# ip link add veth0 type veth peer name veth1</span><br><span class="line">[root@localhost vagrant]# ip addr add 192.168.100.10/24 dev veth0</span><br><span class="line">[root@localhost vagrant]# ip addr add 192.168.100.11/24 dev veth1</span><br><span class="line">## 因为veth创建完后默认不启用，此时还没有路由</span><br><span class="line">[root@localhost vagrant]# route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         gateway         0.0.0.0         UG    100    0        0 eth0</span><br><span class="line">10.0.2.0        0.0.0.0         255.255.255.0   U     100    0        0 eth0</span><br><span class="line">192.168.33.0    0.0.0.0         255.255.255.0   U     101    0        0 eth1</span><br><span class="line"></span><br><span class="line">## 启用veth0后增加路由</span><br><span class="line">[root@localhost vagrant]# ip link set veth0 up</span><br><span class="line">[root@localhost vagrant]# route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         gateway         0.0.0.0         UG    100    0        0 eth0</span><br><span class="line">10.0.2.0        0.0.0.0         255.255.255.0   U     100    0        0 eth0</span><br><span class="line">192.168.33.0    0.0.0.0         255.255.255.0   U     101    0        0 eth1</span><br><span class="line">192.168.100.0   0.0.0.0         255.255.255.0   U     0      0        0 veth0</span><br><span class="line"></span><br><span class="line">## 启用veth1后居然又增加了一条路由信息</span><br><span class="line">[root@localhost vagrant]# ip link set veth1 up</span><br><span class="line">[root@localhost vagrant]# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:26:10:60 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute dynamic eth0</span><br><span class="line">       valid_lft 86214sec preferred_lft 86214sec</span><br><span class="line">    inet6 fe80::5054:ff:fe26:1060/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:98:06:20 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.33.11/24 brd 192.168.33.255 scope global noprefixroute eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::a00:27ff:fe98:620/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">4: veth1@veth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether e2:15:95:0a:1f:da brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.100.11/24 scope global veth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::e015:95ff:fe0a:1fda/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">5: veth0@veth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether b2:2c:f6:e4:74:c5 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.100.10/24 scope global veth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::b02c:f6ff:fee4:74c5/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@localhost vagrant]# route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         gateway         0.0.0.0         UG    100    0        0 eth0</span><br><span class="line">10.0.2.0        0.0.0.0         255.255.255.0   U     100    0        0 eth0</span><br><span class="line">192.168.33.0    0.0.0.0         255.255.255.0   U     101    0        0 eth1</span><br><span class="line">192.168.100.0   0.0.0.0         255.255.255.0   U     0      0        0 veth0</span><br><span class="line">192.168.100.0   0.0.0.0         255.255.255.0   U     0      0        0 veth1</span><br></pre></td></tr></table></figure>

<p>默认情况下arp表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># arp</span><br><span class="line">Address                  HWtype  HWaddress           Flags Mask            Iface</span><br><span class="line">localhost.localdomain            (incomplete)                              veth0</span><br><span class="line">192.168.33.1             ether   0a:00:27:00:00:00   C                     eth1</span><br><span class="line">gateway                  ether   52:54:00:12:35:02   C                     eth0</span><br><span class="line">10.0.2.3                 ether   52:54:00:12:35:03   C                     eth0</span><br></pre></td></tr></table></figure>

<p>使用ping命令<code>ping -I veth0 192.168.100.11 -c 2</code>，默认情况下veth1和veth0会接收到arp报文，但并没有arp的响应报文。这是因为默认情况下有些arp内核参数的限制。执行如下命令解决arp的限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/conf/veth1/accept_local</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4/conf/veth0/accept_local</span><br><span class="line">echo 0 &gt; /proc/sys/net/ipv4/conf/all/rp_filter</span><br><span class="line">echo 0 &gt; /proc/sys/net/ipv4/conf/veth0/rp_filter</span><br><span class="line">echo 0 &gt; /proc/sys/net/ipv4/conf/veth1/rp_filter</span><br></pre></td></tr></table></figure>

<h2 id="veth-pair设备的删除"><a href="#veth-pair设备的删除" class="headerlink" title="veth pair设备的删除"></a>veth pair设备的删除</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除veth0后会自动删除veth1</span><br><span class="line">$ ip link delete veth0</span><br></pre></td></tr></table></figure>

<h2 id="container与host-veth-pair的关系"><a href="#container与host-veth-pair的关系" class="headerlink" title="container与host veth pair的关系"></a>container与host veth pair的关系</h2><p>veth pair的其中一个设备位于container中备位于container中，另外一个设备位于host network namespace中，如何知道container中的eth0和host network namesapce中的veth设备的对应关系呢？</p>
<p>原理为veth pair设备都有一个ifindex和iflink值，，容器中的eth0设备的ifindex值跟host network namespace中的对应veth pair设备的iflink值相等，反之亦然。</p>
<h3 id="在容器中找到eth0的iflink"><a href="#在容器中找到eth0的iflink" class="headerlink" title="在容器中找到eth0的iflink"></a>在容器中找到eth0的iflink</h3><p>方法一</p>
<p>获取iflink值：<code>cat /sys/class/net/eth0/iflink</code> </p>
<p>也可用此方法获取ifindex值：<code>cat /sys/class/net/eth0/ifindex</code> </p>
<p>方法二</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ip link show eth0</span><br><span class="line">3: eth0@if18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">    link/ether 96:5f:80:a3:a3:01 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>

<p>其中的3为eth0的ifindex。18为eth0的iflink，即对应的veth pair的另外一个设备的ifindex。</p>
<h3 id="host-network-namespace中找到对应ifindex值的veth-pair设备"><a href="#host-network-namespace中找到对应ifindex值的veth-pair设备" class="headerlink" title="host network namespace中找到对应ifindex值的veth pair设备"></a>host network namespace中找到对应ifindex值的veth pair设备</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ip addr </span><br><span class="line">18: veth0e09999e@if3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master br0 state UP group default</span><br><span class="line">    link/ether de:b0:74:89:e8:3e brd ff:ff:ff:ff:ff:ff link-netnsid 4</span><br><span class="line">    inet6 fe80::dcb0:74ff:fe89:e83e/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>其中的18为ifindex，3为对应的veth pair的ifindex。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://www.cnblogs.com/bakari/p/10613710.html">Linux 虚拟网络设备 veth-pair 详解，看这一篇就够了</a></li>
<li><a href="https://segmentfault.com/a/1190000009251098">Linux虚拟网络设备之veth</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>vim插件安装</title>
    <url>/post/vim_plugin/</url>
    <content><![CDATA[<p>本文的安装环境为ubuntu13.04。为了以后便于查阅，本文将相关插件的使用放到了文章的开始部分。这里不作插件的相关介绍，相关介绍看文章底部的参考文章。</p>
<h1 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h1><p>本插件快捷键会跟随下文安装内容一块同步。</p>
<h2 id="ctags"><a href="#ctags" class="headerlink" title="ctags"></a>ctags</h2><p>在源码目录执行<code>ctags -R</code>可生成ctags文件。该文件在源码修改后并不会改变，需要重新生成ctags文件。<br>ctrl+]：转到函数定义处。<br>ctrl+T：回到执行<code>ctrl+]</code>的地方。</p>
<h2 id="taglist"><a href="#taglist" class="headerlink" title="taglist"></a>taglist</h2><p><code>:TlistOpen</code>：打开taglist窗口<br><code>:TlistClose</code>：关闭taglist窗口。<br><code>:TlistToggle</code>：在打开和关闭间切换。</p>
<h2 id="NERD-tree"><a href="#NERD-tree" class="headerlink" title="NERD tree"></a>NERD tree</h2><p><code>:NERDTree</code>：打开窗口。</p>
<h2 id="winmanager"><a href="#winmanager" class="headerlink" title="winmanager"></a>winmanager</h2><p><code>wm</code>：打开和关闭taglist和NERD tree窗口。</p>
<h2 id="a-vim"><a href="#a-vim" class="headerlink" title="a.vim"></a>a.vim</h2><p><code>:A</code>：在新Buffer中切换到c&#x2F;h文件<br><code>:AS</code>：横向分割窗口并打开c&#x2F;h文件<br><code>:AV</code>：纵向分割窗口并打开c&#x2F;h文件<br><code>:AT</code>：新建一个标签页并打开c&#x2F;h文件<br><code>F12</code>：代替<code>:A</code>命令</p>
<h2 id="MiniBufExplorer"><a href="#MiniBufExplorer" class="headerlink" title="MiniBufExplorer"></a>MiniBufExplorer</h2><p><code>&lt;Tab&gt;</code>：向前循环切换到每个buffer名上<br><code>&lt;S-Tab&gt;</code>：向后循环切换到每个buffer名上<br><code>&lt;Enter&gt;</code>：在打开光标所在的buffer<br><code>d</code>：删除光标所在的buffer</p>
<h1 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h1><h2 id="安装ctags"><a href="#安装ctags" class="headerlink" title="安装ctags"></a>安装ctags</h2><p>执行： <code>sudo apt-get install ctags</code>。</p>
<h2 id="安装taglist"><a href="#安装taglist" class="headerlink" title="安装taglist"></a>安装taglist</h2><ol>
<li>下载页面：<a href="http://www.vim.org/scripts/script.php?script_id=273%E3%80%82%E4%B8%8B%E8%BD%BD%E5%90%8E%E5%BE%97%E5%88%B0taglist_46.zip%E6%96%87%E4%BB%B6%E3%80%82">http://www.vim.org/scripts/script.php?script_id=273。下载后得到taglist_46.zip文件。</a></li>
<li>执行<code>unzip taglist_46.zip</code>解压文件。</li>
<li>将解压出的文件复制到~&#x2F;.vim目录下。<code>sudo cp ~/tmp/ ~/.vim/</code>。</li>
<li>在~&#x2F;.vimrc文件中添加如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let Tlist_Show_One_File = 1            &quot;不同时显示多个文件的tag，只显示当前文件的</span><br><span class="line">let Tlist_Exit_OnlyWindow = 1          &quot;如果taglist窗口是最后一个窗口，则退出vim</span><br><span class="line">let Tlist_Use_Right_Window = 1         &quot;在右侧窗口中显示</span><br></pre></td></tr></table></figure>
参考网址：<a href="http://www.cnblogs.com/mo-beifeng/archive/2011/11/22/2259356.html">http://www.cnblogs.com/mo-beifeng/archive/2011/11/22/2259356.html</a></li>
</ol>
<h2 id="安装文件浏览器NERD-tree"><a href="#安装文件浏览器NERD-tree" class="headerlink" title="安装文件浏览器NERD tree"></a>安装文件浏览器NERD tree</h2><ol>
<li>下载页面：<a href="http://www.vim.org/scripts/script.php?script_id=1658%E3%80%82">http://www.vim.org/scripts/script.php?script_id=1658。</a></li>
<li>将下载后的nerdtree.zip文件解压到~&#x2F;.vim目录下。</li>
</ol>
<h2 id="安装winmanager"><a href="#安装winmanager" class="headerlink" title="安装winmanager"></a>安装winmanager</h2><ol>
<li>下载页面：<a href="http://www.vim.org/scripts/script.php?script_id=95">http://www.vim.org/scripts/script.php?script_id=95</a></li>
<li>将下载后的winmanager.zip文件解压到~&#x2F;.vim目录下</li>
<li>修改.vimrc文件，添加：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let g:winManagerWindowLayout=&#x27;FileExplorer|TagList&#x27;</span><br><span class="line">nmap wm :WMToggle&lt;cr&gt;</span><br></pre></td></tr></table></figure>
这样利用winmanager工具将taglist和NERD tree工具整合到了一个块，输入wm可以打开和关闭窗口。</li>
</ol>
<h2 id="安装cscope"><a href="#安装cscope" class="headerlink" title="安装cscope"></a>安装cscope</h2><ol>
<li>下载页面：<a href="http://cscope.sourceforge.net,下载后得到文件cscope-15.8a.tar.gz./">http://cscope.sourceforge.net，下载后得到文件cscope-15.8a.tar.gz。</a></li>
<li>.&#x2F;configure</li>
<li>make。可能会出现错误，执行如下命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install libncurses-dev</span><br><span class="line">sudo apt-get install flex</span><br><span class="line">sudo apt-get install byacc</span><br></pre></td></tr></table></figure>
然后执行<code>make clean</code>后重新make。</li>
<li>sudo make install</li>
</ol>
<h2 id="安装在h-x2F-c文件之间切换插件a-vim"><a href="#安装在h-x2F-c文件之间切换插件a-vim" class="headerlink" title="安装在h&#x2F;c文件之间切换插件a.vim"></a>安装在h&#x2F;c文件之间切换插件a.vim</h2><ol>
<li>下载页面：<a href="http://www.vim.org/scripts/script.php?script_id=31%E3%80%82">http://www.vim.org/scripts/script.php?script_id=31。</a></li>
<li>将下载的a.vim文件复制到~&#x2F;.vim&#x2F;plugin文件夹下。</li>
<li>在~&#x2F;.vimrc文件中添加<code>nnoremap &lt;silent&gt; &lt;F12&gt; :A&lt;CR&gt;</code></li>
<li>下面内容为快捷键列表：<br>:A switches to the header file corresponding to the current file being edited (or vise versa)<br>:AS splits and switches<br>:AV vertical splits and switches<br>:AT new tab and switches<br>:AN cycles through matches<br>:IH switches to file under cursor<br>:IHS splits and switches<br>:IHV vertical splits and switches<br>:IHT new tab and switches<br>:IHN cycles through matches<br><Leader>ih switches to file under cursor<br><Leader>is switches to the alternate file of file under cursor (e.g. on  &lt;foo.h&gt; switches to foo.cpp)<br><Leader>ihn cycles through matches</li>
</ol>
<h2 id="安装快速浏览和操作Buffer"><a href="#安装快速浏览和操作Buffer" class="headerlink" title="安装快速浏览和操作Buffer"></a>安装快速浏览和操作Buffer</h2><ol>
<li>下载页面：<a href="http://www.vim.org/scripts/script.php?script_id=159">http://www.vim.org/scripts/script.php?script_id=159</a></li>
<li>将下载的 minibufexpl.vim文件丢到 ~&#x2F;.vim&#x2F;plugin 文件夹中即可</li>
<li>在~&#x2F;.vimrc文件中增加如下行：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let g:miniBufExplMapCTabSwitchBufs = 1</span><br><span class="line">let g:miniBufExplMapWindowNavVim = 1</span><br><span class="line">let g:miniBufExplMapWindowNavArrows = 1</span><br></pre></td></tr></table></figure></li>
<li>快捷键：<br><Tab>	向前循环切换到每个buffer名上<br><S-Tab>	向后循环切换到每个buffer名上<br><Enter>	在打开光标所在的buffer<br>d	删除光标所在的buffer</li>
</ol>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://blog.csdn.net/tge7618291/article/details/4216977">经典vim插件功能说明、安装方法和使用方法介绍</a></li>
<li><a href="http://blog.csdn.net/wooin/article/details/1858917">手把手教你把Vim改装成一个IDE编程环境</a></li>
</ul>
]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox磁盘扩容</title>
    <url>/post/virtualbox-scaleup/</url>
    <content><![CDATA[<p>今天发现vagrant的其中一个虚拟机磁盘空间不够了，需要对其进行磁盘扩容，但不期望是通过增加新硬盘的方式，而是直接增加原磁盘容量的方式来无缝扩容。</p>
<h2 id="修改磁盘文件"><a href="#修改磁盘文件" class="headerlink" title="修改磁盘文件"></a>修改磁盘文件</h2><p>进入到vm磁盘文件所在的目录<code>~/VirtualBox VMs/dev_default_1531796361866_92956</code>下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">% vboxmanage showhdinfo  centos-vm-disk1.vmdk</span><br><span class="line">UUID:           acbb4ffc-0580-40d6-8627-3ed24cd0beff</span><br><span class="line">Parent UUID:    base</span><br><span class="line">State:          created</span><br><span class="line">Type:           normal (base)</span><br><span class="line">Location:       /Users/lvkai/VirtualBox VMs/dev_default_1531796361866_92956/centos-vm-disk1.vmdk</span><br><span class="line">Storage format: VMDK</span><br><span class="line">Format variant: dynamic default</span><br><span class="line">Capacity:       10000 MBytes</span><br><span class="line">Size on disk:   9634 MBytes</span><br><span class="line">Encryption:     disabled</span><br><span class="line">In use by VMs:  dev_default_1531796361866_92956 (UUID: a153957c-e43f-4dd2-8512-f51d42dee3d3)</span><br><span class="line"></span><br><span class="line"># 将之前存储的vmdk格式的文件复制一份vdi格式的文件，由于需要复制文件，该命令需要执行一段时间</span><br><span class="line">% vboxmanage clonehd centos-vm-disk1.vmdk new-centos-vm-disk1.vdi --format vdi</span><br><span class="line"></span><br><span class="line"># 将vdi格式的文件修改磁盘空间上限大小为80g，但实际占用磁盘空间仍然为之前的大小</span><br><span class="line">% vboxmanage modifyhd  new-centos-vm-disk1.vdi --resize 81920</span><br><span class="line"></span><br><span class="line"># 将vdi格式的文件重新转换为vmdk格式，会产生一个新的uuid</span><br><span class="line">% vboxmanage clonehd new-centos-vm-disk1.vdi resized.vmdk --format vmdk</span><br><span class="line">0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%</span><br><span class="line">Clone medium created in format &#x27;vmdk&#x27;. UUID: 7e454b50-0681-494b-b9ca-81700d217c0a</span><br></pre></td></tr></table></figure>

<p>新的硬盘创建完成后，在virtualbox的界面上将对应虚拟机的硬盘更换为resized.vmdk，并将之前旧的centos-vm-disk1.vmdk给删除掉。</p>
<h2 id="使用fdisk创建新的磁盘分区"><a href="#使用fdisk创建新的磁盘分区" class="headerlink" title="使用fdisk创建新的磁盘分区"></a>使用fdisk创建新的磁盘分区</h2><p>以上命令执行完成后，开启虚拟机，进入系统，可以看到磁盘空间大小变更为85.9GB，但挂载的磁盘空间大小仍然为8.3G，新增加的磁盘空间仍然处于未分配状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 85.9 GB, 85899345920 bytes, 167772160 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x0000ca5e</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     1026047      512000   83  Linux</span><br><span class="line">/dev/sda2         1026048    20479999     9726976   8e  Linux LVM</span><br><span class="line"></span><br><span class="line">Disk /dev/mapper/centos-root: 8866 MB, 8866758656 bytes, 17317888 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/mapper/centos-swap: 1048 MB, 1048576000 bytes, 2048000 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"># df -h</span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root  8.3G  7.9G  386M  96% /</span><br><span class="line">devtmpfs                 296M     0  296M   0% /dev</span><br><span class="line">tmpfs                    307M     0  307M   0% /dev/shm</span><br><span class="line">tmpfs                    307M  4.5M  303M   2% /run</span><br><span class="line">tmpfs                    307M     0  307M   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1                497M  195M  303M  40% /boot</span><br><span class="line">vagrant                  466G  390G   77G  84% /vagrant</span><br><span class="line">vagrant_data             466G  390G   77G  84% /vagrant_data</span><br><span class="line">tmpfs                     62M     0   62M   0% /run/user/1000</span><br></pre></td></tr></table></figure>

<p>接下来需要将未分配的磁盘空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># fdisk /dev/sda</span><br><span class="line"># 依次输入可创建新的分区</span><br><span class="line">n</span><br><span class="line">p</span><br><span class="line">回车</span><br><span class="line">回车</span><br><span class="line"></span><br><span class="line"># 继续输入p，可以看到磁盘的情况，多出了/dev/sda3</span><br><span class="line"># /dev/sda3的System为Linux，而/dev/sda2的System为Linux LVM</span><br><span class="line">Command (m for help): p</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 85.9 GB, 85899345920 bytes, 167772160 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x0000ca5e</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     1026047      512000   83  Linux</span><br><span class="line">/dev/sda2         1026048    20479999     9726976   8e  Linux LVM</span><br><span class="line">/dev/sda3        20480000   167772159    73646080   83  Linux</span><br><span class="line"></span><br><span class="line"># 依次输入将/dev/sda3更改为LVM格式</span><br><span class="line">t</span><br><span class="line">3</span><br><span class="line">8e</span><br><span class="line">p</span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 85.9 GB, 85899345920 bytes, 167772160 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x0000ca5e</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     1026047      512000   83  Linux</span><br><span class="line">/dev/sda2         1026048    20479999     9726976   8e  Linux LVM</span><br><span class="line">/dev/sda3        20480000   167772159    73646080   8e  Linux LVM</span><br><span class="line"></span><br><span class="line"># 输入w后进行保存操作</span><br><span class="line">Command (m for help): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line"></span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span><br><span class="line">The kernel still uses the old table. The new table will be used at</span><br><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>

<h2 id="将新创建的磁盘分区添加到LVM分区中"><a href="#将新创建的磁盘分区添加到LVM分区中" class="headerlink" title="将新创建的磁盘分区添加到LVM分区中"></a>将新创建的磁盘分区添加到LVM分区中</h2><p>将机器重启后，继续执行如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vgdisplay</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               centos</span><br><span class="line">  System ID</span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  3</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                2</span><br><span class="line">  Open LV               2</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               9.27 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              2374</span><br><span class="line">  Alloc PE / Size       2364 / 9.23 GiB</span><br><span class="line">  Free  PE / Size       10 / 40.00 MiB</span><br><span class="line">  VG UUID               cpEmYK-XFew-6ZWT-GEeY-yEou-0vLq-OJiD08</span><br><span class="line"></span><br><span class="line"># lvscan</span><br><span class="line">  ACTIVE            &#x27;/dev/centos/swap&#x27; [1000.00 MiB] inherit</span><br><span class="line">  ACTIVE            &#x27;/dev/centos/root&#x27; [&lt;8.26 GiB] inherit</span><br><span class="line"></span><br><span class="line"># pvcreate /dev/sda3</span><br><span class="line">  Physical volume &quot;/dev/sda3&quot; successfully created.</span><br><span class="line"></span><br><span class="line"># vgextend centos /dev/sda3</span><br><span class="line">  Volume group &quot;centos&quot; successfully extended</span><br><span class="line"></span><br><span class="line"># lvextend /dev/centos/root /dev/sda3</span><br><span class="line">  Size of logical volume centos/root changed from &lt;8.26 GiB (2114 extents) to &lt;78.49 GiB (20093 extents).</span><br><span class="line">  Logical volume centos/root successfully resized.</span><br><span class="line"></span><br><span class="line"># xfs_growfs /dev/centos/root</span><br><span class="line">meta-data=/dev/mapper/centos-root isize=256    agcount=4, agsize=541184 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=0        finobt=0 spinodes=0</span><br><span class="line">data     =                       bsize=4096   blocks=2164736, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=0</span><br><span class="line">log      =internal               bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">data blocks changed from 2164736 to 20575232</span><br><span class="line"></span><br><span class="line"># 最后执行命令可以看到磁盘空间已经增加</span><br><span class="line"># df -h</span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root   79G  7.9G   71G  11% /</span><br><span class="line">devtmpfs                 296M     0  296M   0% /dev</span><br><span class="line">tmpfs                    307M     0  307M   0% /dev/shm</span><br><span class="line">tmpfs                    307M  4.5M  303M   2% /run</span><br><span class="line">tmpfs                    307M     0  307M   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1                497M  195M  303M  40% /boot</span><br><span class="line">vagrant                  466G  390G   77G  84% /vagrant</span><br><span class="line">vagrant_data             466G  390G   77G  84% /vagrant_data</span><br><span class="line">tmpfs                     62M     0   62M   0% /run/user/1000</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>我要看电视 - 投影仪和电视盒子选型</title>
    <url>/post/watch-tv/</url>
    <content><![CDATA[<p>去年装修的时候预留了投影仪和幕布的位置，搬家已经有几个月的时间了，最近开始考虑安装投影仪。作为技术男，已经有多年不看电视，在决策前自然要考察下市场，了解下当前的技术，综合考虑多种技术因素。</p>
<h1 id="投影仪的选型"><a href="#投影仪的选型" class="headerlink" title="投影仪的选型"></a>投影仪的选型</h1><p>家装投影仪分为了两大阵营：</p>
<ol>
<li>以传统厂商为代表的 3LCD 阵营。典型的厂家为爱普生、明基。优点为清晰度高、对比度高。缺点为噪音大、灯泡寿命短、个头偏大。</li>
<li>以国产新势力厂商为代表的 DLP 阵营。典型厂家为极米、当贝、坚果，无论其市场分布，还是技术形态，都像极了新能源领域的新势力”蔚小理“。优点为自带 android 系统、更加人性化、寿命长。缺点为亮度低。</li>
</ol>
<p>我的需求优先级依次如下：</p>
<ol>
<li>亮度高，抛开亮度和对比度谈体验就本末倒置了，电视的最基本需求就是看得见，看得清楚。</li>
<li>最好不要带 android 系统，时间长了肯定会卡，不希望跟 android 系统绑定。</li>
<li>开机不要有广告。</li>
</ol>
<p>经过对比后，选择了爱普生的 3LCD 投影仪，亮度完全满足需求，即使在白天不拉窗帘的情况下，清晰度也完全足够。选择了其优点，自然要忍受其缺点，噪音大也并没有大到不能忍受，一般播放片源后就可以将风扇的声音盖住，在投影仪旁实测噪音在 40 分贝左右。灯泡寿命短的缺点暂时忽略，毕竟官方说明灯泡的寿命在三年到六年之间，而且更换灯泡的费用并不高。</p>
<h1 id="电视盒子的选型"><a href="#电视盒子的选型" class="headerlink" title="电视盒子的选型"></a>电视盒子的选型</h1><p>有了投影仪后，还缺一个电视盒子用于提供视频源，电视盒子的选择比投影仪更加丰富。</p>
<h2 id="Apple-TV"><a href="#Apple-TV" class="headerlink" title="Apple TV"></a>Apple TV</h2><p>第一优先级考虑为地表最强电视盒子 Apple TV，无论其流畅度、清晰度、用户体验都堪称完美。主要的优点：</p>
<ol>
<li>强大的 Infuse 软件用来查看蓝光光源、杜比视界，绝对不是 1080P 的片源可以比的。</li>
<li>苹果一如既往丝滑般的体验。无论是操作系统，还是遥控器，其用户体验都能吊打一众安卓盒子。</li>
<li>可在 Netflix、Disney+、Apple TV+ 追剧。要想在设备上播放 Netflix，是需要授权的，国内的电视盒子一概不支持。</li>
<li>无广告。</li>
</ol>
<p>虽然想体验一把最好的看电视体验，但存在如下两个问题导致我最终放弃了 Apple TV：</p>
<ol>
<li>无法看国内的”爱优腾“。投影仪的主要使用方并非我自己，而更多的是家人，没有国内的”爱优腾“，查看片源过于复杂，使用体验将大打折扣。</li>
<li>Netflix 和 Disney+ 并非强需求。Apple TV 用来追剧非常方便，但我个人并没有太多的时间用来追剧，而且还需要魔法，追剧还需要付费，使用成本整体并不低。</li>
</ol>
<h2 id="国产电视盒子"><a href="#国产电视盒子" class="headerlink" title="国产电视盒子"></a>国产电视盒子</h2><p>网上可以买到各式各样的电视盒子，当贝、小米、腾讯极光等，整体特点：</p>
<ol>
<li>均基于 Android TV 系统，又叠加了自己的桌面应用。</li>
<li>厂商均不靠硬件赚钱，而是靠 VIP 会员赚钱，因此所有的电视盒子均需要充值 VIP，没有了 VIP 也就剩下一个盒子了，基本上看不了多少片源。</li>
<li>各种开机广告、开屏广告满天飞。</li>
</ol>
<p>下单销量排名靠前的当贝盒子后，体验一番后，大失所望。虽然如宣传的一般没有了开机广告，但进入系统后没有 VIP 寸步难行，每个视频右下角都会带一个灰色的 VIP logo。我的选择逻辑，既然”爱优腾“的会员在所难免，毕竟还有手机端 app 看视频的需求，再买一个盒子 VIP 的意义何在。如果盒子 VIP 不买，那盒子自身系统提供的片源很多就是个摆设。实在无法容忍，遂退之。</p>
<p>国产的电视盒子没有一个能打的，整个产品的定位全跑偏了。如果能有一个干净、用户体验好的电视盒子可以给到用户，哪怕卖得贵一点（毕竟就要靠卖硬件赚钱了），我相信也是有市场的。</p>
<h2 id="树莓派"><a href="#树莓派" class="headerlink" title="树莓派"></a>树莓派</h2><p>看了下 Android TV 的原生系统后，更加符合自己的需求，干净清爽，而且还可以刷 Google 服务包，用来安装 Google 全家桶应用。所以就开始考虑自己刷机使用 Android TV。要想刷机必须先有盒子，盒子的选型有如下几个：</p>
<ol>
<li>国产电视盒子。可在国产电视盒子的硬件上刷 Android TV 系统。</li>
<li>其他 Arm 架构的盒子。比如非常流行的斐讯 N1 盒子，曾经用于挖矿，现在却在软路由领域焕发出了新的生机。</li>
<li>开发版。最为流行的树莓派，还有友善 NanoPi 开发版、Banana Pi，均为基于 ARM 架构。</li>
</ol>
<p>我最终选择了树莓派 5 作为电视盒子，主要考虑如下：</p>
<ol>
<li>性能强大，用来作为电视盒子性能是过剩的。</li>
<li>可玩性强。即使作为电视盒子翻车了，还可以用来作为小型服务器，跑 Home Assiant、TeslaMate 等应用，甚至可以作为 NAS 使用。</li>
<li>用户基数大。自己踩到的坑更容易找到解决方案。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>投影仪完成后，且电视盒子也选好了，接下来将另起一篇文章讲解下我的树莓派刷 Android TV 系统的折腾经历，自己选择的路线，查再多的资料，刷再多的机，也要折腾成功。</p>
]]></content>
  </entry>
  <entry>
    <title>脆弱的生命</title>
    <url>/post/weak_life/</url>
    <content><![CDATA[<p><img src="/ref/life/weak_life.JPG" alt="Image Title"></p>
<p>得知老家三老爷家的三叔去世了，原本还在看代码的我收到消息之后立刻无法平静了，只好出去走走散散心，回家之后依然感觉莫名的胸闷，玩游戏分散分散精力，游戏过后依然胸闷。意料之中的失眠，中途醒了好几次。总感觉消息不是真实的，总感觉昨晚在梦中，真希望一觉醒来之后什么都没有发生。</p>
<p>三叔42岁，正值壮年，在家附近的号称有一万员工的炼钢厂打工，在整个市也算是很大的企业了。工作中意外丧命。总觉得这样的事情不会发生在我身边，客观事实是发生了。</p>
<p>听家人说，三叔小时候调皮爬到树上掏鸟窝从树上掉下来把一个肩膀都磕到身体里了，大家都觉得肯定好不了，在镇上医院住院打吊瓶打够了自己偷偷跑回学校，后来居然奇迹般的好了，而且还没留下任何痕迹。大家都说三叔命大，谁知三叔小时候躲过了一劫却没有躲过这一劫，这难道就是天命？三叔一生勤俭节约，人忠厚老实，到头来却落得如此下场，谁说上帝是公平的，谁说好人有好报，这都是胡扯。</p>
<p>临近三叔出事的前天，我做了一个很不好的梦，梦的内容我已经记不起来了。回家后听家里人说很多人都做了不好的梦，甚至连平常不怎么做梦的都会被梦惊醒。这绝对不是巧合，很明显已经超出了当前科学的范畴。</p>
<p>记得最后一次跟三叔接触还是在过年的时候，三叔到我家来转转，聊了几句，现在还记忆犹新。再上一次见面就是在去年夏天的一个下午，约着三婶去火车站接三叔家的弟弟和我爸，正巧在三叔家的门口碰到三叔，估计是要去上夜班。</p>
<p>每年过年我们一大家20多人就会团聚在一起，男人一桌，女人一桌，还有我们小孩一桌，其乐融融。最近两年过年三叔是唯一缺席的，由于工作的原因，三叔正巧在过年的时候上夜班。总觉得少了三叔过年的时候是个遗憾，现在看来以后过年要永远遗憾下去了。</p>
<p>企业在追求经济效益的同时，往往会忽略员工的安全。员工伤亡事件屡见不鲜，却很难得到企业的重视。相比人类的伤亡，企业的经济效益显得那么苍白无力。听说钢厂每年总会出些事故，但是事故的赔偿是从所有员工的工资中扣除的，而不是工厂承担，这也是工厂对安全问题不够重视的原因，反正出了事掉血的是员工。</p>
<p>现在村中的人大部分出去在外面打工，农忙时回家忙几天。在此提醒相亲们一定要注意人身安全，没有了安全保障赚再多的钱都白搭。</p>
<p>谨以此文献给为工作而献身的三叔。</p>
]]></content>
  </entry>
  <entry>
    <title>Windows和Linux之间的中文编码问题</title>
    <url>/post/windows_linux_code/</url>
    <content><![CDATA[<p>在开发Linux程序的时候通常会在Windows下编码，然后拿到Linux下编译调试。而两个操作系统之间的默认编码往往有差别。</p>
<h1 id="文件编码问题"><a href="#文件编码问题" class="headerlink" title="文件编码问题"></a>文件编码问题</h1><p>在Windows下查看文件编码可以使用记事本打开文件，然后点击“另存为”在右下角即可看到当前文件的编码方式。如果显示为ANSI编码，在简体中文系统下，ANSI 编码代表 GB2312 编码。不同 ANSI 编码之间互不兼容，ANSI是American National Standards Institute的缩写， 记事本默认是以ANSI编码保存文本文档的。</p>
<p>在Linux可以通过vi命令查看文件编码，用vi打开文件，然后输入<code>:set encoding</code>即可显示文件编码。</p>
<p>在VS2008中创建文件的默认编码是根据当前系统的编码格式确定的。VS2008编译器可以同时支持GB2312和UTF-8两种编码。</p>
<p>为了解决在Linux下的乱码问题，Linux下的编码格式为utf8编码，这里采用在Windows下将gb2312编码更改为utf8的方式来解决。iconv是一个可以转换文件编码的工具，编写一个批处理脚本来实现批量转换文件编码的功能。批处理文件的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ECHO OFF</span><br><span class="line">FOR /R %%F IN (*.h,*.cpp) DO (</span><br><span class="line">echo %%~nxF</span><br><span class="line">iconv.exe -f GB2312 -t UTF-8 %%F &gt; %%F.utf8</span><br><span class="line">move %%F.utf8 %%F &gt;nul</span><br><span class="line">)</span><br><span class="line">PAUSE</span><br></pre></td></tr></table></figure>
<p>本脚本来自网络，不是我自己写的。<br>注意：在使用文件编码之前一定要备份文件，防止意外发生，否则后果自负。</p>
<h1 id="文件名编码问题"><a href="#文件名编码问题" class="headerlink" title="文件名编码问题"></a>文件名编码问题</h1><p>Windows的中文系统下文件名的编码默认为gbk，在Linux默认编码为UTF-8。如果将Windows下的中文文件名的文件复制到Linux下肯定会出现乱码的问题。可以利用convmv工具来解决编码的问题。</p>
<p>具体执行操作为：在Linux系统下的要转换编码的目录下执行命令：<code>convmv -f GBk -t UTF-8 --notest -r *</code>，这样就会将该文件夹下的所有文件递归的转换编码为UTF-8。</p>
<p>convmv的帮助文档点<a href="http://www.j3e.de/linux/convmv/man/">这里</a>。</p>
<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a href="http://pan.baidu.com/s/19UbCG">脚本和iconv程序下载链接</a></p>
]]></content>
  </entry>
  <entry>
    <title>再谈Windows和Linux之间的中文编码问题</title>
    <url>/post/windows_linux_code_2/</url>
    <content><![CDATA[<p>上次文章《<a href="http://kuring.me/post/windows_linux_code">Windows和Linux之间的中文编码问题</a>》中提到的在Windows下的源代码程序放到Linux下出现中文编码问题，解决方法为通过iconv工具转换源代码文件的编码为UTF8格式。最近多学习了些字符编码的知识，发现了解决此问题的另外一种办法。</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>我们在编译程序的时候会涉及到几个编码问题，包括C++源文件的编码、C++程序的内码和运行环境编码，其中C++程序的内码较难理解。</p>
<p>C++程序的内码是指在可执行文件中字符串常量是以什么编码形式存放的，其中字符串常量为窄字符形式。在Windows系统中C++的内码通常为GB18030，在Linux下的gcc&#x2F;g++使用的内码默认为utf8，可以通过fexec-charset参数来修改。</p>
<p>运行环境编码即为操作系统的编码，通常情况下，简体中文Windows操作系统编码为GB18030，而Linux下默认为UTF8。</p>
<h1 id="gcc命令的参数"><a href="#gcc命令的参数" class="headerlink" title="gcc命令的参数"></a>gcc命令的参数</h1><p>gcc有两个参数可以用来解决编码问题。<br>-finput-charset：用来指定源文件的编码。<br>-fexec-charset：用来指定生成的可执行文件的编码。</p>
<p>如果这两个参数均未指定，则GCC不会对编码进行转换。<br>以上这两个参数就可以用来在不修改源文件编码的基础上来达到正确的效果，达到和上篇文章中解决问题同样的效果。</p>
<h1 id="关于Unicode编码"><a href="#关于Unicode编码" class="headerlink" title="关于Unicode编码"></a>关于Unicode编码</h1><p>一直对Unicode编码比较糊涂，Unicode只是编码方法规范，而不是具体的存储方法。<br>常用的Unicode又分为UCS-2和UCS-两种编码，其中UCS-2采用固定的2个字节存储，UCS-4采用固定的4个字节存储。<br>通常情况下提到的Unicode编码即为UCS-2编码，比如Windows记事本中的保存为Unicode编码，其实就是保存为了UCS-2编码，由于每个字符均为2个字节，所以下次读取的时候仍然可以通过存储格式还原出来。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode和UTF-8</a><br><a href="http://www.crifan.com/files/doc/docbook/char_encoding/release/html/char_encoding.html">字符编码详解</a><br><a href="http://www.vip-tarena.com/C__peixun/876.html">关于c++的一些编码问题</a></p>
]]></content>
  </entry>
  <entry>
    <title>工作中经常用到的理论或法则</title>
    <url>/post/work-theory/</url>
    <content><![CDATA[<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h2 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h2><p>任何一个组织在设计一个系统的时候，这个系统的结构与这个组织的沟通结构是一致的。<br>工作了这么些年对此深有感触，即“组织架构决定软件架构”。</p>
<h2 id="布鲁克定律"><a href="#布鲁克定律" class="headerlink" title="布鲁克定律"></a>布鲁克定律</h2><p>在一个已经延期的项目中增加人手只会让项目延期更长。<br>我个人不是特别认可此定律，该定律肯定是项目而定的，这要看项目的协作复杂程度，如果是体力劳动居多的项目，那么堆人还是特别好使的。</p>
<h2 id="帕金森定律"><a href="#帕金森定律" class="headerlink" title="帕金森定律"></a>帕金森定律</h2><p>一项工作会占用掉所有用来完成它的时间。即如果不给一个项目设置截止日期，那么该项目就永远完成不了。安排多少时间，就会有多少工作。</p>
<h2 id="冰山谬论"><a href="#冰山谬论" class="headerlink" title="冰山谬论"></a>冰山谬论</h2><p>一款新软件的开发成本只占管理层预算的总成本的25%左右。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="黄金圈法则"><a href="#黄金圈法则" class="headerlink" title="黄金圈法则"></a>黄金圈法则</h2><p>著名的营销顾问西蒙斯.涅克提出了一个“黄金圈”理论：三个同心圆，最里面的一个是Why,中间一层是How，最外面一层是What。</p>
<p>大多数人的思维方式是想做什么（what）和怎么做（how），不太考虑为什么这么做（why）。</p>
<p>本理论提倡的思维方式为：</p>
<ol>
<li>Why：最内层——为什么，做一件事的原因或目的，也可以说是理念和宗旨，属于战略层面；</li>
<li>How：中间层——怎么做，针对这个目的或理念的计划，也即如何去做好这件事情，属于战术层面；</li>
<li>What：最外层——是什么，最终得到什么，或者要做哪些具体的事，这基本是事情的表象，主要是执行层面的东西。</li>
</ol>
<p>该法则在软件行业的述职晋升等场景下非常适用。</p>
<ol>
<li>Why：描述为什么做这个项目？</li>
<li>How：做这个项目遇到的挑战有哪些，是怎么解决的。挑战和解决方法可以一一对应起来。</li>
<li>What：项目的最终结果，最好有具体的可以量化的指标。</li>
</ol>
<h2 id="SWOT分析法"><a href="#SWOT分析法" class="headerlink" title="SWOT分析法"></a>SWOT分析法</h2><p>常见的战略分析方法，对研究对象进行全面、系统、准确的研究。</p>
<p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/swot.jpeg"></p>
<h2 id="金字塔原理"><a href="#金字塔原理" class="headerlink" title="金字塔原理"></a>金字塔原理</h2><p>参见《<a href="http://kuring.me/post/minto-pyramid/">金字塔原理总结</a>》</p>
<p>成功的面试 &#x3D; 把握正确清晰的用人标准 + 挖掘真实匹配的应聘者信息 &#x3D; 以素质模型去“发问” + 用STAR方式去“追问”</p>
<h2 id="STAR行为面试法"><a href="#STAR行为面试法" class="headerlink" title="STAR行为面试法"></a>STAR行为面试法</h2><p>STAR是业界公认的最为有效的面试方法之一，为背景（Situation）、任务（Task）、行为（Action）、结果（Result）的缩写。该方法不仅用于面试的场合，也会用于述职、晋升答辩等场景。</p>
<p>任务（Task）描述在事情里的担任的角色和负责的任务。</p>
<p>行为（Action）是最关键部分，要了解做了什么，展现出了哪些能力。</p>
<p>结果（Result）部分通常需要虚实结合，且重点在实，围绕效率、效果、质量和成本四个维度量化评估。</p>
<p>STAR方法同样适用于述职汇报或者晋升中。</p>
<h2 id="奥克姆剃刀理论"><a href="#奥克姆剃刀理论" class="headerlink" title="奥克姆剃刀理论"></a>奥克姆剃刀理论</h2><p>如无必要，勿增实体。</p>
<h2 id="马斯洛需求层次理论"><a href="#马斯洛需求层次理论" class="headerlink" title="马斯洛需求层次理论"></a>马斯洛需求层次理论</h2><p><img src="https://kuring.oss-cn-beijing.aliyuncs.com/common/masiluo.png"></p>
<p>心理学中重要理论，将人类的需求分为五个层级：</p>
<ol>
<li>生理</li>
<li>安全</li>
<li>社交</li>
<li>尊重</li>
<li>自我实现</li>
</ol>
<p>人类的需求为逐步递进的，在满足了基本需求后，就会去实现更高的需求和目标。</p>
<p>在工作中，经常会用类似马斯洛需求层次理论中的金字塔结构来解释一些其他的有递进关系的场景 ，比如一个软件产品的设计目标。</p>
<h2 id="SMART-原则"><a href="#SMART-原则" class="headerlink" title="SMART 原则"></a>SMART 原则</h2><p>确定目标的五原则，通常用在绩效考核中。</p>
<ol>
<li>S（Special）：目标必须是具体的</li>
<li>M（Measurable）：目标必须是可衡量的</li>
<li>A（Attainable）：目标必须是可实现的</li>
<li>R（Relevant）：与其他的目标有一定的相关性</li>
<li>T（Time-bound）：目标必须有完成的期限</li>
</ol>
<h1 id="常见名词"><a href="#常见名词" class="headerlink" title="常见名词"></a>常见名词</h1><p>ROI：投入产出比</p>
]]></content>
  </entry>
  <entry>
    <title>X Window学习</title>
    <url>/post/x_window/</url>
    <content><![CDATA[<p>X Window的实现机制还是比较难以理解的，尤其是跟软件开发中的客户端-服务器模式不太一样。涉及到概念也比较多，甚至很对教程对概念的理解不一。最近深入学习了下X Window的原理，在此做一下整理。先上一个摘自维基百科的图：<br><img src="/ref/x_window/X_client_server_example.svg.png" alt="X Window架构"></p>
<p>常用快捷键<br>ctrl+alt+fn：切换到相应的虚拟控制台，n为1-12。默认情况下，linux操作系统会在1-6上运行6个虚拟控制台。<br>ctrl+alt+退格键：关闭X window系统。<br>在vmware环境下，ctrl+alt快捷键跟vmware冲突，需要先按住ctrl+alt，然后按一下空格键并松开，再按下相应的fn键才能使用。</p>
<p>X Server<br>负责硬件管理、屏幕绘制、字体，并接收输入设备（如键盘、鼠标等）的动作，并且告知X Client。<br>Linux下的X Server软件为Xorg，通过X（Xorg的链接文件）命令即可执行。<br>输入X命令后，会在第7个控制台启动X Server，将会出现一个什么都没有的漆黑界面，这是由于没有任何X client程序输入的原因。<br>可以在Linux下启动多个X Server软件，从0开始编号。如果再执行<code>X:2</code>命令会启动第二个X Server，此时X Server会在第8个控制台运行。如果第一次执行的是<code>X:2</code>命令则X Server会在第7个控制台运行。<br>在Windows操作系统下的Xming、Xmanager等可以远程连接Linux界面的软件其实就是X Server。</p>
<p>X Client<br>即X应用程序，运行在X Window下的窗口程序都属于X client。比如firefox就是一个X Client。接收来自X Server的处理动作，将动作处理成为绘图数据，并将绘图数据传回给X Server。X Client与X Server之间通过X Window System Core Protocol协议进行通讯。<br>xclock是一个简易的X Client的时钟程序，在:1上启动X Server后，执行<code>xclock –display :1&amp;</code>命令将xclock输出到X Server后的画面如下：<br><img src="/ref/x_window/xclock_no_wm.png" alt="xclock"><br>该程序可以在X Server上执行，但是画面非常简陋，甚至没有窗口的菜单栏和最大化等按钮。</p>
<p>Window Manager<br>一种特殊的X Client，提供了窗口的样式。常用的Window Manager包括GNOME默认的metacity、twm等。<br>将metacity输出到:1上的X Server的命令为<code>metacity –display=:1 &amp;</code>，效果如下：<br><img src="/ref/x_window/xclock_wm.png" alt="Image Title"><br>可以看到窗口多出了最小化、最大化、关闭按钮，并且窗口可以移动和缩放等操作。</p>
<p>Display Manager<br>提供用户登录画面、帮助X Server建立Session。<br>gnome采用的Display Manager为gdm，KDE采用kdm，还有tdm、xdm等。</p>
<p>Desktop Manager<br>X Server、X Client、Window Manager的一个集合。常用的Desktop Manager包括：KDE、GNOME等。</p>
<p>startx启动流程<br>在命令行下执行startx命令后，系统直接进入了桌面环境，并未出现登录界面。进程树如下：<br><img src="/ref/x_window/startx_pstree.png" alt="Image Title"></p>
<ol>
<li>startx会调用xinit命令，xinit命令的主要是启动一个X Server软件。</li>
<li>接着xinit命令会调用gnome-session启动gnome的环境所需要的软件。</li>
</ol>
<p>init 5启动流程<br>在命令行下执行init 5，首先出现的画面为登录信息。进程树如下：<br><img src="/ref/x_window/init5_pstree.png" alt="Image Title"></p>
<ol>
<li>执行&#x2F;etc&#x2F;rc.d&#x2F;rc5.d中的daemon。</li>
<li>执行&#x2F;etc&#x2F;X11&#x2F;prefdm文件，会选择启动gdm、kdm、xdm、tdm。</li>
<li>这里以gdm为例，gdm是一个shell脚本，会启动gdm-binary命令。</li>
</ol>
<p>实战<br>Windows主机连接Linux的教程参见我的另外一篇文章《Redhat安装完成之后的设置》中的相关部分。<br>两台Linux机器之间通过XWindow实现连接的用法比较少见，通常情况下可以通过vnc代替。<br>Linux主机连接Windows的工具为rdesktop。</p>
<p>参考文章<br>《鸟哥的Linux私房菜》<br>《Linux操作系统之奥秘》<br>视频：<a href="http://edu.51cto.com/lesson/id-12709.html">RH033-ULE112-16-linux下X图形显示体系</a><br>视频：<a href="http://www.rhce.cc/?p=1117">Xwindow详解</a></p>
]]></content>
  </entry>
  <entry>
    <title>Linux下更改屏幕分辨率</title>
    <url>/post/xrandr/</url>
    <content><![CDATA[<p>在Virbutal Box下安装CentOS虚拟机，在安装完Virtual Box增强功能后在分辨率列表中，仍然没有适合屏幕的分辨率1600*900。本文将通过xrandr命令来修改当前屏幕的分辨率。</p>
<p>一. 执行<code>xrand -q</code>列出当前系统中已有的分辨率。显示内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Screen 0: minimum 64 x 64, current 1024 x 768, maximum 32000 x 32000</span><br><span class="line">VBOX0 connected 1024x768+0+0 0mm x 0mm</span><br><span class="line">   1024x768       60.0*+   60.0* </span><br><span class="line">   1600x1200      60.0  </span><br><span class="line">   1440x1050      60.0  </span><br><span class="line">   1280x960       60.0  </span><br><span class="line">   800x600        60.0  </span><br><span class="line">   640x480        60.0</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是VBOX0，代表显示器的名字，下面会用到。</p>
<p>二. 执行<code>cvt 1600 900</code>命令列出分辨率1600*900需要的参数，后面会用到。显示内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1600x900 59.95 Hz (CVT 1.44M9) hsync: 55.99 kHz; pclk: 118.25 MHz</span><br><span class="line">Modeline &quot;1600x900_60.00&quot;  118.25  1600 1696 1856 2112  900 903 908 934 -hsync +vsync</span><br></pre></td></tr></table></figure>
<p>该命令列出的内容下文会用到。</p>
<p>三. 执行<code>xrandr --newmode &quot;1600x900_60.00&quot;  118.25  1600 1696 1856 2112  900 903 908 934 -hsync +vsync</code>命令，该命令中的参数是参考步骤2中的输出信息。</p>
<p>四. 执行<code>xrandr --addmode VBOX0 1600x900_60.00</code>来向系统分辨率组中添加分辨率1600*900。其中VBOX0为步骤1获取的显示器名字，1600x900_60.00为步骤3添加的分辨率模式。</p>
<p>五. 执行<code>xrandr --output VBOX0 1600x900_60.00</code>来应用刚才添加的分辨率。这样屏幕就可以更改为正确的分辨率了。</p>
]]></content>
  </entry>
  <entry>
    <title>yum源搭建</title>
    <url>/post/yum-build/</url>
    <content><![CDATA[<p>某些情况下需要搭建自己的yum源，比如维持特定的软件包版本等，只需要从网上下载合适的rpm包，即可构建yum源。</p>
<h1 id="repodata数据"><a href="#repodata数据" class="headerlink" title="repodata数据"></a>repodata数据</h1><p>创建&#x2F;data&#x2F;yum.repo目录用来存放rpm包。</p>
<p>可以使用yumdownloader命令来下载rpm包到本地，并且不安装。这里以安装mesos为例，在&#x2F;data&#x2F;yum.repo目录下执行<code>yumdownloader mesos</code>即可下载mesos的rpm包到本地。</p>
<p>安装createrepo：<code>yum install createrepo</code>，用来根据rpm包产生对应的包信息。</p>
<p>每加入一个rpm包需要更新下repo的信息，执行<code>createrepo --update /data/yum.repo</code>。会自动产生repodata目录。</p>
<h1 id="搭建web服务"><a href="#搭建web服务" class="headerlink" title="搭建web服务"></a>搭建web服务</h1><p>需要对外提供web服务，通常会使用nginx或者apache来对外提供服务，这里使用python SimpleHTTPServer来对外提供服务，执行<code>cd /data/yum.repo &amp;&amp; python -m SimpleHTTPServer 1080</code>。</p>
<h1 id="客户端的repo文件设置"><a href="#客户端的repo文件设置" class="headerlink" title="客户端的repo文件设置"></a>客户端的repo文件设置</h1><p>安装yum优先级插件，用来设置yum源的优先级: <code>yum install -y yum-plugin-priorities</code></p>
<p>每个需要使用该yum源的客户端需要在&#x2F;etc&#x2F;yum.repo.d&#x2F;目录下增加devops.repo文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[devops]</span><br><span class="line">name=dev-ops</span><br><span class="line">baseurl=http://10.103.17.184:1080/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">priority=1</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>云南之旅</title>
    <url>/post/yunan_travel/</url>
    <content><![CDATA[<p><img src="http://kuring.qiniudn.com/yunan.JPG" alt="云南" title="云南"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在这个炎热的夏天，在一个特殊的月份，我开启了一段8天7晚的云南之旅。出于资金方面和省心方面的考虑，选择跟团旅游。本次的旅行包含了昆明、大理、丽江和香格里拉四个地点，如果不是跟团，在短短的6天的旅行时间之内不可能走完四个地方的多个景点，因为这四个地方之间的距离坐车基本都在四个小时以上。大多数人去云南还是会选择跟团的，因为跟团省太多事了。如果是独自出行，每天光查路线路、找酒店、查攻略就会浪费掉很大一部分时间，肯定会更自由一些，但是绝对不会走过这么多地方。</p>
<p>跟团也有很多不好的地方，本次出行旅行社制定的路线为“出发地-昆明-大理-丽江-香格里拉-丽江-大理-昆明-目的地”，可以看到路线是重复了一遍，相当于很大一部分时间都浪费在了路上，至少相当于浪费了4+4+4共12个小时的时间，这也就造成了每天早晨需要很早就起床，基本在6点半就坐在大巴上出发了。之所以每天早晨会很早就起床，另一个原因是因为现在是云南旅游的旺季，一旦稍微晚些，很多景点就会排队等好长时间，可能晚起10分钟，就要在景区多排一个小时的队。</p>
<p>跟团的价格之所以便宜，听导游说，这是云南省旅游局的决定。云南绝大多数都是高原山区地貌，交通不够发达。旅游业在云南的经济中占有很大的比重，政府想通过旅游来拉动经济，跟团价格便宜，自然需要在旅游过程中的消费来赚钱。本次旅游的过程中，也有几次购物的经历，其中行程中的大理十八里铺和七彩云南是赤裸裸的购物环节，导游也明确的告知了。在去景点的过程中，很明显发现每个景点的必经通道中均有购物的部分，这是云南的景点和我去过的其他景点比较大的差别。最奇葩的是长江第一弯的观景楼，大约7层楼左右的样子，每层楼的楼梯都不在一个位置，从一层的楼梯走到另一层的楼梯必经卖土特产的柜台，楼层上全是卖土特产的。其实长江第一弯也仅有一个观景楼而已，因此是免费的。</p>
<p>跟团很大一部分时间都在坐车上，游览景点的时间确实非常紧，而导游给的购物地方的时间确实非常充裕。比如游览石林仅给了一个半小时左右的时间，石林是国家的5A级景区，门票价格是170，是本次行程中最贵的景点了吧。石林虽然不大，但是要想在一个半小时内全部游览完是不可能的，因此只能走马观花，没办法，跟团走就只能认了。</p>
<p>之所以要写下这段行程，是因为这段旅行对我而言有着不一般的意义，我想将这段记忆铭记在心。不幸的是，回家后发现单反的SD卡出问题了，照片丢失了很大一部分。我虽不是很认同旅游就是为了拍照，现在人们已经过度的重视拍照而忽略了旅行本身的意义，但是这些照片在这次旅行中确实不可或缺的。</p>
<hr>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>下午三点多就到了春城昆明，抬头一看昆明的天果然不一般，云彩非常多，而且离地面非常近，轮廓感很强。阳光非常强烈，气温虽然不高，但是紫外线较强，阳光照在皮肤上生疼。不像在济南只能看到的雾霾，济南即使有云也是在雾霾之上，从地面看去毫无层次感。找到旅行社后机场接送人员送往酒店，稍事休息后去到昆明市中心的南屏街。从整体看，昆明的市容跟济南相仿，属于不是很繁华的类别，但是却属于省会的档次。下图照片我第一晚酒店的照片，大家感受一下云。</p>
<p><img src="http://kuring.qiniudn.com/yunnan_jinshengyuan.JPG" alt="金生源" title="金生源大酒店"></p>
<p>晚上和朋友在一家彝族的菜馆吃饭，对于北方的我来说，南方的饭菜吃起来不太习惯，米饭是生硬的，汤是油腻的，菜是辣的且没滋味。</p>
<p>吃完饭后准备坐公交回酒店，已经晚上九点半左右了，想抬头看看能不能看到星星，居然看到满天的云，真是奇特。在山东即使晚上有满天的云，也绝对达不到昆明的云的明亮程度。造成这种现象有两个原因，一是昆明属于东七区，比北京时间要晚上一个小时；二是，云南的云离得地面更近且多。</p>
<hr>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>这是悲催的一天，按照行程，要走“昆明—大理—丽江（昆明大理行车约4.5小时，大理-丽江行车约2小时车程）”的路程。早晨一起床，要去餐厅吃早饭，发现餐厅乌秧乌秧的全是人啊，找个地方吃饭都难，在艰难中吃完了早餐。期间一女同胞不小心打碎了一个碗，餐厅老板要了女顾客10块钱，心想真黑啊，几毛钱一个碗至于要这么多吗？</p>
<p>吃完饭后，餐厅外面和酒店大堂全是游客，经过电话沟通后找到了导游。导游点名后坐上了悲催的大巴。幸运的是，导游还不错，东北小伙，在云南上的大学。云南的旅游大巴都是车牌号都是统一编号的，车牌号以“L“开头，表示旅游的含义。旅游大巴启动后，雨就开始稀里哗啦的下起来了，运气还不错。</p>
<p>旅游大巴在高速上要在好多地方做例行检查，大约9点左右行驶到楚雄地段的某个高速检查点时，我们大巴的右侧玻璃跟后面的大巴的左侧后视镜摩擦而过，因为我就坐在后排，眼睁睁的目睹了这一过程。结果我们大巴右侧玻璃和后面大巴的左侧后视镜全部挂掉了，幸好没有驴友受伤情况，有图有真相。</p>
<p><img src="http://kuring.qiniudn.com/yunnan_daba.JPG" alt="旅游大巴" title="旅游大巴受伤后的样子"></p>
<p>在服务区经过1个小时的等待后大巴向前走了，目的地不是大理，而是前方的某个小镇。因为大巴没了挡风玻璃，速度也上不去了，在后面坐着还是相当凉快的。在小镇吃了个野生菌火锅后，开始了漫长的等待，等待着更换的大巴从大理赶来。从出现事故到新的大巴的到来，花掉了近5个小时的时间，这五个小时就算浪费了。</p>
<p>大巴前往大理，到达大理时接近5点多了，在天龙八部影视城附近吃了个晚餐，开始了赶往丽江的行程。本来计划中的大理古城和束河古镇全部泡汤，只能将行程安排到回来时在游览。</p>
<p>到达丽江时已经晚上十点的样子，刚刚下过一场雨，直接入住酒店。</p>
<hr>
<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>相对来说最轻松的一天，今天的行程中仅有玉龙雪山景区和玉水寨。</p>
<p>在云南给我们带团的导游属于省级导游，到了丽江这种地方性景点导游需要更换为地方性导游，这也是一种地方拉动就业的措施。昨天的导游直接休息一天，今天的导游是当地的纳西族导游带领。</p>
<p>玉龙雪山是丽江旅游的必去之地，每天丽江的游客大约在2万人的样子，也就意味着每天也会有2万人会前往玉龙雪山。为了避免在景区排队，早晨6点半就出发前往玉龙雪山，一个小时左右时间到达了玉龙雪山的入口。下车后坐着环保大巴盘山而上，到达云杉坪脚下，乘索道而上到达云杉坪。云龙雪山终年云雾缭绕，尤其是在云南的雨季更是非常难以看到玉龙雪山的面貌，听导游讲他也仅仅看过10次左右的样子。我不是个幸运的人，自然也无法看到玉龙雪山的面貌，此时天还下着小雨，从云杉坪上望去仅有白茫茫的云而已。其实从索道下和索道上看到的玉龙雪山的景色几乎是完全一致的，增加索道仅是为了增加景点的可玩性。</p>
<p><img src="http://kuring.qiniudn.com/yunnan_yulong.JPG" alt="玉龙雪山" title="玉龙雪山"></p>
<p>从索道下来后，开始乘坐电瓶车往下走，经过三站，每一站都会停下来观赏风景。三站观赏都是下山的白水河，只是分为了三段，三段景色不尽相同。河水属于碱性，河水颜色是蓝色且清澈，看起来相当漂亮，所以叫做蓝月谷。</p>
<p><img src="http://kuring.qiniudn.com/yunnan_lanyuegu.JPG" alt="蓝月谷1" title="蓝月谷"></p>
<p><img src="http://kuring.qiniudn.com/yunnan_lanyuegu2.JPG" alt="蓝月谷2" title="蓝月谷"></p>
<p><img src="http://kuring.qiniudn.com/yunnan_lanyuegu3.JPG" alt="蓝月谷3" title="蓝月谷"></p>
<p>从雪山下来后，如果时间来的及可以看到张艺谋导演的《印象丽江》，500名纳西族的群众演员的表演。由于下来晚了，仅看了个5分钟的结尾，不过可以从网上找的到视频。自从有了老谋子的《印象丽江》，带团的必须跟着演出时间走，来晚了就看不上了。</p>
<p>从云龙雪山出来后，前往玉水寨。玉水寨是丽江古城河水主要源头之一，是丽江东巴文化的传承圣地。景点面积不大，但属于东巴教圣地。既然属于圣地，照片就不上了。</p>
<p>在回丽江市的途中，导游领我们去了所谓的螺旋藻配送中心，实实在在的购物环节。螺旋藻的确属于丽江特产，野生的螺旋藻需要生长在碱性环境中，而离丽江不远的程海湖是世界第三大碱性湖泊，绝对是野生螺旋藻的产地，就是不知道市面上的所谓程海湖螺旋藻有多少是真的，因为一个程海湖再大也供应不了市场上这么多的螺旋藻。螺旋藻可以被导游描述出一堆好处，什么降血压、调肠胃、增强抵抗力等。每罐螺旋藻290元，属于批发价。机灵的我在没有了解一件商品之前是不会冲动消费的，淘宝一下发现有更便宜的，好像这个品牌也不是什么最好的，自然不买，何况想买还非得从这里买不成。</p>
<p>下午一点左右到达丽江古城北门后就是我们的自由时间。首先来到了黑龙潭公园，属于市民最常去的健身场所，跟济南的五龙潭公园类似，没什么特别之处，属于市民最常去的健身场所。</p>
<p><img src="http://kuring.qiniudn.com/yunan_heilongtan.JPG" alt="黑龙潭公园" title="丽江古城旁边的黑龙潭公园"></p>
<p>从黑龙潭出来后直奔丽江古城，整个游览下来丽江古城给我的感觉就是一座已经完全商业化的现代古城，几乎跟我想象中的一致。导游跟我们说过，丽江古城内其中90%是外地人，因此要在这里找回古城的感觉是比较难了，但在这里文艺一把还是可以的。</p>
<p>丽江古城面积虽大，但是游览下来古城内也就文艺客栈、普通餐馆、艳遇酒吧、彩条围巾、特色小饰品、银首饰、手敲鼓、写真。客栈几乎被鲜花包裹，随便找一家客栈都看上去很美很艺术，看上去像是一件艺术作品。餐馆跟古城外面的没什么两样，只是位置不同罢了。酒吧在古城中占有很大一部分席地，丽江是以艳遇闻名的，艳遇最多的地方还是得在酒吧。甚至大街上都有卖艳遇服装的，可见艳遇在游客心中的地位。彩条围巾基本拿回家都是送人和当桌布的，导游说围巾基本都产自浙江的，但在逛古城的时候买个披肩披在身上看起来还是不错的。导游说银首饰是买不得的，不知真假，不买为好。从店外面看去手敲鼓店里在边劈着腿坐着敲鼓边唱歌的女士怎么看怎么觉得别扭，但那音乐很特别。古城的街道挺多，但是走着走着却厌倦了，因为每条街道上的商品也就那些。</p>
<p><img src="http://kuring.qiniudn.com/yunan_kezhan.JPG" alt="丽江古城客栈" title="丽江古城客栈"><br><img src="http://kuring.qiniudn.com/yunnan_jiuba.JPG" alt="丽江古城酒吧" title="丽江古城酒吧"><br><img src="http://kuring.qiniudn.com/yunnan_lijiang_lubiao.JPG" alt="丽江古城路标" title="丽江古城路标"><br><img src="http://kuring.qiniudn.com/yunnan_lijiang_street.JPG" alt="丽江古城街道" title="丽江古城街道"></p>
<p>边看地图边问路，再配合上不太好用的百度地图向酒店返回。丽江的特色菜为三文鱼、黑山羊和腊排骨。一路上想找一家可以吃腊排骨的店，愣是没有找到一家合适的。最后累并饿的不行了，在四方街找了家德克士填饱肚子算了。</p>
<hr>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p>一早起来，发觉胃部不适，不知是不是昨天在丽江古城吃了什么不合适的小吃还是晚上睡觉忘记开窗户了还是有点轻微的高原反应还是这几天的劳累还是水土不服。总之身体不舒服是旅游中的大忌，我恰巧就碰到了。稍微喝了点米粥后就上路了。约莫走了一个小时，吐了一次。还好，吐完后整个身体都轻松多了。</p>
<p>在虎跳峡附近接上我们的香格里拉导游，地方导游自然是藏族人，叫什么措，我们的团改成叫“措团”。</p>
<p>今天第一个景点为虎跳峡，虎跳峡为金沙江上的一个峡谷，下车点在峡谷上方，景点为沿着护栏峡谷底部行进，到达底部后再沿上行木栈道到达出发点。下车后听到最多的就是知了叫，知了数量非常之多，以至于木栈道上都有，伸手就可以抓到。沿木栈道而下，江水并没有想象中的急，不过在最下面的观景台上声音听起来确实很大。观景台对面有一个连接两山的石桥远远看去非常漂亮。由于照片全部损坏，不能贴图了。</p>
<p>从虎跳峡走后下午一点抵达“心中的日月–香格里拉”，香格里拉一名源于《消失的地平线》小说中虚构的地名。香格里拉的海拔在3200米，很多人在这种海拔高度会出现高原反应。</p>
<p>下午一到酒店就趴在床上累的起不来了，沉睡了两个小时后，由于晚上要去藏族家里进行家访，不敢睡的太沉。醒后又在床上躺了一个多小时，一闭眼就能睡着，感觉从来没有这么累过。咬咬牙起来后，找个超时买点东西，感觉走起来也非常的累，心想，这辈子再也不会来这地方了，纯粹的花钱找罪受。</p>
<p>吃过晚饭后，就去了藏族家。这个是额外收费的，而且费用不低。带牦牛肉和烤鸡肉的价格为一人260元，不带的为一人180元。胃部本来就不适的自然选择了180元的价格。等到我们去了之后问起其他团的，他们带牦牛和烤鸡的价格才100元，可见我们导游能黑我们多少money。这次家访纯粹是一次商业性质的家访，大巴在藏族家门口停下来，下车后就会有人给佩戴围巾，并且有专人拿着单反拍照。</p>
<p>进屋后直接到二楼，屋里已经有好多个团围着屋中央而坐。坐下后，品尝酥油茶，青稞酒，还有酸奶干，甚至还有青稞拿来当瓜子吃的。</p>
<p>等牦牛肉和烤鸡都上齐后，节目就开始了。主持人很明显经过些专业的训练，嗓门特别大，也特别擅长带动气氛。藏族人好客的方式就是跺地板加鼓掌，声音越大越好。地板为木制的，一群人跺起脚来后声音特别大。节目大约持续了三个小时，无非就是跳舞、唱歌、跺脚、教些藏族的语言等。其实节目挺无聊，但是热闹。挺佩服主持人能够将这么庸俗的一个节目坚持了三个小时之巨。本来身体非常难受的我，在欢呼中也变得热情高涨，使劲跺脚，使劲故障，全身心投入到节目中，最后居然难受的症状全部消失了。</p>
<p>期间，藏民开始按照在门口时拍摄的照片找人，所有人的照片早已经洗好，并且用硬塑料膜保护着。照片20元一位，可见这是多么商业的一次活动。</p>
<p>到了酒店已经11点了，导游嘱咐过不能早睡，不能洗澡，否则很容易出现高原头痛等高原反应的症状。</p>
<hr>
<h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h1><p>照旧是早起，今天的行程为普达措国家森林公园。为了防止出现高原反应带来的事故，同时也可以达到赚钱的目的，导游推荐我们在香格里拉买氧气灌和红景天口服液。仙剑奇侠传三中的景天大概就取自此药名吧。普达措的最高处海拔可以达到4200米，想想这个海拔高度，为了避免高原反应，再加上昨天我本来就很不舒服，为了保险了我买了两罐，并且购买了一盒红景天口服液。后来才发现这些花费都是多余的，普达措之所以称之为森林公园，森林肯定非常之多，空气中氧气含量不会很低。走在普达措中，感觉空气比氧气瓶中的更纯净。</p>
<p>整个森林公园分为了三部分：属都湖、弥里塘和碧塔海。整个森林公园的面积非常之大，三个景点之间大约需要坐10-20分钟的电瓶车，电瓶车上都会有导游对景点进行讲解。</p>
<p>普达措应该是我这次云南旅游中最值得一去的地方，整个游览下来就感觉这个地方好似人间仙境。这里的湖面非常静，远处牦牛和马儿低着头在不停的吃草，一副悠闲自得的样子。遍地的小野花，在牛粪堆中自由的生长。从山上留下来的水就在平地上冲出一条弯弯曲曲的河，令我一直在想河道为什么是S型，这说明山上留下来的水总是缓缓的。水杉树上挂满了蜘蛛网版的白色的毛，更添加了这里的仙境色彩，据说是寄生在水杉上的一种植物。山间偶尔会见到特别小的小松鼠在树下找点吃的，然后一会就不见了，仿佛刚才见到的不是真的。这中景色中有身临其境方能体会。</p>
<p>属都湖为一个天然湖泊，远处就能看到牦牛和马儿。弥里塘是整个森林的海拔最高处，地方非常平静，视野相当开阔，牦牛和马儿在远处的草地上吃着小花小草。碧塔海是整个景区的核心景点，我们选择徒步4公里的路程，沿着碧塔海从湖的一边走到另外一边。在漫步中慢慢体会碧塔海的迷人之处。</p>
<p><img src="http://kuring.qiniudn.com/yunan_pudacuo_xiaohe.JPG" alt="山间的小河" title="山间的小河"><br><img src="http://kuring.qiniudn.com/yunan_pudacuo_militang.JPG" alt="弥里塘" title="弥里塘"><br><img src="http://kuring.qiniudn.com/yunan_pudacuo_bitahai.JPG" alt="碧塔海" title="碧塔海"><br><img src="http://kuring.qiniudn.com/yunnan_pudacuo_hua.JPG" alt="野花" title="野花"><br><img src="http://kuring.qiniudn.com/yunnan_pudacuo_river.JPG" alt="河" title="富有诗意的小河"></p>
<p>从普达措出来后，藏族导游跟我们说拜拜。在香格里拉吃过午饭后，开始马不停蹄的往丽江赶。期间路过“长江第一湾”景点，在观景楼上高高看去，除了恐高之外没有别的感觉。前文已经介绍过“长江第一湾”景点的一些坑况，不再对坑进行过多描述。</p>
<p>下午三点多到达丽江的酒店，在酒店放下东西后直接前往大理古城，这里酒店离的大理古城的南门算是比较近。上次来没有吃上当地特色小吃腊排骨，在南门外找了家店品尝一番，吃起来跟我想象中的一致，除了有点排骨味之外还略带腊味。</p>
<p>吃完腊排骨后已经是晚上8点左右的时间，上次逛丽江古城主要是逛了北门附近多些，这次逛上次没有逛过的南门附近。南门附近与北门不同的是，古城南边有很多的客栈，但是这里的胡同和客栈却略显凄凉，人少了需要，客栈也没有那么文艺。转了几个胡同后，在转了一个又一个弯后的胡同中找到了大名鼎鼎的木府。时间已晚，看着地图加导航接回酒店睡下了。</p>
<hr>
<h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><p>今天的行程为从丽江-大理-昆明。上次去大理仅是路过，这次是去体验，虽然时间也仅仅有一天。</p>
<p>下关风，上关花，苍山雪，洱海月。风花雪月便是大理景色的最真实写照，大理城就被下关、上关、苍山和洱海包裹着。本次大理执行风花雪月均为体会到，甚至连洱海边都未到过，仅仅是去了洱源小西湖，也勉强算是到过洱海吧。</p>
<p>快到洱源小西湖的路上遇到了集市，集市上有用竹篓子卖小猪，看起来挺滑稽挺有意思。</p>
<p>进入洱源小西湖后导游会先带领到购物区，都是些当地的特产，价格也不贵。刚坐上木船会看到鱼鹰表演，木船绕着西湖转上一圈，欣赏西湖的美景。</p>
<p>下船后，会去餐馆白族的歌舞表演，并品尝白族三道茶。三道茶“头苦、二甜、三回味”，喝起来味道怪怪的。从歌舞表演厅出来后就直接出西湖了。</p>
<p><img src="http://kuring.qiniudn.com/yunan_xihu.JPG" alt="洱源小西湖" title="洱源小西湖门口"><br><img src="http://kuring.qiniudn.com/yunan_xihu_yuying.JPG" alt="鱼鹰表演" title="鱼鹰表演"><br><img src="http://kuring.qiniudn.com/yunan_xihu2.JPG" alt="洱源小西湖" title="洱源小西湖"><br><img src="http://kuring.qiniudn.com/yunan_sandaocha.JPG" alt="三道茶" title="白族三道茶"></p>
<p>从西湖出来后，直接赶到白银购物中心十八里铺。大理是白银产地，在大理旅游购物自然少不了白银。一下车，在十八里铺的停车场已经停了几十辆大巴，显然都是拉来购物的。导游象征性的给我们介绍了下大理白族的房屋布置和婚房布置，顺便看了下几个人在手工制作白银，最后就带我们到白银购物大厅里了，然后导游就撤了。留下来选择购买白银的时间非常的长，有一个半小时之久。</p>
<p>艰难的等待后，在十八里铺吃完午饭后，直接奔向大理古城。由于南门无法停车，大巴在离大理古城南门2里地的停车场停下，导游给我们游玩的时间是1个半小时，偌大一个大理古城仅有一个半小时的游玩时间，而一个十八里铺的购物大厅却也预留了差不多时间。</p>
<p>大理古城相比丽江古城更现代化，古城内有相当多的现代商店，甚至都有超市的存在，除了建筑风格比较古之外，其他都是新的。古城的北面，直接就成了居民区了。不过相比丽江古城，我更喜欢大理古城，因为这里购物更方便，而且街道也建设的更加规整，不会出现迷路的情况。里面的物品价格也更加便宜，整个古城更像是城市中的步行街。</p>
<p><img src="http://kuring.qiniudn.com/yunan_daligucheng.JPG" alt="古城南门" title="大理古城南门"><br><img src="http://kuring.qiniudn.com/yunan_dali_wuhualou.JPG" alt="五华楼" title="大理古城的五华楼"><br><img src="http://kuring.qiniudn.com/yunan_dali_yangrenjie.JPG" alt="洋人街" title="大理古城的洋人街"></p>
<p>从大理古城走后，直接赶回昆明，到达昆明酒店已经是晚上10点了。</p>
<hr>
<h1 id="Day-7"><a href="#Day-7" class="headerlink" title="Day 7"></a>Day 7</h1><p>早餐后赶往中国名牌企业七彩云南，顾名思义就是购物了。导游一而再再而三的强调，导游前五天是天使，第六天就是魔鬼。“什么都可以落在宾馆，唯独你们的武器–钱包不能落在宾馆”。没有比这个更直白的了。</p>
<p>七彩云南园区内共有七个展馆，首先带领我们去的是翡翠馆。翡翠主要产自缅甸和云南接壤地带，自然会成为云南的特产代表。导游带领我们体验一把模拟的翡翠形成过程的动画，紧接着就会带领我们到达翡翠销售大厅。购买翡翠的时间预留的非常充足，期间为了打发时间跑去了孔雀园转了一圈。整个行程中导游是只字未提孔雀园，但是孔雀园却是七彩云南园区中最适合游玩的地方。孔雀园内有几千只孔雀，植物的种类也非常多，还有一面非常大的花墙，看上去也是相当漂亮。</p>
<p>集合后又餐馆了普洱茶馆，直接被关到屋里面品茶，品完熟茶品生茶，品完茶后自然是买茶。</p>
<p><img src="http://kuring.qiniudn.com/yunan_qicai.JPG" alt="七彩云南" title="七彩云南"><br><img src="http://kuring.qiniudn.com/yunan_qicai_map.JPG" alt="七彩云南地图" title="七彩云南地图"><br><img src="http://kuring.qiniudn.com/yunan_qicai_hua.JPG" alt="孔雀园花墙" title="孔雀园的花墙"></p>
<p>在七彩云南吃过午餐后，大巴赶往天造奇观的石林。去石林的路上，从未看到过石林内形状的石头，可是到了石林内部却到处都是竖状的石头，一直对竖状石头的成因感到颇为好奇。一个5A级的景区仅仅预留了一个半小时的时间游览，而且还包含了排队等电瓶车的时间。</p>
<p>石林分大石林和小石林，大石林的石头看上去更高大一些，小石林的石头看上去稍微矮小一些。听景区的导游介绍，到了大石林找到“石林”二子后拍个照后就相当于花掉了100块钱的门票，到了小石林后找到“阿诗玛的化身”后就相当于又花掉了70元的门票。</p>
<p>到达大石林后找到了“石林”二字拍完照后，没有听导游的话直接原路返回坐电瓶车到小石林，而是出于好奇在石林内部转起迷宫来，石林面积应该不小，至少我在内部至少走了40分钟后也没有走多少，而且重要的是我彻底迷路了，找不到入口也找不到出口。一看时间已经过去了一大半，还没到小石林，就抓紧时间往外赶，转了半天迷宫终于出来了。</p>
<p>排队挤上电瓶车到达小石林，小石林石头之间的间隙要大很多，石头之间还有草地，走在里面不会存在迷路的可能。拐个弯找到阿诗玛的化身拍个照抓紧时间往出口赶。阿诗玛的化身石我怎么看也没看出像一个人来，石头背后的故事就不深究了。</p>
<p><img src="http://kuring.qiniudn.com/yunnan_shilin1.JPG" alt="大石林" title="值100块钱的石林二字"><br><img src="http://kuring.qiniudn.com/yunan_shilin2.JPG" alt="剑锋池" title="大石林的剑锋池"><br><img src="http://kuring.qiniudn.com/yunan_xiaoshilin.JPG" alt="小石林" title="小石林"><br><img src="http://kuring.qiniudn.com/yunan_xiaoshilin2.JPG" alt="小石林" title="小石林"><br><img src="http://kuring.qiniudn.com/yunan_xiaoshilin3.JPG" alt="小石林" title="小石林"><br><img src="http://kuring.qiniudn.com/yunan_ashima.JPG" alt="阿诗玛化身" title="阿诗玛化身"></p>
<p>从石林归来后，又回到了七彩云南。这次购物的重点已经不再是翡翠，而是黄龙玉。黄龙玉产自云南，发现较晚，因此价格较便宜。我直接走向黄龙玉旁边的土特产超市，从里面买点鲜花饼、当地咖啡、普洱茶等，价格还算亲民，拿回来送朋友是个很不错的选择。</p>
<p>在七彩云南吃过地道的过桥米线后直接入住温泉酒店，跟陪伴我们六天的导游和司机师傅说再见后，在温泉酒店做了个鱼疗后，收拾所有的物品打包准备回温馨的家。</p>
<hr>
<h1 id="Day-8"><a href="#Day-8" class="headerlink" title="Day 8"></a>Day 8</h1><p>8点20的飞机，五点半开始往机场赶。12点左右已经回到了温馨的家。</p>
<hr>
<h1 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h1><h2 id="方向感"><a href="#方向感" class="headerlink" title="方向感"></a>方向感</h2><p>我无论到哪里都喜欢找找方向感，看看那是南，我是属于那种第一次到一个地方后只要认错了方向就再也调不过来的那种人。这一周的时间我却几乎没有掉过方向来，以至于到后来干脆就不考虑方向了，管他东西南北，只要能回得了酒店，只要能找到大巴就OK了。</p>
<h2 id="民族"><a href="#民族" class="headerlink" title="民族"></a>民族</h2><p>本次行程中的几个城市分属于不同的少数民族，风俗习惯、文化传统和建筑风格各有特点。昆明和楚雄是彝族人居多，大理是白族自治州，丽江是纳西族的聚居地，香格里拉主要是藏族人。最有意思的是，这几个少数名族对男女的称呼各有特色。彝族人对男性称呼为“阿黑哥”，对女性称呼为“阿诗玛”；白族分别称呼为“金花”和“阿鹏”；纳西族分别称呼为“胖金妹”和“胖金哥”；藏族分别称呼为“扎西”和“卓玛”。</p>
<hr>
<h1 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h1><p>本来是计划写成散文的，文笔有限，写着写着就写成记叙文了。要是有足够的文采，绝对可以写出比《从百草园到三味书屋》中需要背诵的片段更优美的文字，可惜不是作家的料，仅能码字而已。</p>
<p>旅游不易，码字更难，且行且珍惜。</p>
]]></content>
  </entry>
</search>
