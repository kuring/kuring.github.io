<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"kuring.me","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="404频道">
<meta property="og:url" content="http://kuring.me/page/17/index.html">
<meta property="og:site_name" content="404频道">
<meta property="og:locale">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://kuring.me/page/17/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-Hans","comments":"","permalink":"","path":"page/17/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>404频道</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">404频道</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学习笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">246</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/kuring" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kuring" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/majority_element/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/majority_element/" class="post-title-link" itemprop="url">leetcode题目之Majority Element</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-03-11 00:00:00" itemprop="dateCreated datePublished" datetime="2015-03-11T00:00:00+00:00">2015-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-08-31 09:27:11" itemprop="dateModified" datetime="2024-08-31T09:27:11+00:00">2024-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n&#x2F;2 ⌋ times.<br>You may assume that the array is non-empty and the majority element always exist in the array.</p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题是一道非常简单的题目，但我能想到的思路有限，仅能想到排序法和哈希法两种算法，在Solution中提供了另外几种方法，这是非常值得我学习和思考的。本文仅将网站的思路拿过来，可以直接看该问题的<a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element/solution/">Solution</a>。</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h2><p>最原始的解决办法，逐个元素比较是否为该数组中的最多元素，只要满足条件即可终止。时间复杂度为O(n^2)。</p>
<h2 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h2><p>将数组中的元素遍历一遍，并将数组中元素的个数保存到哈希中。然后遍历哈希，从哈希中找到最多元素。时间复杂度O(n)，但需要占用一定的空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">        std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; result_map;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = num.<span class="built_in">begin</span>(); iter != num.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result_map.<span class="built_in">find</span>(*iter) == result_map.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                result_map.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(*iter, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result_map[*iter]++;                                                                                                                                            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">for</span> (std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator iter = result_map.<span class="built_in">begin</span>(); iter != result_map.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;second &gt; max_count)</span><br><span class="line">            &#123;</span><br><span class="line">                result = iter-&gt;first;</span><br><span class="line">                max_count = iter-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h2><p>直接对元素进行排序，排序后元素的中间元素即为要求的最多元素。时间复杂度为O(nlogn)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElementSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">   <span class="keyword">return</span> num[num.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随机抽取法"><a href="#随机抽取法" class="headerlink" title="随机抽取法"></a>随机抽取法</h2><p>随机从数组中抽取元素，然后遍历数组判断该元素是否为最多元素。该算法利用了最多元素被随机抽取的概率最大的特点，但该算法效率的随机性较大，最好时间复杂度为O(n)，最坏情况下一直随机不到最多元素。</p>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>将数组均分为两份，分别求出两个数组中的最多元素A和B，则整个数组中的最多元素必然在两个子数组的最多元素A和B中，这一点可以通过举例子的方式来证明，但是仅凭感觉不太容易得出该结论。如果A&#x3D;&#x3D;B，则结果就是A。如果A!&#x3D;B，则分别求出A和B在这个数组中的元素个数。时间复杂度接近O(nlogn)。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有一些比较不容易想到的算法，这里就不列举了。至少我看过一次之后，下次这些算法仍然是记不住的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/aleap_idx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/aleap_idx/" class="post-title-link" itemprop="url">asleap中的简单文件索引机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-02-28 00:00:00" itemprop="dateCreated datePublished" datetime="2015-02-28T00:00:00+00:00">2015-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-08-31 09:27:11" itemprop="dateModified" datetime="2024-08-31T09:27:11+00:00">2024-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>asleap是一个开源的vpn破解工具，最近查看了asleap的源码，该项目<a target="_blank" rel="noopener" href="http://sourceforge.net/projects/asleap/">地址</a>。本文的重点是对其中的带索引的字典文件的产生过程进行介绍，产生带索引的字典文件并不复杂，但是要想用简洁易懂的语言将该问题描述明白却不容易。</p>
<p>asleap破解vpn的机制是通过字典文件暴力破解的方式，该字典文件有dat数据文件和idx索引文件两个文件组成，两个文件均为二进制格式。asleap工程中自带了genkey程序，可以将文本的字典文件转换为asleap程序需要的带索引的字典文件。</p>
<p>本文以字典文件为以下内容讲解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">turquoise</span><br><span class="line">da</span><br><span class="line">test</span><br></pre></td></tr></table></figure>

<h1 id="读取字典文件并产生md4值"><a href="#读取字典文件并产生md4值" class="headerlink" title="读取字典文件并产生md4值"></a>读取字典文件并产生md4值</h1><p>md4编码占16个字节，三个字典进行md4编码后的结果分别为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18 07 33 43 f6 30 b5 f8 2c 38 c0 34 37 f2 81 6b</span><br><span class="line">01 19 a3 80 94 40 60 3c 57 39 5e 73 f3 60 95 98</span><br><span class="line">0c b6 94 88 05 f7 97 bf 2a 82 80 79 73 b8 95 37</span><br></pre></td></tr></table></figure>

<h1 id="将字典信息写入到临时文件"><a href="#将字典信息写入到临时文件" class="headerlink" title="将字典信息写入到临时文件"></a>将字典信息写入到临时文件</h1><p>为了能够对最终生成的dat文件中的内容进行排序和便于索引，程序生成了256个临时文件，文件名格式为从genk-bucket-00.tmp到genk-bucket-ff.tmp。程序根据md4编码中的第14位将字典对应的信息分别写入到临时文件中，一个字典写入到临时文件的内容如下，如果一个临时文件中存在多个字典则依次存放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashpass_rec</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> rec_size;		<span class="comment">// 一个字典占用文件的大小，包括该变量+字典+字典对应的md4值共占用的字节数</span></span><br><span class="line">    <span class="type">char</span>          *password;	<span class="comment">// 字典</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hash[<span class="number">16</span>];		<span class="comment">// 字典对应的md4值</span></span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure>

<p>本例子中turquoise对应结构体会写入到genk-bucket-81.tmp中，da和test对应结构体会依次写入到genk-bucket-95.tmp中。</p>
<h1 id="读取临时文件并写入到dat数据文件中"><a href="#读取临时文件并写入到dat数据文件中" class="headerlink" title="读取临时文件并写入到dat数据文件中"></a>读取临时文件并写入到dat数据文件中</h1><p>最终dat文件中的数据内容为hashpass_rec的有序集合，排序的原则是按照md4的第14和15两个字节。依次读取256个临时文件中的hashpass_rec可以保证dat文件中的数据内容是按照第14字节排序的，但是不能够保证是按照第15个字节排序的。为了保证最终dat文件中的数据内容是按照第14和15字节有序的，在将一个临时文件中的内容写入到dat文件中前需要对该临时文件中的hashpass_rec结果按照hash变量的第15字节进行排序，直接使用C语言中的qsort进行排序。</p>
<p>该例子中da和test位于同一个临时文件中，需要根据hash变量的第15字节排序的结果为test、da，最终写入到dat文件中的排序结果为turquoise、test、da。</p>
<h1 id="根据dat数据文件产生idx索引文件"><a href="#根据dat数据文件产生idx索引文件" class="headerlink" title="根据dat数据文件产生idx索引文件"></a>根据dat数据文件产生idx索引文件</h1><p>idx索引文件中存放的是多个hashpassidx_rec结果，最多有256*256项，其结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashpassidx_rec</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>	        hashkey[<span class="number">2</span>];	<span class="comment">// 对应md4编码的第14和15字节</span></span><br><span class="line">    <span class="type">off_t</span>                   offset;		<span class="comment">// 第一个匹配的hashpass_rec结构在dat文件中的偏移，占用4个字节</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> 	numrec;		<span class="comment">// dat文件中共有多少个匹配的hashpass_rec结果</span></span><br><span class="line">&#125; __attribute__ ((packed));	<span class="comment">// 字节对齐，需要填充4个字节</span></span><br></pre></td></tr></table></figure>

<p>最终完成的dat文件和idx文件的指向如下图所示：</p>
<p><img src="http://kuring.qiniudn.com/aleap_idx.png" alt="最终完成的dat文件和idx文件的指向"></p>
<h1 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h1><p>genkeys.c文件中在读取字典文件时存在bug，在文件的207行将内容更改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!feof(inputfl)) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(password, <span class="number">0</span>, MAX_NT_PASSWORD + <span class="number">1</span>);</span><br><span class="line">        fgets(password, MAX_NT_PASSWORD+<span class="number">1</span>, inputfl);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strlen</span>(password) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1jGmVF06">字典文件等相关文件下载</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/algorithm_sort_code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/algorithm_sort_code/" class="post-title-link" itemprop="url">常用排序算法整理及代码实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2015-02-25T00:00:00+00:00">2015-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-08-31 09:27:11" itemprop="dateModified" datetime="2024-08-31T09:27:11+00:00">2024-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文对我编写的常用的排序算法进行整理和总结，方便用时进行查阅和参考。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是实际应用中的最好选择，采用了分治法的思想。通过一趟排序将待排序记录分割成独立的两部分，其中一部分的关键字均比另外一部分的小，分别对这两部分记录进行排序，已达到整个有序。</p>
<p>是否稳定：不稳定</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(logn)，需要栈来实现递归用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivotkey = numbers[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; numbers[high] &gt;= pivotkey)</span><br><span class="line">        &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers[low] = numbers[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; numbers[low] &lt;= pivotkey)</span><br><span class="line">        &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers[high] = numbers[low];</span><br><span class="line">        numbers[low] = pivotkey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pivotloc = <span class="built_in">partition</span>(numbers, low, high);</span><br><span class="line">        <span class="built_in">quick_sort</span>(numbers, low, pivotloc - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quick_sort</span>(numbers, pivotloc + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">quick_sort</span>(numbers, <span class="number">0</span>, numbers.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">49</span>&#125;;</span><br><span class="line">    <span class="built_in">quick_sort</span>(numbers);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numbers.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>将两个或两个以上的有序表组合成一个新的有序表。合并两个有序表的方法为：比较两个有序表中第一个数，谁小先取谁。继续进行比较，只要有一个有序表为空，直接将另一个有序表取出即可。</p>
<p>是否稳定：稳定</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(n) （当使用顺序存储时，为了能够实现两个有序表之间的合并），或O(1)（当使用链式存储的时候，不再需要临时的空间来存储排序的结果）</p>
<h2 id="顺序存储代码"><a href="#顺序存储代码" class="headerlink" title="顺序存储代码"></a>顺序存储代码</h2><p>以下为采用顺序存储结构的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序使用递归算法的效率比较低，具体应用中会采用非递归算法代替</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers, std::vector&lt;<span class="type">int</span>&gt; &amp;extra, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> middle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = low, j = middle+<span class="number">1</span>, k = low;</span><br><span class="line">    <span class="keyword">for</span> (; i&lt;=middle &amp;&amp; j&lt;=high; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &lt;= numbers[j])</span><br><span class="line">        &#123;</span><br><span class="line">            extra[k] = numbers[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            extra[k] = numbers[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle)</span><br><span class="line">    &#123;</span><br><span class="line">        extra[k++] = numbers[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= middle)</span><br><span class="line">    &#123;</span><br><span class="line">        extra[k++] = numbers[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = low; m &lt;= high; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        numbers[m] = extra[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers, std::vector&lt;<span class="type">int</span>&gt; &amp;extra, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low == high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(numbers, extra, low, middle);</span><br><span class="line">    <span class="built_in">merge_sort</span>(numbers, extra, middle + <span class="number">1</span>, high);</span><br><span class="line">    <span class="built_in">merge</span>(numbers, extra, low, high, middle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请额外的存储空间来用于排序处理</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; extra = numbers;</span><br><span class="line">    <span class="built_in">merge_sort</span>(numbers, extra, <span class="number">0</span>, numbers.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">49</span>&#125;;</span><br><span class="line">    <span class="built_in">merge_sort</span>(numbers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numbers.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式存储代码"><a href="#链式存储代码" class="headerlink" title="链式存储代码"></a>链式存储代码</h2><p>以下为采用链式存储结构的代码，本答案为我在LeetCode上的<a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-list/">Sort List </a>题目的答案，源码放在<a target="_blank" rel="noopener" href="https://github.com/kuring/leetcode/blob/master/src/sortList/sort_list.cpp">我的Github上</a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用归并排序方法，核心思想为将数组拆分为两半，分别对两半进行排序，排序完成后再进行一次排序，排序算法就可以采用插入排序的方式。</span></span><br><span class="line"><span class="comment"> * 对两半排序的算法仍然采用归并排序算法，即问题为递归问题</span></span><br><span class="line"><span class="comment"> * 在使用线性存储结果的归并排序算法中，会使用额外的空间来存储临时结果，空间复杂度为O(n)，而在链式存储中，空间复杂度为O(1)</span></span><br><span class="line"><span class="comment"> * 归并排序的时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="comment"> * 如果存储结构为双向链表，可以使用快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 仅有两个元素，对两个元素进行排序后直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val &lt; head-&gt;next-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = head-&gt;next;</span><br><span class="line">            tmp-&gt;next = head;</span><br><span class="line">            tmp-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了找到中间节点，这里采用快慢指针的方式，否则需要使用先遍历一次取长度，然后找到中间位置的两次遍历方式</span></span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    ListNode *slow_prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow_prev = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = slow_prev-&gt;next;</span><br><span class="line">    slow_prev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别对两段链表进行排序</span></span><br><span class="line">    slow = <span class="built_in">sortList</span>(head);</span><br><span class="line">    fast = <span class="built_in">sortList</span>(fast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对两段链表进行合并</span></span><br><span class="line">    ListNode *node = <span class="literal">nullptr</span>, *result = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="literal">nullptr</span> &amp;&amp; fast != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow-&gt;val &lt; fast-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;next = slow;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node = slow;</span><br><span class="line">                result = slow;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;next = fast;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node = fast;</span><br><span class="line">                result = fast;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slow != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;next = slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;next = fast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p>该排序算法的时间复杂度为O(n^2)，算法复杂度过高。分为顺序存储和链式存储两种算法，其中顺序存储每比较一个元素是从该元素往前比较的，而链式存储是从链头开始比较的，这点有所不同，造成不同的是由存储结构决定的。</p>
<h2 id="顺序存储代码-1"><a href="#顺序存储代码-1" class="headerlink" title="顺序存储代码"></a>顺序存储代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void insertion_sort(std::vector&lt;int&gt; &amp;numbers)</span><br><span class="line">&#123;</span><br><span class="line">	if (numbers.size() &lt;= 1)</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 1; i &lt; numbers.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int j = i; j &gt; 0; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			if (numbers[j] &lt; numbers[j - 1])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(numbers[j], numbers[j - 1]);</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[] = &#123; 49, 38, 65, 97, 76, 13, 27, 49 &#125;;</span><br><span class="line">	vector&lt;int&gt; numbers(a, a + sizeof(a) / sizeof(int));</span><br><span class="line">	insertion_sort(numbers);</span><br><span class="line">	for (int i = 0; i&lt;numbers.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d\t&quot;, numbers[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式存储代码-1"><a href="#链式存储代码-1" class="headerlink" title="链式存储代码"></a>链式存储代码</h2><p>以下代码为LeetCode上的链式存储的情况时的直接插入排序算法的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    ListNode *node = head-&gt;next;</span><br><span class="line">    ListNode *new_head = head;</span><br><span class="line">    new_head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *node_next = node-&gt;next;   <span class="comment">// 先将当前遍历的下一个节点保存</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前节点插入到新链表中</span></span><br><span class="line">        ListNode *new_node_tmp = new_head;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val &lt; new_node_tmp-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前节点插入新链表的第一个位置</span></span><br><span class="line">            node-&gt;next = new_head;</span><br><span class="line">            new_head = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将当前节点插入到中间</span></span><br><span class="line">            <span class="keyword">while</span> (new_node_tmp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;val &lt; new_node_tmp-&gt;next-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    node-&gt;next = new_node_tmp-&gt;next;</span><br><span class="line">                    new_node_tmp-&gt;next = node;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                new_node_tmp = new_node_tmp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将该节点插入到最后位置</span></span><br><span class="line">            <span class="keyword">if</span> (new_node_tmp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                new_node_tmp-&gt;next = node;</span><br><span class="line">                node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 开始遍历当前节点的下一个节点</span></span><br><span class="line">        node = node_next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/summary/2014_summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/summary/2014_summary/" class="post-title-link" itemprop="url">2014年总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-02-13 00:00:00" itemprop="dateCreated datePublished" datetime="2015-02-13T00:00:00+00:00">2015-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-08-31 09:27:11" itemprop="dateModified" datetime="2024-08-31T09:27:11+00:00">2024-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我的年总结是依照农历的，因为在我心中春节才算是一年的真正开始，因为只有春节的时候才能找到年的滋味，年的感觉，才能称之为年，阳历的年只能称之为year。</p>
<p>2014年又在不经意间过去了，很多地方跟2013年一样是平淡，工作和学习仍然是生活的主旋律，闲暇时间抽个时间玩玩dota放松一下，周末偶尔爬个小山锻炼下身体，对我的人生中算是比较重要的一年。</p>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>2014年经历了结婚、毕业答辩和考驾照几件占用时间的事情，留给我业余时间用来学习的就少之又少了。结婚占用两个月时间，毕业论文占用了我两个月时间，考驾照占用了多个周末，工作出差占用了我一个月时间，留给我能够独立学习的晚上也就6个月时间。</p>
<p>开始的时候小看了硕士论文，以为很简单一事情，搞过这么多软件项目还搞不了一篇硕士论文。一直以来我看不起软件工程类论文，就一项目套个模板一介绍就是一篇论文，于是我选择了写一篇理论研究类论文，没有高大上的理论，而是在公司实践中真正用到的，《将Windows平台的C&#x2F;C++程序向Linux平台移植的技术研究》，选择论文的时候我已经看到了该题目不太适合作为硕士论文，当我还是毅然作为了我的硕士论文题目，不得不说这是我今年的一大败笔。第一篇论文失败后，我重新走起了保守路线，以之前熟悉的系统为主线，辅以各种文档的拼凑，完成了一篇我曾经嗤之以项目类硕士论文，并顺利通过答辩。对于我这样的新手而言，写论文是一件漫长又痛苦的过程，占用了我大量的宝贵时间。</p>
<p>一直以来对嵌入式linux方向比较好奇，今年终于抵不住好奇，买了个2140开发板自己捣鼓了一段时间，由于时间关系虽然到现在也没有入门，多多少少对嵌入式已经有所了解。</p>
<p>感谢我的另一半，给我提供了足够的时间来干我想干的事情。</p>
<h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><p>比起2013年，今年读过的书籍少了一些。</p>
<ul>
<li>《Linux&#x2F;Unix系统编程手册》</li>
<li>《编程珠玑》</li>
<li>《LINUX设备驱动程序》（部分章节）</li>
<li>《LINUX内核设计与实现》（大部分章节）</li>
<li>《深度探索linux操作系统》</li>
<li>《剑指Office》</li>
<li>《大规模C++程序设计》</li>
<li>《程序员的自我修养》（第二遍）</li>
<li>《文明之光》</li>
<li>《程序员健康指南》</li>
<li>《黄金时代》</li>
<li>《一只特立独行的猪》</li>
<li>《算法导论》（部分章节）</li>
</ul>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>已经比较熟练掌握了公司产品的大部分技术，工作起来算是得心应手，但是却少了许多挑战，是时候该接收大挑战的了。工作的职位从后台组长到研发部副经理到研发部经理，开始了工作的转型，这是我不期望这么早来到的，我自认为技术的成长空间还很大，不想过早的接触管理岗位。</p>
<p>五月份的出差成为了我心中抹不去的痛，莫名其妙接受了任务，匆忙出差，不过坑才刚刚开始。要维护的是一个我没见过界面的产品，不过基本原理我是清楚的。产品有很多bug，这我可以理解，要不然也不会让我出差了，但要命的是我没有产品的代码，我接受的任务仅是去应付客户、发现bug后反馈、更新产品、施工，这明白着是市场+测试+维护的话，跟我半毛钱关系都没有。以上这些都无所谓，要知道我可不是一个顽固不化的程序员，但工作地点竟然是机房，而且机房是我见过最脏最乱的机房，我就站在一排机柜的后面的一堆烂纸箱子上吹着空调的冷风和机器的热风办公，时而蹲着，时而站着，时而坐着，时而将衣领撩起保暖，时而浑身打颤，以至于到现在我留下了膝盖隐隐作痛的毛病。而且系统bug不断，一连在不吃晚饭的情况下加班到大半夜好多次，而我竟然坚持下来了。原本三五天的出差计划，一待就是二十多天。这短短的二十多天成为了我今年最难忘的痛，多少次期望回到家里温暖的被窝，多少次期望在家吃着我做的炖土豆。</p>
<p>今年面试了不少人，通过面试也发现大部分技术人员的水平太差了，我甚至都搞不明白他们是怎么厚着脸皮来面试技术岗位的。济南软件行业实在是不景气，甚至找一个靠谱点的web或者php程序员都成为了公司的一大难题。</p>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>长达五年的恋情在今年终于得到了升华，当然这升华是我不愿意这么快就看到的，多么希望能迟来几年，给原本一直以为自己还是个孩子的我一个接受的缓冲区，但站在两家人面前，我的想法竟然不能主导我。我对结婚这件事情持怎么简单怎么办的态度，结婚本就一仪式，豪华也罢，没有也罢，都是过眼云烟，为一天忙碌了一阵子仅为了那一天，而之后又有谁记得。结婚之所以在中国的古代非常重视，那是因为在农业社会中人民的娱乐方式非常单一，结婚可以成为人民心中的一个盼头和没有灯光的饭后侃的资本，现在娱乐方式早已多元化，相比之下结婚的光鲜早已显得微不足道。可结婚毕竟不是我一个人的事，甚至不是两个人的事，而是两家人的事。</p>
<p>结婚定在酷夏，定下来的时间比较匆忙，从定下来要结婚到结婚仅一个月时间，对我来说是莫大的好事，因为拖得时间越长占用的准备时间就越多。半年的婚前和半年的婚后生活，其实真的没人什么两样，都是美满的二人世界，希望这种状况能持续几年。</p>
<p>我一向对车比较排斥，始终认为汽车是一个比较失败的发明，用户体验特别差。好的设计应该让用户忽略其内部实现细节，好的发明不应该让用户花费大量的时间来学习怎样使用，甚至需要多个课时的专业培训。汽车不仅是一个毫无用户体验的发明，而且危险到极致，危险到一失误就会要掉人的性命。</p>
<p>但今年我随波逐流了，毕竟驾照是早晚要考的，晚考成本只会更高。于是考驾照提上了议程，8月初已经计划报名，只可惜流程过于复杂，到现在也才到了科目二的程度。先是报名需要办暂住证，暂住证一办就是15个工作日，直接拖到了十一之后。找个离家近的驾校报个名，一等就是一个月才考科目一。科目一考完一等又是一个月才开始分车学科目二。科目二刚开始学又开始继续了，一共练了两个工作日后驾校又开始集训了，又没我啥事了。好在我找了个陪练，练了几把就顺手了。</p>
<p>虽然驾照没有考出来，仅考到了科目二，算是完成了驾照的一半，但却耗去了我的部分经历。找驾校、准备科目一、学习科目二、找陪练，这些花费的都是我的时间。要是驾校培训行业能够再成熟些，再人性化些能给多少学车的人带来方便。</p>
<p>玩游戏多少有些过了，虽然每周也就不想学习的两个晚上用来玩游戏，但我深知自己不是玩游戏的料。很多时候为了能够赢一局，会熬夜到下半夜，这是非常不理智的。另外，以后尽量用其他方式来代替游戏放松，当然我深知其中的苦难。</p>
<h1 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h1><p>去过一次云南，都在<a target="_blank" rel="noopener" href="http://www.kuring.me/post/yunan_travel">这里</a>了。</p>
<p>清明节时间去过一次天津，天津比我想象的要好很多，各个地方特色比较明显，有别墅区、意大利风情区、现代的商业区等，这之间能够非常明显的区分，不像济南太混杂。不过天津的人却给我留下的印象不是很好，这也是小小的遗憾。</p>
<h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>在我心中已经为2015年制定好了一些计划，为家庭，为自己，2015年会是我人生的一个转折点，期望2015年能够顺利。我会努力的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/Maximum_Subarray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/Maximum_Subarray/" class="post-title-link" itemprop="url">leetcode题目之Maximum Subarray</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-01-02 00:00:00" itemprop="dateCreated datePublished" datetime="2015-01-02T00:00:00+00:00">2015-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-08-31 09:27:11" itemprop="dateModified" datetime="2024-08-31T09:27:11+00:00">2024-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],<br>the contiguous subarray [4,−1,2,1] has the largest sum &#x3D; 6.</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>该题目为经典题目，存在多种解题思路。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>求动态规划的关键在于找到状态方程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 问题的关键是找到状态方式，找到状态方程后问题就迎刃而解</span></span><br><span class="line"><span class="comment"> * 状态方程如下：</span></span><br><span class="line"><span class="comment"> * b[j]表示第j处，以a[j]结尾的子序列的最大和</span></span><br><span class="line"><span class="comment"> * b[j]=max(a[j] + b[j-1], a[j])</span></span><br><span class="line"><span class="comment"> * b数据的最大值即为问题的解</span></span><br><span class="line"><span class="comment"> * 问题转换为求解b数组</span></span><br><span class="line"><span class="comment"> * 时间复杂度为O(1)，空间复杂度为(n)，空间复杂度可以降为O(1)，为了使程序易读，不做调整</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> *b = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">	b[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> max_b = b[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		b[i] = std::<span class="built_in">max</span>(A[i] + b[i<span class="number">-1</span>], A[i]);</span><br><span class="line">		<span class="keyword">if</span> (max_b &lt; b[i])</span><br><span class="line">		&#123;</span><br><span class="line">			max_b = b[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] b;</span><br><span class="line">	<span class="keyword">return</span> max_b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><p>《算法导论》的分治策略一章有关于该问题的详细解释。该题利用分治法来解决要比二分查找类最简单的分治算法要复杂。将数组一分为二后，最大数组存在三种情况：在左半或右半部分、跨越中点分别占据左部分一点和右部分一点。对于跨越中点的情况，转化为求从中点开始向左的最大值和从中点开始向右的最大值之和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> compare_array[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maxSubArray</span>(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * leetcode not support stdarg.h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> count, ...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        va_list ap;</span><br><span class="line">        <span class="built_in">va_start</span>(ap, count);</span><br><span class="line">        <span class="type">int</span> max = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = <span class="built_in">va_arg</span>(ap, <span class="type">int</span>);</span><br><span class="line">            <span class="keyword">if</span> (max &lt; temp)</span><br><span class="line">            &#123;</span><br><span class="line">                max = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">va_end</span>(ap);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_compare_array</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> max_num = compare_array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (max_num &lt; compare_array[i])</span><br><span class="line">            &#123;</span><br><span class="line">                max_num = compare_array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;begin : %d, end : %d\n&quot;, begin, end);</span></span><br><span class="line">        <span class="keyword">if</span> (begin == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> A[begin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((end - begin) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//return max(3, A[begin], A[begin] + A[end], A[end]);</span></span><br><span class="line">            compare_array[<span class="number">0</span>] = A[begin];</span><br><span class="line">            compare_array[<span class="number">1</span>] = A[begin] + A[end];</span><br><span class="line">            compare_array[<span class="number">2</span>] = A[end];</span><br><span class="line">            compare_array[<span class="number">3</span>] = INT_MIN;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max_compare_array</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 处理左边子数组</span></span><br><span class="line">        <span class="type">int</span> max_left = <span class="built_in">maxSubArray</span>(A, begin, middle);</span><br><span class="line">        <span class="comment">// 处理右边子数组</span></span><br><span class="line">        <span class="type">int</span> max_right = <span class="built_in">maxSubArray</span>(A, middle + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// 处理跨越中点的情况</span></span><br><span class="line">        <span class="type">int</span> max_cross = <span class="built_in">maxCrossMiddle</span>(A, begin, end);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;begin : %d, end : %d, max_left = %d, max_right = %d, max_cross = %d\n&quot;</span>, begin, end, max_left, max_right, max_cross);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回三者中的最大值</span></span><br><span class="line">        compare_array[<span class="number">0</span>] = max_left;</span><br><span class="line">        compare_array[<span class="number">1</span>] = max_right;</span><br><span class="line">        compare_array[<span class="number">2</span>] = max_cross;</span><br><span class="line">        compare_array[<span class="number">3</span>] = INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max_compare_array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理跨越中点的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCrossMiddle</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> A[begin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 求得[begin -- middle-1]的最大值</span></span><br><span class="line">        <span class="type">int</span> max_left = A[middle - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=middle - <span class="number">1</span>; i&gt;=begin &amp;&amp; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            <span class="keyword">if</span> (max_left &lt; sum)</span><br><span class="line">            &#123;</span><br><span class="line">                max_left = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求得[middle+1 -- end]的最大值</span></span><br><span class="line">        <span class="type">int</span> max_right = A[middle + <span class="number">1</span>];</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=middle + <span class="number">1</span>; i&lt;=end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            <span class="keyword">if</span> (max_right&lt; sum)</span><br><span class="line">            &#123;</span><br><span class="line">                max_right = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        compare_array[<span class="number">0</span>] = A[middle];</span><br><span class="line">        compare_array[<span class="number">1</span>] = A[middle] + max_left;</span><br><span class="line">        compare_array[<span class="number">2</span>] = A[middle] + max_right;</span><br><span class="line">        compare_array[<span class="number">3</span>] = A[middle] + max_left + max_right;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max_compare_array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="扫描算法"><a href="#扫描算法" class="headerlink" title="扫描算法"></a>扫描算法</h1><p>《编程珠玑》一书8.4节提到该算法，时间复杂度为O(1)，是解决该问题最好的算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> current_sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> max_sum = INT_MIN;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">if</span> (current_sum &lt;= <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		current_sum = A[i];</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">		current_sum += A[i];</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (current_sum &gt; max_sum)</span><br><span class="line">	    &#123;</span><br><span class="line">		max_sum = current_sum;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/linux_funtion_advance_feature/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/linux_funtion_advance_feature/" class="post-title-link" itemprop="url">Linux函数高级特性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2014-12-22 00:00:00" itemprop="dateCreated datePublished" datetime="2014-12-22T00:00:00+00:00">2014-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-08-31 09:27:11" itemprop="dateModified" datetime="2024-08-31T09:27:11+00:00">2024-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近在看《Linux&#x2F;Unix系统编程手册》一书，这里对书中提到的函数类型进行总结。</p>
<h1 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h1><p>POSIX标准中的解释如下：</p>
<blockquote>
<p>Reentrant Function:<br>A function whose effect, when called by two or more threads,is guaranteed to be as if the threads each executed thefunction one after another in an undefined order, even ifthe actual execution is interleaved.</p>
</blockquote>
<p>可重入函数跟信号相关，一种更容易理解的解释为：</p>
<p>程序执行到某个函数foo()时，收到信号，于是暂停目前正在执行的函数，转到信号处理函数，而这个信号处理函数的执行过程中，又恰恰也会进入到刚刚执行的函数foo()，便发生了所谓的重入。此时如果foo()能够正确的运行，而且处理完成后，之前暂停的foo()也能够正确运行，则说明它是可重入的。</p>
<p>可重入函数需要满足如下几个条件：</p>
<ul>
<li>不在函数内部使用静态或全局数据</li>
<li>不返回静态或全局数据，所有数据均有函数调用者提供</li>
<li>使用本地数据或通过复制全局数据来保护全局数据</li>
<li>不调用不可重入函数</li>
</ul>
<h1 id="标准的异步安全信号函数"><a href="#标准的异步安全信号函数" class="headerlink" title="标准的异步安全信号函数"></a>标准的异步安全信号函数</h1><p>异步信号安全的函数指当从信号处理函数调用时，可保证实现是安全的。如果某一个函数是可重入的，或者信号处理函数无法将其中断时，称该函数是异步信号安全的。</p>
<p>我的理解是可重入函数和标准的异步安全信号函数基本等同，只是描述层面不同。</p>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>若函数可同时供多个线程安全的调用，则该函数为线程安全的函数。比较容易理解。</p>
<h1 id="线程安全与可重入之间的关系"><a href="#线程安全与可重入之间的关系" class="headerlink" title="线程安全与可重入之间的关系"></a>线程安全与可重入之间的关系</h1><p>可重入函数一定为线程安全的函数。线程安全函数不一定是可重入函数。</p>
<p>不可重入函数，函数调用结果不具有可再现性，可通过互斥锁等机制供多个线程安全的调用，这样该不可重入函数即为线程安全的函数。</p>
<p>malloc函数内部维护了全局数据结构，因此为不可重入的，但是内部通过递归互斥量来确保为线程安全的函数。并且该互斥量必须是可递归的，否则当malloc函数重入的情况下，会造成死锁。在glibc中，malloc有线程安全和非线程安全两个版本，两个区别在于内部是否使用递归锁，当编译程序时使用了<code>_pthreads</code>选项时使用线程安全版本，否则使用非线程安全版本。</p>
<h1 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h1><p>Linux中的某些系统调用在阻塞的过程中，如果接受到信号并转去处理信号处理函数，当从信号处理函数返回时这些阻塞的系统调用默认会返回EINTR。为了避免信号处理函数对阻塞中的系统调用的打断，可以通过设置SA_RESTART标志的sigaction()来建立信号处理函数，从而令内核代表进程自动重启系统调用，而无需处理系统调用返回的EINTR错误。</p>
<p>并非所有的系统调用都支持自动重启，具体可参考《Linux&#x2F;Unix系统编程手册（上册）》的21.5节。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《Linux&#x2F;Unix系统编程手册（上册）》</p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/lovekatherine/article/details/1544644">对可重性和线程安全的小结</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/linux_signal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/linux_signal/" class="post-title-link" itemprop="url">Linux信号机制学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2014-12-22 00:00:00" itemprop="dateCreated datePublished" datetime="2014-12-22T00:00:00+00:00">2014-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-08-31 09:27:11" itemprop="dateModified" datetime="2024-08-31T09:27:11+00:00">2024-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[TOC]</p>
<p>信号机制在Linux编程中一直是一个难点，因为信号往往跟进程、线程、定时器、I&#x2F;O等多个层面都有牵涉，这些情况存在错综复杂的关系，堪比娱乐圈错综复杂的男女关系，要想全面理解信号机制确实不易。</p>
<h1 id="信号种类"><a href="#信号种类" class="headerlink" title="信号种类"></a>信号种类</h1><p>在Linux中可以通过如下命令来查看所有的信号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[kuring@localhost ~]$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>共64个信号，分为两种信号：非实时信号和实时信号。其中1-31个信号为非实时信号，32-64为实时信号。</p>
<p>当一信号在阻塞状态下产生多次信号，当解除该信号的阻塞后，非实时信号仅传递一次信号，而实时信号会传递多次。</p>
<p>对于非实时信号：内核会为每个信号维护一个信号掩码，并阻塞信号针对该进程的传递。如果将阻塞的信号发送给某进程，对该信号的传递将延时，直至从进程掩码中移除该信号为止。当从进程掩码中移除该信号时该信号将传递给该进程。如果信号在阻塞期间传递过多次该信号，信号解除阻塞后仅传递一次。</p>
<p>对于实时信号：实时信号采用队列化处理，一个实时信号的多个实例发送给进程，信号将会传递多次。可以制定伴随数据，用于产生信号时的数据传递。不同实时信号的传递顺序是固定的，优先传递信号编号小的。</p>
<h1 id="信号阻塞"><a href="#信号阻塞" class="headerlink" title="信号阻塞"></a>信号阻塞</h1><p>内核会为每个信号维护一个信号掩码，来阻塞内核将信号传递给该进程。如果将阻塞的信号发送给该进程，信号的传递将延后，从进程信号掩码中移除该信号后内核立刻将信号传递给该进程。如果一个信号在阻塞状态下产生多次，对于非实时信号稍后仅会传递一次，对于实时信号内核会进行排队处理，会传递多次。</p>
<h1 id="信号处理函数"><a href="#信号处理函数" class="headerlink" title="信号处理函数"></a>信号处理函数</h1><p>要想在进程中设置信号处理函数有两种选择：signal()和sigaction()。其中signal()函数提供的接口比较简单，但是在不同的UNIX系统之间存在差异，跨平台特性不是很好,signal()函数由于是C库函数，实现往往是采用sigaction()系统调用完成。sigaction()具有很好的跨平台性，但是使用较为复杂，但是却可以在信号处理程序中完成阻塞信号的作用。</p>
<p>在sigaction函数中可以指定调用信号处理函数时要阻塞的信号集，不允许这些信号中断信号处理函数的调用，直到信号处理函数调用完毕后信号才会传递。这一点通过signal函数是完不成的，利用signal函数设定的信号处理函数只能在信号处理函数开始时使用sigprocmask设置要阻塞的信号，在信号处理函数尾部利用sigprocmask还原信号，但在调用第一次调用sigprocmask函数之前和第二次调用sigprocmask函数之后的空白期内却无法防止要阻塞信号的传递。</p>
<p>信号处理函数中调用的函数尽量是异步信号安全的，C库中的函数不是异步信号安全的函数。</p>
<p>在信号处理函数中尽量避免访问全局变量，要访问全局变量可以使用<code>volatile sig_atomic_t flag</code>，volatile防止将编译器将变量优化到内存中，sig_atomic_t是一种整形数据类型，用来保证读写操作的原子性。</p>
<h1 id="系统调用的中断"><a href="#系统调用的中断" class="headerlink" title="系统调用的中断"></a>系统调用的中断</h1><p>当系统调用阻塞时，之前创建了处理函数的信号传递过来。在信号处理函数返回后，默认情况下，系统调用会失败，并将errno置为EINTR。</p>
<p>如果调用指定了SA_RESTART标志的sigaction()函数来创建信号处理器函数，内核会在信号处理函数返回后自动重启系统调用，从而避免了信号处理函数对阻塞的系统调用产生的影响。比较不幸的是，并非所有的系统调用都支持该特性。</p>
<h1 id="信号的同步生成和异步生成"><a href="#信号的同步生成和异步生成" class="headerlink" title="信号的同步生成和异步生成"></a>信号的同步生成和异步生成</h1><p>这里的同步是对信号产生方式的描述，跟具体哪个信号无关。所有的信号均可同步生成，也可异步生成。</p>
<p>异步生成：引发信号产生的事件与进程的执行无关。例如，用户输入了中断字符、子进程终止等事件，这些信号的产生该进程是无法左右的。</p>
<p>同步生成：当执行特定的机制指令产生硬件异常时或进程使用raise()、kill()等向自身发生信号时，信号是同步传递的。这些信号的产生时间该进程是可以左右的。</p>
<h1 id="信号传递的时机和顺序"><a href="#信号传递的时机和顺序" class="headerlink" title="信号传递的时机和顺序"></a>信号传递的时机和顺序</h1><p>同步产生的信号会立即传递给该进程。例如，当使用raise()函数向自身发送信号时，信号会在raise()调用前发生。</p>
<p>异步产生一个信号时，且在进程并未阻塞的情况下，信号也不会立即被传递。当且仅当进程正在执行，并且由内核态到用户态的下一次切换时才会传递信号。说人话就是在以下两种情况下会传递信号：进程获得调度时和系统调用完成时。这是因为内核会在进程在内核态和用户态进行的切换的时候才会检测信号。</p>
<p>非实时信号的传递顺序无法保障，实时信号的传递顺序是固定的，当多个不同的实时信号处于等待状态时，优先传递最小编号的信号。</p>
<h1 id="信号和线程"><a href="#信号和线程" class="headerlink" title="信号和线程"></a>信号和线程</h1><p>信号模型是基于进程模型而设计的，应尽量避免在多线程中使用信号模型。</p>
<p>信号的发送可以针对整个进程，也可以针对特定线程。</p>
<p>当进程收到一个信号后，内核会任选一个线程来接收信号，并调用信号处理函数对信号进行处理。</p>
<p>每个线程可以独立设置信号掩码。</p>
<p>如果信号处理程序中断了对pthread_mutex_lock()和pthread_cond_wait()的调用，该调用会自动重启。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>《Linux&#x2F;Unix系统编程手册》</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/linux_unp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/linux_unp/" class="post-title-link" itemprop="url">UNIX网络编程读书笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2014-12-22 00:00:00" itemprop="dateCreated datePublished" datetime="2014-12-22T00:00:00+00:00">2014-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-08-31 09:27:11" itemprop="dateModified" datetime="2024-08-31T09:27:11+00:00">2024-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>第一遍阅读unpv3后，对书中讲述的内容有了大体的认识，但对书中的具体细节地方却是早已忘记。重新阅读unpv3，这次不希望仍然是阅后即忘，于是通过编写代码的方式对书中的例子和注意事项加深理解。</p>
<p>为了能够将书中的很多细节问题理解清楚并且便于记忆，本文采用了编写书中代码并运行的方式，并将书中容易出错和意想不到的问题记在代码中。</p>
<p>本文的代码实例并未完全按照书中的代码实例，本着单个文件即能编译通过并运行的原则，本文对于很多系统调用并未做防御式编程处理。针对每个版本的程序中缺点和注意事项在代码中已经进行了标注。</p>
<p>鉴于高性能的epoll机制出现比较晚，晚于unp的编写时间，书中并未做介绍。</p>
<h1 id="TCP客户端程序"><a href="#TCP客户端程序" class="headerlink" title="TCP客户端程序"></a>TCP客户端程序</h1><p>客户端函数执行效率情况：select非阻塞式I&#x2F;O版本&gt;线程化版本&gt;fork版本&gt;select阻塞式I&#x2F;O版本&gt;停等版本，停等版本的执行效率非常低，在实际生产环境中不建议使用。</p>
<p>其中poll和select机制基本类似，书中并未给出poll版本。</p>
<h2 id="停-等版本"><a href="#停-等版本" class="headerlink" title="停-等版本"></a>停-等版本</h2><p>最常规的实现思路，但效率非常低，且当程序阻塞在读取要发送内容时，程序是无法收到服务端的状态变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 停-等版本</span></span><br><span class="line"><span class="comment"> * 该版本缺陷为当服务端发生某些事件时，客户端可能仍然阻塞于fgets调用中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line">	<span class="keyword">while</span> (fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 当阻塞在fgets函数时将服务器进程关闭时虽然给客户端发送了FIN信号，客户端并不会知道，</span></span><br><span class="line"><span class="comment">		 * 服务端关闭时第一次调用write服务器会返回RST，</span></span><br><span class="line"><span class="comment">		 * 当一个进程向某个收到RST的套接字执行写操作时，内核会向该进程发送一个SIGPIPE信号</span></span><br><span class="line"><span class="comment">		 * 该问题需要使用I/O复用技术来解决，或者使用fork处理的方式来解决</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		write(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">		<span class="type">int</span> n = read(sockfd, recvline, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;str_cli: server terminated prematurely\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 向标准输出写内容，既可以使用write也可以使用fputs</span></span><br><span class="line">		write(STDOUT_FILENO, recvline, n);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用fputs时需要注意将recvline数组有效内容的后面一位设置为&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">//		recvline[n] = &#x27;\0&#x27;;</span></span><br><span class="line"><span class="comment">//		fputs(recvline, stdout);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sockfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>	<span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: tcpcli &lt;IPaddress&gt;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当一个进程向某个收到RST的套接字执行写操作时，内核会向该进程发送一个SIGPIPE信号</span></span><br><span class="line">	<span class="comment">// 最好的方式是忽略此信号的处理方式，并在程序下面处理该异常情况</span></span><br><span class="line">	signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">	connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">	str_cli(<span class="built_in">stdin</span>, sockfd);		<span class="comment">/* do it all */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fork版本"><a href="#fork版本" class="headerlink" title="fork版本"></a>fork版本</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞式I/O的fork版本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 即使服务端已经退出，子进程的read方法仍然能够感知到并且退出while循环，并给父进程发送SIGTERM,父进程对该信号的默认处理方式为退出</span></span><br><span class="line"><span class="comment"> * 优点：代码量比较少，每个进程只处理2个I/O流，从一个复制到另一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// child process : server -&gt; stdout</span></span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="keyword">while</span> ((n = read(sockfd, recvline, MAXLINE)) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			recvline[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		kill(getppid(), SIGTERM);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// parent process : stdin -&gt; server</span></span><br><span class="line">	<span class="keyword">while</span> (fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		write(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">	&#125;</span><br><span class="line">	shutdown(sockfd, SHUT_WR);</span><br><span class="line">	pause();</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sockfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>	<span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: tcpcli &lt;IPaddress&gt;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当一个进程向某个收到RST的套接字执行写操作时，内核会向该进程发送一个SIGPIPE信号</span></span><br><span class="line">	<span class="comment">// 最好的方式是忽略此信号的处理方式，并在程序下面处理该异常情况</span></span><br><span class="line">	signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connect error...\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	str_cli(<span class="built_in">stdin</span>, sockfd);		<span class="comment">/* do it all */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阻塞式I-x2F-O的select版本"><a href="#阻塞式I-x2F-O的select版本" class="headerlink" title="阻塞式I&#x2F;O的select版本"></a>阻塞式I&#x2F;O的select版本</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞式I/O的select版本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缺点：使用了阻塞式I/O，如果在向套接字调用write发送给服务器时，套接字缓冲区已满，write调用会阻塞，从而影响了后续的套接字缓冲区的读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> maxfdp1;</span><br><span class="line">	fd_set rset;</span><br><span class="line">	<span class="type">char</span> sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line">	<span class="type">int</span> stdineof = <span class="number">0</span>;</span><br><span class="line">	FD_ZERO(&amp;rset);</span><br><span class="line">	<span class="keyword">for</span> (; ;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// select</span></span><br><span class="line">		FD_SET(fileno(fp), &amp;rset);</span><br><span class="line">		FD_SET(sockfd, &amp;rset);</span><br><span class="line">		maxfdp1 = (fileno(fp) &gt; sockfd ? fileno(fp) : sockfd) + <span class="number">1</span>;</span><br><span class="line">		select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// socket</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> n = read(sockfd, recvline, MAXLINE);</span><br><span class="line">			<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (stdineof == <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;str_cli: server terminated prematurely\n&quot;</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			recvline[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="comment">//			write(STDOUT_FILENO, recvline, n);</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// input</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 此处不能使用fgets函数，该函数带有缓冲区功能，select跟带有缓冲区的c函数混合使用有问题</span></span><br><span class="line"><span class="comment">//			if (fgets(sendline, MAXLINE, fp) == NULL)</span></span><br><span class="line"><span class="comment">//			&#123;</span></span><br><span class="line"><span class="comment">//				return ;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line">			<span class="type">int</span> n = read(fileno(fp), sendline, MAXLINE);</span><br><span class="line">			<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				stdineof = <span class="number">1</span>;</span><br><span class="line">				shutdown(sockfd, SHUT_WR);	<span class="comment">// 关闭写</span></span><br><span class="line">				FD_CLR(fileno(fp), &amp;rset);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			write(sockfd, sendline, n);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sockfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>	<span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: tcpcli &lt;IPaddress&gt;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connect error...\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	str_cli(<span class="built_in">stdin</span>, sockfd);		<span class="comment">/* do it all */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非阻塞式I-x2F-O的select版本"><a href="#非阻塞式I-x2F-O的select版本" class="headerlink" title="非阻塞式I&#x2F;O的select版本"></a>非阻塞式I&#x2F;O的select版本</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非阻塞式I/O的select版本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) ( ((a)&gt;(b)) ? (a):(b) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优点：速度是最快的，可以防止进程在做任何工作时发生阻塞</span></span><br><span class="line"><span class="comment"> * 缺点：同时管理4个不同的I/O流，每个流都是非阻塞的，需要考虑到4个流的部分读和部分写问题。编码量是最多的，需要引入缓冲区管理机制。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 将socket、标准输入和标准输出描述符设置为非阻塞方式</span></span><br><span class="line">	<span class="type">int</span> val = fcntl(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">	fcntl(sockfd, F_SETFL, val | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">	val = fcntl(STDIN_FILENO, F_GETFL, <span class="number">0</span>);</span><br><span class="line">	fcntl(STDIN_FILENO, F_SETFL, val | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">	val = fcntl(STDOUT_FILENO, F_GETFL, <span class="number">0</span>);</span><br><span class="line">	fcntl(STDOUT_FILENO, F_SETFL, val | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> to[MAXLINE], fr[MAXLINE];</span><br><span class="line">	<span class="type">char</span> *toiptr, *tooptr, *friptr, *froptr;</span><br><span class="line">	toiptr = tooptr = to;</span><br><span class="line">	friptr = froptr = fr;</span><br><span class="line">	<span class="type">int</span> stdineof = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> maxfdp1 = max(max(STDIN_FILENO, STDOUT_FILENO), sockfd) + <span class="number">1</span>;</span><br><span class="line">	fd_set rset, wset;</span><br><span class="line">	<span class="keyword">for</span> (; ;)</span><br><span class="line">	&#123;</span><br><span class="line">		FD_ZERO(&amp;rset);</span><br><span class="line">		FD_ZERO(&amp;wset);</span><br><span class="line">		<span class="keyword">if</span> (stdineof == <span class="number">0</span> &amp;&amp; toiptr &lt; &amp;to[MAXLINE])</span><br><span class="line">		&#123;</span><br><span class="line">			FD_SET(STDIN_FILENO, &amp;rset);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (friptr &lt; &amp;fr[MAXLINE])</span><br><span class="line">		&#123;</span><br><span class="line">			FD_SET(sockfd, &amp;rset);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tooptr != toiptr)</span><br><span class="line">		&#123;</span><br><span class="line">			FD_SET(sockfd, &amp;wset);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (froptr != friptr)</span><br><span class="line">		&#123;</span><br><span class="line">			FD_SET(STDOUT_FILENO, &amp;wset);</span><br><span class="line">		&#125;</span><br><span class="line">		select(maxfdp1, &amp;rset, &amp;wset, <span class="literal">NULL</span>, <span class="literal">NULL</span>);	<span class="comment">// select函数仍然是阻塞的</span></span><br><span class="line">		<span class="comment">// 标准输入</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;rset))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> n;</span><br><span class="line">			<span class="keyword">if</span> ((n = read(STDIN_FILENO, toiptr, &amp;to[MAXLINE] - toiptr)) &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 对于非阻塞式IO，如果操作不能满足，相应系统调用会返回EWOULDBLOCK错误</span></span><br><span class="line">				<span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;read error on stdin\n&quot;</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;EOF on stdin\n&quot;</span>);</span><br><span class="line">				stdineof = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (tooptr == toiptr)</span><br><span class="line">				&#123;</span><br><span class="line">					shutdown(sockfd, SHUT_WR);	<span class="comment">// 缓冲区中没有数据要发送，关闭socket</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read %d bytes from stdin\n&quot;</span>, n);</span><br><span class="line">				toiptr += n;</span><br><span class="line">				FD_SET(sockfd, &amp;wset);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从套接字读</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> n;</span><br><span class="line">			<span class="keyword">if</span> ((n = read(sockfd, friptr, &amp;fr[MAXLINE] - friptr)) &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;read error on socket\n&quot;</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;EOF on socket\n&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (stdineof)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;server terminated prematurely\n&quot;</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read %d bytes from socket\n&quot;</span>, n);</span><br><span class="line">				friptr += n;</span><br><span class="line">				FD_SET(STDOUT_FILENO, &amp;wset);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 标准输出</span></span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(STDOUT_FILENO, &amp;wset) &amp;&amp; ((n = friptr - froptr) &gt; <span class="number">0</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> nwritten;</span><br><span class="line">			<span class="keyword">if</span> ((nwritten = write(STDOUT_FILENO, froptr, n)) &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;write error to stdout\n&quot;</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;wrote %d bytes to stdout\n&quot;</span>, nwritten);</span><br><span class="line">				froptr += nwritten;</span><br><span class="line">				<span class="keyword">if</span> (froptr == friptr)</span><br><span class="line">				&#123;</span><br><span class="line">					froptr = friptr = fr;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 向socket写</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(sockfd, &amp;wset) &amp;&amp; ((n = toiptr - tooptr)) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> nwritten;</span><br><span class="line">			<span class="keyword">if</span> ((nwritten = write(sockfd, tooptr, n)) &lt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;write error to socket\n&quot;</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;wrote %d bytes to socket\n&quot;</span>, nwritten);</span><br><span class="line">				tooptr += nwritten;</span><br><span class="line">				<span class="keyword">if</span> (tooptr == toiptr)</span><br><span class="line">				&#123;</span><br><span class="line">					toiptr = tooptr = to;</span><br><span class="line">					<span class="keyword">if</span> (stdineof)</span><br><span class="line">					&#123;</span><br><span class="line">						shutdown(sockfd, SHUT_WR);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * connect的非阻塞版本</span></span><br><span class="line"><span class="comment"> * 连接建立成功时，描述符变为可写；连接建立错误时，描述符变为即可读又可写</span></span><br><span class="line"><span class="comment"> * 优点：</span></span><br><span class="line"><span class="comment"> * 1、阻塞式的connect调用会消耗CPU时间，非阻塞式connect可以充分利用CPU时间，在等待的过程中可以处理其他工作</span></span><br><span class="line"><span class="comment"> * 2、可以同时建立多个连接，浏览器中会用到此技术</span></span><br><span class="line"><span class="comment"> * 3、阻塞式connect的函数超时过长，可以通过该函数设置超时时间</span></span><br><span class="line"><span class="comment"> * 4、阻塞式的套接字调用connect时，在TCP的三次握手完成之前被某些信号中断时并且connect未设置内核自动重启的标志时，connect将返回EINTR错误</span></span><br><span class="line"><span class="comment"> * 当再次调用connect等待未完成的连接时将会返回EADDRINUSE错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect_nonb</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *saptr, <span class="type">socklen_t</span> salen, <span class="type">int</span> nsec)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 将套接字设置为非阻塞状态</span></span><br><span class="line">	<span class="type">int</span> flags = fcntl(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">	fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">if</span> ((n = connect(sockfd, saptr, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 连接未成功建立，正常情况下返回EINPROGRESS错误，表示操作正在处理</span></span><br><span class="line">		<span class="keyword">if</span> (errno != EINPROGRESS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// EINPROGRESS表示连接建立已经启动，但是尚未完成</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 当服务器和客户端在一台主机上时会立即建立连接</span></span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当代码执行到如下过程中时，connect正在建立连接，可以在此位置执行业务相关代码</span></span><br><span class="line">	<span class="comment">// 当然真正使用时，在此位置加入其他代码并不合适，需要根据具体情况重新调整代码</span></span><br><span class="line">	<span class="comment">// 可以参照书中的web客户程序例子</span></span><br><span class="line"></span><br><span class="line">	fd_set rset, wset;</span><br><span class="line">	FD_ZERO(&amp;rset);</span><br><span class="line">	FD_SET(sockfd, &amp;rset);</span><br><span class="line">	wset = rset;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tval</span>;</span></span><br><span class="line">	tval.tv_sec = nsec;</span><br><span class="line">	tval.tv_usec = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> ((n = select(sockfd + <span class="number">1</span>, &amp;rset, &amp;wset, <span class="literal">NULL</span>, nsec ? &amp;tval : <span class="literal">NULL</span>)) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 发生超时</span></span><br><span class="line">		close(sockfd);</span><br><span class="line">		errno = ETIMEDOUT;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当连接建立成功时sockfd变为可写，当连接建立失败时sockfd变为即可读又可写</span></span><br><span class="line">	<span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset) || FD_ISSET(sockfd, &amp;wset))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> len = <span class="keyword">sizeof</span>(error);</span><br><span class="line">		<span class="comment">// 非可移植性函数，连接建立成功返回0，连接建立失败将错误值返回给error</span></span><br><span class="line">		<span class="comment">// 连接建立失败时，有返回-1和返回0的情况</span></span><br><span class="line">		<span class="keyword">if</span> (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// solaris连接建立失败返回-1</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;select error:sockfd not set&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">done:</span><br><span class="line">	<span class="comment">// 恢复套接字的文件状态标志</span></span><br><span class="line">	fcntl(sockfd, F_SETFL, flags);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">	&#123;</span><br><span class="line">		close(sockfd);</span><br><span class="line">		errno = error;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sockfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>	<span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: tcpcli &lt;IPaddress&gt;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当一个进程向某个收到RST的套接字执行写操作时，内核会向该进程发送一个SIGPIPE信号</span></span><br><span class="line">	<span class="comment">// 最好的方式是忽略此信号的处理方式，并在程序下面处理该异常情况</span></span><br><span class="line">	signal(SIGPIPE, SIG_IGN);</span><br><span class="line"></span><br><span class="line">	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//connect(sockfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr));</span></span><br><span class="line">	<span class="keyword">if</span> (connect_nonb(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr), <span class="number">50</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;socket connect error\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	str_cli(<span class="built_in">stdin</span>, sockfd);		<span class="comment">/* do it all */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TCP服务端程序"><a href="#TCP服务端程序" class="headerlink" title="TCP服务端程序"></a>TCP服务端程序</h1><p>服务器程序要处理大量并发，在设计时更要注重效率。</p>
<h2 id="fork版本-1"><a href="#fork版本-1" class="headerlink" title="fork版本"></a>fork版本</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * fork版本</span></span><br><span class="line"><span class="comment"> * PPC(Process per Connection)模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE		4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_chld</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (signo != SIGIO)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> stat;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 此处不可以使用wait函数，当多个SIGCHLD信号同时发出时会因为信号覆盖而出现僵尸进程的情况</span></span><br><span class="line"><span class="comment">	pid_t pid = wait(&amp;stat);</span></span><br><span class="line"><span class="comment">	printf(&quot;child %d terminated\n&quot;, pid);	// 非异步信号安全函数，此处不应该调用</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用非阻塞的参数WNOHANG来循环处理信号，避免信号丢失问题 */</span></span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child %d terminated\n&quot;</span>, pid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_echo</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span>	n;</span><br><span class="line">	<span class="type">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">while</span> ( (n = read(sockfd, buf, MAXLINE)) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		write(sockfd, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">		<span class="keyword">goto</span> again;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str_echo: read error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * fork版本</span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * 		1.fork需要将父进程的内存映像复制到子进程，并在子进程中复制所有的描述符，尽管现在的操作系统已经都实现了写时复制技术，但是耗时仍然比较多</span></span><br><span class="line"><span class="comment"> * 		2.父进程和子进程之间需要IPC机制进行通信，从子进程返回信息到父进程比较麻烦</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	signal(SIGCHLD, sig_chld);</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd,  (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen</span></span><br><span class="line">    <span class="comment">// 套接字排队的最大连接数为20</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">20</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">socklen_t</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    	<span class="comment">// 处理accept被信号中断时返回EINTR错误</span></span><br><span class="line">		<span class="keyword">if</span> ((connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* child process */</span></span><br><span class="line">			close(listenfd); <span class="comment">/* close listening socket */</span></span><br><span class="line">			str_echo(connfd); <span class="comment">/* process the request */</span></span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		close(connfd); <span class="comment">/* parent closes connected socket */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="select版本"><a href="#select版本" class="headerlink" title="select版本"></a>select版本</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * select版本</span></span><br><span class="line"><span class="comment"> * 缺点：</span></span><br><span class="line"><span class="comment"> * 		1. 有最大并发数限制，一个进程最多打开FD_SETSIZE个文件描述符，FD_SETSIZE往往是1024或2048字节</span></span><br><span class="line"><span class="comment"> * 		2. select每次调用都会线性扫描全部的FD集合，这样效率就会呈现线性下降，把FD_SETSIZE改大的后果就是所有FD处理都慢慢来</span></span><br><span class="line"><span class="comment"> * 		3. 内核/用户空间内存拷贝问题，内核把FD消息通知给用户空间采取了内存拷贝方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE		4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用select的需要维护client数组和allset的描述符集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish socket...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd,  (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish bind...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen</span></span><br><span class="line">    <span class="comment">// 套接字排队的最大连接数为20</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">20</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish listening...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxfd = listenfd;</span><br><span class="line">    <span class="type">int</span> maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> client[FD_SETSIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;FD_SETSIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	client[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fd_set allset;</span><br><span class="line">    FD_ZERO(&amp;allset);</span><br><span class="line">    FD_SET(listenfd, &amp;allset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">    	fd_set rset = allset;</span><br><span class="line">    	<span class="type">int</span> nready = select(maxfd + <span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    	<span class="keyword">if</span> (FD_ISSET(listenfd, &amp;rset))</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="comment">// 设置client数组</span></span><br><span class="line">    		<span class="type">socklen_t</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    		<span class="comment">// 调用select时有个问题，见书中16.6节</span></span><br><span class="line">    		<span class="comment">// 如果调用accept时客户端已经关闭连接，此时accept会阻塞并直到新的客户端连接到来</span></span><br><span class="line">    		<span class="comment">// 为了解决该问题可以将套接字设置为非阻塞再调用accept</span></span><br><span class="line">			<span class="type">int</span> connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;accept one client:%d...\n&quot;</span>, connfd);</span><br><span class="line">			<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (; i&lt;FD_SETSIZE; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					client[i] = connfd;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			FD_SET(connfd, &amp;allset);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i == FD_SETSIZE)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (connfd &gt; maxfd)</span><br><span class="line">			&#123;</span><br><span class="line">				maxfd = connfd;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">			&#123;</span><br><span class="line">				maxi = i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 检测所有客户端的数据</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=maxi; i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span> (client[i] &lt; <span class="number">0</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">continue</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span> (FD_ISSET(client[i], &amp;rset))</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="type">int</span> n;</span><br><span class="line">    			<span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    			<span class="built_in">printf</span>(<span class="string">&quot;start reading form one client...\n&quot;</span>);</span><br><span class="line">    			<span class="keyword">if</span> ((n = read(client[i], buf, MAXLINE)) == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">    				close(client[i]);</span><br><span class="line">    				FD_CLR(client[i], &amp;allset);</span><br><span class="line">    				client[i] = <span class="number">-1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">    			<span class="keyword">else</span></span><br><span class="line">    			&#123;</span><br><span class="line">    				write(client[i], buf, n);</span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">    			&#123;</span><br><span class="line">    				<span class="keyword">break</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="poll版本"><a href="#poll版本" class="headerlink" title="poll版本"></a>poll版本</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * poll版本</span></span><br><span class="line"><span class="comment"> * poll版本的解决了select文件描述符限制问题，但是仍然具备select的缺点中的2和3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stropts.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE		4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_MAX 1024  <span class="comment">// 该宏已经从limit.h中移除，用来表示一个进程可以打开的最大描述符数目</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用select的缺点为需要维护client数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish socket...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd,  (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish bind...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen</span></span><br><span class="line">    <span class="comment">// 套接字排队的最大连接数为20</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">20</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish listening...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[<span class="title">OPEN_MAX</span>];</span></span><br><span class="line">    client[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">    client[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;OPEN_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	client[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxi = <span class="number">0</span>;	<span class="comment">// 当前client正在使用的最大下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">int</span> nready = poll(client, maxi + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    	<span class="keyword">if</span> (client[<span class="number">0</span>].revents &amp; POLLIN)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="comment">// 设置client数组</span></span><br><span class="line">    		<span class="type">socklen_t</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">			<span class="type">int</span> connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;accept one client:%d...\n&quot;</span>, connfd);</span><br><span class="line">			<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (; i&lt;OPEN_MAX; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					client[i].fd = connfd;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i == OPEN_MAX)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;too many clients&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			client[i].events = POLLIN;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; maxi)</span><br><span class="line">			&#123;</span><br><span class="line">				maxi = i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 检测所有客户端的数据</span></span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=maxi; i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span> (client[i].fd &lt; <span class="number">0</span>)</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">continue</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">if</span> (client[i].revents &amp; (POLLIN | POLLERR))</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="type">int</span> n;</span><br><span class="line">    			<span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    			<span class="built_in">printf</span>(<span class="string">&quot;start reading form one client...\n&quot;</span>);</span><br><span class="line">    			<span class="keyword">if</span> ((n = read(client[i].fd, buf, MAXLINE)) &lt; <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">    				<span class="keyword">if</span> (errno == ECONNRESET)</span><br><span class="line">    				&#123;</span><br><span class="line">    					close(client[i].fd);</span><br><span class="line">    					client[i].fd = <span class="number">-1</span>;</span><br><span class="line">    				&#125;</span><br><span class="line">    				<span class="keyword">else</span></span><br><span class="line">    				&#123;</span><br><span class="line">    					<span class="built_in">printf</span>(<span class="string">&quot;read client error\n&quot;</span>);</span><br><span class="line">    					<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    				&#125;</span><br><span class="line">				&#125;</span><br><span class="line">    			<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    			&#123;</span><br><span class="line">    				<span class="built_in">printf</span>(<span class="string">&quot;client %d close\n&quot;</span>, client[i].fd);</span><br><span class="line">    				close(client[i].fd);</span><br><span class="line">    				client[i].fd = <span class="number">-1</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">else</span></span><br><span class="line">    			&#123;</span><br><span class="line">    				write(client[i].fd, buf, n);</span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">if</span> (--nready &lt;= <span class="number">0</span>)</span><br><span class="line">    			&#123;</span><br><span class="line">    				<span class="keyword">break</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多线程版本"><a href="#多线程版本" class="headerlink" title="多线程版本"></a>多线程版本</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程版本</span></span><br><span class="line"><span class="comment"> * TPC(Thread Per Connection)模型</span></span><br><span class="line"><span class="comment"> * 线程的开销虽然比进程小，但是仍然有比较大开销，因此并发数不是很高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE		4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">str_echo</span><span class="params">(<span class="type">int</span> sockfd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span>	n;</span><br><span class="line">	<span class="type">char</span> buf[MAXLINE];</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">while</span> ( (n = read(sockfd, buf, MAXLINE)) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		write(sockfd, buf, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">		<span class="keyword">goto</span> again;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str_echo: read error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">doit</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_detach(pthread_self());</span><br><span class="line">	str_echo((<span class="type">int</span>)arg);</span><br><span class="line">	close((<span class="type">int</span>)arg);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;close socket...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> listenfd, connfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket</span></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (listenfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind</span></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    <span class="keyword">if</span> (bind(listenfd,  (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen</span></span><br><span class="line">    <span class="comment">// 套接字排队的最大连接数为20</span></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, <span class="number">20</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">socklen_t</span> clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    	<span class="comment">// 处理accept被信号中断时返回EINTR错误</span></span><br><span class="line">		<span class="keyword">if</span> ((connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;receive new client...\n&quot;</span>);</span><br><span class="line">		<span class="type">pthread_t</span> tid;</span><br><span class="line">		pthread_create(&amp;tid, <span class="literal">NULL</span>, &amp;doit, (<span class="type">void</span> *)connfd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>由于udp比较简单，书中并未将udp协议当做重点来讲解。</p>
<h2 id="UDP客户端程序"><a href="#UDP客户端程序" class="headerlink" title="UDP客户端程序"></a>UDP客户端程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE		4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sendto、recvfrom方式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dg_cli</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *pservaddr, <span class="type">socklen_t</span> servlen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> sendline[MAXLINE], recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">preply_addr</span> =</span> (<span class="keyword">struct</span> sockaddr *)<span class="built_in">malloc</span>(servlen);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sendto(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>, pservaddr, servlen);</span><br><span class="line">		<span class="type">int</span> len = servlen;</span><br><span class="line">		<span class="type">int</span> n = recvfrom(sockfd, recvline, MAXLINE, <span class="number">0</span>, preply_addr, &amp;len);</span><br><span class="line">		<span class="comment">// 为了防止接收到其他进程的数据，通过条件判断去除</span></span><br><span class="line">		<span class="keyword">if</span> (len != servlen || <span class="built_in">memcmp</span>(pservaddr, preply_addr, len) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;reply from others (!ignore)\n&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		recvline[n] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connect、write、read方式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dg_cli2</span><span class="params">(FILE *fp, <span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *pservaddr, <span class="type">socklen_t</span> servlen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> sendline[MAXLINE], recvline[MAXLINE + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	connect(sockfd, (<span class="keyword">struct</span> sockaddr *)pservaddr, servlen);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (fgets(sendline, MAXLINE, fp) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		write(sockfd, sendline, <span class="built_in">strlen</span>(sendline));</span><br><span class="line">		<span class="type">int</span> n = read(sockfd, recvline, MAXLINE);</span><br><span class="line">		recvline[n] = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fputs</span>(recvline, <span class="built_in">stdout</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: tcpcli &lt;IPaddress&gt;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	dg_cli2(<span class="built_in">stdin</span>, sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP服务端程序"><a href="#UDP服务端程序" class="headerlink" title="UDP服务端程序"></a>UDP服务端程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE		4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dg_echo</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *pcliaddr, <span class="type">socklen_t</span> clilen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> mesg[MAXLINE];</span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">socklen_t</span> len = clilen;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		bzero(mesg, MAXLINE);</span><br><span class="line">		<span class="keyword">if</span> ((n = recvfrom(sockfd, mesg, MAXLINE, <span class="number">0</span>,  pcliaddr, &amp;len)) &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			close(sockfd);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;recvfrom error, error=%m\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;recv %s\n&quot;</span>, mesg);</span><br><span class="line">		sendto(sockfd, mesg, n, <span class="number">0</span>, pcliaddr, len);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	<span class="keyword">if</span> (bind(sockfd,  (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dg_echo(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP服务端信号驱动式I-x2F-O版本"><a href="#UDP服务端信号驱动式I-x2F-O版本" class="headerlink" title="UDP服务端信号驱动式I&#x2F;O版本"></a>UDP服务端信号驱动式I&#x2F;O版本</h2><p>信号驱动式I&#x2F;O：进程执行I&#x2F;O系统调用告知内核启动某个I&#x2F;O操作，内核启动I&#x2F;O操作后立即返回到进程。进程在I&#x2F;O操作发生期间继续执行。当操作完成或遇到错误时，内核以进程在I&#x2F;O系统调用中指定的方式通知进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信号驱动式I/O在TCP套接字用途不大，该信号产生的过于频繁，它的出现并未指示发生的事情</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 9877</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE		4096	<span class="comment">/* max text line length */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXDG 4096</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">void</span> *dg_data;				<span class="comment">// 实际数据</span></span><br><span class="line">	<span class="type">size_t</span> dg_len;				<span class="comment">// 实际数据长度</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">dg_sa</span>;</span>		<span class="comment">// 包含客户端地址</span></span><br><span class="line">	<span class="type">socklen_t</span> dg_salen;			<span class="comment">// 客户端地址长度</span></span><br><span class="line">&#125; DG;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QSIZE 8</span></span><br><span class="line"><span class="type">static</span> DG dg[QSIZE];			<span class="comment">// 存放数据的环形缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> cntread[QSIZE + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 需要处理的下一个数据元素的下标</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> iget;</span><br><span class="line"><span class="comment">// 存放数据元素的下一个位置</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> iput;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> nqueue;				<span class="comment">// 队列中的数据个数</span></span><br><span class="line"><span class="type">static</span> <span class="type">socklen_t</span> clilen;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_hup</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt;= QSIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;cntread[%d = %ld\n&quot;</span>, i, cntread[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_io</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> nread;</span><br><span class="line">	<span class="comment">// 为了解决非实时信号不排队问题，采用循环读取方式</span></span><br><span class="line">	<span class="keyword">for</span> (nread = <span class="number">0</span>; ; )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 检查队列是否已满</span></span><br><span class="line">		<span class="keyword">if</span> (nread &gt;= QSIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;receive overflow\n&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		DG *ptr = &amp;dg[iput];</span><br><span class="line">		ptr-&gt;dg_salen = clilen;</span><br><span class="line">		<span class="type">ssize_t</span> len = recvfrom(sockfd, ptr-&gt;dg_data, MAXDG, <span class="number">0</span>, ptr-&gt;dg_sa, &amp;ptr-&gt;dg_salen);</span><br><span class="line">		<span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EWOULDBLOCK)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;recvfrom error\n&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ptr-&gt;dg_len = len;</span><br><span class="line">		nread++;</span><br><span class="line">		nqueue++;</span><br><span class="line">		<span class="keyword">if</span> (++iput &gt;= QSIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			iput = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cntread[nread]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dg_echo</span><span class="params">(<span class="type">int</span> sockfd_arg, <span class="keyword">struct</span> sockaddr *pcliaddr, <span class="type">socklen_t</span> clilen_arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	sockfd = sockfd_arg;</span><br><span class="line">	clilen = clilen_arg;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i&lt;QSIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dg[i].dg_data = <span class="built_in">malloc</span>(MAXDG);</span><br><span class="line">		dg[i].dg_sa = (<span class="keyword">struct</span> sockaddr *)<span class="built_in">malloc</span>(clilen);</span><br><span class="line">		dg[i].dg_salen = clilen;</span><br><span class="line">	&#125;</span><br><span class="line">	iget = iput = nqueue = <span class="number">0</span>;</span><br><span class="line">	signal(SIGHUP, sig_hup);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在启动信号I/O前设置信号处理函数</span></span><br><span class="line">	signal(SIGIO, sig_io);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置接收信号通知的进程，让本进程接收SIGIO信号</span></span><br><span class="line">	fcntl(sockfd, F_SETOWN, getpid());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了能够在得到I/O事件后重复执行I/O操作，需要将文件描述符设置为非阻塞方式</span></span><br><span class="line">	<span class="comment">// O_ASYNC表示在文件描述符上使用信号驱动I/O</span></span><br><span class="line">	<span class="type">int</span> flags = fcntl(sockfd, F_GETFL);</span><br><span class="line">	fcntl(sockfd, F_SETFL, flags | O_ASYNC | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">	<span class="type">sigset_t</span> zeromask, newmask, oldmask;</span><br><span class="line">	sigemptyset(&amp;zeromask);</span><br><span class="line">	sigemptyset(&amp;newmask);</span><br><span class="line">	sigemptyset(&amp;oldmask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置新的信号掩码，阻塞SIGIO信号</span></span><br><span class="line">	sigaddset(&amp;newmask, SIGIO);</span><br><span class="line">	sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);</span><br><span class="line">	<span class="keyword">for</span> (; ;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (nqueue == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 挂起进程直到收到任何信号，该函数返回后SIGIO继续被阻塞</span></span><br><span class="line">			sigsuspend(&amp;zeromask);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 解除SIGIO的阻塞</span></span><br><span class="line">		sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">		sendto(sockfd, dg[iget].dg_data, dg[iget].dg_len, <span class="number">0</span>, dg[iget].dg_sa, dg[iget].dg_salen);</span><br><span class="line">		<span class="keyword">if</span> (++iget &gt;= QSIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			iget = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 为了能够修改nqueue的值，阻塞SIGIO信号</span></span><br><span class="line">		sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);</span><br><span class="line">		nqueue--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">	bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">	servaddr.sin_family = AF_INET;</span><br><span class="line">	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">	servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">	<span class="keyword">if</span> (bind(sockfd,  (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dg_echo(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p>本文中的实例，代码采用eclipse CDT编写，可以直接导入eclipse中运行。</p>
<p><a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1o6zCNOm">下载实例</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/python_parse_web/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/python_parse_web/" class="post-title-link" itemprop="url">通过python来抓取和解析网页内容</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2014-12-14 00:00:00" itemprop="dateCreated datePublished" datetime="2014-12-14T00:00:00+00:00">2014-12-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-08-31 09:27:11" itemprop="dateModified" datetime="2024-08-31T09:27:11+00:00">2024-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近这段时间回顾了下python，距离上次使用python已经超过两年的时间了。</p>
<p>相对于c++语言，python要灵活许多，对于工作中的一些小问题的解决可以通过python来实现比较高效和方便，比如网页的抓取和解析。甚至对于非IT的工作，也可以通过脚本的方式来解决，只要是工作中遇到反复处理的体力活劳动就可以考虑利用编程方式来解决。</p>
<p>本文以我的博客的<a href="http://kuring.me/archive">文档列表页面</a>为例，利用python对页面中的文章名进行提取。</p>
<p>文章列表页中的文章列表部分的url如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;listing&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;listing-item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;date&quot;</span>&gt;</span>2014-12-03<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/post/linux_funtion_advance_feature&quot;</span>  <span class="attr">title</span>=<span class="string">&quot;Linux函数高级特性&quot;</span> &gt;</span>Linux函数高级特性<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;listing-item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;date&quot;</span>&gt;</span>2014-12-02<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/post/cgdb&quot;</span>  <span class="attr">title</span>=<span class="string">&quot;cgdb的使用&quot;</span> &gt;</span>cgdb的使用<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="requests模块的安装"><a href="#requests模块的安装" class="headerlink" title="requests模块的安装"></a>requests模块的安装</h1><p>requests模块用于加载要请求的web页面。</p>
<p>在python的命令行中输入<code>import requests</code>，报错说明requests模块没有安装。</p>
<p>我这里打算采用easy_install的在线安装方式安装，发现系统中并不存在easy_install命令，输入<code>sudo apt-get install python-setuptools</code>来安装easy_install工具。</p>
<p>执行<code>sudo easy_install requests</code>安装requests模块。</p>
<h1 id="Beautiful-Soup安装"><a href="#Beautiful-Soup安装" class="headerlink" title="Beautiful Soup安装"></a>Beautiful Soup安装</h1><p>为了能够对页面中的内容进行解析，本文使用Beautiful Soup。当然，本文的例子需求较简单，完全可以使用分析字符串的方式。</p>
<p>执行<code>sudo easy_install beautifulsoup4</code>即可安装。</p>
<h1 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h1><p>python的编码问题确实是一个很头大的问题，尤其是对于不熟悉python的菜鸟。</p>
<p>python自身的编码问题就已经够头大的了，碰巧requests模块也有一个编码问题的bug，具体的bug见参考文章。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python                                                                                                                                                           </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; a http parse test programe &#x27;</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&#x27;kuring lv&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line">archives_url = <span class="string">&quot;http://kuring.me/archive&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start_parse</span>(<span class="params">url</span>) :</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;开始获取(%s)内容&quot;</span> % url</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;获取网页内容完毕&quot;</span></span><br><span class="line">    </span><br><span class="line">    soup = bs4.BeautifulSoup(response.content.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="comment">#soup = bs4.BeautifulSoup(response.text);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 为了防止漏掉调用close方法，这里使用了with语句</span></span><br><span class="line">    <span class="comment"># 写入到文件中的编码为utf-8</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;archives.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f :</span><br><span class="line">        <span class="keyword">for</span> archive <span class="keyword">in</span> soup.select(<span class="string">&quot;li.listing-item a&quot;</span>) :</span><br><span class="line">            f.write(archive.get_text().encode(<span class="string">&#x27;utf-8&#x27;</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span> archive.get_text().encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当命令行运行该模块时，__name__等于&#x27;__main__&#x27;</span></span><br><span class="line"><span class="comment"># 其他模块导入该模块时，__name__等于&#x27;parse_html&#x27;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :</span><br><span class="line">    start_parse(archives_url)</span><br></pre></td></tr></table></figure>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><p><a target="_blank" rel="noopener" href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000">廖雪峰的python教程</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html">Beautiful Soup 4.2.0 文档</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://wuchong.me/blog/2014/04/24/easy-web-scraping-with-python/">使用 Python 轻松抓取网页</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.au92.com/archives/python-requests-chinese-improve-random-code.html">Python+Requests抓取中文乱码改进方案</a></p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/my_makefile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/my_makefile/" class="post-title-link" itemprop="url">我的Makefile文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2014-11-23 00:00:00" itemprop="dateCreated datePublished" datetime="2014-11-23T00:00:00+00:00">2014-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-08-31 09:27:11" itemprop="dateModified" datetime="2024-08-31T09:27:11+00:00">2024-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近学习了《GNU Make项目管理》，改进了我之前一直在用的Makefile文件，解决我之前的Makefile中一直存在的修改依赖头文件后不能自动编译cpp文件的问题。本文列举了我常用的两个Makefile文件，其中第一个为我常用的Makefile，第二个为从网上找到的其他Makefile文件。</p>
<h1 id="第一个Makefile"><a href="#第一个Makefile" class="headerlink" title="第一个Makefile"></a>第一个Makefile</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">INCLUDE = -I./</span><br><span class="line"></span><br><span class="line">FLAGS = -g -Wall <span class="variable">$(INCLUDE)</span></span><br><span class="line">FLAGS += -fPIC</span><br><span class="line"></span><br><span class="line">LIBDIR = -lz -lm -lcrypto</span><br><span class="line"></span><br><span class="line">LINK = <span class="variable">$(LIBDIR)</span> -lpthread</span><br><span class="line"></span><br><span class="line">GCC = g++</span><br><span class="line"></span><br><span class="line"><span class="comment"># for C++ language</span></span><br><span class="line">CODE.cpp = main.cpp \</span><br><span class="line">			trim.cpp</span><br><span class="line"></span><br><span class="line">CPP.o = $(CODE.cpp:.cpp=.o)</span><br><span class="line">OBJS.d = $(CODE.cpp:.cpp=.d)</span><br><span class="line"></span><br><span class="line">OBJS.o = $(CPP.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决头文件依赖</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(<span class="built_in">subst</span> .cpp,.d,$(CODE.cpp)</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">%.d: %.cpp</span></span><br><span class="line">	<span class="variable">$(GCC)</span> -M <span class="variable">$(FLAGS)</span> <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span>.$$$$;		\</span><br><span class="line">	sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.$$$$ &gt; <span class="variable">$@</span>;	\</span><br><span class="line">	rm -f <span class="variable">$@</span>.$$$$</span><br><span class="line"></span><br><span class="line"><span class="comment"># rule for C++ language</span></span><br><span class="line">%.o : %.cpp	</span><br><span class="line">	<span class="variable">$(GCC)</span> <span class="variable">$(FLAGS)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span>	</span><br><span class="line">	@echo <span class="variable">$*</span>.o build successfully!......</span><br><span class="line"></span><br><span class="line">TARGET = main</span><br><span class="line">	</span><br><span class="line"><span class="variable">$(TARGET)</span> : $(OBJS.o) </span><br><span class="line">	<span class="variable">$(GCC)</span> $(OBJS.o) -o <span class="variable">$(TARGET)</span> <span class="variable">$(LINK)</span></span><br><span class="line">	@echo <span class="variable">$(TARGET)</span> BUILD OK!.........</span><br><span class="line"></span><br><span class="line">all : <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(TARGET)</span></span><br><span class="line">	rm -rf $(OBJS.o)</span><br><span class="line">	rm -rf $(OBJS.d)</span><br><span class="line">	rm -rf *.d</span><br></pre></td></tr></table></figure>

<p>该文件特点为需要手工将需要编译的源文件手动添加到Makefile中，可能比较麻烦，但是编译时比较灵活。可以随意修改需要编译源文件的顺序和是否需要编译源文件。</p>
<h1 id="第二个Makefile"><a href="#第二个Makefile" class="headerlink" title="第二个Makefile"></a>第二个Makefile</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># KEFILE FOR C/C++ PROJECT</span></span><br><span class="line"><span class="comment"># Author: swm8023 &lt;swm8023@gmail.com&gt;</span></span><br><span class="line"><span class="comment"># Date:   2014/01/30</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">###########################################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"><span class="section">all: </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># annotation when release version</span></span><br><span class="line">DEBUG       := y</span><br><span class="line">TARGET_PROG := main</span><br><span class="line"></span><br><span class="line"><span class="comment"># project directory	</span></span><br><span class="line">DEBUG_DIR   := ./Debug</span><br><span class="line">RELEASE_DIR := ./Release</span><br><span class="line">BIN_DIR     := <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(DEBUG)</span>, <span class="variable">$(DEBUG_DIR)</span>, <span class="variable">$(RELEASE_DIR)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell command</span></span><br><span class="line">CC    := gcc</span><br><span class="line">CXX   := g++</span><br><span class="line">RM    := rm -rf</span><br><span class="line">MKDIR := mkdir -p</span><br><span class="line">SED   := sed</span><br><span class="line">MV    := mv</span><br><span class="line"></span><br><span class="line"><span class="comment"># init sources &amp; objects &amp; depends</span></span><br><span class="line">sources_all := <span class="variable">$(<span class="built_in">shell</span> find . -name &quot;*.c&quot; -o -name &quot;*.cpp&quot; -o -name &quot;*.h&quot;)</span></span><br><span class="line">sources_c   := <span class="variable">$(<span class="built_in">filter</span> %.c, <span class="variable">$(sources_all)</span>)</span></span><br><span class="line">sources_cpp := <span class="variable">$(<span class="built_in">filter</span> %.cpp, <span class="variable">$(sources_all)</span>)</span></span><br><span class="line">sources_h   := <span class="variable">$(<span class="built_in">filter</span> %.h, <span class="variable">$(sources_all)</span>)</span></span><br><span class="line">objs        := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(BIN_DIR)</span>/,$(<span class="built_in">strip</span> $(sources_cpp:.cpp=.o)</span> $(sources_c:.c=.o)))</span><br><span class="line">deps        := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(BIN_DIR)</span>/,$(<span class="built_in">strip</span> $(sources_cpp:.cpp=.d)</span> $(sources_c:.c=.d)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># create directory</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> dirname,$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(sources_c)</span> <span class="variable">$(sources_cpp)</span>)</span>),\</span><br><span class="line">  <span class="variable">$(<span class="built_in">shell</span> <span class="variable">$(MKDIR)</span> <span class="variable">$(BIN_DIR)</span>/<span class="variable">$(dirname)</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># complie &amp; link variable</span></span><br><span class="line">CFLAGS     := <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(DEBUG)</span>,-g -O, -O2)</span></span><br><span class="line">CFLAGS     += <span class="variable">$(<span class="built_in">addprefix</span> -I ,$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(sources_h)</span>)</span>))</span><br><span class="line">CXXFLAGS    = <span class="variable">$(CFLAGS)</span></span><br><span class="line">LDFLAGS    := </span><br><span class="line">LOADLIBES  += <span class="comment">#-L/usr/include/mysql</span></span><br><span class="line">LDLIBS     += <span class="comment">#-lpthread -lmysqlclient</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add vpath</span></span><br><span class="line"><span class="keyword">vpath</span> %.h <span class="variable">$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(sources_h)</span>)</span>)</span><br><span class="line"><span class="keyword">vpath</span> %.c <span class="variable">$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(sources_c)</span>)</span>)</span><br><span class="line"><span class="keyword">vpath</span> %.cpp <span class="variable">$(<span class="built_in">sort</span> $(<span class="built_in">dir</span> <span class="variable">$(sources_cpp)</span>)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate depend files</span></span><br><span class="line"><span class="comment"># actually generate after object generated, beacasue it only used when next make)</span></span><br><span class="line"><span class="keyword">ifneq</span> <span class="string">&quot;<span class="variable">$(MAKECMDGOALS)</span>&quot;</span> <span class="string">&quot;clean&quot;</span></span><br><span class="line"><span class="keyword">sinclude</span> <span class="variable">$(deps)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make-depend(depend-file,source-file,object-file,cc)</span></span><br><span class="line"><span class="keyword">define</span> make-depend</span><br><span class="line">  <span class="variable">$(RM)</span> $1;                                     \</span><br><span class="line">  $4 <span class="variable">$(CFLAGS)</span> -MM $2 |                         \</span><br><span class="line">  <span class="variable">$(SED)</span> &#x27;s,\(<span class="variable">$(<span class="built_in">notdir</span> $3)</span>\): ,$3: ,&#x27; &gt; $1.tmp; \</span><br><span class="line">  <span class="variable">$(SED)</span> -e &#x27;s/<span class="comment">#.*//&#x27;                           \</span></span><br><span class="line">         -e &#x27;s/^[^:]*: *//&#x27;                     \</span><br><span class="line">         -e &#x27;s/ *\\$$//&#x27;                        \</span><br><span class="line">         -e &#x27;/^$$/ d&#x27;                           \</span><br><span class="line">         -e &#x27;s/$$/ :/&#x27; &lt; $1.tmp &gt;&gt; $1.tmp;      \</span><br><span class="line">  <span class="variable">$(MV)</span> $1.tmp $1;</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rules to generate objects file</span></span><br><span class="line"><span class="variable">$(BIN_DIR)</span>/%.o: %.c</span><br><span class="line">	@<span class="variable">$(<span class="built_in">call</span> make-depend,$(<span class="built_in">patsubst</span> %.o,%.d,<span class="variable">$@</span>)</span>,<span class="variable">$&lt;</span>,<span class="variable">$@</span>,<span class="variable">$(CC)</span>)</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(BIN_DIR)</span>/%.o: %.cpp</span><br><span class="line">	@<span class="variable">$(<span class="built_in">call</span> make-depend,$(<span class="built_in">patsubst</span> %.o,%.d,<span class="variable">$@</span>)</span>,<span class="variable">$&lt;</span>,<span class="variable">$@</span>,<span class="variable">$(CXX)</span>)</span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add-target(target,objs,cc)</span></span><br><span class="line"><span class="keyword">define</span> add-target</span><br><span class="line">  REAL_TARGET += <span class="variable">$(BIN_DIR)</span>/$1</span><br><span class="line">  <span class="variable">$(BIN_DIR)</span>/$1: $2</span><br><span class="line">	$3 <span class="variable">$(LDFLAGS)</span> $<span class="variable">$^</span> <span class="variable">$(LOADLIBES)</span> <span class="variable">$(LDLIBS)</span> -o $<span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># call add-target</span></span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> targ,<span class="variable">$(TARGET_PROG)</span>,$(<span class="built_in">eval</span> $(<span class="built_in">call</span> add-target,<span class="variable">$(targ)</span>,<span class="variable">$(objs)</span>,<span class="variable">$(CXX)</span>)</span>))</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(REAL_TARGET)</span> <span class="variable">$(TARGET_LIBS)</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">	<span class="variable">$(RM)</span> <span class="variable">$(BIN_DIR)</span></span><br></pre></td></tr></table></figure>

<p>该Makefile为从<a target="_blank" rel="noopener" href="http://c4fun.cn/blog/2014/01/30/common-makefile/">一个通用的C&#x2F;C++ Makefile</a>中直接获得的，为了避免原博客以后不能访问的情况，这里备份一下。</p>
<p>该Makefile可以动检测Makefile所在目录及其子目录中的.c和.cpp文件，并进行编译，不需要手动修改Makefile来填写需要编译的源文件，比较自动化。</p>
<h1 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h1><p>第二个Makefile文件的作者博客中的两篇文章：<a target="_blank" rel="noopener" href="http://c4fun.cn/blog/2014/01/13/gnu-make-study01/">GNU Make学习总结（一）</a>和<a target="_blank" rel="noopener" href="http://c4fun.cn/blog/2014/01/13/gnu-make-study02/">GNU Make学习总结（二）</a></p>
<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1jGDo5ls">一个包含上述两个Makefile的例子</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/16/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/18/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"kuring/kuring.github.io","repo_id":"MDEwOlJlcG9zaXRvcnkyODM4MzQ0NTk=","category":"Announcements","category_id":"DIC_kwDOEOr4W84CdeTU","mapping":"pathname","reactions_enabled":1,"emit_metadata":1,"theme":"light","lang":"zh-CN","crossorigin":"anonymous","input_position":"bottom","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
