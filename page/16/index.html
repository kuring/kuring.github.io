<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"kuring.me","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":true}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="404频道">
<meta property="og:url" content="http://kuring.me/page/16/index.html">
<meta property="og:site_name" content="404频道">
<meta property="og:locale">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://kuring.me/page/16/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-Hans","comments":"","permalink":"","path":"page/16/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>404频道</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">404频道</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学习笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">241</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/kuring" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kuring" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/cpp11_right_reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/cpp11_right_reference/" class="post-title-link" itemprop="url">C++11中的右值引用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-05-18 00:00:00" itemprop="dateCreated datePublished" datetime="2015-05-18T00:00:00+00:00">2015-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-13 01:42:32" itemprop="dateModified" datetime="2024-05-13T01:42:32+00:00">2024-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在C++98中有左值和右值的概念，不过这两个概念对于很多程序员并不关心，因为不知道这两个概念照样可以写出好程序。在C++11中对右值的概念进行了增强，我个人理解这部分内容是C++11引入的特性中最难以理解的了。该特性的引入至少可以解决C++98中的移动语义和完美转发问题，若你还不清楚这两个问题是什么，请向下看。</p>
<p>温馨提示，由于内容比较难懂，请仔细看。C++已经够复杂了，C++11中引入的新特性令C++更加复杂了。在学习本文的时候一定要理解清楚左值、右值、左值引用和右值引用。</p>
<h1 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h1><p>首先看一个C++98中的关于函数返回类对象的例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">MyString</span>() &#123; </span><br><span class="line">        _data = <span class="literal">nullptr</span>; </span><br><span class="line">        _len = <span class="number">0</span>; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Constructor is called!\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* p) &#123; </span><br><span class="line">        _len = <span class="built_in">strlen</span> (p); </span><br><span class="line">        _init_data(p); </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Constructor is called! this-&gt;_data: &quot;</span> &lt;&lt; (<span class="type">long</span>)_data &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; str) &#123; </span><br><span class="line">        _len = str._len; </span><br><span class="line">        _init_data(str._data); </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Constructor is called! src: &quot;</span> &lt;&lt; (<span class="type">long</span>)str._data &lt;&lt; <span class="string">&quot; dst: &quot;</span> &lt;&lt; (<span class="type">long</span>)_data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123; </span><br><span class="line">        <span class="keyword">if</span> (_data)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;DeConstructor is called! this-&gt;_data: &quot;</span> &lt;&lt; (<span class="type">long</span>)_data &lt;&lt; endl; </span><br><span class="line">            <span class="built_in">free</span>(_data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;DeConstructor is called!&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; str) &#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123; </span><br><span class="line">            _len = str._len; </span><br><span class="line">            _init_data(str._data); </span><br><span class="line">        &#125; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Copy Assignment is called! src: &quot;</span> &lt;&lt; (<span class="type">long</span>)str._data &lt;&lt; <span class="string">&quot; dst&quot;</span> &lt;&lt; (<span class="type">long</span>)_data &lt;&lt; endl; </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">operator</span> <span class="type">const</span> <span class="type">char</span> *() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">char</span> *_data; </span><br><span class="line">    <span class="type">size_t</span>   _len; </span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _init_data(<span class="type">const</span> <span class="type">char</span> *s) &#123; </span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_len+<span class="number">1</span>]; </span><br><span class="line">        <span class="built_in">memcpy</span>(_data, s, _len); </span><br><span class="line">        _data[_len] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">middle</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    MyString a = <span class="built_in">foo</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该例子在编译器没有进行优化的情况下会输出以下内容，我在输出的内容中做了注释处理，如果连这个例子的输出都看不懂，建议再看一下C++的语法了。我这里使用的编译器命令为<code>g++ test.cpp -o main -g -fno-elide-constructors</code>，之所以要加上<code>-fno-elide-constructors</code>选项时因为g++编译器默认情况下会对函数返回类对象的情况作<em>返回值优化</em>处理，这不是我们讨论的重点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">29483024</span> <span class="comment">// middle对象的构造函数</span></span><br><span class="line">Copy Constructor is called! src: <span class="number">29483024</span> dst: <span class="number">29483056</span> <span class="comment">// 临时对象的构造，通过middle对象调用复制构造函数</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">29483024</span> <span class="comment">// middle对象的析构</span></span><br><span class="line">Copy Constructor is called! src: <span class="number">29483056</span> dst: <span class="number">29483024</span>	<span class="comment">// a对象构造，通过临时对象调用复制构造函数</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">29483056</span> <span class="comment">// 临时对象析构</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">29483024</span> <span class="comment">// a对象析构</span></span><br></pre></td></tr></table></figure>

<p>在上述例子中，临时对象的构造、复制和析构操作所带来的效率影响一直是C++中为人诟病的问题，临时对象的构造和析构操作均对堆上的内存进行操作，而如果_data的内存过大，势必会非常影响效率。从程序员的角度而言，该临时对象是透明的。而这一问题正是C++11中需要解决的问题。</p>
<p>在C++11中解决该问题的思路为，引入了移动构造函数，移动构造函数的定义如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyString</span>(MyString &amp;&amp;str) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Move Constructor is called! src: &quot;</span> &lt;&lt; (<span class="type">long</span>)str._data &lt;&lt; endl;</span><br><span class="line">    _len = str._len;</span><br><span class="line">    _data = str._data;</span><br><span class="line">    str._data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在移动构造函数中我们窃取了str对象已经申请的内存，将其拿为己用，并将str申请的内存给赋值为nullptr。移动构造函数和复制构造函数的不同之处在于移动构造函数的参数使用*&amp;&amp;*，这就是下文要讲解的右值引用符号。参数不再是const，因为在移动构造函数需要修改右值str的内容。</p>
<p>移动构造函数的调用时机为用来构造临时变量和用临时变量来构造对象的时候移动语义会被调用。可以通过下面的输出结果看到，我们所使用的编译参数为<code>g++ test.cpp -o main -g -fno-elide-constructors --std=c++11</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">22872080</span> <span class="comment">// middle对象构造</span></span><br><span class="line">Move Constructor is called! src: <span class="number">22872080</span> <span class="comment">// 临时对象通过移动构造函数构造，将middle申请的内存窃取</span></span><br><span class="line">DeConstructor is called! <span class="comment">// middle对象析构</span></span><br><span class="line">Move Constructor is called! src: <span class="number">22872080</span> <span class="comment">// 对象a通过移动构造函数构造，将临时对象的内存窃取</span></span><br><span class="line">DeConstructor is called! <span class="comment">// 临时对象析构</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">22872080</span> <span class="comment">// 对象a析构</span></span><br></pre></td></tr></table></figure>

<p>通过输出结果可以看出，整个过程中仅申请了一块内存，这也正好符合我们的要求了。</p>
<h1 id="C-98中的左值和右值"><a href="#C-98中的左值和右值" class="headerlink" title="C++98中的左值和右值"></a>C++98中的左值和右值</h1><p>我们先来看下C++98中的左值和右值的概念。左值和右值最直观的理解就是一条语句等号左边的为左值，等号右边的为右值，而事实上该种理解是错误的。左值：可以取地址，有名字的值，是一个指向某内存空间的表达式，可以使用&amp;操作符获取内存地址。右值：不能取地址，即非左值的都是右值，没有名字的值，是一个临时值，表达式结束后右值就没有意义了。我想通过下面的例子，读者可以清楚的理解左值和右值了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lvalues:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">i = <span class="number">43</span>; <span class="comment">// i是左值</span></span><br><span class="line"><span class="type">int</span>* p = &amp;i; <span class="comment">// i是左值</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">foo</span>() = <span class="number">42</span>; <span class="comment">// foo()返回引用类型是左值</span></span><br><span class="line"><span class="type">int</span>* p1 = &amp;<span class="built_in">foo</span>(); <span class="comment">// foo()可以取地址是左值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rvalues:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foobar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">j = <span class="built_in">foobar</span>(); <span class="comment">// foobar()是右值</span></span><br><span class="line"><span class="type">int</span>* p2 = &amp;<span class="built_in">foobar</span>(); <span class="comment">// 编译错误，foobar()是右值不能取地址</span></span><br><span class="line">j = <span class="number">42</span>; <span class="comment">// 42是右值</span></span><br></pre></td></tr></table></figure>

<h1 id="C-11右值引用和移动语义"><a href="#C-11右值引用和移动语义" class="headerlink" title="C++11右值引用和移动语义"></a>C++11右值引用和移动语义</h1><p>在C++98中有引用的概念，对于<code>const int &amp;m = 1</code>，其中m为引用类型，可以对其取地址，故为左值。在C++11中，引入了右值引用的概念，使用*&amp;&amp;*来表示。在引入了右值引用后，在函数重载时可以根据是左值引用还是右值引用来区分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(MyString &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;left reference&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(MyString &amp;&amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;right reference&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="function">MyString <span class="title">a</span><span class="params">(<span class="string">&quot;456&quot;</span>)</span></span>; </span><br><span class="line">    <span class="built_in">fun</span>(a); <span class="comment">// 左值引用，调用void fun(MyString &amp;str)</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="built_in">foo</span>()); <span class="comment">// 右值引用，调用void fun(MyString &amp;&amp;str)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在绝大多数情况下，这种通过左值引用和右值引用重载函数的方式仅会在类的构造函数和赋值操作符中出现，被例子仅是为了方便采用函数的形式，该种形式的函数用到的比较少。上述代码中所使用的将资源从一个对象到另外一个对象之间的转移就是移动语义。这里提到的资源是指类中的在堆上申请的内存、文件描述符等资源。</p>
<p>前面已经介绍过了移动构造函数的具体形式和使用情况，这里对移动赋值操作符的定义再说明一下，并将main函数的内容也一起更改，将得到如下输出结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) &#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Move Operator= is called! src: &quot;</span> &lt;&lt; (<span class="type">long</span>)str._data &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123; </span><br><span class="line">        <span class="keyword">if</span> (_data != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(_data);</span><br><span class="line">        &#125;</span><br><span class="line">        _len = str._len;</span><br><span class="line">        _data = str._data;</span><br><span class="line">        str._len = <span class="number">0</span>;</span><br><span class="line">        str._data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    MyString b;</span><br><span class="line">    b = <span class="built_in">foo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果，整个过程仅申请了一个内存地址</span></span><br><span class="line">Constructor is called! <span class="comment">// 对象b构造函数调用</span></span><br><span class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">14835728</span> <span class="comment">// middle对象构造</span></span><br><span class="line">Move Constructor is called! src: <span class="number">14835728</span> <span class="comment">// 临时对象通过移动构造函数由middle对象构造</span></span><br><span class="line">DeConstructor is called! <span class="comment">// middle对象析构</span></span><br><span class="line">Move Operator= is called! src: <span class="number">14835728</span> <span class="comment">// 对象b通过移动赋值操作符由临时对象赋值</span></span><br><span class="line">DeConstructor is called! <span class="comment">// 临时对象析构</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">14835728</span> <span class="comment">// 对象b析构函数调用</span></span><br></pre></td></tr></table></figure>

<p>在C++中对一个变量可以通过const来修饰，而const和引用是对变量约束的两种方式，为并行存在，相互独立。因此，就可以划分为了const左值引用、非const左值引用、const右值引用和非const右值引用四种类型。其中左值引用的绑定规则和C++98中是一致的。</p>
<p>非const左值引用只能绑定到非const左值，不能绑定到const右值、非const右值和const左值。这一点可以通过const关键字的语义来判断。</p>
<p>const左值引用可以绑定到任何类型，包括const左值、非const左值、const右值和非const右值，属于万能引用类型。其中绑定const右值的规则比较少见，但是语法上是可行的，比如<code>const int &amp;a = 1</code>，只是我们一般都会直接使用<code>int &amp;a = 1</code>了。</p>
<p>非const右值引用不能绑定到任何左值和const右值，只能绑定非const右值。</p>
<p>const右值引用类型仅是为了语法的完整性而设计的， 比如可以使用<code>const MyString &amp;&amp;right_ref = foo()</code>，但是右值引用类型的引入主要是为了移动语义，而移动语义需要右值引用是可以被修改的，因此const右值引用类型没有实际意义。</p>
<p>我们通过表格的形式对上文中提到的四种引用类型可以绑定的类型进行总结。</p>
<table>
<thead>
<tr>
<th>引用类型&#x2F;是否绑定</th>
<th>非const左值</th>
<th>const左值</th>
<th>非const右值</th>
<th>const右值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>非const左值引用</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>无</td>
</tr>
<tr>
<td>const左值引用</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>全能绑定类型，绑定到const右值的情况比较少见</td>
</tr>
<tr>
<td>非const右值引用</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>C++11中引入的特性，用于移动语义和完美转发</td>
</tr>
<tr>
<td>const值引用</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>没有实际意义，为了语法完整性而存在</td>
</tr>
</tbody></table>
<p>下面针对上述例子，我们看一下foo函数绑定参数的情况。</p>
<p>如果只实现了<code>void foo(MyString &amp;str)</code>，而没有实现<code>void fun(MyString &amp;&amp;str)</code>，则和之前一样foo函数的实参只能是非const左值。</p>
<p>如果只实现了<code>void foo(const MyString &amp;str)</code>，而没有实现<code>void fun(MyString &amp;&amp;str)</code>，则和之前一样foo函数的参数即可以是左值又可以是右值，因为const左值引用是万能绑定类型。</p>
<p>如果只实现了<code>void foo(MyString &amp;&amp;str)</code>，而没有实现<code>void fun(MyString &amp;str)</code>，则foo函数的参数只能是非const右值。</p>
<h1 id="强制移动语义std-move"><a href="#强制移动语义std-move" class="headerlink" title="强制移动语义std::move()"></a>强制移动语义std::move()</h1><p>前文中我们通过右值引用给类增加移动构造函数和移动赋值操作符已经解决了函数返回类对象效率低下的问题。那么还有什么问题没有解决呢？</p>
<p>在C++98中的swap函数的实现形式如下，在该函数中我们可以看到整个函数中的变量a、b、c均为左值，无法直接使用前面移动语义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">( T&amp; a, T&amp; b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">c</span><span class="params">(a)</span></span>; </span><br><span class="line">    a=b;</span><br><span class="line">    b=c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果该函数中能够使用移动语义是非常合适的，仅是为了交换两个变量，却要反复申请和释放资源。按照前面的知识变量c不可能为非const右值引用，因为变量a为非const左值，非const右值引用不能绑定到任何左值。</p>
<p>在C++11的标准库中引入了std::move()函数来解决该问题，该函数的作用为将其参数转换为右值。在C++11中的swap函数就可以更改为了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">c</span><span class="params">(std::move(a))</span></span>; </span><br><span class="line">    a=std::<span class="built_in">move</span>(b); </span><br><span class="line">    b=std::<span class="built_in">move</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用了move语义以后,swap函数的效率会大大提升，我们更改main函数后测试如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// move函数</span></span><br><span class="line">    <span class="function">MyString <span class="title">d</span><span class="params">(<span class="string">&quot;123&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">e</span><span class="params">(<span class="string">&quot;456&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">swap</span>(d, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果，通过输出结果可以看出对象交换是成功的</span></span><br><span class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">38469648</span> <span class="comment">// 对象d构造</span></span><br><span class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">38469680</span> <span class="comment">// 对象e构造</span></span><br><span class="line">Move Constructor is called! src: <span class="number">38469648</span> <span class="comment">// swap函数中的对象c通过移动构造函数构造</span></span><br><span class="line">Move Operator= is called! src: <span class="number">38469680</span> <span class="comment">// swap函数中的对象a通过移动赋值操作符赋值</span></span><br><span class="line">Move Operator= is called! src: <span class="number">38469648</span> <span class="comment">// swap函数中的对象b通过移动赋值操作符赋值</span></span><br><span class="line">DeConstructor is called! <span class="comment">// swap函数中的对象c析构</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">38469648</span> <span class="comment">// 对象e析构</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">38469680</span> <span class="comment">// 对象d析构</span></span><br></pre></td></tr></table></figure>

<h1 id="右值引用和右值的关系"><a href="#右值引用和右值的关系" class="headerlink" title="右值引用和右值的关系"></a>右值引用和右值的关系</h1><p>这个问题就有点绕了，需要开动思考一下右值引用和右值是啥含义了。读者会凭空的认为右值引用肯定是右值，其实不然。我们在之前的例子中添加如下代码，并将main函数进行修改如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_rvalue_rref</span><span class="params">(MyString &amp;&amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;tmp object construct start&quot;</span> &lt;&lt; endl;</span><br><span class="line">    MyString tmp = str;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;tmp object construct finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_rvalue_rref</span>(<span class="built_in">foo</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">Constructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">28913680</span></span><br><span class="line">Move Constructor is called! src: <span class="number">28913680</span></span><br><span class="line">DeConstructor is called!</span><br><span class="line">tmp object construct start</span><br><span class="line">Copy Constructor is called! src: <span class="number">28913680</span> dst: <span class="number">28913712</span> <span class="comment">// 可以看到这里调用的是复制构造函数而不是移动构造函数</span></span><br><span class="line">tmp object construct finish</span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">28913712</span></span><br><span class="line">DeConstructor is called! <span class="keyword">this</span>-&gt;_data: <span class="number">28913680</span></span><br></pre></td></tr></table></figure>

<p>我想程序运行的结果肯定跟大多数人想到的不一样，“Are you kidding me?不是应该调用移动构造函数吗？为什么调用了复制构造函数？”。关于右值引用和左右值之间的规则是：</p>
<blockquote>
<p>如果右值引用有名字则为左值，如果右值引用没有名字则为右值。</p>
</blockquote>
<p>通过规则我们可以发现，在我们的例子中右值引用str是有名字的，因此为左值，tmp的构造会调用复制构造函数。之所以会这样，是因为如果tmp构造的时候调用了移动构造函数，则调用完成后str的申请的内存自己已经不可用了，如果在该函数中该语句的后面在调用str变量会出现我们意想不到的问题。鉴于此，我们也就能够理解为什么有名字的右值引用是左值了。如果已经确定在tmp构造语句的后面不需要使用str变量了，可以使用std::move()函数将str变量从左值转换为右值，这样tmp变量的构造就可以使用移动构造函数了。</p>
<p>而如果我们调用的是<code>MyString b = foo()</code>语句，由于foo()函数返回的是临时对象没有名字属于右值，因此b的构造会调用移动构造函数。</p>
<p>该规则非常的重要，要想能够正确使用右值引用，该规则必须要掌握，否则写出来的代码会有一个大坑。</p>
<h1 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h1><p>前面已经介绍了本文的两大主题之一的移动语义，还剩下完美转发机制。完美转发机制通常用于库函数中，至少在我的工作中还是很少使用的。如果实在不想理解该问题，可以不用向下看了。在泛型编程中，经常会遇到的一个问题是怎样将一组参数原封不动的转发给另外一个函数。这里的原封不动是指，如果函数是左值，那么转发给的那个函数也要接收一个左值；如果参数是右值，那么转发给的函数也要接收一个右值；如果参数是const的，转发给的函数也要接收一个const参数；如果参数是非const的，转发给的函数也要接收一个非const值。</p>
<p>该问题看上去非常简单，其实不然。看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> &amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;lvalue ref&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> &amp;&amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;rvalue ref&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const lvalue ref&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;&amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const rvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T t)</span> </span>&#123; <span class="built_in">fun</span>(t); &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="number">10</span>);           <span class="comment">// rvalue ref</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(a);            <span class="comment">// lvalue ref</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(std::<span class="built_in">move</span>(a)); <span class="comment">// rvalue ref</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(b);            <span class="comment">// const lvalue ref</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(std::<span class="built_in">move</span>(b)); <span class="comment">// const rvalue ref</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，我们想达到的目的是PerfectForward模板函数能够完美转发参数t到fun函数中。上述例子中的PerfectForward函数必然不能够达到此目的，因为PerfectForward函数的参数为左值类型，调用的fun函数也必然为<code>void fun(int &amp;)</code>。且调用PerfectForward之前就产生了一次参数的复制操作，因此这样的转发只能称之为正确转发，而不是完美转发。要想达到完美转发，需要做到像转发函数不存在一样的效率。</p>
<p>因此，我们考虑将PerfectForward函数的参数更改为引用类型，因为引用类型不会有额外的开销。另外，还需要考虑转发函数PerfectForward是否可以接收引用类型。如果转发函数PerfectForward仅能接收左值引用或右值引用的一种，那么也无法实现完美转发。</p>
<p>我们考虑使用<code>const T &amp;t</code>类型的参数，因为我们在前文中提到过，const左值引用类型可以绑定到任何类型。但是这样目标函数就不一定能接收const左值引用类型的参数了。const左值引用属于左值，非const左值引用和非const右值引用是无法绑定到const左值的。</p>
<p>如果将参数t更改为非const右值引用、const右值也是不可以实现完美转发的。</p>
<p>在C++11中为了能够解决完美转发问题，引入了更为复杂的规则：引用折叠规则和特殊模板参数推导规则。</p>
<h2 id="引用折叠推导规则"><a href="#引用折叠推导规则" class="headerlink" title="引用折叠推导规则"></a>引用折叠推导规则</h2><p>为了能够理解清楚引用折叠规则，还是通过以下例子来学习。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>&amp; TR;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> &amp;b = a;</span><br><span class="line">    <span class="type">int</span> &amp; &amp;c = a;  <span class="comment">// 编译器报错，不可以对引用再显示添加引用</span></span><br><span class="line">    TR &amp;d = a;     <span class="comment">// 通过typedef定义的类型隐式添加引用是可以的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++中，不可以在程序中对引用再显示添加引用类型，对于<code>int &amp; &amp;c</code>的声明变量方式，编译器会提示错误。但是如果在上下文中（包括使用模板实例化、typedef、auto类型推断等）出现了对引用类型再添加引用的情况，编译器是可以编译通过的。具体的引用折叠规则如下，可以看出一旦引用中定义了左值类型，折叠规则总是将其折叠为左值引用。这就是引用折叠规则的全部内容了。另外折叠规则跟变量的const特性是没有关系的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A&amp; &amp; =&gt; A&amp;</span><br><span class="line">A&amp; &amp;&amp; =&gt; A&amp;</span><br><span class="line">A&amp;&amp; &amp; =&gt; A&amp;</span><br><span class="line">A&amp;&amp; &amp;&amp; =&gt; A&amp;&amp;</span><br></pre></td></tr></table></figure>

<h2 id="特殊模板参数推导规则"><a href="#特殊模板参数推导规则" class="headerlink" title="特殊模板参数推导规则"></a>特殊模板参数推导规则</h2><p>下面我们再来学习特殊模板参数推导规则，考虑下面的模板函数，模板函数接收一个右值引用作为模板参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>说白点，特殊模板参数推导规则其实就是引用折叠规则在模板参数为右值引用时模板情况下的应用，是引用折叠规则的一种情况。我们结合上文中的引用折叠规则，</p>
<ol>
<li>如果foo的实参是上文中的A类型的左值时，T的类型就为A&amp;。根据引用折叠规则，最后foo的参数类型为A&amp;。</li>
<li>如果foo的实参是上文中的A类型的右值时，T的类型就为A&amp;&amp;。根据引用折叠规则，最后foo的参数类型为A&amp;&amp;。</li>
</ol>
<h2 id="解决完美转发问题"><a href="#解决完美转发问题" class="headerlink" title="解决完美转发问题"></a>解决完美转发问题</h2><p>我们已经学习了模板参数为右值引用时的特殊模板参数推导规则，那么我们利用刚学习的知识来解决本文中待解决的完美转发的例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> &amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;lvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> &amp;&amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;rvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const lvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;&amp;)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const rvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//template&lt;typename T&gt;</span></span><br><span class="line"><span class="comment">//void PerfectForward(T t) &#123; fun(t); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用引用折叠规则代替了原有的不完美转发机制</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; <span class="built_in">fun</span>(<span class="built_in">static_cast</span>&lt;T &amp;&amp;&gt;(t)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="number">10</span>);           <span class="comment">// rvalue ref，折叠后t类型仍然为T &amp;&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(a);            <span class="comment">// lvalue ref，折叠后t类型为T &amp;</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(std::<span class="built_in">move</span>(a)); <span class="comment">// rvalue ref，折叠后t类型为T &amp;&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">PerfectForward</span>(b);            <span class="comment">// const lvalue ref，折叠后t类型为const T &amp;</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(std::<span class="built_in">move</span>(b)); <span class="comment">// const rvalue ref，折叠后t类型为const T &amp;&amp;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子中已经对完美转发的各种情况进行了说明，这里需要对PerfectForward模板函数中的static_cast进行说明。static_cast仅是对传递右值时起作用。我们看一下当参数为右值时的情况，这里的右值包括了const右值和非const右值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为右值，引用折叠规则引用前</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> &amp;&amp; &amp;&amp;T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(<span class="type">int</span> &amp;&amp; &amp;&amp;t)</span> </span>&#123; <span class="built_in">fun</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&amp; &amp;&amp;&gt;(t)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用折叠规则应用后</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> &amp;&amp;T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(<span class="type">int</span> &amp;&amp;t)</span> </span>&#123; <span class="built_in">fun</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span> &amp;&amp;&gt;(t)); &#125;</span><br></pre></td></tr></table></figure>

<p>可能读者仍然没有发现上述例子中的问题，“不用static_cast进行强制类型转换不是也可以吗？”。别忘记前文中仍然提到一个右值引用和右值之间关系的规则，<code>如果右值引用有名字则为左值，如果右值引用没有名字则为右值。</code>。这里的变量t虽然为右值引用，但是是左值。如果我们想继续向fun函数中传递右值，就需要使用static_cast进行强制类型转换了。</p>
<p>其实在C++11中已经为我们封装了std::forward函数来替代我们上文中使用的static_cast类型转换，该例子中使用std::forward函数的版本变为了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; <span class="built_in">fun</span>(std::forward&lt;T&gt;(t)); &#125;</span><br></pre></td></tr></table></figure>

<p>对于上文中std::move函数的实现也是使用了引用折叠规则，实现方式跟std::forward一致。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol>
<li>《深入理解C++11-C++11新特性解析与应用》</li>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/">C++11 标准新特性: 右值引用与转移语义</a></li>
<li><a target="_blank" rel="noopener" href="http://www.zhihu.com/question/22111546">如何评价 C++11 的右值引用（Rvalue reference）特性？</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.bitdewy.me/blog/2013/07/08/cpp11-perfect-forward/">C++11 完美转发</a></li>
<li><a target="_blank" rel="noopener" href="http://thbecker.net/articles/rvalue_references/section_01.html#section_01">C++ Rvalue References Explained</a></li>
<li><a target="_blank" rel="noopener" href="http://jxq.me/2012/06/06/%E8%AF%91%E8%AF%A6%E8%A7%A3c%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">详解C++右值引用</a> （对C++ Rvalue References Explained的翻译）</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/large_website_architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/large_website_architecture/" class="post-title-link" itemprop="url">大型网站技术架构读书笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-05-13 00:00:00" itemprop="dateCreated datePublished" datetime="2015-05-13T00:00:00+00:00">2015-05-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-13 01:42:32" itemprop="dateModified" datetime="2024-05-13T01:42:32+00:00">2024-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近粗读了一遍《大型网站技术架构-核心原理与案例分析》，并对其中的内容通过思维导图的形式进行了整理。本书的所讲解的内容均为大型网站中涉及到的问题及相关技术，但并未展开深入讨论相关技术的解决办法，非常适合入门。下面我将我的思维导图以图片的形式贴出来，并提供XMind编辑的.xmid格式的文件。</p>
<p><img src="http://kuring.qiniudn.com/large_website_architecture.png"></p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1lngiq">大型网站技术架构读书笔记</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/airodump-ng_ssid_messy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/airodump-ng_ssid_messy/" class="post-title-link" itemprop="url">解决airodump-ng显示ssid名称的乱码问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-05-04 00:00:00" itemprop="dateCreated datePublished" datetime="2015-05-04T00:00:00+00:00">2015-05-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-13 01:42:32" itemprop="dateModified" datetime="2024-05-13T01:42:32+00:00">2024-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>无线wifi的essid支持英文和中文，中文的编码在802.11协议并没有规定，对于802.11协议而言仅将essid看作是二进制。而中文又存在多种编码方式，最常见的就是GB18030（我这里直接用GB18030代替了GB系列的字符集）和UTF-8了。</p>
<p>iwlist程序通过命令<code>iwlist wlan0 scanning</code>可以在终端上正常显示UTF-8编码的essid，对于其他编码的中文仍然是乱码，这也就非常容易理解了。因为具体的essid能否将中文正常显示在终端屏幕上跟essid的编码和当前终端环境的编码是否能够匹配有关，如果essid的编码和当前终端环境的编码均为UTF-8，则essid可以在屏幕上正常显示。如果当前网络中的可以搜索到的essid即包含了GB18030编码又包含了UTF-8编码，则打印在终端上的essid必然会有乱码的情况出现。</p>
<h1 id="airodump-ng程序问题"><a href="#airodump-ng程序问题" class="headerlink" title="airodump-ng程序问题"></a>airodump-ng程序问题</h1><p>对于airodump-ng程序而言，即时是essid的编码和终端编码一致也会出现某些中文字符乱码的问题，这一点比较奇怪。比如“免费”中的“免”字是乱码，“费”却能正常显示。通过这一现象有理由怀疑airodump-ng对essid做了某些处理。</p>
<p>经过查看源码发现，在airodump-ng.c文件中存在三处如下类似代码，作用为将essid中的ascii值在(126,160)之间的转换为”.”。看来airodump-ng程序并没有考虑到中文的情况，仅将ascii中无法显示的字符做了转换。将程序中的三处代码注释后就可以正常显示了。具体三处代码可以通过搜索’.’来查找。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">&#123;</span><br><span class="line">	c = p[<span class="number">2</span> + i];</span><br><span class="line">	<span class="keyword">if</span>( c == <span class="number">0</span> || ( c &gt; <span class="number">126</span> &amp;&amp; c &lt; <span class="number">160</span> ) )</span><br><span class="line">	&#123;</span><br><span class="line">		c = <span class="string">&#x27;.&#x27;</span>;  <span class="comment">//could also check ||(c&gt;0 &amp;&amp; c&lt;32)</span></span><br><span class="line">	&#125;</span><br><span class="line">	st_cur-&gt;probes[st_cur-&gt;probe_index][i] = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="NetworkManager"><a href="#NetworkManager" class="headerlink" title="NetworkManager"></a>NetworkManager</h1><p>通过实践发现，GNOME和KDE桌面下的查看无线网络连接的ssid是可以正常显示的，即可以正常显示GB18030，又可以正常显示UTF-8编码的essid。则可以推测，在桌面环境下的搜索网络的程序肯定对编码做了某些处理，顺着这个思路，就可以查找GNOME或KDE的代码了。</p>
<p>在GNOME的源码中看到了network-manager-applet，该程序即为桌面上查看无线网络连接的小控件。在applet-device-wifi.c文件中看到了如下代码，其中的<code>nm_utils_ssid_to_utf8</code>函数即为将其他编码转换为UTF-8编码的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">char</span> *</span></span><br><span class="line"><span class="function"><span class="title">get_ssid_utf8</span> <span class="params">(NMAccessPoint *ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *ssid_utf8 = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">const</span> GByteArray *ssid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ap) &#123;</span><br><span class="line">		ssid = <span class="built_in">nm_access_point_get_ssid</span> (ap);</span><br><span class="line">		<span class="keyword">if</span> (ssid)</span><br><span class="line">			ssid_utf8 = <span class="built_in">nm_utils_ssid_to_utf8</span> (ssid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!ssid_utf8)</span><br><span class="line">		ssid_utf8 = <span class="built_in">g_strdup</span> (_(<span class="string">&quot;(none)&quot;</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ssid_utf8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nm_utils_ssid_to_utf8</code>函数定义在NetworkManager工程中的nm-utils.c文件中。该函数的代码如下，该函数具体功能可以查看代码中的注释，已经非常详细了。其中以<code>g_</code>开头的函数是glib库中的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *</span></span><br><span class="line"><span class="function"><span class="title">nm_utils_ssid_to_utf8</span> <span class="params">(<span class="type">const</span> GByteArray *ssid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *converted = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">char</span> *lang, *e1 = <span class="literal">NULL</span>, *e2 = <span class="literal">NULL</span>, *e3 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">g_return_val_if_fail</span> (ssid != <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">g_utf8_validate</span> ((<span class="type">const</span> gchar *) ssid-&gt;data, ssid-&gt;len, <span class="literal">NULL</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">g_strndup</span> ((<span class="type">const</span> gchar *) ssid-&gt;data, ssid-&gt;len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* LANG may be a good encoding hint */</span></span><br><span class="line">	<span class="built_in">g_get_charset</span> ((<span class="type">const</span> <span class="type">char</span> **)(&amp;e1));</span><br><span class="line">	<span class="keyword">if</span> ((lang = <span class="built_in">getenv</span> (<span class="string">&quot;LANG&quot;</span>))) &#123;</span><br><span class="line">		<span class="type">char</span> * dot;</span><br><span class="line"></span><br><span class="line">		lang = <span class="built_in">g_ascii_strdown</span> (lang, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> ((dot = <span class="built_in">strchr</span> (lang, <span class="string">&#x27;.&#x27;</span>)))</span><br><span class="line">			*dot = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">get_encodings_for_lang</span> (lang, &amp;e1, &amp;e2, &amp;e3);</span><br><span class="line">		<span class="built_in">g_free</span> (lang);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	converted = <span class="built_in">g_convert</span> ((<span class="type">const</span> gchar *) ssid-&gt;data, ssid-&gt;len, <span class="string">&quot;UTF-8&quot;</span>, e1, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!converted &amp;&amp; e2)</span><br><span class="line">		converted = <span class="built_in">g_convert</span> ((<span class="type">const</span> gchar *) ssid-&gt;data, ssid-&gt;len, <span class="string">&quot;UTF-8&quot;</span>, e2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!converted &amp;&amp; e3)</span><br><span class="line">		converted = <span class="built_in">g_convert</span> ((<span class="type">const</span> gchar *) ssid-&gt;data, ssid-&gt;len, <span class="string">&quot;UTF-8&quot;</span>, e3, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!converted) &#123;</span><br><span class="line">		converted = <span class="built_in">g_convert_with_fallback</span> ((<span class="type">const</span> gchar *) ssid-&gt;data, ssid-&gt;len,</span><br><span class="line">		                                     <span class="string">&quot;UTF-8&quot;</span>, e1, <span class="string">&quot;?&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> converted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nm_utils_ssid_to_utf8该函数位于libnm-util.so.1动态库中，可通过<code>nm -D  /usr/lib64/libnm-util.so.1 | grep nm_utils_ssid_to_utf8</code>命令查看导出表中存在该函数。但是系统中并不存在该函数的头文件libnm-util.h，给该库的调用增加了不少难度。可以通过将相关头文件引入到该工程编译的方式来完成，但是可能会牵涉到的头文件比较多，比较繁琐。</p>
<p>我这里直接采用了将NetworkManager中相关代码抓取出来的思路，并将其封装成类的形式以方便调用。具体代码可以参照demo中的例子。</p>
<h1 id="glib"><a href="#glib" class="headerlink" title="glib"></a>glib</h1><p>glib是GTK底层调用的核心库，跟glibc是没有关系的，虽然名字中仅差一个字母。为了调用该库需要在编译的时候添加*<code>pkg-config --cflags --libs glib-2.0</code>*信息，以引入需要的头文件和要链接的库。</p>
<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1qWqjMCc">文中用到的软件源码和程序demo</a></p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a target="_blank" rel="noopener" href="https://git.gnome.org/browse/">GNOME源码列表</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/single_number/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/single_number/" class="post-title-link" itemprop="url">leetcode题目之Single Number</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-03-31 00:00:00" itemprop="dateCreated datePublished" datetime="2015-03-31T00:00:00+00:00">2015-03-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-13 01:42:32" itemprop="dateModified" datetime="2024-05-13T01:42:32+00:00">2024-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="题目一-Single-Number"><a href="#题目一-Single-Number" class="headerlink" title="题目一 Single Number"></a>题目一 Single Number</h1><blockquote>
<p>Given an array of integers, every element appears twice except for one. Find that single one.<br>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<h1 id="题目二-Single-Number-II"><a href="#题目二-Single-Number-II" class="headerlink" title="题目二 Single Number II"></a>题目二 Single Number II</h1><blockquote>
<p>Given an array of integers, every element appears three times except for one. Find that single one.<br>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<h1 id="题目一分析及解答"><a href="#题目一分析及解答" class="headerlink" title="题目一分析及解答"></a>题目一分析及解答</h1><p>针对题目一，一看就能看出是考察异或操作的特点，并迅速写出了解答方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;   </span><br><span class="line">            result ^= A[i];</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="题目二分析及解答"><a href="#题目二分析及解答" class="headerlink" title="题目二分析及解答"></a>题目二分析及解答</h1><p>要想实现时间复杂度为O(n)，空间复杂度为O(1)的算法，还是跟题目一一样需要充分利用位操作特性，但是并没有直接可用的位操作特性可以完成，于是想到肯定是各种位操作的组合操作，但是并没有继续向下想到具体的算法。本质上该题目就是模拟一个三进制的操作，当一个位的最大值为2，当为3时直接清0。</p>
<p>参照网上的算法，利用一个int类型的数组来模拟一个三进制数，每个int值的最大值为3，当然这样存在一定空间上的浪费。算法需要将A中的每个值通过移位运算获取到该位的状态，并将值添加到用来模拟三进制的int数组中相应的位置，最后将模拟三进制int数组中的值为3的更改为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++&#123;</span><br><span class="line">                <span class="keyword">if</span> ((A[j] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    count[i]++;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">            result |= ((count[i] % <span class="number">3</span>) &lt;&lt; i); </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外，还有上述算法的改进算法，更为节省空间，效率更高，但是确实不容易理解和记忆，属于下次仍然无法记忆的算法类型。这里仅提供代码，不再给出解释，自己领悟。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>, threes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        twos |= ones &amp; A[i];</span><br><span class="line">        ones ^= A[i];<span class="comment">// 异或3次 和 异或 1次的结果是一样的</span></span><br><span class="line">       <span class="comment">//对于ones 和 twos 把出现了3次的位置设置为0 （取反之后1的位置为0）</span></span><br><span class="line">        threes = ones &amp; twos;</span><br><span class="line">        ones &amp;= ~threes;</span><br><span class="line">        twos &amp;= ~threes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/nowcoder_2015.3.12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/nowcoder_2015.3.12/" class="post-title-link" itemprop="url">牛客网内推笔试卷题目2015.3.12</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-03-25 00:00:00" itemprop="dateCreated datePublished" datetime="2015-03-25T00:00:00+00:00">2015-03-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-13 01:42:32" itemprop="dateModified" datetime="2024-05-13T01:42:32+00:00">2024-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前段时间参加了牛客网的答题活动，共两套试题，每套题目3个算法题，我只做了每套题的前两道。最近想查看之前做的题目的答案，却发现非常不方便，特此将我做过的4道题目记录一下，算法的思路就不再解释了。</p>
<h1 id="题目一-奇数位上都是奇数或者偶数位上都是偶数"><a href="#题目一-奇数位上都是奇数或者偶数位上都是偶数" class="headerlink" title="题目一 奇数位上都是奇数或者偶数位上都是偶数"></a>题目一 奇数位上都是奇数或者偶数位上都是偶数</h1><blockquote>
<p>给定一个长度不小于2的数组arr。 写一个函数调整arr，使arr中要么所有的偶数位上都是偶数，要么所有的奇数位上都是奇数上。 要求：如果数组长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1),下标0,2,4,6…算作偶数位,下标1,3,5,7…算作奇数位，例如[1,2,3,4]调整为[2,1,4,3]即可。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">oddInOddEvenInEven</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> odd = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> even = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (odd &lt; len &amp;&amp; even &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[odd] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (arr[even] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    even += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (even &lt; len)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> tmp = arr[even];</span><br><span class="line">                    arr[even] = arr[odd];</span><br><span class="line">                    arr[odd] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                odd += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="题目二-求正数数组的最小不可组成和"><a href="#题目二-求正数数组的最小不可组成和" class="headerlink" title="题目二 求正数数组的最小不可组成和"></a>题目二 求正数数组的最小不可组成和</h1><blockquote>
<p>给定一个全是正数的数组arr，定义一下arr的最小不可组成和的概念： 1，arr的所有非空子集中，把每个子集内的所有元素加起来会出现很多的值，其中最小的记为min，最大的记为max； 2，在区间[min,max]上，如果有一些正数不可以被arr某一个子集相加得到，那么这些正数中最小的那个，就是arr的最小不可组成和； 3，在区间[min,max]上，如果所有的数都可以被arr的某一个子集相加得到，那么max+1是arr的最小不可组成和； 举例： arr &#x3D; {3,2,5} arr的min为2，max为10，在区间[2,10]上，4是不能被任何一个子集相加得到的值中最小的，所以4是arr的最小不可组成和； arr &#x3D; {3,2,4} arr的min为2，max为9，在区间[2,9]上，8是不能被任何一个子集相加得到的值中最小的，所以8是arr的最小不可组成和； arr &#x3D; {3,1,2} arr的min为1，max为6，在区间[2,6]上，任何数都可以被某一个子集相加得到，所以7是arr的最小不可组成和； 请写函数返回arr的最小不可组成和。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getFirstUnFormedNum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            set&lt;<span class="type">int</span>&gt; tmp = res;</span><br><span class="line">            <span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator iter = res.<span class="built_in">begin</span>(); iter != res.<span class="built_in">end</span>(); iter++)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">insert</span>(*iter + arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res = tmp;</span><br><span class="line">            res.<span class="built_in">insert</span>(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set&lt;<span class="type">int</span>&gt;::iterator iter = res.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">int</span> before = *iter;</span><br><span class="line">        iter++;</span><br><span class="line">        <span class="keyword">for</span> (; iter != res.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*iter - before &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> before + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            before = *iter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> before + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="题目三-最大的LeftMax与rightMax之差绝对值"><a href="#题目三-最大的LeftMax与rightMax之差绝对值" class="headerlink" title="题目三 最大的LeftMax与rightMax之差绝对值"></a>题目三 最大的LeftMax与rightMax之差绝对值</h1><blockquote>
<p>给定一个长度为N的整型数组arr，可以划分成左右两个部分： 左部分arr[0..K]，右部分arr[K+1..arr.length-1]，K可以取值的范围是[0,arr.length-2] 求这么多划分方案中，左部分中的最大值减去右部分最大值的绝对值，最大是多少？ 例如： [2,7,3,1,1] 当左部分为[2,7]，右部分为[3,1,1]时，左部分中的最大值减去右部分最大值的绝对值为4; 当左部分为[2,7,3]，右部分为[1,1]时，左部分中的最大值减去右部分最大值的绝对值为6; 最后返回的结果为6。 注意：如果数组的长度为N，请尽量做到时间复杂度O(N)，额外空间复杂度O(1)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxABSLeftAndRight</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vec, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find the max in array</span></span><br><span class="line">        <span class="type">int</span> max = vec[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;(<span class="type">int</span>)vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = vec[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare the head and tail in array</span></span><br><span class="line">        <span class="keyword">if</span> (vec[<span class="number">0</span>] &lt; vec[len - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> max - vec[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max - vec[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="题目四-按照左右半区的方式重新组合单链表"><a href="#题目四-按照左右半区的方式重新组合单链表" class="headerlink" title="题目四 按照左右半区的方式重新组合单链表"></a>题目四 按照左右半区的方式重新组合单链表</h1><blockquote>
<p>给定一个单链表的头部节点head，链表长度为N。 如果N为偶数，那么前N&#x2F;2个节点算作左半区，后N&#x2F;2个节点算作右半区； 如果N为奇数，那么前N&#x2F;2个节点算作左半区，后N&#x2F;2+1个节点算作右半区； 左半区从左到右依次记为L1-&gt;L2-&gt;…，右半区从左到右依次记为R1-&gt;R2-&gt;…。请将单链表调整成L1-&gt;R1-&gt;L2-&gt;R2-&gt;…的样子。 例如： 1-&gt;2-&gt;3-&gt;4 调整后：1-&gt;3-&gt;2-&gt;4 1-&gt;2-&gt;3-&gt;4-&gt;5 调整后：1-&gt;3-&gt;2-&gt;4-&gt;5 要求：如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">relocateList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use one loop, find the right head</span></span><br><span class="line">        ListNode *right_head = head;</span><br><span class="line">        ListNode *node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                right_head = right_head-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right_head = right_head-&gt;next;</span><br><span class="line">            node = node-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode *left_node = head;</span><br><span class="line">        ListNode *right_node = right_head;</span><br><span class="line">        <span class="keyword">while</span> (left_node-&gt;next != right_head)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = left_node-&gt;next;</span><br><span class="line">            left_node-&gt;next = right_node;</span><br><span class="line">            right_node = right_node-&gt;next;</span><br><span class="line">            left_node-&gt;next-&gt;next = tmp;</span><br><span class="line">            left_node = left_node-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left_node-&gt;next = right_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/majority_element/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/majority_element/" class="post-title-link" itemprop="url">leetcode题目之Majority Element</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-03-11 00:00:00" itemprop="dateCreated datePublished" datetime="2015-03-11T00:00:00+00:00">2015-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-13 01:42:32" itemprop="dateModified" datetime="2024-05-13T01:42:32+00:00">2024-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><blockquote>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n&#x2F;2 ⌋ times.<br>You may assume that the array is non-empty and the majority element always exist in the array.</p>
</blockquote>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>本题是一道非常简单的题目，但我能想到的思路有限，仅能想到排序法和哈希法两种算法，在Solution中提供了另外几种方法，这是非常值得我学习和思考的。本文仅将网站的思路拿过来，可以直接看该问题的<a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element/solution/">Solution</a>。</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h2><p>最原始的解决办法，逐个元素比较是否为该数组中的最多元素，只要满足条件即可终止。时间复杂度为O(n^2)。</p>
<h2 id="哈希表法"><a href="#哈希表法" class="headerlink" title="哈希表法"></a>哈希表法</h2><p>将数组中的元素遍历一遍，并将数组中元素的个数保存到哈希中。然后遍历哈希，从哈希中找到最多元素。时间复杂度O(n)，但需要占用一定的空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">        std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; result_map;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = num.<span class="built_in">begin</span>(); iter != num.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result_map.<span class="built_in">find</span>(*iter) == result_map.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                result_map.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(*iter, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result_map[*iter]++;                                                                                                                                            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">for</span> (std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator iter = result_map.<span class="built_in">begin</span>(); iter != result_map.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;second &gt; max_count)</span><br><span class="line">            &#123;</span><br><span class="line">                result = iter-&gt;first;</span><br><span class="line">                max_count = iter-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h2><p>直接对元素进行排序，排序后元素的中间元素即为要求的最多元素。时间复杂度为O(nlogn)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">majorityElementSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">   <span class="keyword">return</span> num[num.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随机抽取法"><a href="#随机抽取法" class="headerlink" title="随机抽取法"></a>随机抽取法</h2><p>随机从数组中抽取元素，然后遍历数组判断该元素是否为最多元素。该算法利用了最多元素被随机抽取的概率最大的特点，但该算法效率的随机性较大，最好时间复杂度为O(n)，最坏情况下一直随机不到最多元素。</p>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>将数组均分为两份，分别求出两个数组中的最多元素A和B，则整个数组中的最多元素必然在两个子数组的最多元素A和B中，这一点可以通过举例子的方式来证明，但是仅凭感觉不太容易得出该结论。如果A&#x3D;&#x3D;B，则结果就是A。如果A!&#x3D;B，则分别求出A和B在这个数组中的元素个数。时间复杂度接近O(nlogn)。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有一些比较不容易想到的算法，这里就不列举了。至少我看过一次之后，下次这些算法仍然是记不住的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/aleap_idx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/aleap_idx/" class="post-title-link" itemprop="url">asleap中的简单文件索引机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-02-28 00:00:00" itemprop="dateCreated datePublished" datetime="2015-02-28T00:00:00+00:00">2015-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-13 01:42:32" itemprop="dateModified" datetime="2024-05-13T01:42:32+00:00">2024-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>asleap是一个开源的vpn破解工具，最近查看了asleap的源码，该项目<a target="_blank" rel="noopener" href="http://sourceforge.net/projects/asleap/">地址</a>。本文的重点是对其中的带索引的字典文件的产生过程进行介绍，产生带索引的字典文件并不复杂，但是要想用简洁易懂的语言将该问题描述明白却不容易。</p>
<p>asleap破解vpn的机制是通过字典文件暴力破解的方式，该字典文件有dat数据文件和idx索引文件两个文件组成，两个文件均为二进制格式。asleap工程中自带了genkey程序，可以将文本的字典文件转换为asleap程序需要的带索引的字典文件。</p>
<p>本文以字典文件为以下内容讲解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">turquoise</span><br><span class="line">da</span><br><span class="line">test</span><br></pre></td></tr></table></figure>

<h1 id="读取字典文件并产生md4值"><a href="#读取字典文件并产生md4值" class="headerlink" title="读取字典文件并产生md4值"></a>读取字典文件并产生md4值</h1><p>md4编码占16个字节，三个字典进行md4编码后的结果分别为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18 07 33 43 f6 30 b5 f8 2c 38 c0 34 37 f2 81 6b</span><br><span class="line">01 19 a3 80 94 40 60 3c 57 39 5e 73 f3 60 95 98</span><br><span class="line">0c b6 94 88 05 f7 97 bf 2a 82 80 79 73 b8 95 37</span><br></pre></td></tr></table></figure>

<h1 id="将字典信息写入到临时文件"><a href="#将字典信息写入到临时文件" class="headerlink" title="将字典信息写入到临时文件"></a>将字典信息写入到临时文件</h1><p>为了能够对最终生成的dat文件中的内容进行排序和便于索引，程序生成了256个临时文件，文件名格式为从genk-bucket-00.tmp到genk-bucket-ff.tmp。程序根据md4编码中的第14位将字典对应的信息分别写入到临时文件中，一个字典写入到临时文件的内容如下，如果一个临时文件中存在多个字典则依次存放：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashpass_rec</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> rec_size;		<span class="comment">// 一个字典占用文件的大小，包括该变量+字典+字典对应的md4值共占用的字节数</span></span><br><span class="line">    <span class="type">char</span>          *password;	<span class="comment">// 字典</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hash[<span class="number">16</span>];		<span class="comment">// 字典对应的md4值</span></span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure>

<p>本例子中turquoise对应结构体会写入到genk-bucket-81.tmp中，da和test对应结构体会依次写入到genk-bucket-95.tmp中。</p>
<h1 id="读取临时文件并写入到dat数据文件中"><a href="#读取临时文件并写入到dat数据文件中" class="headerlink" title="读取临时文件并写入到dat数据文件中"></a>读取临时文件并写入到dat数据文件中</h1><p>最终dat文件中的数据内容为hashpass_rec的有序集合，排序的原则是按照md4的第14和15两个字节。依次读取256个临时文件中的hashpass_rec可以保证dat文件中的数据内容是按照第14字节排序的，但是不能够保证是按照第15个字节排序的。为了保证最终dat文件中的数据内容是按照第14和15字节有序的，在将一个临时文件中的内容写入到dat文件中前需要对该临时文件中的hashpass_rec结果按照hash变量的第15字节进行排序，直接使用C语言中的qsort进行排序。</p>
<p>该例子中da和test位于同一个临时文件中，需要根据hash变量的第15字节排序的结果为test、da，最终写入到dat文件中的排序结果为turquoise、test、da。</p>
<h1 id="根据dat数据文件产生idx索引文件"><a href="#根据dat数据文件产生idx索引文件" class="headerlink" title="根据dat数据文件产生idx索引文件"></a>根据dat数据文件产生idx索引文件</h1><p>idx索引文件中存放的是多个hashpassidx_rec结果，最多有256*256项，其结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hashpassidx_rec</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>	        hashkey[<span class="number">2</span>];	<span class="comment">// 对应md4编码的第14和15字节</span></span><br><span class="line">    <span class="type">off_t</span>                   offset;		<span class="comment">// 第一个匹配的hashpass_rec结构在dat文件中的偏移，占用4个字节</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> 	numrec;		<span class="comment">// dat文件中共有多少个匹配的hashpass_rec结果</span></span><br><span class="line">&#125; __attribute__ ((packed));	<span class="comment">// 字节对齐，需要填充4个字节</span></span><br></pre></td></tr></table></figure>

<p>最终完成的dat文件和idx文件的指向如下图所示：</p>
<p><img src="http://kuring.qiniudn.com/aleap_idx.png" alt="最终完成的dat文件和idx文件的指向"></p>
<h1 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h1><p>genkeys.c文件中在读取字典文件时存在bug，在文件的207行将内容更改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!feof(inputfl)) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(password, <span class="number">0</span>, MAX_NT_PASSWORD + <span class="number">1</span>);</span><br><span class="line">        fgets(password, MAX_NT_PASSWORD+<span class="number">1</span>, inputfl);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strlen</span>(password) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相关下载"><a href="#相关下载" class="headerlink" title="相关下载"></a>相关下载</h1><p><a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1jGmVF06">字典文件等相关文件下载</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/algorithm_sort_code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/algorithm_sort_code/" class="post-title-link" itemprop="url">常用排序算法整理及代码实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-02-25 00:00:00" itemprop="dateCreated datePublished" datetime="2015-02-25T00:00:00+00:00">2015-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-13 01:42:32" itemprop="dateModified" datetime="2024-05-13T01:42:32+00:00">2024-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文对我编写的常用的排序算法进行整理和总结，方便用时进行查阅和参考。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是实际应用中的最好选择，采用了分治法的思想。通过一趟排序将待排序记录分割成独立的两部分，其中一部分的关键字均比另外一部分的小，分别对这两部分记录进行排序，已达到整个有序。</p>
<p>是否稳定：不稳定</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(logn)，需要栈来实现递归用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivotkey = numbers[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; numbers[high] &gt;= pivotkey)</span><br><span class="line">        &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers[low] = numbers[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; numbers[low] &lt;= pivotkey)</span><br><span class="line">        &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        numbers[high] = numbers[low];</span><br><span class="line">        numbers[low] = pivotkey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pivotloc = <span class="built_in">partition</span>(numbers, low, high);</span><br><span class="line">        <span class="built_in">quick_sort</span>(numbers, low, pivotloc - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">quick_sort</span>(numbers, pivotloc + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">quick_sort</span>(numbers, <span class="number">0</span>, numbers.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">49</span>&#125;;</span><br><span class="line">    <span class="built_in">quick_sort</span>(numbers);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numbers.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>将两个或两个以上的有序表组合成一个新的有序表。合并两个有序表的方法为：比较两个有序表中第一个数，谁小先取谁。继续进行比较，只要有一个有序表为空，直接将另一个有序表取出即可。</p>
<p>是否稳定：稳定</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(n) （当使用顺序存储时，为了能够实现两个有序表之间的合并），或O(1)（当使用链式存储的时候，不再需要临时的空间来存储排序的结果）</p>
<h2 id="顺序存储代码"><a href="#顺序存储代码" class="headerlink" title="顺序存储代码"></a>顺序存储代码</h2><p>以下为采用顺序存储结构的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序使用递归算法的效率比较低，具体应用中会采用非递归算法代替</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers, std::vector&lt;<span class="type">int</span>&gt; &amp;extra, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> middle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = low, j = middle+<span class="number">1</span>, k = low;</span><br><span class="line">    <span class="keyword">for</span> (; i&lt;=middle &amp;&amp; j&lt;=high; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &lt;= numbers[j])</span><br><span class="line">        &#123;</span><br><span class="line">            extra[k] = numbers[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            extra[k] = numbers[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle)</span><br><span class="line">    &#123;</span><br><span class="line">        extra[k++] = numbers[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= middle)</span><br><span class="line">    &#123;</span><br><span class="line">        extra[k++] = numbers[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = low; m &lt;= high; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        numbers[m] = extra[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers, std::vector&lt;<span class="type">int</span>&gt; &amp;extra, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low == high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(numbers, extra, low, middle);</span><br><span class="line">    <span class="built_in">merge_sort</span>(numbers, extra, middle + <span class="number">1</span>, high);</span><br><span class="line">    <span class="built_in">merge</span>(numbers, extra, low, high, middle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;numbers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请额外的存储空间来用于排序处理</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; extra = numbers;</span><br><span class="line">    <span class="built_in">merge_sort</span>(numbers, extra, <span class="number">0</span>, numbers.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">49</span>&#125;;</span><br><span class="line">    <span class="built_in">merge_sort</span>(numbers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numbers.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式存储代码"><a href="#链式存储代码" class="headerlink" title="链式存储代码"></a>链式存储代码</h2><p>以下为采用链式存储结构的代码，本答案为我在LeetCode上的<a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-list/">Sort List </a>题目的答案，源码放在<a target="_blank" rel="noopener" href="https://github.com/kuring/leetcode/blob/master/src/sortList/sort_list.cpp">我的Github上</a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用归并排序方法，核心思想为将数组拆分为两半，分别对两半进行排序，排序完成后再进行一次排序，排序算法就可以采用插入排序的方式。</span></span><br><span class="line"><span class="comment"> * 对两半排序的算法仍然采用归并排序算法，即问题为递归问题</span></span><br><span class="line"><span class="comment"> * 在使用线性存储结果的归并排序算法中，会使用额外的空间来存储临时结果，空间复杂度为O(n)，而在链式存储中，空间复杂度为O(1)</span></span><br><span class="line"><span class="comment"> * 归并排序的时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="comment"> * 如果存储结构为双向链表，可以使用快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 仅有两个元素，对两个元素进行排序后直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val &lt; head-&gt;next-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *tmp = head-&gt;next;</span><br><span class="line">            tmp-&gt;next = head;</span><br><span class="line">            tmp-&gt;next-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了找到中间节点，这里采用快慢指针的方式，否则需要使用先遍历一次取长度，然后找到中间位置的两次遍历方式</span></span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    ListNode *slow_prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow_prev = slow;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = slow_prev-&gt;next;</span><br><span class="line">    slow_prev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别对两段链表进行排序</span></span><br><span class="line">    slow = <span class="built_in">sortList</span>(head);</span><br><span class="line">    fast = <span class="built_in">sortList</span>(fast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对两段链表进行合并</span></span><br><span class="line">    ListNode *node = <span class="literal">nullptr</span>, *result = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="literal">nullptr</span> &amp;&amp; fast != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow-&gt;val &lt; fast-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;next = slow;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node = slow;</span><br><span class="line">                result = slow;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;next = fast;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node = fast;</span><br><span class="line">                result = fast;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slow != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;next = slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        node-&gt;next = fast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p>该排序算法的时间复杂度为O(n^2)，算法复杂度过高。分为顺序存储和链式存储两种算法，其中顺序存储每比较一个元素是从该元素往前比较的，而链式存储是从链头开始比较的，这点有所不同，造成不同的是由存储结构决定的。</p>
<h2 id="顺序存储代码-1"><a href="#顺序存储代码-1" class="headerlink" title="顺序存储代码"></a>顺序存储代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void insertion_sort(std::vector&lt;int&gt; &amp;numbers)</span><br><span class="line">&#123;</span><br><span class="line">	if (numbers.size() &lt;= 1)</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 1; i &lt; numbers.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int j = i; j &gt; 0; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			if (numbers[j] &lt; numbers[j - 1])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(numbers[j], numbers[j - 1]);</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a[] = &#123; 49, 38, 65, 97, 76, 13, 27, 49 &#125;;</span><br><span class="line">	vector&lt;int&gt; numbers(a, a + sizeof(a) / sizeof(int));</span><br><span class="line">	insertion_sort(numbers);</span><br><span class="line">	for (int i = 0; i&lt;numbers.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d\t&quot;, numbers[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式存储代码-1"><a href="#链式存储代码-1" class="headerlink" title="链式存储代码"></a>链式存储代码</h2><p>以下代码为LeetCode上的链式存储的情况时的直接插入排序算法的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    ListNode *node = head-&gt;next;</span><br><span class="line">    ListNode *new_head = head;</span><br><span class="line">    new_head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *node_next = node-&gt;next;   <span class="comment">// 先将当前遍历的下一个节点保存</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前节点插入到新链表中</span></span><br><span class="line">        ListNode *new_node_tmp = new_head;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val &lt; new_node_tmp-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前节点插入新链表的第一个位置</span></span><br><span class="line">            node-&gt;next = new_head;</span><br><span class="line">            new_head = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将当前节点插入到中间</span></span><br><span class="line">            <span class="keyword">while</span> (new_node_tmp-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;val &lt; new_node_tmp-&gt;next-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    node-&gt;next = new_node_tmp-&gt;next;</span><br><span class="line">                    new_node_tmp-&gt;next = node;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                new_node_tmp = new_node_tmp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将该节点插入到最后位置</span></span><br><span class="line">            <span class="keyword">if</span> (new_node_tmp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                new_node_tmp-&gt;next = node;</span><br><span class="line">                node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 开始遍历当前节点的下一个节点</span></span><br><span class="line">        node = node_next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/summary/2014_summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/summary/2014_summary/" class="post-title-link" itemprop="url">2014年总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-02-13 00:00:00" itemprop="dateCreated datePublished" datetime="2015-02-13T00:00:00+00:00">2015-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-13 01:42:32" itemprop="dateModified" datetime="2024-05-13T01:42:32+00:00">2024-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我的年总结是依照农历的，因为在我心中春节才算是一年的真正开始，因为只有春节的时候才能找到年的滋味，年的感觉，才能称之为年，阳历的年只能称之为year。</p>
<p>2014年又在不经意间过去了，很多地方跟2013年一样是平淡，工作和学习仍然是生活的主旋律，闲暇时间抽个时间玩玩dota放松一下，周末偶尔爬个小山锻炼下身体，对我的人生中算是比较重要的一年。</p>
<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>2014年经历了结婚、毕业答辩和考驾照几件占用时间的事情，留给我业余时间用来学习的就少之又少了。结婚占用两个月时间，毕业论文占用了我两个月时间，考驾照占用了多个周末，工作出差占用了我一个月时间，留给我能够独立学习的晚上也就6个月时间。</p>
<p>开始的时候小看了硕士论文，以为很简单一事情，搞过这么多软件项目还搞不了一篇硕士论文。一直以来我看不起软件工程类论文，就一项目套个模板一介绍就是一篇论文，于是我选择了写一篇理论研究类论文，没有高大上的理论，而是在公司实践中真正用到的，《将Windows平台的C&#x2F;C++程序向Linux平台移植的技术研究》，选择论文的时候我已经看到了该题目不太适合作为硕士论文，当我还是毅然作为了我的硕士论文题目，不得不说这是我今年的一大败笔。第一篇论文失败后，我重新走起了保守路线，以之前熟悉的系统为主线，辅以各种文档的拼凑，完成了一篇我曾经嗤之以项目类硕士论文，并顺利通过答辩。对于我这样的新手而言，写论文是一件漫长又痛苦的过程，占用了我大量的宝贵时间。</p>
<p>一直以来对嵌入式linux方向比较好奇，今年终于抵不住好奇，买了个2140开发板自己捣鼓了一段时间，由于时间关系虽然到现在也没有入门，多多少少对嵌入式已经有所了解。</p>
<p>感谢我的另一半，给我提供了足够的时间来干我想干的事情。</p>
<h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><p>比起2013年，今年读过的书籍少了一些。</p>
<ul>
<li>《Linux&#x2F;Unix系统编程手册》</li>
<li>《编程珠玑》</li>
<li>《LINUX设备驱动程序》（部分章节）</li>
<li>《LINUX内核设计与实现》（大部分章节）</li>
<li>《深度探索linux操作系统》</li>
<li>《剑指Office》</li>
<li>《大规模C++程序设计》</li>
<li>《程序员的自我修养》（第二遍）</li>
<li>《文明之光》</li>
<li>《程序员健康指南》</li>
<li>《黄金时代》</li>
<li>《一只特立独行的猪》</li>
<li>《算法导论》（部分章节）</li>
</ul>
<h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>已经比较熟练掌握了公司产品的大部分技术，工作起来算是得心应手，但是却少了许多挑战，是时候该接收大挑战的了。工作的职位从后台组长到研发部副经理到研发部经理，开始了工作的转型，这是我不期望这么早来到的，我自认为技术的成长空间还很大，不想过早的接触管理岗位。</p>
<p>五月份的出差成为了我心中抹不去的痛，莫名其妙接受了任务，匆忙出差，不过坑才刚刚开始。要维护的是一个我没见过界面的产品，不过基本原理我是清楚的。产品有很多bug，这我可以理解，要不然也不会让我出差了，但要命的是我没有产品的代码，我接受的任务仅是去应付客户、发现bug后反馈、更新产品、施工，这明白着是市场+测试+维护的话，跟我半毛钱关系都没有。以上这些都无所谓，要知道我可不是一个顽固不化的程序员，但工作地点竟然是机房，而且机房是我见过最脏最乱的机房，我就站在一排机柜的后面的一堆烂纸箱子上吹着空调的冷风和机器的热风办公，时而蹲着，时而站着，时而坐着，时而将衣领撩起保暖，时而浑身打颤，以至于到现在我留下了膝盖隐隐作痛的毛病。而且系统bug不断，一连在不吃晚饭的情况下加班到大半夜好多次，而我竟然坚持下来了。原本三五天的出差计划，一待就是二十多天。这短短的二十多天成为了我今年最难忘的痛，多少次期望回到家里温暖的被窝，多少次期望在家吃着我做的炖土豆。</p>
<p>今年面试了不少人，通过面试也发现大部分技术人员的水平太差了，我甚至都搞不明白他们是怎么厚着脸皮来面试技术岗位的。济南软件行业实在是不景气，甚至找一个靠谱点的web或者php程序员都成为了公司的一大难题。</p>
<h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>长达五年的恋情在今年终于得到了升华，当然这升华是我不愿意这么快就看到的，多么希望能迟来几年，给原本一直以为自己还是个孩子的我一个接受的缓冲区，但站在两家人面前，我的想法竟然不能主导我。我对结婚这件事情持怎么简单怎么办的态度，结婚本就一仪式，豪华也罢，没有也罢，都是过眼云烟，为一天忙碌了一阵子仅为了那一天，而之后又有谁记得。结婚之所以在中国的古代非常重视，那是因为在农业社会中人民的娱乐方式非常单一，结婚可以成为人民心中的一个盼头和没有灯光的饭后侃的资本，现在娱乐方式早已多元化，相比之下结婚的光鲜早已显得微不足道。可结婚毕竟不是我一个人的事，甚至不是两个人的事，而是两家人的事。</p>
<p>结婚定在酷夏，定下来的时间比较匆忙，从定下来要结婚到结婚仅一个月时间，对我来说是莫大的好事，因为拖得时间越长占用的准备时间就越多。半年的婚前和半年的婚后生活，其实真的没人什么两样，都是美满的二人世界，希望这种状况能持续几年。</p>
<p>我一向对车比较排斥，始终认为汽车是一个比较失败的发明，用户体验特别差。好的设计应该让用户忽略其内部实现细节，好的发明不应该让用户花费大量的时间来学习怎样使用，甚至需要多个课时的专业培训。汽车不仅是一个毫无用户体验的发明，而且危险到极致，危险到一失误就会要掉人的性命。</p>
<p>但今年我随波逐流了，毕竟驾照是早晚要考的，晚考成本只会更高。于是考驾照提上了议程，8月初已经计划报名，只可惜流程过于复杂，到现在也才到了科目二的程度。先是报名需要办暂住证，暂住证一办就是15个工作日，直接拖到了十一之后。找个离家近的驾校报个名，一等就是一个月才考科目一。科目一考完一等又是一个月才开始分车学科目二。科目二刚开始学又开始继续了，一共练了两个工作日后驾校又开始集训了，又没我啥事了。好在我找了个陪练，练了几把就顺手了。</p>
<p>虽然驾照没有考出来，仅考到了科目二，算是完成了驾照的一半，但却耗去了我的部分经历。找驾校、准备科目一、学习科目二、找陪练，这些花费的都是我的时间。要是驾校培训行业能够再成熟些，再人性化些能给多少学车的人带来方便。</p>
<p>玩游戏多少有些过了，虽然每周也就不想学习的两个晚上用来玩游戏，但我深知自己不是玩游戏的料。很多时候为了能够赢一局，会熬夜到下半夜，这是非常不理智的。另外，以后尽量用其他方式来代替游戏放松，当然我深知其中的苦难。</p>
<h1 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h1><p>去过一次云南，都在<a target="_blank" rel="noopener" href="http://www.kuring.me/post/yunan_travel">这里</a>了。</p>
<p>清明节时间去过一次天津，天津比我想象的要好很多，各个地方特色比较明显，有别墅区、意大利风情区、现代的商业区等，这之间能够非常明显的区分，不像济南太混杂。不过天津的人却给我留下的印象不是很好，这也是小小的遗憾。</p>
<h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>在我心中已经为2015年制定好了一些计划，为家庭，为自己，2015年会是我人生的一个转折点，期望2015年能够顺利。我会努力的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://kuring.me/post/Maximum_Subarray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="404频道">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 404频道">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/post/Maximum_Subarray/" class="post-title-link" itemprop="url">leetcode题目之Maximum Subarray</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2015-01-02 00:00:00" itemprop="dateCreated datePublished" datetime="2015-01-02T00:00:00+00:00">2015-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-13 01:42:32" itemprop="dateModified" datetime="2024-05-13T01:42:32+00:00">2024-05-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],<br>the contiguous subarray [4,−1,2,1] has the largest sum &#x3D; 6.</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>该题目为经典题目，存在多种解题思路。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>求动态规划的关键在于找到状态方程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 问题的关键是找到状态方式，找到状态方程后问题就迎刃而解</span></span><br><span class="line"><span class="comment"> * 状态方程如下：</span></span><br><span class="line"><span class="comment"> * b[j]表示第j处，以a[j]结尾的子序列的最大和</span></span><br><span class="line"><span class="comment"> * b[j]=max(a[j] + b[j-1], a[j])</span></span><br><span class="line"><span class="comment"> * b数据的最大值即为问题的解</span></span><br><span class="line"><span class="comment"> * 问题转换为求解b数组</span></span><br><span class="line"><span class="comment"> * 时间复杂度为O(1)，空间复杂度为(n)，空间复杂度可以降为O(1)，为了使程序易读，不做调整</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> *b = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">	b[<span class="number">0</span>] = A[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> max_b = b[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		b[i] = std::<span class="built_in">max</span>(A[i] + b[i<span class="number">-1</span>], A[i]);</span><br><span class="line">		<span class="keyword">if</span> (max_b &lt; b[i])</span><br><span class="line">		&#123;</span><br><span class="line">			max_b = b[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] b;</span><br><span class="line">	<span class="keyword">return</span> max_b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><p>《算法导论》的分治策略一章有关于该问题的详细解释。该题利用分治法来解决要比二分查找类最简单的分治算法要复杂。将数组一分为二后，最大数组存在三种情况：在左半或右半部分、跨越中点分别占据左部分一点和右部分一点。对于跨越中点的情况，转化为求从中点开始向左的最大值和从中点开始向右的最大值之和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> compare_array[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">maxSubArray</span>(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * leetcode not support stdarg.h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> count, ...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        va_list ap;</span><br><span class="line">        <span class="built_in">va_start</span>(ap, count);</span><br><span class="line">        <span class="type">int</span> max = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = <span class="built_in">va_arg</span>(ap, <span class="type">int</span>);</span><br><span class="line">            <span class="keyword">if</span> (max &lt; temp)</span><br><span class="line">            &#123;</span><br><span class="line">                max = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">va_end</span>(ap);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_compare_array</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> max_num = compare_array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (max_num &lt; compare_array[i])</span><br><span class="line">            &#123;</span><br><span class="line">                max_num = compare_array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;begin : %d, end : %d\n&quot;, begin, end);</span></span><br><span class="line">        <span class="keyword">if</span> (begin == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> A[begin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((end - begin) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//return max(3, A[begin], A[begin] + A[end], A[end]);</span></span><br><span class="line">            compare_array[<span class="number">0</span>] = A[begin];</span><br><span class="line">            compare_array[<span class="number">1</span>] = A[begin] + A[end];</span><br><span class="line">            compare_array[<span class="number">2</span>] = A[end];</span><br><span class="line">            compare_array[<span class="number">3</span>] = INT_MIN;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max_compare_array</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 处理左边子数组</span></span><br><span class="line">        <span class="type">int</span> max_left = <span class="built_in">maxSubArray</span>(A, begin, middle);</span><br><span class="line">        <span class="comment">// 处理右边子数组</span></span><br><span class="line">        <span class="type">int</span> max_right = <span class="built_in">maxSubArray</span>(A, middle + <span class="number">1</span>, end);</span><br><span class="line">        <span class="comment">// 处理跨越中点的情况</span></span><br><span class="line">        <span class="type">int</span> max_cross = <span class="built_in">maxCrossMiddle</span>(A, begin, end);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;begin : %d, end : %d, max_left = %d, max_right = %d, max_cross = %d\n&quot;</span>, begin, end, max_left, max_right, max_cross);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回三者中的最大值</span></span><br><span class="line">        compare_array[<span class="number">0</span>] = max_left;</span><br><span class="line">        compare_array[<span class="number">1</span>] = max_right;</span><br><span class="line">        compare_array[<span class="number">2</span>] = max_cross;</span><br><span class="line">        compare_array[<span class="number">3</span>] = INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max_compare_array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理跨越中点的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCrossMiddle</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> A[begin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> middle = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 求得[begin -- middle-1]的最大值</span></span><br><span class="line">        <span class="type">int</span> max_left = A[middle - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=middle - <span class="number">1</span>; i&gt;=begin &amp;&amp; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            <span class="keyword">if</span> (max_left &lt; sum)</span><br><span class="line">            &#123;</span><br><span class="line">                max_left = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求得[middle+1 -- end]的最大值</span></span><br><span class="line">        <span class="type">int</span> max_right = A[middle + <span class="number">1</span>];</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=middle + <span class="number">1</span>; i&lt;=end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            <span class="keyword">if</span> (max_right&lt; sum)</span><br><span class="line">            &#123;</span><br><span class="line">                max_right = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        compare_array[<span class="number">0</span>] = A[middle];</span><br><span class="line">        compare_array[<span class="number">1</span>] = A[middle] + max_left;</span><br><span class="line">        compare_array[<span class="number">2</span>] = A[middle] + max_right;</span><br><span class="line">        compare_array[<span class="number">3</span>] = A[middle] + max_left + max_right;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max_compare_array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="扫描算法"><a href="#扫描算法" class="headerlink" title="扫描算法"></a>扫描算法</h1><p>《编程珠玑》一书8.4节提到该算法，时间复杂度为O(1)，是解决该问题最好的算法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> current_sum = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> max_sum = INT_MIN;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">if</span> (current_sum &lt;= <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">		current_sum = A[i];</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">		current_sum += A[i];</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (current_sum &gt; max_sum)</span><br><span class="line">	    &#123;</span><br><span class="line">		max_sum = current_sum;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/15/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/17/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder"></span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"kuring/kuring.github.io","repo_id":"MDEwOlJlcG9zaXRvcnkyODM4MzQ0NTk=","category":"Announcements","category_id":"DIC_kwDOEOr4W84CdeTU","mapping":"pathname","reactions_enabled":1,"emit_metadata":1,"theme":"light","lang":"zh-CN","crossorigin":"anonymous","input_position":"bottom","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
